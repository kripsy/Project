/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

GGRC = window.GGRC || {};

GGRC.Tracker = GGRC.Tracker || {};

if(typeof st === "number") {
  GGRC.Tracker.timing("dashboard", "load_scripts", Date.now() - st, "dashboard.js script tag to exec start");
}
window.st = Date.now();

GGRC.Tracker.init = function() {
  GGRC.Tracker.ga = this._ga;

  //  Emit any events already recorded
  for (var i = 0; i < this._pending_emit; i++) {
    this.emit(this._pending_emit[i]);
  }
  delete this._pending_emit;

  this.setup_jQuery();
}

GGRC.Tracker._ga = function(func, data) {
  if (window.GoogleAnalyticsObject)
    window[window.GoogleAnalyticsObject](func, data);
}

GGRC.Tracker.setup_jQuery = function() {
  //  Setup jQuery AJAX tracking once jQuery is available
  var that = this;
  if (this._setup_jQuery_done)
    return;
  if (!window.jQuery) {
    setTimeout(function() { that.setup_jQuery() }, 20);
  } else {
    $.ajaxTransport("json", this.api_timing_transport);
  }
}

GGRC.Tracker.emit = function(data) {
  if (this.ga) {
    this._events = this._events || [];
    this._events.push(data);
    this.ga('send', data);
  } else {
    this._pending_emit = this._pending_emit || [];
    this._pending_emit.push(data);
  }
}

GGRC.Tracker.event = function(category, action, label, value) {
  var data = {
    'hitType': 'event',
    'eventCategory': category,
    'eventAction': action
  };
  if (label)
    data.eventLabel = label;
  if (value)
    data.eventValue = +value;
  this.emit(data);
}

GGRC.Tracker.timing = function(category, variable, value, label) {
  var data = {
    'hitType': 'timing'
  };
  data.timingCategory = category;
  data.timingVar = variable;
  data.timingValue = +value;
  if (label)
    data.timingLabel = label;
  this.emit(data);
}

GGRC.Tracker.exception = function(description, fatal) {
  var data = {
    'hitType': 'exception'
  };
  data.exDescription = description;
  if (arguments.length > 1) {
    data.exFatal = !!fatal;
  }
  this.emit(data);
}

GGRC.Tracker.start = function(category, action, label) {
  var data;
  if (!this._pending_timings)
    this._pending_timings = {};
  if (!this._pending_timings[category])
    this._pending_timings[category] = {};
  if (!this._pending_timings[category][action]) {
    data = {
      start: Date.now()
    };
    if (label)
      data.label = label;
    this._pending_timings[category][action] = data;
    return function() {
      GGRC.Tracker.stop(category, action);
    };
  } else {
    //  Ignore re-entrant events for now by returning no-op function
    return function(){};
  }
};

GGRC.Tracker.stop = function(category, action, label) {
  var data;
  if (this._pending_timings[category]) {
    if (this._pending_timings[category][action]) {
      data = this._pending_timings[category][action];
      this.timing(
        category, action, Date.now() - data.start, data.label || label);
      delete this._pending_timings[category][action];
    }
    if (Object.keys(this._pending_timings[category]).length == 0)
      delete this._pending_timings[category];
    if (Object.keys(this._pending_timings).length == 0)
      delete this._pending_timings;
  }
};

GGRC.Tracker.api_timing_transport = function(options, _originalOptions, _jqXHR) {
  if (_originalOptions._canonical_url) {
    //console.debug("Found re-entrant request: " + _originalOptions._canonical_url);
    return;
  }

  var url = options.url,
      match = url.match(/^(.*)([?&])_=\d+(?:([?&])(.*))?$/);

  if (match) {
    if (match[4]) {
      url = match[1] + match[2] + match[4];
    }
    else {
      url = match[1];
    }
  }

  _originalOptions._canonical_url = url;

  var tracker_stop = null;

  return {
    send: function(headers, completeCallback) {
      tracker_stop = GGRC.Tracker.start("AJAX:" + options.type, url);

      jQuery.ajax(_originalOptions).done(function(data, statusText, jqXHR) {
        tracker_stop();
        completeCallback(
          jqXHR.status,
          statusText,
          { json: data },
          jqXHR.getAllResponseHeaders());
      }).fail(function(jqXHR, message, statusText) {
        GGRC.Tracker.exception(
          ["AJAX request failed", statusText, options.type, url].join(": "));
        completeCallback(
          jqXHR.status,
          statusText,
          { text: jqXHR.responseText},
          jqXHR.getAllResponseHeaders());
      });
    },
    abort: function() {
      console.debug("Aborted ajax");
    }
  };
};

GGRC.Tracker.setup_jQuery();

/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});
//# sourceMappingURL=jquery.min.map
/**
 * @license
 * lodash 3.10.1 (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 * Build: `lodash modern -o ./lodash.js`
 */
;(function(){function n(n,t){if(n!==t){var r=null===n,e=n===w,u=n===n,o=null===t,i=t===w,f=t===t;if(n>t&&!o||!u||r&&!i&&f||e&&f)return 1;if(n<t&&!r||!f||o&&!e&&u||i&&u)return-1}return 0}function t(n,t,r){for(var e=n.length,u=r?e:-1;r?u--:++u<e;)if(t(n[u],u,n))return u;return-1}function r(n,t,r){if(t!==t)return p(n,r);r-=1;for(var e=n.length;++r<e;)if(n[r]===t)return r;return-1}function e(n){return typeof n=="function"||false}function u(n){return null==n?"":n+""}function o(n,t){for(var r=-1,e=n.length;++r<e&&-1<t.indexOf(n.charAt(r)););
return r}function i(n,t){for(var r=n.length;r--&&-1<t.indexOf(n.charAt(r)););return r}function f(t,r){return n(t.a,r.a)||t.b-r.b}function a(n){return Nn[n]}function c(n){return Tn[n]}function l(n,t,r){return t?n=Bn[n]:r&&(n=Dn[n]),"\\"+n}function s(n){return"\\"+Dn[n]}function p(n,t,r){var e=n.length;for(t+=r?0:-1;r?t--:++t<e;){var u=n[t];if(u!==u)return t}return-1}function h(n){return!!n&&typeof n=="object"}function _(n){return 160>=n&&9<=n&&13>=n||32==n||160==n||5760==n||6158==n||8192<=n&&(8202>=n||8232==n||8233==n||8239==n||8287==n||12288==n||65279==n);
}function v(n,t){for(var r=-1,e=n.length,u=-1,o=[];++r<e;)n[r]===t&&(n[r]=z,o[++u]=r);return o}function g(n){for(var t=-1,r=n.length;++t<r&&_(n.charCodeAt(t)););return t}function y(n){for(var t=n.length;t--&&_(n.charCodeAt(t)););return t}function d(n){return Ln[n]}function m(_){function Nn(n){if(h(n)&&!(Oo(n)||n instanceof zn)){if(n instanceof Ln)return n;if(nu.call(n,"__chain__")&&nu.call(n,"__wrapped__"))return Mr(n)}return new Ln(n)}function Tn(){}function Ln(n,t,r){this.__wrapped__=n,this.__actions__=r||[],
this.__chain__=!!t}function zn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=Ru,this.__views__=[]}function Bn(){this.__data__={}}function Dn(n){var t=n?n.length:0;for(this.data={hash:gu(null),set:new lu};t--;)this.push(n[t])}function Mn(n,t){var r=n.data;return(typeof t=="string"||ge(t)?r.set.has(t):r.hash[t])?0:-1}function qn(n,t){var r=-1,e=n.length;for(t||(t=Be(e));++r<e;)t[r]=n[r];return t}function Pn(n,t){for(var r=-1,e=n.length;++r<e&&false!==t(n[r],r,n););
return n}function Kn(n,t){for(var r=-1,e=n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function Vn(n,t){for(var r=-1,e=n.length,u=-1,o=[];++r<e;){var i=n[r];t(i,r,n)&&(o[++u]=i)}return o}function Gn(n,t){for(var r=-1,e=n.length,u=Be(e);++r<e;)u[r]=t(n[r],r,n);return u}function Jn(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function Xn(n,t,r,e){var u=-1,o=n.length;for(e&&o&&(r=n[++u]);++u<o;)r=t(r,n[u],u,n);return r}function Hn(n,t){for(var r=-1,e=n.length;++r<e;)if(t(n[r],r,n))return true;
return false}function Qn(n,t,r,e){return n!==w&&nu.call(e,r)?n:t}function nt(n,t,r){for(var e=-1,u=zo(t),o=u.length;++e<o;){var i=u[e],f=n[i],a=r(f,t[i],i,n,t);(a===a?a===f:f!==f)&&(f!==w||i in n)||(n[i]=a)}return n}function tt(n,t){return null==t?n:et(t,zo(t),n)}function rt(n,t){for(var r=-1,e=null==n,u=!e&&Er(n),o=u?n.length:0,i=t.length,f=Be(i);++r<i;){var a=t[r];f[r]=u?Cr(a,o)?n[a]:w:e?w:n[a]}return f}function et(n,t,r){r||(r={});for(var e=-1,u=t.length;++e<u;){var o=t[e];r[o]=n[o]}return r}function ut(n,t,r){
var e=typeof n;return"function"==e?t===w?n:Bt(n,t,r):null==n?Fe:"object"==e?bt(n):t===w?ze(n):xt(n,t)}function ot(n,t,r,e,u,o,i){var f;if(r&&(f=u?r(n,e,u):r(n)),f!==w)return f;if(!ge(n))return n;if(e=Oo(n)){if(f=kr(n),!t)return qn(n,f)}else{var a=ru.call(n),c=a==K;if(a!=Z&&a!=B&&(!c||u))return Fn[a]?Rr(n,a,t):u?n:{};if(f=Ir(c?{}:n),!t)return tt(f,n)}for(o||(o=[]),i||(i=[]),u=o.length;u--;)if(o[u]==n)return i[u];return o.push(n),i.push(f),(e?Pn:_t)(n,function(e,u){f[u]=ot(e,t,r,u,n,o,i)}),f}function it(n,t,r){
if(typeof n!="function")throw new Ge(L);return su(function(){n.apply(w,r)},t)}function ft(n,t){var e=n?n.length:0,u=[];if(!e)return u;var o=-1,i=xr(),f=i===r,a=f&&t.length>=F&&gu&&lu?new Dn(t):null,c=t.length;a&&(i=Mn,f=false,t=a);n:for(;++o<e;)if(a=n[o],f&&a===a){for(var l=c;l--;)if(t[l]===a)continue n;u.push(a)}else 0>i(t,a,0)&&u.push(a);return u}function at(n,t){var r=true;return Su(n,function(n,e,u){return r=!!t(n,e,u)}),r}function ct(n,t,r,e){var u=e,o=u;return Su(n,function(n,i,f){i=+t(n,i,f),(r(i,u)||i===e&&i===o)&&(u=i,
o=n)}),o}function lt(n,t){var r=[];return Su(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function st(n,t,r,e){var u;return r(n,function(n,r,o){return t(n,r,o)?(u=e?r:n,false):void 0}),u}function pt(n,t,r,e){e||(e=[]);for(var u=-1,o=n.length;++u<o;){var i=n[u];h(i)&&Er(i)&&(r||Oo(i)||pe(i))?t?pt(i,t,r,e):Jn(e,i):r||(e[e.length]=i)}return e}function ht(n,t){Nu(n,t,Re)}function _t(n,t){return Nu(n,t,zo)}function vt(n,t){return Tu(n,t,zo)}function gt(n,t){for(var r=-1,e=t.length,u=-1,o=[];++r<e;){var i=t[r];
ve(n[i])&&(o[++u]=i)}return o}function yt(n,t,r){if(null!=n){r!==w&&r in Br(n)&&(t=[r]),r=0;for(var e=t.length;null!=n&&r<e;)n=n[t[r++]];return r&&r==e?n:w}}function dt(n,t,r,e,u,o){if(n===t)n=true;else if(null==n||null==t||!ge(n)&&!h(t))n=n!==n&&t!==t;else n:{var i=dt,f=Oo(n),a=Oo(t),c=D,l=D;f||(c=ru.call(n),c==B?c=Z:c!=Z&&(f=xe(n))),a||(l=ru.call(t),l==B?l=Z:l!=Z&&xe(t));var s=c==Z,a=l==Z,l=c==l;if(!l||f||s){if(!e&&(c=s&&nu.call(n,"__wrapped__"),a=a&&nu.call(t,"__wrapped__"),c||a)){n=i(c?n.value():n,a?t.value():t,r,e,u,o);
break n}if(l){for(u||(u=[]),o||(o=[]),c=u.length;c--;)if(u[c]==n){n=o[c]==t;break n}u.push(n),o.push(t),n=(f?yr:mr)(n,t,i,r,e,u,o),u.pop(),o.pop()}else n=false}else n=dr(n,t,c)}return n}function mt(n,t,r){var e=t.length,u=e,o=!r;if(null==n)return!u;for(n=Br(n);e--;){var i=t[e];if(o&&i[2]?i[1]!==n[i[0]]:!(i[0]in n))return false}for(;++e<u;){var i=t[e],f=i[0],a=n[f],c=i[1];if(o&&i[2]){if(a===w&&!(f in n))return false}else if(i=r?r(a,c,f):w,i===w?!dt(c,a,r,true):!i)return false}return true}function wt(n,t){var r=-1,e=Er(n)?Be(n.length):[];
return Su(n,function(n,u,o){e[++r]=t(n,u,o)}),e}function bt(n){var t=Ar(n);if(1==t.length&&t[0][2]){var r=t[0][0],e=t[0][1];return function(n){return null==n?false:n[r]===e&&(e!==w||r in Br(n))}}return function(n){return mt(n,t)}}function xt(n,t){var r=Oo(n),e=Wr(n)&&t===t&&!ge(t),u=n+"";return n=Dr(n),function(o){if(null==o)return false;var i=u;if(o=Br(o),!(!r&&e||i in o)){if(o=1==n.length?o:yt(o,Et(n,0,-1)),null==o)return false;i=Zr(n),o=Br(o)}return o[i]===t?t!==w||i in o:dt(t,o[i],w,true)}}function At(n,t,r,e,u){
if(!ge(n))return n;var o=Er(t)&&(Oo(t)||xe(t)),i=o?w:zo(t);return Pn(i||t,function(f,a){if(i&&(a=f,f=t[a]),h(f)){e||(e=[]),u||(u=[]);n:{for(var c=a,l=e,s=u,p=l.length,_=t[c];p--;)if(l[p]==_){n[c]=s[p];break n}var p=n[c],v=r?r(p,_,c,n,t):w,g=v===w;g&&(v=_,Er(_)&&(Oo(_)||xe(_))?v=Oo(p)?p:Er(p)?qn(p):[]:me(_)||pe(_)?v=pe(p)?ke(p):me(p)?p:{}:g=false),l.push(_),s.push(v),g?n[c]=At(v,_,r,l,s):(v===v?v!==p:p===p)&&(n[c]=v)}}else c=n[a],l=r?r(c,f,a,n,t):w,(s=l===w)&&(l=f),l===w&&(!o||a in n)||!s&&(l===l?l===c:c!==c)||(n[a]=l);
}),n}function jt(n){return function(t){return null==t?w:t[n]}}function kt(n){var t=n+"";return n=Dr(n),function(r){return yt(r,n,t)}}function It(n,t){for(var r=n?t.length:0;r--;){var e=t[r];if(e!=u&&Cr(e)){var u=e;pu.call(n,e,1)}}}function Rt(n,t){return n+yu(ku()*(t-n+1))}function Ot(n,t,r,e,u){return u(n,function(n,u,o){r=e?(e=false,n):t(r,n,u,o)}),r}function Et(n,t,r){var e=-1,u=n.length;for(t=null==t?0:+t||0,0>t&&(t=-t>u?0:u+t),r=r===w||r>u?u:+r||0,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Be(u);++e<u;)r[e]=n[e+t];
return r}function Ct(n,t){var r;return Su(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function Ut(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;return n}function Wt(t,r,e){var u=wr(),o=-1;return r=Gn(r,function(n){return u(n)}),t=wt(t,function(n){return{a:Gn(r,function(t){return t(n)}),b:++o,c:n}}),Ut(t,function(t,r){var u;n:{for(var o=-1,i=t.a,f=r.a,a=i.length,c=e.length;++o<a;)if(u=n(i[o],f[o])){if(o>=c)break n;o=e[o],u*="asc"===o||true===o?1:-1;break n}u=t.b-r.b}return u})}function $t(n,t){
var r=0;return Su(n,function(n,e,u){r+=+t(n,e,u)||0}),r}function St(n,t){var e=-1,u=xr(),o=n.length,i=u===r,f=i&&o>=F,a=f&&gu&&lu?new Dn(void 0):null,c=[];a?(u=Mn,i=false):(f=false,a=t?[]:c);n:for(;++e<o;){var l=n[e],s=t?t(l,e,n):l;if(i&&l===l){for(var p=a.length;p--;)if(a[p]===s)continue n;t&&a.push(s),c.push(l)}else 0>u(a,s,0)&&((t||f)&&a.push(s),c.push(l))}return c}function Ft(n,t){for(var r=-1,e=t.length,u=Be(e);++r<e;)u[r]=n[t[r]];return u}function Nt(n,t,r,e){for(var u=n.length,o=e?u:-1;(e?o--:++o<u)&&t(n[o],o,n););
return r?Et(n,e?0:o,e?o+1:u):Et(n,e?o+1:0,e?u:o)}function Tt(n,t){var r=n;r instanceof zn&&(r=r.value());for(var e=-1,u=t.length;++e<u;)var o=t[e],r=o.func.apply(o.thisArg,Jn([r],o.args));return r}function Lt(n,t,r){var e=0,u=n?n.length:e;if(typeof t=="number"&&t===t&&u<=Eu){for(;e<u;){var o=e+u>>>1,i=n[o];(r?i<=t:i<t)&&null!==i?e=o+1:u=o}return u}return zt(n,t,Fe,r)}function zt(n,t,r,e){t=r(t);for(var u=0,o=n?n.length:0,i=t!==t,f=null===t,a=t===w;u<o;){var c=yu((u+o)/2),l=r(n[c]),s=l!==w,p=l===l;
(i?p||e:f?p&&s&&(e||null!=l):a?p&&(e||s):null==l?0:e?l<=t:l<t)?u=c+1:o=c}return xu(o,Ou)}function Bt(n,t,r){if(typeof n!="function")return Fe;if(t===w)return n;switch(r){case 1:return function(r){return n.call(t,r)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,o){return n.call(t,r,e,u,o)};case 5:return function(r,e,u,o,i){return n.call(t,r,e,u,o,i)}}return function(){return n.apply(t,arguments)}}function Dt(n){var t=new ou(n.byteLength);return new hu(t).set(new hu(n)),
t}function Mt(n,t,r){for(var e=r.length,u=-1,o=bu(n.length-e,0),i=-1,f=t.length,a=Be(f+o);++i<f;)a[i]=t[i];for(;++u<e;)a[r[u]]=n[u];for(;o--;)a[i++]=n[u++];return a}function qt(n,t,r){for(var e=-1,u=r.length,o=-1,i=bu(n.length-u,0),f=-1,a=t.length,c=Be(i+a);++o<i;)c[o]=n[o];for(i=o;++f<a;)c[i+f]=t[f];for(;++e<u;)c[i+r[e]]=n[o++];return c}function Pt(n,t){return function(r,e,u){var o=t?t():{};if(e=wr(e,u,3),Oo(r)){u=-1;for(var i=r.length;++u<i;){var f=r[u];n(o,f,e(f,u,r),r)}}else Su(r,function(t,r,u){
n(o,t,e(t,r,u),u)});return o}}function Kt(n){return le(function(t,r){var e=-1,u=null==t?0:r.length,o=2<u?r[u-2]:w,i=2<u?r[2]:w,f=1<u?r[u-1]:w;for(typeof o=="function"?(o=Bt(o,f,5),u-=2):(o=typeof f=="function"?f:w,u-=o?1:0),i&&Ur(r[0],r[1],i)&&(o=3>u?w:o,u=1);++e<u;)(i=r[e])&&n(t,i,o);return t})}function Vt(n,t){return function(r,e){var u=r?Bu(r):0;if(!Sr(u))return n(r,e);for(var o=t?u:-1,i=Br(r);(t?o--:++o<u)&&false!==e(i[o],o,i););return r}}function Zt(n){return function(t,r,e){var u=Br(t);e=e(t);for(var o=e.length,i=n?o:-1;n?i--:++i<o;){
var f=e[i];if(false===r(u[f],f,u))break}return t}}function Yt(n,t){function r(){return(this&&this!==Zn&&this instanceof r?e:n).apply(t,arguments)}var e=Jt(n);return r}function Gt(n){return function(t){var r=-1;t=$e(Ce(t));for(var e=t.length,u="";++r<e;)u=n(u,t[r],r);return u}}function Jt(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:
return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=$u(n.prototype),t=n.apply(r,t);return ge(t)?t:r}}function Xt(n){function t(r,e,u){return u&&Ur(r,e,u)&&(e=w),r=gr(r,n,w,w,w,w,w,e),r.placeholder=t.placeholder,r}return t}function Ht(n,t){return le(function(r){var e=r[0];return null==e?e:(r.push(t),n.apply(w,r))})}function Qt(n,t){return function(r,e,u){if(u&&Ur(r,e,u)&&(e=w),e=wr(e,u,3),1==e.length){
u=r=Oo(r)?r:zr(r);for(var o=e,i=-1,f=u.length,a=t,c=a;++i<f;){var l=u[i],s=+o(l);n(s,a)&&(a=s,c=l)}if(u=c,!r.length||u!==t)return u}return ct(r,e,n,t)}}function nr(n,r){return function(e,u,o){return u=wr(u,o,3),Oo(e)?(u=t(e,u,r),-1<u?e[u]:w):st(e,u,n)}}function tr(n){return function(r,e,u){return r&&r.length?(e=wr(e,u,3),t(r,e,n)):-1}}function rr(n){return function(t,r,e){return r=wr(r,e,3),st(t,r,n,true)}}function er(n){return function(){for(var t,r=arguments.length,e=n?r:-1,u=0,o=Be(r);n?e--:++e<r;){
var i=o[u++]=arguments[e];if(typeof i!="function")throw new Ge(L);!t&&Ln.prototype.thru&&"wrapper"==br(i)&&(t=new Ln([],true))}for(e=t?-1:r;++e<r;){var i=o[e],u=br(i),f="wrapper"==u?zu(i):w;t=f&&$r(f[0])&&f[1]==(E|k|R|C)&&!f[4].length&&1==f[9]?t[br(f[0])].apply(t,f[3]):1==i.length&&$r(i)?t[u]():t.thru(i)}return function(){var n=arguments,e=n[0];if(t&&1==n.length&&Oo(e)&&e.length>=F)return t.plant(e).value();for(var u=0,n=r?o[u].apply(this,n):e;++u<r;)n=o[u].call(this,n);return n}}}function ur(n,t){
return function(r,e,u){return typeof e=="function"&&u===w&&Oo(r)?n(r,e):t(r,Bt(e,u,3))}}function or(n){return function(t,r,e){return(typeof r!="function"||e!==w)&&(r=Bt(r,e,3)),n(t,r,Re)}}function ir(n){return function(t,r,e){return(typeof r!="function"||e!==w)&&(r=Bt(r,e,3)),n(t,r)}}function fr(n){return function(t,r,e){var u={};return r=wr(r,e,3),_t(t,function(t,e,o){o=r(t,e,o),e=n?o:e,t=n?t:o,u[e]=t}),u}}function ar(n){return function(t,r,e){return t=u(t),(n?t:"")+pr(t,r,e)+(n?"":t)}}function cr(n){
var t=le(function(r,e){var u=v(e,t.placeholder);return gr(r,n,w,e,u)});return t}function lr(n,t){return function(r,e,u,o){var i=3>arguments.length;return typeof e=="function"&&o===w&&Oo(r)?n(r,e,u,i):Ot(r,wr(e,o,4),u,i,t)}}function sr(n,t,r,e,u,o,i,f,a,c){function l(){for(var m=arguments.length,b=m,j=Be(m);b--;)j[b]=arguments[b];if(e&&(j=Mt(j,e,u)),o&&(j=qt(j,o,i)),_||y){var b=l.placeholder,k=v(j,b),m=m-k.length;if(m<c){var I=f?qn(f):w,m=bu(c-m,0),E=_?k:w,k=_?w:k,C=_?j:w,j=_?w:j;return t|=_?R:O,t&=~(_?O:R),
g||(t&=~(x|A)),j=[n,t,r,C,E,j,k,I,a,m],I=sr.apply(w,j),$r(n)&&Du(I,j),I.placeholder=b,I}}if(b=p?r:this,I=h?b[n]:n,f)for(m=j.length,E=xu(f.length,m),k=qn(j);E--;)C=f[E],j[E]=Cr(C,m)?k[C]:w;return s&&a<j.length&&(j.length=a),this&&this!==Zn&&this instanceof l&&(I=d||Jt(n)),I.apply(b,j)}var s=t&E,p=t&x,h=t&A,_=t&k,g=t&j,y=t&I,d=h?w:Jt(n);return l}function pr(n,t,r){return n=n.length,t=+t,n<t&&mu(t)?(t-=n,r=null==r?" ":r+"",Ue(r,vu(t/r.length)).slice(0,t)):""}function hr(n,t,r,e){function u(){for(var t=-1,f=arguments.length,a=-1,c=e.length,l=Be(c+f);++a<c;)l[a]=e[a];
for(;f--;)l[a++]=arguments[++t];return(this&&this!==Zn&&this instanceof u?i:n).apply(o?r:this,l)}var o=t&x,i=Jt(n);return u}function _r(n){var t=Pe[n];return function(n,r){return(r=r===w?0:+r||0)?(r=au(10,r),t(n*r)/r):t(n)}}function vr(n){return function(t,r,e,u){var o=wr(e);return null==e&&o===ut?Lt(t,r,n):zt(t,r,o(e,u,1),n)}}function gr(n,t,r,e,u,o,i,f){var a=t&A;if(!a&&typeof n!="function")throw new Ge(L);var c=e?e.length:0;if(c||(t&=~(R|O),e=u=w),c-=u?u.length:0,t&O){var l=e,s=u;e=u=w}var p=a?w:zu(n);
return r=[n,t,r,e,u,l,s,o,i,f],p&&(e=r[1],t=p[1],f=e|t,u=t==E&&e==k||t==E&&e==C&&r[7].length<=p[8]||t==(E|C)&&e==k,(f<E||u)&&(t&x&&(r[2]=p[2],f|=e&x?0:j),(e=p[3])&&(u=r[3],r[3]=u?Mt(u,e,p[4]):qn(e),r[4]=u?v(r[3],z):qn(p[4])),(e=p[5])&&(u=r[5],r[5]=u?qt(u,e,p[6]):qn(e),r[6]=u?v(r[5],z):qn(p[6])),(e=p[7])&&(r[7]=qn(e)),t&E&&(r[8]=null==r[8]?p[8]:xu(r[8],p[8])),null==r[9]&&(r[9]=p[9]),r[0]=p[0],r[1]=f),t=r[1],f=r[9]),r[9]=null==f?a?0:n.length:bu(f-c,0)||0,(p?Lu:Du)(t==x?Yt(r[0],r[2]):t!=R&&t!=(x|R)||r[4].length?sr.apply(w,r):hr.apply(w,r),r);
}function yr(n,t,r,e,u,o,i){var f=-1,a=n.length,c=t.length;if(a!=c&&(!u||c<=a))return false;for(;++f<a;){var l=n[f],c=t[f],s=e?e(u?c:l,u?l:c,f):w;if(s!==w){if(s)continue;return false}if(u){if(!Hn(t,function(n){return l===n||r(l,n,e,u,o,i)}))return false}else if(l!==c&&!r(l,c,e,u,o,i))return false}return true}function dr(n,t,r){switch(r){case M:case q:return+n==+t;case P:return n.name==t.name&&n.message==t.message;case V:return n!=+n?t!=+t:n==+t;case Y:case G:return n==t+""}return false}function mr(n,t,r,e,u,o,i){var f=zo(n),a=f.length,c=zo(t).length;
if(a!=c&&!u)return false;for(c=a;c--;){var l=f[c];if(!(u?l in t:nu.call(t,l)))return false}for(var s=u;++c<a;){var l=f[c],p=n[l],h=t[l],_=e?e(u?h:p,u?p:h,l):w;if(_===w?!r(p,h,e,u,o,i):!_)return false;s||(s="constructor"==l)}return s||(r=n.constructor,e=t.constructor,!(r!=e&&"constructor"in n&&"constructor"in t)||typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)?true:false}function wr(n,t,r){var e=Nn.callback||Se,e=e===Se?ut:e;return r?e(n,t,r):e}function br(n){for(var t=n.name+"",r=Wu[t],e=r?r.length:0;e--;){
var u=r[e],o=u.func;if(null==o||o==n)return u.name}return t}function xr(n,t,e){var u=Nn.indexOf||Vr,u=u===Vr?r:u;return n?u(n,t,e):u}function Ar(n){n=Oe(n);for(var t=n.length;t--;){var r=n[t][1];n[t][2]=r===r&&!ge(r)}return n}function jr(n,t){var r=null==n?w:n[t];return ye(r)?r:w}function kr(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&nu.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ir(n){return n=n.constructor,typeof n=="function"&&n instanceof n||(n=Ve),
new n}function Rr(n,t,r){var e=n.constructor;switch(t){case J:return Dt(n);case M:case q:return new e(+n);case X:case H:case Q:case nn:case tn:case rn:case en:case un:case on:return t=n.buffer,new e(r?Dt(t):t,n.byteOffset,n.length);case V:case G:return new e(n);case Y:var u=new e(n.source,kn.exec(n));u.lastIndex=n.lastIndex}return u}function Or(n,t,r){return null==n||Wr(t,n)||(t=Dr(t),n=1==t.length?n:yt(n,Et(t,0,-1)),t=Zr(t)),t=null==n?n:n[t],null==t?w:t.apply(n,r)}function Er(n){return null!=n&&Sr(Bu(n));
}function Cr(n,t){return n=typeof n=="number"||On.test(n)?+n:-1,t=null==t?Cu:t,-1<n&&0==n%1&&n<t}function Ur(n,t,r){if(!ge(r))return false;var e=typeof t;return("number"==e?Er(r)&&Cr(t,r.length):"string"==e&&t in r)?(t=r[t],n===n?n===t:t!==t):false}function Wr(n,t){var r=typeof n;return"string"==r&&dn.test(n)||"number"==r?true:Oo(n)?false:!yn.test(n)||null!=t&&n in Br(t)}function $r(n){var t=br(n),r=Nn[t];return typeof r=="function"&&t in zn.prototype?n===r?true:(t=zu(r),!!t&&n===t[0]):false}function Sr(n){return typeof n=="number"&&-1<n&&0==n%1&&n<=Cu;
}function Fr(n,t){return n===w?t:Eo(n,t,Fr)}function Nr(n,t){n=Br(n);for(var r=-1,e=t.length,u={};++r<e;){var o=t[r];o in n&&(u[o]=n[o])}return u}function Tr(n,t){var r={};return ht(n,function(n,e,u){t(n,e,u)&&(r[e]=n)}),r}function Lr(n){for(var t=Re(n),r=t.length,e=r&&n.length,u=!!e&&Sr(e)&&(Oo(n)||pe(n)),o=-1,i=[];++o<r;){var f=t[o];(u&&Cr(f,e)||nu.call(n,f))&&i.push(f)}return i}function zr(n){return null==n?[]:Er(n)?ge(n)?n:Ve(n):Ee(n)}function Br(n){return ge(n)?n:Ve(n)}function Dr(n){if(Oo(n))return n;
var t=[];return u(n).replace(mn,function(n,r,e,u){t.push(e?u.replace(An,"$1"):r||n)}),t}function Mr(n){return n instanceof zn?n.clone():new Ln(n.__wrapped__,n.__chain__,qn(n.__actions__))}function qr(n,t,r){return n&&n.length?((r?Ur(n,t,r):null==t)&&(t=1),Et(n,0>t?0:t)):[]}function Pr(n,t,r){var e=n?n.length:0;return e?((r?Ur(n,t,r):null==t)&&(t=1),t=e-(+t||0),Et(n,0,0>t?0:t)):[]}function Kr(n){return n?n[0]:w}function Vr(n,t,e){var u=n?n.length:0;if(!u)return-1;if(typeof e=="number")e=0>e?bu(u+e,0):e;else if(e)return e=Lt(n,t),
e<u&&(t===t?t===n[e]:n[e]!==n[e])?e:-1;return r(n,t,e||0)}function Zr(n){var t=n?n.length:0;return t?n[t-1]:w}function Yr(n){return qr(n,1)}function Gr(n,t,e,u){if(!n||!n.length)return[];null!=t&&typeof t!="boolean"&&(u=e,e=Ur(n,t,u)?w:t,t=false);var o=wr();if((null!=e||o!==ut)&&(e=o(e,u,3)),t&&xr()===r){t=e;var i;e=-1,u=n.length;for(var o=-1,f=[];++e<u;){var a=n[e],c=t?t(a,e,n):a;e&&i===c||(i=c,f[++o]=a)}n=f}else n=St(n,e);return n}function Jr(n){if(!n||!n.length)return[];var t=-1,r=0;n=Vn(n,function(n){
return Er(n)?(r=bu(n.length,r),true):void 0});for(var e=Be(r);++t<r;)e[t]=Gn(n,jt(t));return e}function Xr(n,t,r){return n&&n.length?(n=Jr(n),null==t?n:(t=Bt(t,r,4),Gn(n,function(n){return Xn(n,t,w,true)}))):[]}function Hr(n,t){var r=-1,e=n?n.length:0,u={};for(!e||t||Oo(n[0])||(t=[]);++r<e;){var o=n[r];t?u[o]=t[r]:o&&(u[o[0]]=o[1])}return u}function Qr(n){return n=Nn(n),n.__chain__=true,n}function ne(n,t,r){return t.call(r,n)}function te(n,t,r){var e=Oo(n)?Kn:at;return r&&Ur(n,t,r)&&(t=w),(typeof t!="function"||r!==w)&&(t=wr(t,r,3)),
e(n,t)}function re(n,t,r){var e=Oo(n)?Vn:lt;return t=wr(t,r,3),e(n,t)}function ee(n,t,r,e){var u=n?Bu(n):0;return Sr(u)||(n=Ee(n),u=n.length),r=typeof r!="number"||e&&Ur(t,r,e)?0:0>r?bu(u+r,0):r||0,typeof n=="string"||!Oo(n)&&be(n)?r<=u&&-1<n.indexOf(t,r):!!u&&-1<xr(n,t,r)}function ue(n,t,r){var e=Oo(n)?Gn:wt;return t=wr(t,r,3),e(n,t)}function oe(n,t,r){if(r?Ur(n,t,r):null==t){n=zr(n);var e=n.length;return 0<e?n[Rt(0,e-1)]:w}r=-1,n=je(n);var e=n.length,u=e-1;for(t=xu(0>t?0:+t||0,e);++r<t;){var e=Rt(r,u),o=n[e];
n[e]=n[r],n[r]=o}return n.length=t,n}function ie(n,t,r){var e=Oo(n)?Hn:Ct;return r&&Ur(n,t,r)&&(t=w),(typeof t!="function"||r!==w)&&(t=wr(t,r,3)),e(n,t)}function fe(n,t){var r;if(typeof t!="function"){if(typeof n!="function")throw new Ge(L);var e=n;n=t,t=e}return function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=w),r}}function ae(n,t,r){function e(t,r){r&&iu(r),a=p=h=w,t&&(_=ho(),c=n.apply(s,f),p||a||(f=s=w))}function u(){var n=t-(ho()-l);0>=n||n>t?e(h,a):p=su(u,n)}function o(){e(g,p);
}function i(){if(f=arguments,l=ho(),s=this,h=g&&(p||!y),false===v)var r=y&&!p;else{a||y||(_=l);var e=v-(l-_),i=0>=e||e>v;i?(a&&(a=iu(a)),_=l,c=n.apply(s,f)):a||(a=su(o,e))}return i&&p?p=iu(p):p||t===v||(p=su(u,t)),r&&(i=true,c=n.apply(s,f)),!i||p||a||(f=s=w),c}var f,a,c,l,s,p,h,_=0,v=false,g=true;if(typeof n!="function")throw new Ge(L);if(t=0>t?0:+t||0,true===r)var y=true,g=false;else ge(r)&&(y=!!r.leading,v="maxWait"in r&&bu(+r.maxWait||0,t),g="trailing"in r?!!r.trailing:g);return i.cancel=function(){p&&iu(p),a&&iu(a),
_=0,a=p=h=w},i}function ce(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],o=r.cache;return o.has(u)?o.get(u):(e=n.apply(this,e),r.cache=o.set(u,e),e)}if(typeof n!="function"||t&&typeof t!="function")throw new Ge(L);return r.cache=new ce.Cache,r}function le(n,t){if(typeof n!="function")throw new Ge(L);return t=bu(t===w?n.length-1:+t||0,0),function(){for(var r=arguments,e=-1,u=bu(r.length-t,0),o=Be(u);++e<u;)o[e]=r[t+e];switch(t){case 0:return n.call(this,o);case 1:return n.call(this,r[0],o);
case 2:return n.call(this,r[0],r[1],o)}for(u=Be(t+1),e=-1;++e<t;)u[e]=r[e];return u[t]=o,n.apply(this,u)}}function se(n,t){return n>t}function pe(n){return h(n)&&Er(n)&&nu.call(n,"callee")&&!cu.call(n,"callee")}function he(n,t,r,e){return e=(r=typeof r=="function"?Bt(r,e,3):w)?r(n,t):w,e===w?dt(n,t,r):!!e}function _e(n){return h(n)&&typeof n.message=="string"&&ru.call(n)==P}function ve(n){return ge(n)&&ru.call(n)==K}function ge(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function ye(n){
return null==n?false:ve(n)?uu.test(Qe.call(n)):h(n)&&Rn.test(n)}function de(n){return typeof n=="number"||h(n)&&ru.call(n)==V}function me(n){var t;if(!h(n)||ru.call(n)!=Z||pe(n)||!(nu.call(n,"constructor")||(t=n.constructor,typeof t!="function"||t instanceof t)))return false;var r;return ht(n,function(n,t){r=t}),r===w||nu.call(n,r)}function we(n){return ge(n)&&ru.call(n)==Y}function be(n){return typeof n=="string"||h(n)&&ru.call(n)==G}function xe(n){return h(n)&&Sr(n.length)&&!!Sn[ru.call(n)]}function Ae(n,t){
return n<t}function je(n){var t=n?Bu(n):0;return Sr(t)?t?qn(n):[]:Ee(n)}function ke(n){return et(n,Re(n))}function Ie(n){return gt(n,Re(n))}function Re(n){if(null==n)return[];ge(n)||(n=Ve(n));for(var t=n.length,t=t&&Sr(t)&&(Oo(n)||pe(n))&&t||0,r=n.constructor,e=-1,r=typeof r=="function"&&r.prototype===n,u=Be(t),o=0<t;++e<t;)u[e]=e+"";for(var i in n)o&&Cr(i,t)||"constructor"==i&&(r||!nu.call(n,i))||u.push(i);return u}function Oe(n){n=Br(n);for(var t=-1,r=zo(n),e=r.length,u=Be(e);++t<e;){var o=r[t];
u[t]=[o,n[o]]}return u}function Ee(n){return Ft(n,zo(n))}function Ce(n){return(n=u(n))&&n.replace(En,a).replace(xn,"")}function Ue(n,t){var r="";if(n=u(n),t=+t,1>t||!n||!mu(t))return r;do t%2&&(r+=n),t=yu(t/2),n+=n;while(t);return r}function We(n,t,r){var e=n;return(n=u(n))?(r?Ur(e,t,r):null==t)?n.slice(g(n),y(n)+1):(t+="",n.slice(o(n,t),i(n,t)+1)):n}function $e(n,t,r){return r&&Ur(n,t,r)&&(t=w),n=u(n),n.match(t||Wn)||[]}function Se(n,t,r){return r&&Ur(n,t,r)&&(t=w),h(n)?Ne(n):ut(n,t)}function Fe(n){
return n}function Ne(n){return bt(ot(n,true))}function Te(n,t,r){if(null==r){var e=ge(t),u=e?zo(t):w;((u=u&&u.length?gt(t,u):w)?u.length:e)||(u=false,r=t,t=n,n=this)}u||(u=gt(t,zo(t)));var o=true,e=-1,i=ve(n),f=u.length;false===r?o=false:ge(r)&&"chain"in r&&(o=r.chain);for(;++e<f;){r=u[e];var a=t[r];n[r]=a,i&&(n.prototype[r]=function(t){return function(){var r=this.__chain__;if(o||r){var e=n(this.__wrapped__);return(e.__actions__=qn(this.__actions__)).push({func:t,args:arguments,thisArg:n}),e.__chain__=r,e}return t.apply(n,Jn([this.value()],arguments));
}}(a))}return n}function Le(){}function ze(n){return Wr(n)?jt(n):kt(n)}_=_?Yn.defaults(Zn.Object(),_,Yn.pick(Zn,$n)):Zn;var Be=_.Array,De=_.Date,Me=_.Error,qe=_.Function,Pe=_.Math,Ke=_.Number,Ve=_.Object,Ze=_.RegExp,Ye=_.String,Ge=_.TypeError,Je=Be.prototype,Xe=Ve.prototype,He=Ye.prototype,Qe=qe.prototype.toString,nu=Xe.hasOwnProperty,tu=0,ru=Xe.toString,eu=Zn._,uu=Ze("^"+Qe.call(nu).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ou=_.ArrayBuffer,iu=_.clearTimeout,fu=_.parseFloat,au=Pe.pow,cu=Xe.propertyIsEnumerable,lu=jr(_,"Set"),su=_.setTimeout,pu=Je.splice,hu=_.Uint8Array,_u=jr(_,"WeakMap"),vu=Pe.ceil,gu=jr(Ve,"create"),yu=Pe.floor,du=jr(Be,"isArray"),mu=_.isFinite,wu=jr(Ve,"keys"),bu=Pe.max,xu=Pe.min,Au=jr(De,"now"),ju=_.parseInt,ku=Pe.random,Iu=Ke.NEGATIVE_INFINITY,Ru=Ke.POSITIVE_INFINITY,Ou=4294967294,Eu=2147483647,Cu=9007199254740991,Uu=_u&&new _u,Wu={};
Nn.support={},Nn.templateSettings={escape:_n,evaluate:vn,interpolate:gn,variable:"",imports:{_:Nn}};var $u=function(){function n(){}return function(t){if(ge(t)){n.prototype=t;var r=new n;n.prototype=w}return r||{}}}(),Su=Vt(_t),Fu=Vt(vt,true),Nu=Zt(),Tu=Zt(true),Lu=Uu?function(n,t){return Uu.set(n,t),n}:Fe,zu=Uu?function(n){return Uu.get(n)}:Le,Bu=jt("length"),Du=function(){var n=0,t=0;return function(r,e){var u=ho(),o=S-(u-t);if(t=u,0<o){if(++n>=$)return r}else n=0;return Lu(r,e)}}(),Mu=le(function(n,t){
return h(n)&&Er(n)?ft(n,pt(t,false,true)):[]}),qu=tr(),Pu=tr(true),Ku=le(function(n){for(var t=n.length,e=t,u=Be(l),o=xr(),i=o===r,f=[];e--;){var a=n[e]=Er(a=n[e])?a:[];u[e]=i&&120<=a.length&&gu&&lu?new Dn(e&&a):null}var i=n[0],c=-1,l=i?i.length:0,s=u[0];n:for(;++c<l;)if(a=i[c],0>(s?Mn(s,a):o(f,a,0))){for(e=t;--e;){var p=u[e];if(0>(p?Mn(p,a):o(n[e],a,0)))continue n}s&&s.push(a),f.push(a)}return f}),Vu=le(function(t,r){r=pt(r);var e=rt(t,r);return It(t,r.sort(n)),e}),Zu=vr(),Yu=vr(true),Gu=le(function(n){return St(pt(n,false,true));
}),Ju=le(function(n,t){return Er(n)?ft(n,t):[]}),Xu=le(Jr),Hu=le(function(n){var t=n.length,r=2<t?n[t-2]:w,e=1<t?n[t-1]:w;return 2<t&&typeof r=="function"?t-=2:(r=1<t&&typeof e=="function"?(--t,e):w,e=w),n.length=t,Xr(n,r,e)}),Qu=le(function(n){return n=pt(n),this.thru(function(t){t=Oo(t)?t:[Br(t)];for(var r=n,e=-1,u=t.length,o=-1,i=r.length,f=Be(u+i);++e<u;)f[e]=t[e];for(;++o<i;)f[e++]=r[o];return f})}),no=le(function(n,t){return rt(n,pt(t))}),to=Pt(function(n,t,r){nu.call(n,r)?++n[r]:n[r]=1}),ro=nr(Su),eo=nr(Fu,true),uo=ur(Pn,Su),oo=ur(function(n,t){
for(var r=n.length;r--&&false!==t(n[r],r,n););return n},Fu),io=Pt(function(n,t,r){nu.call(n,r)?n[r].push(t):n[r]=[t]}),fo=Pt(function(n,t,r){n[r]=t}),ao=le(function(n,t,r){var e=-1,u=typeof t=="function",o=Wr(t),i=Er(n)?Be(n.length):[];return Su(n,function(n){var f=u?t:o&&null!=n?n[t]:w;i[++e]=f?f.apply(n,r):Or(n,t,r)}),i}),co=Pt(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),lo=lr(Xn,Su),so=lr(function(n,t,r,e){var u=n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r},Fu),po=le(function(n,t){
if(null==n)return[];var r=t[2];return r&&Ur(t[0],t[1],r)&&(t.length=1),Wt(n,pt(t),[])}),ho=Au||function(){return(new De).getTime()},_o=le(function(n,t,r){var e=x;if(r.length)var u=v(r,_o.placeholder),e=e|R;return gr(n,e,t,r,u)}),vo=le(function(n,t){t=t.length?pt(t):Ie(n);for(var r=-1,e=t.length;++r<e;){var u=t[r];n[u]=gr(n[u],x,n)}return n}),go=le(function(n,t,r){var e=x|A;if(r.length)var u=v(r,go.placeholder),e=e|R;return gr(t,e,n,r,u)}),yo=Xt(k),mo=Xt(I),wo=le(function(n,t){return it(n,1,t)}),bo=le(function(n,t,r){
return it(n,t,r)}),xo=er(),Ao=er(true),jo=le(function(n,t){if(t=pt(t),typeof n!="function"||!Kn(t,e))throw new Ge(L);var r=t.length;return le(function(e){for(var u=xu(e.length,r);u--;)e[u]=t[u](e[u]);return n.apply(this,e)})}),ko=cr(R),Io=cr(O),Ro=le(function(n,t){return gr(n,C,w,w,w,pt(t))}),Oo=du||function(n){return h(n)&&Sr(n.length)&&ru.call(n)==D},Eo=Kt(At),Co=Kt(function(n,t,r){return r?nt(n,t,r):tt(n,t)}),Uo=Ht(Co,function(n,t){return n===w?t:n}),Wo=Ht(Eo,Fr),$o=rr(_t),So=rr(vt),Fo=or(Nu),No=or(Tu),To=ir(_t),Lo=ir(vt),zo=wu?function(n){
var t=null==n?w:n.constructor;return typeof t=="function"&&t.prototype===n||typeof n!="function"&&Er(n)?Lr(n):ge(n)?wu(n):[]}:Lr,Bo=fr(true),Do=fr(),Mo=le(function(n,t){if(null==n)return{};if("function"!=typeof t[0])return t=Gn(pt(t),Ye),Nr(n,ft(Re(n),t));var r=Bt(t[0],t[1],3);return Tr(n,function(n,t,e){return!r(n,t,e)})}),qo=le(function(n,t){return null==n?{}:"function"==typeof t[0]?Tr(n,Bt(t[0],t[1],3)):Nr(n,pt(t))}),Po=Gt(function(n,t,r){return t=t.toLowerCase(),n+(r?t.charAt(0).toUpperCase()+t.slice(1):t);
}),Ko=Gt(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Vo=ar(),Zo=ar(true),Yo=Gt(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Go=Gt(function(n,t,r){return n+(r?" ":"")+(t.charAt(0).toUpperCase()+t.slice(1))}),Jo=le(function(n,t){try{return n.apply(w,t)}catch(r){return _e(r)?r:new Me(r)}}),Xo=le(function(n,t){return function(r){return Or(r,n,t)}}),Ho=le(function(n,t){return function(r){return Or(n,r,t)}}),Qo=_r("ceil"),ni=_r("floor"),ti=Qt(se,Iu),ri=Qt(Ae,Ru),ei=_r("round");return Nn.prototype=Tn.prototype,
Ln.prototype=$u(Tn.prototype),Ln.prototype.constructor=Ln,zn.prototype=$u(Tn.prototype),zn.prototype.constructor=zn,Bn.prototype["delete"]=function(n){return this.has(n)&&delete this.__data__[n]},Bn.prototype.get=function(n){return"__proto__"==n?w:this.__data__[n]},Bn.prototype.has=function(n){return"__proto__"!=n&&nu.call(this.__data__,n)},Bn.prototype.set=function(n,t){return"__proto__"!=n&&(this.__data__[n]=t),this},Dn.prototype.push=function(n){var t=this.data;typeof n=="string"||ge(n)?t.set.add(n):t.hash[n]=true;
},ce.Cache=Bn,Nn.after=function(n,t){if(typeof t!="function"){if(typeof n!="function")throw new Ge(L);var r=n;n=t,t=r}return n=mu(n=+n)?n:0,function(){return 1>--n?t.apply(this,arguments):void 0}},Nn.ary=function(n,t,r){return r&&Ur(n,t,r)&&(t=w),t=n&&null==t?n.length:bu(+t||0,0),gr(n,E,w,w,w,w,t)},Nn.assign=Co,Nn.at=no,Nn.before=fe,Nn.bind=_o,Nn.bindAll=vo,Nn.bindKey=go,Nn.callback=Se,Nn.chain=Qr,Nn.chunk=function(n,t,r){t=(r?Ur(n,t,r):null==t)?1:bu(yu(t)||1,1),r=0;for(var e=n?n.length:0,u=-1,o=Be(vu(e/t));r<e;)o[++u]=Et(n,r,r+=t);
return o},Nn.compact=function(n){for(var t=-1,r=n?n.length:0,e=-1,u=[];++t<r;){var o=n[t];o&&(u[++e]=o)}return u},Nn.constant=function(n){return function(){return n}},Nn.countBy=to,Nn.create=function(n,t,r){var e=$u(n);return r&&Ur(n,t,r)&&(t=w),t?tt(e,t):e},Nn.curry=yo,Nn.curryRight=mo,Nn.debounce=ae,Nn.defaults=Uo,Nn.defaultsDeep=Wo,Nn.defer=wo,Nn.delay=bo,Nn.difference=Mu,Nn.drop=qr,Nn.dropRight=Pr,Nn.dropRightWhile=function(n,t,r){return n&&n.length?Nt(n,wr(t,r,3),true,true):[]},Nn.dropWhile=function(n,t,r){
return n&&n.length?Nt(n,wr(t,r,3),true):[]},Nn.fill=function(n,t,r,e){var u=n?n.length:0;if(!u)return[];for(r&&typeof r!="number"&&Ur(n,t,r)&&(r=0,e=u),u=n.length,r=null==r?0:+r||0,0>r&&(r=-r>u?0:u+r),e=e===w||e>u?u:+e||0,0>e&&(e+=u),u=r>e?0:e>>>0,r>>>=0;r<u;)n[r++]=t;return n},Nn.filter=re,Nn.flatten=function(n,t,r){var e=n?n.length:0;return r&&Ur(n,t,r)&&(t=false),e?pt(n,t):[]},Nn.flattenDeep=function(n){return n&&n.length?pt(n,true):[]},Nn.flow=xo,Nn.flowRight=Ao,Nn.forEach=uo,Nn.forEachRight=oo,Nn.forIn=Fo,
Nn.forInRight=No,Nn.forOwn=To,Nn.forOwnRight=Lo,Nn.functions=Ie,Nn.groupBy=io,Nn.indexBy=fo,Nn.initial=function(n){return Pr(n,1)},Nn.intersection=Ku,Nn.invert=function(n,t,r){r&&Ur(n,t,r)&&(t=w),r=-1;for(var e=zo(n),u=e.length,o={};++r<u;){var i=e[r],f=n[i];t?nu.call(o,f)?o[f].push(i):o[f]=[i]:o[f]=i}return o},Nn.invoke=ao,Nn.keys=zo,Nn.keysIn=Re,Nn.map=ue,Nn.mapKeys=Bo,Nn.mapValues=Do,Nn.matches=Ne,Nn.matchesProperty=function(n,t){return xt(n,ot(t,true))},Nn.memoize=ce,Nn.merge=Eo,Nn.method=Xo,Nn.methodOf=Ho,
Nn.mixin=Te,Nn.modArgs=jo,Nn.negate=function(n){if(typeof n!="function")throw new Ge(L);return function(){return!n.apply(this,arguments)}},Nn.omit=Mo,Nn.once=function(n){return fe(2,n)},Nn.pairs=Oe,Nn.partial=ko,Nn.partialRight=Io,Nn.partition=co,Nn.pick=qo,Nn.pluck=function(n,t){return ue(n,ze(t))},Nn.property=ze,Nn.propertyOf=function(n){return function(t){return yt(n,Dr(t),t+"")}},Nn.pull=function(){var n=arguments,t=n[0];if(!t||!t.length)return t;for(var r=0,e=xr(),u=n.length;++r<u;)for(var o=0,i=n[r];-1<(o=e(t,i,o));)pu.call(t,o,1);
return t},Nn.pullAt=Vu,Nn.range=function(n,t,r){r&&Ur(n,t,r)&&(t=r=w),n=+n||0,r=null==r?1:+r||0,null==t?(t=n,n=0):t=+t||0;var e=-1;t=bu(vu((t-n)/(r||1)),0);for(var u=Be(t);++e<t;)u[e]=n,n+=r;return u},Nn.rearg=Ro,Nn.reject=function(n,t,r){var e=Oo(n)?Vn:lt;return t=wr(t,r,3),e(n,function(n,r,e){return!t(n,r,e)})},Nn.remove=function(n,t,r){var e=[];if(!n||!n.length)return e;var u=-1,o=[],i=n.length;for(t=wr(t,r,3);++u<i;)r=n[u],t(r,u,n)&&(e.push(r),o.push(u));return It(n,o),e},Nn.rest=Yr,Nn.restParam=le,
Nn.set=function(n,t,r){if(null==n)return n;var e=t+"";t=null!=n[e]||Wr(t,n)?[e]:Dr(t);for(var e=-1,u=t.length,o=u-1,i=n;null!=i&&++e<u;){var f=t[e];ge(i)&&(e==o?i[f]=r:null==i[f]&&(i[f]=Cr(t[e+1])?[]:{})),i=i[f]}return n},Nn.shuffle=function(n){return oe(n,Ru)},Nn.slice=function(n,t,r){var e=n?n.length:0;return e?(r&&typeof r!="number"&&Ur(n,t,r)&&(t=0,r=e),Et(n,t,r)):[]},Nn.sortBy=function(n,t,r){if(null==n)return[];r&&Ur(n,t,r)&&(t=w);var e=-1;return t=wr(t,r,3),n=wt(n,function(n,r,u){return{a:t(n,r,u),
b:++e,c:n}}),Ut(n,f)},Nn.sortByAll=po,Nn.sortByOrder=function(n,t,r,e){return null==n?[]:(e&&Ur(t,r,e)&&(r=w),Oo(t)||(t=null==t?[]:[t]),Oo(r)||(r=null==r?[]:[r]),Wt(n,t,r))},Nn.spread=function(n){if(typeof n!="function")throw new Ge(L);return function(t){return n.apply(this,t)}},Nn.take=function(n,t,r){return n&&n.length?((r?Ur(n,t,r):null==t)&&(t=1),Et(n,0,0>t?0:t)):[]},Nn.takeRight=function(n,t,r){var e=n?n.length:0;return e?((r?Ur(n,t,r):null==t)&&(t=1),t=e-(+t||0),Et(n,0>t?0:t)):[]},Nn.takeRightWhile=function(n,t,r){
return n&&n.length?Nt(n,wr(t,r,3),false,true):[]},Nn.takeWhile=function(n,t,r){return n&&n.length?Nt(n,wr(t,r,3)):[]},Nn.tap=function(n,t,r){return t.call(r,n),n},Nn.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new Ge(L);return false===r?e=false:ge(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),ae(n,t,{leading:e,maxWait:+t,trailing:u})},Nn.thru=ne,Nn.times=function(n,t,r){if(n=yu(n),1>n||!mu(n))return[];var e=-1,u=Be(xu(n,4294967295));for(t=Bt(t,r,1);++e<n;)4294967295>e?u[e]=t(e):t(e);
return u},Nn.toArray=je,Nn.toPlainObject=ke,Nn.transform=function(n,t,r,e){var u=Oo(n)||xe(n);return t=wr(t,e,4),null==r&&(u||ge(n)?(e=n.constructor,r=u?Oo(n)?new e:[]:$u(ve(e)?e.prototype:w)):r={}),(u?Pn:_t)(n,function(n,e,u){return t(r,n,e,u)}),r},Nn.union=Gu,Nn.uniq=Gr,Nn.unzip=Jr,Nn.unzipWith=Xr,Nn.values=Ee,Nn.valuesIn=function(n){return Ft(n,Re(n))},Nn.where=function(n,t){return re(n,bt(t))},Nn.without=Ju,Nn.wrap=function(n,t){return t=null==t?Fe:t,gr(t,R,w,[n],[])},Nn.xor=function(){for(var n=-1,t=arguments.length;++n<t;){
var r=arguments[n];if(Er(r))var e=e?Jn(ft(e,r),ft(r,e)):r}return e?St(e):[]},Nn.zip=Xu,Nn.zipObject=Hr,Nn.zipWith=Hu,Nn.backflow=Ao,Nn.collect=ue,Nn.compose=Ao,Nn.each=uo,Nn.eachRight=oo,Nn.extend=Co,Nn.iteratee=Se,Nn.methods=Ie,Nn.object=Hr,Nn.select=re,Nn.tail=Yr,Nn.unique=Gr,Te(Nn,Nn),Nn.add=function(n,t){return(+n||0)+(+t||0)},Nn.attempt=Jo,Nn.camelCase=Po,Nn.capitalize=function(n){return(n=u(n))&&n.charAt(0).toUpperCase()+n.slice(1)},Nn.ceil=Qo,Nn.clone=function(n,t,r,e){return t&&typeof t!="boolean"&&Ur(n,t,r)?t=false:typeof t=="function"&&(e=r,
r=t,t=false),typeof r=="function"?ot(n,t,Bt(r,e,3)):ot(n,t)},Nn.cloneDeep=function(n,t,r){return typeof t=="function"?ot(n,true,Bt(t,r,3)):ot(n,true)},Nn.deburr=Ce,Nn.endsWith=function(n,t,r){n=u(n),t+="";var e=n.length;return r=r===w?e:xu(0>r?0:+r||0,e),r-=t.length,0<=r&&n.indexOf(t,r)==r},Nn.escape=function(n){return(n=u(n))&&hn.test(n)?n.replace(sn,c):n},Nn.escapeRegExp=function(n){return(n=u(n))&&bn.test(n)?n.replace(wn,l):n||"(?:)"},Nn.every=te,Nn.find=ro,Nn.findIndex=qu,Nn.findKey=$o,Nn.findLast=eo,
Nn.findLastIndex=Pu,Nn.findLastKey=So,Nn.findWhere=function(n,t){return ro(n,bt(t))},Nn.first=Kr,Nn.floor=ni,Nn.get=function(n,t,r){return n=null==n?w:yt(n,Dr(t),t+""),n===w?r:n},Nn.gt=se,Nn.gte=function(n,t){return n>=t},Nn.has=function(n,t){if(null==n)return false;var r=nu.call(n,t);if(!r&&!Wr(t)){if(t=Dr(t),n=1==t.length?n:yt(n,Et(t,0,-1)),null==n)return false;t=Zr(t),r=nu.call(n,t)}return r||Sr(n.length)&&Cr(t,n.length)&&(Oo(n)||pe(n))},Nn.identity=Fe,Nn.includes=ee,Nn.indexOf=Vr,Nn.inRange=function(n,t,r){
return t=+t||0,r===w?(r=t,t=0):r=+r||0,n>=xu(t,r)&&n<bu(t,r)},Nn.isArguments=pe,Nn.isArray=Oo,Nn.isBoolean=function(n){return true===n||false===n||h(n)&&ru.call(n)==M},Nn.isDate=function(n){return h(n)&&ru.call(n)==q},Nn.isElement=function(n){return!!n&&1===n.nodeType&&h(n)&&!me(n)},Nn.isEmpty=function(n){return null==n?true:Er(n)&&(Oo(n)||be(n)||pe(n)||h(n)&&ve(n.splice))?!n.length:!zo(n).length},Nn.isEqual=he,Nn.isError=_e,Nn.isFinite=function(n){return typeof n=="number"&&mu(n)},Nn.isFunction=ve,Nn.isMatch=function(n,t,r,e){
return r=typeof r=="function"?Bt(r,e,3):w,mt(n,Ar(t),r)},Nn.isNaN=function(n){return de(n)&&n!=+n},Nn.isNative=ye,Nn.isNull=function(n){return null===n},Nn.isNumber=de,Nn.isObject=ge,Nn.isPlainObject=me,Nn.isRegExp=we,Nn.isString=be,Nn.isTypedArray=xe,Nn.isUndefined=function(n){return n===w},Nn.kebabCase=Ko,Nn.last=Zr,Nn.lastIndexOf=function(n,t,r){var e=n?n.length:0;if(!e)return-1;var u=e;if(typeof r=="number")u=(0>r?bu(e+r,0):xu(r||0,e-1))+1;else if(r)return u=Lt(n,t,true)-1,n=n[u],(t===t?t===n:n!==n)?u:-1;
if(t!==t)return p(n,u,true);for(;u--;)if(n[u]===t)return u;return-1},Nn.lt=Ae,Nn.lte=function(n,t){return n<=t},Nn.max=ti,Nn.min=ri,Nn.noConflict=function(){return Zn._=eu,this},Nn.noop=Le,Nn.now=ho,Nn.pad=function(n,t,r){n=u(n),t=+t;var e=n.length;return e<t&&mu(t)?(e=(t-e)/2,t=yu(e),e=vu(e),r=pr("",e,r),r.slice(0,t)+n+r):n},Nn.padLeft=Vo,Nn.padRight=Zo,Nn.parseInt=function(n,t,r){return(r?Ur(n,t,r):null==t)?t=0:t&&(t=+t),n=We(n),ju(n,t||(In.test(n)?16:10))},Nn.random=function(n,t,r){r&&Ur(n,t,r)&&(t=r=w);
var e=null==n,u=null==t;return null==r&&(u&&typeof n=="boolean"?(r=n,n=1):typeof t=="boolean"&&(r=t,u=true)),e&&u&&(t=1,u=false),n=+n||0,u?(t=n,n=0):t=+t||0,r||n%1||t%1?(r=ku(),xu(n+r*(t-n+fu("1e-"+((r+"").length-1))),t)):Rt(n,t)},Nn.reduce=lo,Nn.reduceRight=so,Nn.repeat=Ue,Nn.result=function(n,t,r){var e=null==n?w:n[t];return e===w&&(null==n||Wr(t,n)||(t=Dr(t),n=1==t.length?n:yt(n,Et(t,0,-1)),e=null==n?w:n[Zr(t)]),e=e===w?r:e),ve(e)?e.call(n):e},Nn.round=ei,Nn.runInContext=m,Nn.size=function(n){var t=n?Bu(n):0;
return Sr(t)?t:zo(n).length},Nn.snakeCase=Yo,Nn.some=ie,Nn.sortedIndex=Zu,Nn.sortedLastIndex=Yu,Nn.startCase=Go,Nn.startsWith=function(n,t,r){return n=u(n),r=null==r?0:xu(0>r?0:+r||0,n.length),n.lastIndexOf(t,r)==r},Nn.sum=function(n,t,r){if(r&&Ur(n,t,r)&&(t=w),t=wr(t,r,3),1==t.length){n=Oo(n)?n:zr(n),r=n.length;for(var e=0;r--;)e+=+t(n[r])||0;n=e}else n=$t(n,t);return n},Nn.template=function(n,t,r){var e=Nn.templateSettings;r&&Ur(n,t,r)&&(t=r=w),n=u(n),t=nt(tt({},r||t),e,Qn),r=nt(tt({},t.imports),e.imports,Qn);
var o,i,f=zo(r),a=Ft(r,f),c=0;r=t.interpolate||Cn;var l="__p+='";r=Ze((t.escape||Cn).source+"|"+r.source+"|"+(r===gn?jn:Cn).source+"|"+(t.evaluate||Cn).source+"|$","g");var p="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,u,f,a){return e||(e=u),l+=n.slice(c,a).replace(Un,s),r&&(o=true,l+="'+__e("+r+")+'"),f&&(i=true,l+="';"+f+";\n__p+='"),e&&(l+="'+((__t=("+e+"))==null?'':__t)+'"),c=a+t.length,t}),l+="';",(t=t.variable)||(l="with(obj){"+l+"}"),l=(i?l.replace(fn,""):l).replace(an,"$1").replace(cn,"$1;"),
l="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(o?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+l+"return __p}",t=Jo(function(){return qe(f,p+"return "+l).apply(w,a)}),t.source=l,_e(t))throw t;return t},Nn.trim=We,Nn.trimLeft=function(n,t,r){var e=n;return(n=u(n))?n.slice((r?Ur(e,t,r):null==t)?g(n):o(n,t+"")):n},Nn.trimRight=function(n,t,r){var e=n;return(n=u(n))?(r?Ur(e,t,r):null==t)?n.slice(0,y(n)+1):n.slice(0,i(n,t+"")+1):n;
},Nn.trunc=function(n,t,r){r&&Ur(n,t,r)&&(t=w);var e=U;if(r=W,null!=t)if(ge(t)){var o="separator"in t?t.separator:o,e="length"in t?+t.length||0:e;r="omission"in t?u(t.omission):r}else e=+t||0;if(n=u(n),e>=n.length)return n;if(e-=r.length,1>e)return r;if(t=n.slice(0,e),null==o)return t+r;if(we(o)){if(n.slice(e).search(o)){var i,f=n.slice(0,e);for(o.global||(o=Ze(o.source,(kn.exec(o)||"")+"g")),o.lastIndex=0;n=o.exec(f);)i=n.index;t=t.slice(0,null==i?e:i)}}else n.indexOf(o,e)!=e&&(o=t.lastIndexOf(o),
-1<o&&(t=t.slice(0,o)));return t+r},Nn.unescape=function(n){return(n=u(n))&&pn.test(n)?n.replace(ln,d):n},Nn.uniqueId=function(n){var t=++tu;return u(n)+t},Nn.words=$e,Nn.all=te,Nn.any=ie,Nn.contains=ee,Nn.eq=he,Nn.detect=ro,Nn.foldl=lo,Nn.foldr=so,Nn.head=Kr,Nn.include=ee,Nn.inject=lo,Te(Nn,function(){var n={};return _t(Nn,function(t,r){Nn.prototype[r]||(n[r]=t)}),n}(),false),Nn.sample=oe,Nn.prototype.sample=function(n){return this.__chain__||null!=n?this.thru(function(t){return oe(t,n)}):oe(this.value());
},Nn.VERSION=b,Pn("bind bindKey curry curryRight partial partialRight".split(" "),function(n){Nn[n].placeholder=Nn}),Pn(["drop","take"],function(n,t){zn.prototype[n]=function(r){var e=this.__filtered__;if(e&&!t)return new zn(this);r=null==r?1:bu(yu(r)||0,0);var u=this.clone();return e?u.__takeCount__=xu(u.__takeCount__,r):u.__views__.push({size:r,type:n+(0>u.__dir__?"Right":"")}),u},zn.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),Pn(["filter","map","takeWhile"],function(n,t){
var r=t+1,e=r!=T;zn.prototype[n]=function(n,t){var u=this.clone();return u.__iteratees__.push({iteratee:wr(n,t,1),type:r}),u.__filtered__=u.__filtered__||e,u}}),Pn(["first","last"],function(n,t){var r="take"+(t?"Right":"");zn.prototype[n]=function(){return this[r](1).value()[0]}}),Pn(["initial","rest"],function(n,t){var r="drop"+(t?"":"Right");zn.prototype[n]=function(){return this.__filtered__?new zn(this):this[r](1)}}),Pn(["pluck","where"],function(n,t){var r=t?"filter":"map",e=t?bt:ze;zn.prototype[n]=function(n){
return this[r](e(n))}}),zn.prototype.compact=function(){return this.filter(Fe)},zn.prototype.reject=function(n,t){return n=wr(n,t,1),this.filter(function(t){return!n(t)})},zn.prototype.slice=function(n,t){n=null==n?0:+n||0;var r=this;return r.__filtered__&&(0<n||0>t)?new zn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==w&&(t=+t||0,r=0>t?r.dropRight(-t):r.take(t-n)),r)},zn.prototype.takeRightWhile=function(n,t){return this.reverse().takeWhile(n,t).reverse()},zn.prototype.toArray=function(){return this.take(Ru);
},_t(zn.prototype,function(n,t){var r=/^(?:filter|map|reject)|While$/.test(t),e=/^(?:first|last)$/.test(t),u=Nn[e?"take"+("last"==t?"Right":""):t];u&&(Nn.prototype[t]=function(){function t(n){return e&&i?u(n,1)[0]:u.apply(w,Jn([n],o))}var o=e?[1]:arguments,i=this.__chain__,f=this.__wrapped__,a=!!this.__actions__.length,c=f instanceof zn,l=o[0],s=c||Oo(f);return s&&r&&typeof l=="function"&&1!=l.length&&(c=s=false),l={func:ne,args:[t],thisArg:w},a=c&&!a,e&&!i?a?(f=f.clone(),f.__actions__.push(l),n.call(f)):u.call(w,this.value())[0]:!e&&s?(f=a?f:new zn(this),
f=n.apply(f,o),f.__actions__.push(l),new Ln(f,i)):this.thru(t)})}),Pn("join pop push replace shift sort splice split unshift".split(" "),function(n){var t=(/^(?:replace|split)$/.test(n)?He:Je)[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:join|pop|replace|shift)$/.test(n);Nn.prototype[n]=function(){var n=arguments;return e&&!this.__chain__?t.apply(this.value(),n):this[r](function(r){return t.apply(r,n)})}}),_t(zn.prototype,function(n,t){var r=Nn[t];if(r){var e=r.name+"";(Wu[e]||(Wu[e]=[])).push({
name:t,func:r})}}),Wu[sr(w,A).name]=[{name:"wrapper",func:w}],zn.prototype.clone=function(){var n=new zn(this.__wrapped__);return n.__actions__=qn(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=qn(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=qn(this.__views__),n},zn.prototype.reverse=function(){if(this.__filtered__){var n=new zn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},zn.prototype.value=function(){
var n,t=this.__wrapped__.value(),r=this.__dir__,e=Oo(t),u=0>r,o=e?t.length:0;n=o;for(var i=this.__views__,f=0,a=-1,c=i.length;++a<c;){var l=i[a],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=xu(n,f+s);break;case"takeRight":f=bu(f,n-s)}}if(n={start:f,end:n},i=n.start,f=n.end,n=f-i,u=u?f:i-1,i=this.__iteratees__,f=i.length,a=0,c=xu(n,this.__takeCount__),!e||o<F||o==n&&c==n)return Tt(t,this.__actions__);e=[];n:for(;n--&&a<c;){for(u+=r,o=-1,l=t[u];++o<f;){var p=i[o],s=p.type,p=p.iteratee(l);
if(s==T)l=p;else if(!p){if(s==N)continue n;break n}}e[a++]=l}return e},Nn.prototype.chain=function(){return Qr(this)},Nn.prototype.commit=function(){return new Ln(this.value(),this.__chain__)},Nn.prototype.concat=Qu,Nn.prototype.plant=function(n){for(var t,r=this;r instanceof Tn;){var e=Mr(r);t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},Nn.prototype.reverse=function(){function n(n){return n.reverse()}var t=this.__wrapped__;return t instanceof zn?(this.__actions__.length&&(t=new zn(this)),
t=t.reverse(),t.__actions__.push({func:ne,args:[n],thisArg:w}),new Ln(t,this.__chain__)):this.thru(n)},Nn.prototype.toString=function(){return this.value()+""},Nn.prototype.run=Nn.prototype.toJSON=Nn.prototype.valueOf=Nn.prototype.value=function(){return Tt(this.__wrapped__,this.__actions__)},Nn.prototype.collect=Nn.prototype.map,Nn.prototype.head=Nn.prototype.first,Nn.prototype.select=Nn.prototype.filter,Nn.prototype.tail=Nn.prototype.rest,Nn}var w,b="3.10.1",x=1,A=2,j=4,k=8,I=16,R=32,O=64,E=128,C=256,U=30,W="...",$=150,S=16,F=200,N=1,T=2,L="Expected a function",z="__lodash_placeholder__",B="[object Arguments]",D="[object Array]",M="[object Boolean]",q="[object Date]",P="[object Error]",K="[object Function]",V="[object Number]",Z="[object Object]",Y="[object RegExp]",G="[object String]",J="[object ArrayBuffer]",X="[object Float32Array]",H="[object Float64Array]",Q="[object Int8Array]",nn="[object Int16Array]",tn="[object Int32Array]",rn="[object Uint8Array]",en="[object Uint8ClampedArray]",un="[object Uint16Array]",on="[object Uint32Array]",fn=/\b__p\+='';/g,an=/\b(__p\+=)''\+/g,cn=/(__e\(.*?\)|\b__t\))\+'';/g,ln=/&(?:amp|lt|gt|quot|#39|#96);/g,sn=/[&<>"'`]/g,pn=RegExp(ln.source),hn=RegExp(sn.source),_n=/<%-([\s\S]+?)%>/g,vn=/<%([\s\S]+?)%>/g,gn=/<%=([\s\S]+?)%>/g,yn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,dn=/^\w*$/,mn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g,wn=/^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,bn=RegExp(wn.source),xn=/[\u0300-\u036f\ufe20-\ufe23]/g,An=/\\(\\)?/g,jn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,kn=/\w*$/,In=/^0[xX]/,Rn=/^\[object .+?Constructor\]$/,On=/^\d+$/,En=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,Cn=/($^)/,Un=/['\n\r\u2028\u2029\\]/g,Wn=RegExp("[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?=[A-Z\\xc0-\\xd6\\xd8-\\xde][a-z\\xdf-\\xf6\\xf8-\\xff]+)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+|[A-Z\\xc0-\\xd6\\xd8-\\xde]+|[0-9]+","g"),$n="Array ArrayBuffer Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Math Number Object RegExp Set String _ clearTimeout isFinite parseFloat parseInt setTimeout TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap".split(" "),Sn={};
Sn[X]=Sn[H]=Sn[Q]=Sn[nn]=Sn[tn]=Sn[rn]=Sn[en]=Sn[un]=Sn[on]=true,Sn[B]=Sn[D]=Sn[J]=Sn[M]=Sn[q]=Sn[P]=Sn[K]=Sn["[object Map]"]=Sn[V]=Sn[Z]=Sn[Y]=Sn["[object Set]"]=Sn[G]=Sn["[object WeakMap]"]=false;var Fn={};Fn[B]=Fn[D]=Fn[J]=Fn[M]=Fn[q]=Fn[X]=Fn[H]=Fn[Q]=Fn[nn]=Fn[tn]=Fn[V]=Fn[Z]=Fn[Y]=Fn[G]=Fn[rn]=Fn[en]=Fn[un]=Fn[on]=true,Fn[P]=Fn[K]=Fn["[object Map]"]=Fn["[object Set]"]=Fn["[object WeakMap]"]=false;var Nn={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a",
"\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y",
"\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss"},Tn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},Ln={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},zn={"function":true,object:true},Bn={0:"x30",1:"x31",2:"x32",3:"x33",4:"x34",5:"x35",6:"x36",7:"x37",8:"x38",9:"x39",A:"x41",B:"x42",C:"x43",D:"x44",E:"x45",F:"x46",a:"x61",b:"x62",c:"x63",d:"x64",e:"x65",f:"x66",n:"x6e",r:"x72",t:"x74",u:"x75",v:"x76",x:"x78"},Dn={"\\":"\\",
"'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Mn=zn[typeof exports]&&exports&&!exports.nodeType&&exports,qn=zn[typeof module]&&module&&!module.nodeType&&module,Pn=zn[typeof self]&&self&&self.Object&&self,Kn=zn[typeof window]&&window&&window.Object&&window,Vn=qn&&qn.exports===Mn&&Mn,Zn=Mn&&qn&&typeof global=="object"&&global&&global.Object&&global||Kn!==(this&&this.window)&&Kn||Pn||this,Yn=m();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Zn._=Yn, define(function(){
return Yn})):Mn&&qn?Vn?(qn.exports=Yn)._=Yn:Mn._=Yn:Zn._=Yn}).call(this);
/*! jQuery UI - v1.11.4 - 2015-03-11
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function(e){"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){function t(t,s){var n,a,o,r=t.nodeName.toLowerCase();return"area"===r?(n=t.parentNode,a=n.name,t.href&&a&&"map"===n.nodeName.toLowerCase()?(o=e("img[usemap='#"+a+"']")[0],!!o&&i(o)):!1):(/^(input|select|textarea|button|object)$/.test(r)?!t.disabled:"a"===r?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}function s(e){for(var t,i;e.length&&e[0]!==document;){if(t=e.css("position"),("absolute"===t||"relative"===t||"fixed"===t)&&(i=parseInt(e.css("zIndex"),10),!isNaN(i)&&0!==i))return i;e=e.parent()}return 0}function n(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},e.extend(this._defaults,this.regional[""]),this.regional.en=e.extend(!0,{},this.regional[""]),this.regional["en-US"]=e.extend(!0,{},this.regional.en),this.dpDiv=a(e("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function a(t){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return t.delegate(i,"mouseout",function(){e(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).removeClass("ui-datepicker-next-hover")}).delegate(i,"mouseover",o)}function o(){e.datepicker._isDisabledDatepicker(v.inline?v.dpDiv.parent()[0]:v.input[0])||(e(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),e(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).addClass("ui-datepicker-next-hover"))}function r(t,i){e.extend(t,i);for(var s in i)null==i[s]&&(t[s]=i[s]);return t}function h(e){return function(){var t=this.element.val();e.apply(this,arguments),this._refresh(),t!==this.element.val()&&this._trigger("change")}}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(t){var i=this.css("position"),s="absolute"===i,n=t?/(auto|scroll|hidden)/:/(auto|scroll)/,a=this.parents().filter(function(){var t=e(this);return s&&"static"===t.css("position")?!1:n.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==i&&a.length?a:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&t(i,!n)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],a=i.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?o["inner"+i].call(this):this.each(function(){e(this).css(a,s(this,t)+"px")})},e.fn["outer"+i]=function(t,n){return"number"!=typeof t?o["outer"+i].call(this,t):this.each(function(){e(this).css(a,s(this,t,!0,n)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,n=e(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var n,a=e.ui[t].prototype;for(n in s)a.plugins[n]=a.plugins[n]||[],a.plugins[n].push([i,s[n]])},call:function(e,t,i,s){var n,a=e.plugins[t];if(a&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(n=0;a.length>n;n++)e.options[a[n][0]]&&a[n][1].apply(e.element,i)}};var l=0,u=Array.prototype.slice;e.cleanData=function(t){return function(i){var s,n,a;for(a=0;null!=(n=i[a]);a++)try{s=e._data(n,"events"),s&&s.remove&&e(n).triggerHandler("remove")}catch(o){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var n,a,o,r,h={},l=t.split(".")[0];return t=t.split(".")[1],n=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},a=e[l][t],o=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new o(e,t)},e.extend(o,a,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),r=new i,r.options=e.widget.extend({},r.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},n=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,a=this._superApply;return this._super=e,this._superApply=n,t=s.apply(this,arguments),this._super=i,this._superApply=a,t}}(),void 0):(h[t]=s,void 0)}),o.prototype=e.widget.extend(r,{widgetEventPrefix:a?r.widgetEventPrefix||t:t},h,{constructor:o,namespace:l,widgetName:t,widgetFullName:n}),a?(e.each(a._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete a._childConstructors):i._childConstructors.push(o),e.widget.bridge(t,o),o},e.widget.extend=function(t){for(var i,s,n=u.call(arguments,1),a=0,o=n.length;o>a;a++)for(i in n[a])s=n[a][i],n[a].hasOwnProperty(i)&&void 0!==s&&(t[i]=e.isPlainObject(s)?e.isPlainObject(t[i])?e.widget.extend({},t[i],s):e.widget.extend({},s):s);return t},e.widget.bridge=function(t,i){var s=i.prototype.widgetFullName||t;e.fn[t]=function(n){var a="string"==typeof n,o=u.call(arguments,1),r=this;return a?this.each(function(){var i,a=e.data(this,s);return"instance"===n?(r=a,!1):a?e.isFunction(a[n])&&"_"!==n.charAt(0)?(i=a[n].apply(a,o),i!==a&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+n+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+n+"'")}):(o.length&&(n=e.widget.extend.apply(null,[n].concat(o))),this.each(function(){var t=e.data(this,s);t?(t.option(n||{}),t._init&&t._init()):e.data(this,s,new i(n,this))})),r}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,i){i=e(i||this.defaultElement||this)[0],this.element=e(i),this.uuid=l++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=e(),this.hoverable=e(),this.focusable=e(),i!==this&&(e.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===i&&this.destroy()}}),this.document=e(i.style?i.ownerDocument:i.document||i),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,n,a,o=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(o={},s=t.split("."),t=s.shift(),s.length){for(n=o[t]=e.widget.extend({},this.options[t]),a=0;s.length-1>a;a++)n[s[a]]=n[s[a]]||{},n=n[s[a]];if(t=s.pop(),1===arguments.length)return void 0===n[t]?null:n[t];n[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=i}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var n,a=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=n=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),e.each(s,function(s,o){function r(){return t||a.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?a[o]:o).apply(a,arguments):void 0}"string"!=typeof o&&(r.guid=o.guid=o.guid||r.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+a.eventNamespace,u=h[2];u?n.delegate(u,l,r):i.bind(l,r)})},_off:function(t,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(i).undelegate(i),this.bindings=e(this.bindings.not(t).get()),this.focusable=e(this.focusable.not(t).get()),this.hoverable=e(this.hoverable.not(t).get())},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var o,r=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),o=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),o&&e.effects&&e.effects.effect[r]?s[t](n):r!==t&&s[r]?s[r](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}}),e.widget;var d=!1;e(document).mouseup(function(){d=!1}),e.widget("ui.mouse",{version:"1.11.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!d){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var i=this,s=1===t.which,n="string"==typeof this.options.cancel&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(t)!==!1,!this._mouseStarted)?(t.preventDefault(),!0):(!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return i._mouseMove(e)},this._mouseUpDelegate=function(e){return i._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),d=!0,!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button)return this._mouseUp(t);if(!t.which)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),d=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),function(){function t(e,t,i){return[parseFloat(e[0])*(p.test(e[0])?t/100:1),parseFloat(e[1])*(p.test(e[1])?i/100:1)]}function i(t,i){return parseInt(e.css(t,i),10)||0}function s(t){var i=t[0];return 9===i.nodeType?{width:t.width(),height:t.height(),offset:{top:0,left:0}}:e.isWindow(i)?{width:t.width(),height:t.height(),offset:{top:t.scrollTop(),left:t.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:t.outerWidth(),height:t.outerHeight(),offset:t.offset()}}e.ui=e.ui||{};var n,a,o=Math.max,r=Math.abs,h=Math.round,l=/left|center|right/,u=/top|center|bottom/,d=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,p=/%$/,f=e.fn.position;e.position={scrollbarWidth:function(){if(void 0!==n)return n;var t,i,s=e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),a=s.children()[0];return e("body").append(s),t=a.offsetWidth,s.css("overflow","scroll"),i=a.offsetWidth,t===i&&(i=s[0].clientWidth),s.remove(),n=t-i},getScrollInfo:function(t){var i=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),s=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),n="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,a="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:a?e.position.scrollbarWidth():0,height:n?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:n,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s||n?i.width():i.outerWidth(),height:s||n?i.height():i.outerHeight()}}},e.fn.position=function(n){if(!n||!n.of)return f.apply(this,arguments);n=e.extend({},n);var p,m,g,v,y,b,_=e(n.of),x=e.position.getWithinInfo(n.within),w=e.position.getScrollInfo(x),k=(n.collision||"flip").split(" "),T={};return b=s(_),_[0].preventDefault&&(n.at="left top"),m=b.width,g=b.height,v=b.offset,y=e.extend({},v),e.each(["my","at"],function(){var e,t,i=(n[this]||"").split(" ");1===i.length&&(i=l.test(i[0])?i.concat(["center"]):u.test(i[0])?["center"].concat(i):["center","center"]),i[0]=l.test(i[0])?i[0]:"center",i[1]=u.test(i[1])?i[1]:"center",e=d.exec(i[0]),t=d.exec(i[1]),T[this]=[e?e[0]:0,t?t[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===k.length&&(k[1]=k[0]),"right"===n.at[0]?y.left+=m:"center"===n.at[0]&&(y.left+=m/2),"bottom"===n.at[1]?y.top+=g:"center"===n.at[1]&&(y.top+=g/2),p=t(T.at,m,g),y.left+=p[0],y.top+=p[1],this.each(function(){var s,l,u=e(this),d=u.outerWidth(),c=u.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),D=d+f+i(this,"marginRight")+w.width,S=c+b+i(this,"marginBottom")+w.height,M=e.extend({},y),C=t(T.my,u.outerWidth(),u.outerHeight());"right"===n.my[0]?M.left-=d:"center"===n.my[0]&&(M.left-=d/2),"bottom"===n.my[1]?M.top-=c:"center"===n.my[1]&&(M.top-=c/2),M.left+=C[0],M.top+=C[1],a||(M.left=h(M.left),M.top=h(M.top)),s={marginLeft:f,marginTop:b},e.each(["left","top"],function(t,i){e.ui.position[k[t]]&&e.ui.position[k[t]][i](M,{targetWidth:m,targetHeight:g,elemWidth:d,elemHeight:c,collisionPosition:s,collisionWidth:D,collisionHeight:S,offset:[p[0]+C[0],p[1]+C[1]],my:n.my,at:n.at,within:x,elem:u})}),n.using&&(l=function(e){var t=v.left-M.left,i=t+m-d,s=v.top-M.top,a=s+g-c,h={target:{element:_,left:v.left,top:v.top,width:m,height:g},element:{element:u,left:M.left,top:M.top,width:d,height:c},horizontal:0>i?"left":t>0?"right":"center",vertical:0>a?"top":s>0?"bottom":"middle"};d>m&&m>r(t+i)&&(h.horizontal="center"),c>g&&g>r(s+a)&&(h.vertical="middle"),h.important=o(r(t),r(i))>o(r(s),r(a))?"horizontal":"vertical",n.using.call(this,e,h)}),u.offset(e.extend(M,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=e.left-t.collisionPosition.marginLeft,h=n-r,l=r+t.collisionWidth-a-n;t.collisionWidth>a?h>0&&0>=l?(i=e.left+h+t.collisionWidth-a-n,e.left+=h-i):e.left=l>0&&0>=h?n:h>l?n+a-t.collisionWidth:n:h>0?e.left+=h:l>0?e.left-=l:e.left=o(e.left-r,e.left)},top:function(e,t){var i,s=t.within,n=s.isWindow?s.scrollTop:s.offset.top,a=t.within.height,r=e.top-t.collisionPosition.marginTop,h=n-r,l=r+t.collisionHeight-a-n;t.collisionHeight>a?h>0&&0>=l?(i=e.top+h+t.collisionHeight-a-n,e.top+=h-i):e.top=l>0&&0>=h?n:h>l?n+a-t.collisionHeight:n:h>0?e.top+=h:l>0?e.top-=l:e.top=o(e.top-r,e.top)}},flip:{left:function(e,t){var i,s,n=t.within,a=n.offset.left+n.scrollLeft,o=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-o-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,f=-2*t.offset[0];0>u?(i=e.left+c+p+f+t.collisionWidth-o-a,(0>i||r(u)>i)&&(e.left+=c+p+f)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+f-h,(s>0||d>r(s))&&(e.left+=c+p+f))},top:function(e,t){var i,s,n=t.within,a=n.offset.top+n.scrollTop,o=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-o-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,f="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,m=-2*t.offset[1];0>u?(s=e.top+p+f+m+t.collisionHeight-o-a,(0>s||r(u)>s)&&(e.top+=p+f+m)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+f+m-h,(i>0||d>r(i))&&(e.top+=p+f+m))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,n,o,r=document.getElementsByTagName("body")[0],h=document.createElement("div");t=document.createElement(r?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},r&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(o in s)t.style[o]=s[o];t.appendChild(h),i=r||document.documentElement,i.insertBefore(t,i.firstChild),h.style.cssText="position: absolute; left: 10.7432222px;",n=e(h).offset().left,a=n>10&&11>n,t.innerHTML="",i.removeChild(t)}()}(),e.ui.position,e.widget("ui.accordion",{version:"1.11.4",options:{active:0,animate:{},collapsible:!1,event:"click",header:"> li > :first-child,> :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var t=this.options;this.prevShow=this.prevHide=e(),this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role","tablist"),t.collapsible||t.active!==!1&&null!=t.active||(t.active=0),this._processPanels(),0>t.active&&(t.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():e()}},_createIcons:function(){var t=this.options.icons;t&&(e("<span>").addClass("ui-accordion-header-icon ui-icon "+t.header).prependTo(this.headers),this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader),this.headers.addClass("ui-accordion-icons"))},_destroyIcons:function(){this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()},_destroy:function(){var e;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"),this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId(),this._destroyIcons(),e=this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display","").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&e.css("height","")},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):("event"===e&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(t)),this._super(e,t),"collapsible"!==e||t||this.options.active!==!1||this._activate(0),"icons"===e&&(this._destroyIcons(),t&&this._createIcons()),"disabled"===e&&(this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this.headers.add(this.headers.next()).toggleClass("ui-state-disabled",!!t)),void 0)},_keydown:function(t){if(!t.altKey&&!t.ctrlKey){var i=e.ui.keyCode,s=this.headers.length,n=this.headers.index(t.target),a=!1;switch(t.keyCode){case i.RIGHT:case i.DOWN:a=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:a=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(t);break;case i.HOME:a=this.headers[0];break;case i.END:a=this.headers[s-1]}a&&(e(t.target).attr("tabIndex",-1),e(a).attr("tabIndex",0),a.focus(),t.preventDefault())}},_panelKeyDown:function(t){t.keyCode===e.ui.keyCode.UP&&t.ctrlKey&&e(t.currentTarget).prev().focus()},refresh:function(){var t=this.options;this._processPanels(),t.active===!1&&t.collapsible===!0||!this.headers.length?(t.active=!1,this.active=e()):t.active===!1?this._activate(0):this.active.length&&!e.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(t.active=!1,this.active=e()):this._activate(Math.max(0,t.active-1)):t.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var e=this.headers,t=this.panels;this.headers=this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all"),this.panels=this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide(),t&&(this._off(e.not(this.headers)),this._off(t.not(this.panels)))},_refresh:function(){var t,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all"),this.active.next().addClass("ui-accordion-content-active").show(),this.headers.attr("role","tab").each(function(){var t=e(this),i=t.uniqueId().attr("id"),s=t.next(),n=s.uniqueId().attr("id");t.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(t=n.height(),this.element.siblings(":visible").each(function(){var i=e(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(t-=i.outerHeight(!0))}),this.headers.each(function(){t-=e(this).outerHeight(!0)}),this.headers.next().each(function(){e(this).height(Math.max(0,t-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===s&&(t=0,this.headers.next().each(function(){t=Math.max(t,e(this).css("height","").height())}).height(t))},_activate:function(t){var i=this._findActive(t)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return"number"==typeof t?this.headers.eq(t):e()},_setupEvents:function(t){var i={keydown:"_keydown"};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(t){var i=this.options,s=this.active,n=e(t.currentTarget),a=n[0]===s[0],o=a&&i.collapsible,r=o?e():n.next(),h=s.next(),l={oldHeader:s,oldPanel:h,newHeader:o?e():n,newPanel:r};t.preventDefault(),a&&!i.collapsible||this._trigger("beforeActivate",t,l)===!1||(i.active=o?!1:this.headers.index(n),this.active=a?e():n,this._toggle(l),s.removeClass("ui-accordion-header-active ui-state-active"),i.icons&&s.children(".ui-accordion-header-icon").removeClass(i.icons.activeHeader).addClass(i.icons.header),a||(n.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"),i.icons&&n.children(".ui-accordion-header-icon").removeClass(i.icons.header).addClass(i.icons.activeHeader),n.next().addClass("ui-accordion-content-active")))},_toggle:function(t){var i=t.newPanel,s=this.prevShow.length?this.prevShow:t.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,t):(s.hide(),i.show(),this._toggleComplete(t)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(e(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(e,t,i){var s,n,a,o=this,r=0,h=e.css("box-sizing"),l=e.length&&(!t.length||e.index()<t.index()),u=this.options.animate||{},d=l&&u.down||u,c=function(){o._toggleComplete(i)};return"number"==typeof d&&(a=d),"string"==typeof d&&(n=d),n=n||d.easing||u.easing,a=a||d.duration||u.duration,t.length?e.length?(s=e.show().outerHeight(),t.animate(this.hideProps,{duration:a,easing:n,step:function(e,t){t.now=Math.round(e)}}),e.hide().animate(this.showProps,{duration:a,easing:n,complete:c,step:function(e,i){i.now=Math.round(e),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==o.options.heightStyle&&(i.now=Math.round(s-t.outerHeight()-r),r=0)}}),void 0):t.animate(this.hideProps,a,n,c):e.animate(this.showProps,a,n,c)},_toggleComplete:function(e){var t=e.oldPanel;t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"),t.length&&(t.parent()[0].className=t.parent()[0].className),this._trigger("activate",null,e)}}),e.widget("ui.menu",{version:"1.11.4",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-carat-1-e"},items:"> *",menus:"ul",position:{my:"left-1 top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length).attr({role:this.options.role,tabIndex:0}),this.options.disabled&&this.element.addClass("ui-state-disabled").attr("aria-disabled","true"),this._on({"mousedown .ui-menu-item":function(e){e.preventDefault()},"click .ui-menu-item":function(t){var i=e(t.target);!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(t):!this.element.is(":focus")&&e(this.document[0].activeElement).closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(t){if(!this.previousFilter){var i=e(t.currentTarget);
i.siblings(".ui-state-active").removeClass("ui-state-active"),this.focus(t,i)}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(e,t){var i=this.active||this.element.find(this.options.items).eq(0);t||this.focus(e,i)},blur:function(t){this._delay(function(){e.contains(this.element[0],this.document[0].activeElement)||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(e){this._closeOnDocumentClick(e)&&this.collapseAll(e),this.mouseHandled=!1}})},_destroy:function(){this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(),this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function(){var t=e(this);t.data("ui-menu-submenu-carat")&&t.remove()}),this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")},_keydown:function(t){var i,s,n,a,o=!0;switch(t.keyCode){case e.ui.keyCode.PAGE_UP:this.previousPage(t);break;case e.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case e.ui.keyCode.HOME:this._move("first","first",t);break;case e.ui.keyCode.END:this._move("last","last",t);break;case e.ui.keyCode.UP:this.previous(t);break;case e.ui.keyCode.DOWN:this.next(t);break;case e.ui.keyCode.LEFT:this.collapse(t);break;case e.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(t);break;case e.ui.keyCode.ENTER:case e.ui.keyCode.SPACE:this._activate(t);break;case e.ui.keyCode.ESCAPE:this.collapse(t);break;default:o=!1,s=this.previousFilter||"",n=String.fromCharCode(t.keyCode),a=!1,clearTimeout(this.filterTimer),n===s?a=!0:n=s+n,i=this._filterMenuItems(n),i=a&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(t.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(t,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}o&&t.preventDefault()},_activate:function(e){this.active.is(".ui-state-disabled")||(this.active.is("[aria-haspopup='true']")?this.expand(e):this.select(e))},refresh:function(){var t,i,s=this,n=this.options.icons.submenu,a=this.element.find(this.options.menus);this.element.toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length),a.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var t=e(this),i=t.parent(),s=e("<span>").addClass("ui-menu-icon ui-icon "+n).data("ui-menu-submenu-carat",!0);i.attr("aria-haspopup","true").prepend(s),t.attr("aria-labelledby",i.attr("id"))}),t=a.add(this.element),i=t.find(this.options.items),i.not(".ui-menu-item").each(function(){var t=e(this);s._isDivider(t)&&t.addClass("ui-widget-content ui-menu-divider")}),i.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!e.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(e,t){"icons"===e&&this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(t.submenu),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},focus:function(e,t){var i,s;this.blur(e,e&&"focus"===e.type),this._scrollIntoView(t),this.active=t.first(),s=this.active.addClass("ui-state-focus").removeClass("ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),this.active.parent().closest(".ui-menu-item").addClass("ui-state-active"),e&&"keydown"===e.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=t.children(".ui-menu"),i.length&&e&&/^mouse/.test(e.type)&&this._startOpening(i),this.activeMenu=t.parent(),this._trigger("focus",e,{item:t})},_scrollIntoView:function(t){var i,s,n,a,o,r;this._hasScroll()&&(i=parseFloat(e.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(e.css(this.activeMenu[0],"paddingTop"))||0,n=t.offset().top-this.activeMenu.offset().top-i-s,a=this.activeMenu.scrollTop(),o=this.activeMenu.height(),r=t.outerHeight(),0>n?this.activeMenu.scrollTop(a+n):n+r>o&&this.activeMenu.scrollTop(a+n-o+r))},blur:function(e,t){t||clearTimeout(this.timer),this.active&&(this.active.removeClass("ui-state-focus"),this.active=null,this._trigger("blur",e,{item:this.active}))},_startOpening:function(e){clearTimeout(this.timer),"true"===e.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(e)},this.delay))},_open:function(t){var i=e.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(t,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:e(t&&t.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(t),this.activeMenu=s},this.delay)},_close:function(e){e||(e=this.active?this.active.parent():this.element),e.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active")},_closeOnDocumentClick:function(t){return!e(t.target).closest(".ui-menu").length},_isDivider:function(e){return!/[^\-\u2014\u2013\s]/.test(e.text())},collapse:function(e){var t=this.active&&this.active.parent().closest(".ui-menu-item",this.element);t&&t.length&&(this._close(),this.focus(e,t))},expand:function(e){var t=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();t&&t.length&&(this._open(t.parent()),this._delay(function(){this.focus(e,t)}))},next:function(e){this._move("next","first",e)},previous:function(e){this._move("prev","last",e)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(e,t,i){var s;this.active&&(s="first"===e||"last"===e?this.active["first"===e?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[e+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[t]()),this.focus(i,s)},nextPage:function(t){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=e(this),0>i.offset().top-s-n}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(t),void 0)},previousPage:function(t){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=e(this),i.offset().top-s+n>0}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items).first())),void 0):(this.next(t),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||e(t.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!0),this._trigger("select",t,i)},_filterMenuItems:function(t){var i=t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(e.trim(e(this).text()))})}}),e.widget("ui.autocomplete",{version:"1.11.4",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var t,i,s,n=this.element[0].nodeName.toLowerCase(),a="textarea"===n,o="input"===n;this.isMultiLine=a?!0:o?!1:this.element.prop("isContentEditable"),this.valueMethod=this.element[a||o?"val":"text"],this.isNewMenu=!0,this.element.addClass("ui-autocomplete-input").attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return t=!0,s=!0,i=!0,void 0;t=!1,s=!1,i=!1;var a=e.ui.keyCode;switch(n.keyCode){case a.PAGE_UP:t=!0,this._move("previousPage",n);break;case a.PAGE_DOWN:t=!0,this._move("nextPage",n);break;case a.UP:t=!0,this._keyEvent("previous",n);break;case a.DOWN:t=!0,this._keyEvent("next",n);break;case a.ENTER:this.menu.active&&(t=!0,n.preventDefault(),this.menu.select(n));break;case a.TAB:this.menu.active&&this.menu.select(n);break;case a.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(t)return t=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=e.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(e){return s?(s=!1,e.preventDefault(),void 0):(this._searchTimeout(e),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(e),this._change(e),void 0)}}),this._initSource(),this.menu=e("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur});var i=this.menu.element[0];e(t.target).closest(".ui-menu-item").length||this._delay(function(){var t=this;this.document.one("mousedown",function(s){s.target===t.element[0]||s.target===i||e.contains(i,s.target)||t.close()})})},menufocus:function(t,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){e(t.target).trigger(t.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",t,{item:n})&&t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&e.trim(s).length&&(this.liveRegion.children().hide(),e("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,t){var i=t.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!==this.document[0].activeElement&&(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger("select",e,{item:i})&&this._value(i.value),this.term=this._value(),this.close(e),this.selectedItem=i}}),this.liveRegion=e("<span>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(e,t){this._super(e,t),"source"===e&&this._initSource(),"appendTo"===e&&this.menu.element.appendTo(this._appendTo()),"disabled"===e&&t&&this.xhr&&this.xhr.abort()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_initSource:function(){var t,i,s=this;e.isArray(this.options.source)?(t=this.options.source,this.source=function(i,s){s(e.ui.autocomplete.filter(t,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(t,n){s.xhr&&s.xhr.abort(),s.xhr=e.ajax({url:i,data:t,dataType:"json",success:function(e){n(e)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(e){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),i=this.menu.element.is(":visible"),s=e.altKey||e.ctrlKey||e.metaKey||e.shiftKey;(!t||t&&!i&&!s)&&(this.selectedItem=null,this.search(null,e))},this.options.delay)},search:function(e,t){return e=null!=e?e:this._value(),this.term=this._value(),e.length<this.options.minLength?this.close(t):this._trigger("search",t)!==!1?this._search(e):void 0},_search:function(e){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:e},this._response())},_response:function(){var t=++this.requestIndex;return e.proxy(function(e){t===this.requestIndex&&this.__response(e),this.pending--,this.pending||this.element.removeClass("ui-autocomplete-loading")},this)},__response:function(e){e&&(e=this._normalize(e)),this._trigger("response",null,{content:e}),!this.options.disabled&&e&&e.length&&!this.cancelSearch?(this._suggest(e),this._trigger("open")):this._close()},close:function(e){this.cancelSearch=!0,this._close(e)},_close:function(e){this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",e))},_change:function(e){this.previous!==this._value()&&this._trigger("change",e,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:e.map(t,function(t){return"string"==typeof t?{label:t,value:t}:e.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var i=this.menu.element.empty();this._renderMenu(i,t),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(e.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next()},_resizeMenu:function(){var e=this.menu.element;e.outerWidth(Math.max(e.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(t,i){var s=this;e.each(i,function(e,i){s._renderItemData(t,i)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-autocomplete-item",t)},_renderItem:function(t,i){return e("<li>").text(i.label).appendTo(t)},_move:function(e,t){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(e)||this.menu.isLastItem()&&/^next/.test(e)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[e](t),void 0):(this.search(null,t),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(e,t){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(e,t),t.preventDefault())}}),e.extend(e.ui.autocomplete,{escapeRegex:function(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,i){var s=RegExp(e.ui.autocomplete.escapeRegex(i),"i");return e.grep(t,function(e){return s.test(e.label||e.value||e)})}}),e.widget("ui.autocomplete",e.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(e){return e+(e>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(t){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,this.liveRegion.children().hide(),e("<div>").text(i).appendTo(this.liveRegion))}}),e.ui.autocomplete;var c,p="ui-button ui-widget ui-state-default ui-corner-all",f="ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",m=function(){var t=e(this);setTimeout(function(){t.find(":ui-button").button("refresh")},1)},g=function(t){var i=t.name,s=t.form,n=e([]);return i&&(i=i.replace(/'/g,"\\'"),n=s?e(s).find("[name='"+i+"'][type=radio]"):e("[name='"+i+"'][type=radio]",t.ownerDocument).filter(function(){return!this.form})),n};e.widget("ui.button",{version:"1.11.4",defaultElement:"<button>",options:{disabled:null,text:!0,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset"+this.eventNamespace).bind("reset"+this.eventNamespace,m),"boolean"!=typeof this.options.disabled?this.options.disabled=!!this.element.prop("disabled"):this.element.prop("disabled",this.options.disabled),this._determineButtonType(),this.hasTitle=!!this.buttonElement.attr("title");var t=this,i=this.options,s="checkbox"===this.type||"radio"===this.type,n=s?"":"ui-state-active";null===i.label&&(i.label="input"===this.type?this.buttonElement.val():this.buttonElement.html()),this._hoverable(this.buttonElement),this.buttonElement.addClass(p).attr("role","button").bind("mouseenter"+this.eventNamespace,function(){i.disabled||this===c&&e(this).addClass("ui-state-active")}).bind("mouseleave"+this.eventNamespace,function(){i.disabled||e(this).removeClass(n)}).bind("click"+this.eventNamespace,function(e){i.disabled&&(e.preventDefault(),e.stopImmediatePropagation())}),this._on({focus:function(){this.buttonElement.addClass("ui-state-focus")},blur:function(){this.buttonElement.removeClass("ui-state-focus")}}),s&&this.element.bind("change"+this.eventNamespace,function(){t.refresh()}),"checkbox"===this.type?this.buttonElement.bind("click"+this.eventNamespace,function(){return i.disabled?!1:void 0}):"radio"===this.type?this.buttonElement.bind("click"+this.eventNamespace,function(){if(i.disabled)return!1;e(this).addClass("ui-state-active"),t.buttonElement.attr("aria-pressed","true");var s=t.element[0];g(s).not(s).map(function(){return e(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")}):(this.buttonElement.bind("mousedown"+this.eventNamespace,function(){return i.disabled?!1:(e(this).addClass("ui-state-active"),c=this,t.document.one("mouseup",function(){c=null}),void 0)}).bind("mouseup"+this.eventNamespace,function(){return i.disabled?!1:(e(this).removeClass("ui-state-active"),void 0)}).bind("keydown"+this.eventNamespace,function(t){return i.disabled?!1:((t.keyCode===e.ui.keyCode.SPACE||t.keyCode===e.ui.keyCode.ENTER)&&e(this).addClass("ui-state-active"),void 0)}).bind("keyup"+this.eventNamespace+" blur"+this.eventNamespace,function(){e(this).removeClass("ui-state-active")}),this.buttonElement.is("a")&&this.buttonElement.keyup(function(t){t.keyCode===e.ui.keyCode.SPACE&&e(this).click()})),this._setOption("disabled",i.disabled),this._resetButton()},_determineButtonType:function(){var e,t,i;this.type=this.element.is("[type=checkbox]")?"checkbox":this.element.is("[type=radio]")?"radio":this.element.is("input")?"input":"button","checkbox"===this.type||"radio"===this.type?(e=this.element.parents().last(),t="label[for='"+this.element.attr("id")+"']",this.buttonElement=e.find(t),this.buttonElement.length||(e=e.length?e.siblings():this.element.siblings(),this.buttonElement=e.filter(t),this.buttonElement.length||(this.buttonElement=e.find(t))),this.element.addClass("ui-helper-hidden-accessible"),i=this.element.is(":checked"),i&&this.buttonElement.addClass("ui-state-active"),this.buttonElement.prop("aria-pressed",i)):this.buttonElement=this.element},widget:function(){return this.buttonElement},_destroy:function(){this.element.removeClass("ui-helper-hidden-accessible"),this.buttonElement.removeClass(p+" ui-state-active "+f).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()),this.hasTitle||this.buttonElement.removeAttr("title")},_setOption:function(e,t){return this._super(e,t),"disabled"===e?(this.widget().toggleClass("ui-state-disabled",!!t),this.element.prop("disabled",!!t),t&&("checkbox"===this.type||"radio"===this.type?this.buttonElement.removeClass("ui-state-focus"):this.buttonElement.removeClass("ui-state-focus ui-state-active")),void 0):(this._resetButton(),void 0)},refresh:function(){var t=this.element.is("input, button")?this.element.is(":disabled"):this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOption("disabled",t),"radio"===this.type?g(this.element[0]).each(function(){e(this).is(":checked")?e(this).button("widget").addClass("ui-state-active").attr("aria-pressed","true"):e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")}):"checkbox"===this.type&&(this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false"))},_resetButton:function(){if("input"===this.type)return this.options.label&&this.element.val(this.options.label),void 0;var t=this.buttonElement.removeClass(f),i=e("<span></span>",this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(),s=this.options.icons,n=s.primary&&s.secondary,a=[];s.primary||s.secondary?(this.options.text&&a.push("ui-button-text-icon"+(n?"s":s.primary?"-primary":"-secondary")),s.primary&&t.prepend("<span class='ui-button-icon-primary ui-icon "+s.primary+"'></span>"),s.secondary&&t.append("<span class='ui-button-icon-secondary ui-icon "+s.secondary+"'></span>"),this.options.text||(a.push(n?"ui-button-icons-only":"ui-button-icon-only"),this.hasTitle||t.attr("title",e.trim(i)))):a.push("ui-button-text-only"),t.addClass(a.join(" "))}}),e.widget("ui.buttonset",{version:"1.11.4",options:{items:"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(e,t){"disabled"===e&&this.buttons.button("option",e,t),this._super(e,t)},refresh:function(){var t="rtl"===this.element.css("direction"),i=this.element.find(this.options.items),s=i.filter(":ui-button");i.not(":ui-button").button(),s.button("refresh"),this.buttons=i.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t?"ui-corner-right":"ui-corner-left").end().filter(":last").addClass(t?"ui-corner-left":"ui-corner-right").end().end()},_destroy:function(){this.element.removeClass("ui-buttonset"),this.buttons.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy")}}),e.ui.button,e.extend(e.ui,{datepicker:{version:"1.11.4"}});var v;e.extend(n.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(e){return r(this._defaults,e||{}),this},_attachDatepicker:function(t,i){var s,n,a;s=t.nodeName.toLowerCase(),n="div"===s||"span"===s,t.id||(this.uuid+=1,t.id="dp"+this.uuid),a=this._newInst(e(t),n),a.settings=e.extend({},i||{}),"input"===s?this._connectDatepicker(t,a):n&&this._inlineDatepicker(t,a)},_newInst:function(t,i){var s=t[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:t,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?a(e("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(t,i){var s=e(t);i.append=e([]),i.trigger=e([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp),this._autoSize(i),e.data(t,"datepicker",i),i.settings.disabled&&this._disableDatepicker(t))},_attachments:function(t,i){var s,n,a,o=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),o&&(i.append=e("<span class='"+this._appendClass+"'>"+o+"</span>"),t[r?"before":"after"](i.append)),t.unbind("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&t.focus(this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),a=this._get(i,"buttonImage"),i.trigger=e(this._get(i,"buttonImageOnly")?e("<img/>").addClass(this._triggerClass).attr({src:a,alt:n,title:n}):e("<button type='button'></button>").addClass(this._triggerClass).html(a?e("<img/>").attr({src:a,alt:n,title:n}):n)),t[r?"before":"after"](i.trigger),i.trigger.click(function(){return e.datepicker._datepickerShowing&&e.datepicker._lastInput===t[0]?e.datepicker._hideDatepicker():e.datepicker._datepickerShowing&&e.datepicker._lastInput!==t[0]?(e.datepicker._hideDatepicker(),e.datepicker._showDatepicker(t[0])):e.datepicker._showDatepicker(t[0]),!1}))},_autoSize:function(e){if(this._get(e,"autoSize")&&!e.inline){var t,i,s,n,a=new Date(2009,11,20),o=this._get(e,"dateFormat");o.match(/[DM]/)&&(t=function(e){for(i=0,s=0,n=0;e.length>n;n++)e[n].length>i&&(i=e[n].length,s=n);return s},a.setMonth(t(this._get(e,o.match(/MM/)?"monthNames":"monthNamesShort"))),a.setDate(t(this._get(e,o.match(/DD/)?"dayNames":"dayNamesShort"))+20-a.getDay())),e.input.attr("size",this._formatDate(e,a).length)}},_inlineDatepicker:function(t,i){var s=e(t);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),e.data(t,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(t),i.dpDiv.css("display","block"))},_dialogDatepicker:function(t,i,s,n,a){var o,h,l,u,d,c=this._dialogInst;return c||(this.uuid+=1,o="dp"+this.uuid,this._dialogInput=e("<input type='text' id='"+o+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.keydown(this._doKeyDown),e("body").append(this._dialogInput),c=this._dialogInst=this._newInst(this._dialogInput,!1),c.settings={},e.data(this._dialogInput[0],"datepicker",c)),r(c.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(c,i):i,this._dialogInput.val(i),this._pos=a?a.length?a:[a.pageX,a.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,u=document.documentElement.scrollLeft||document.body.scrollLeft,d=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+u,l/2-150+d]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),c.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),e.blockUI&&e.blockUI(this.dpDiv),e.data(this._dialogInput[0],"datepicker",c),this},_destroyDatepicker:function(t){var i,s=e(t),n=e.data(t,"datepicker");s.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),e.removeData(t,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),v===n&&(v=null))},_enableDatepicker:function(t){var i,s,n=e(t),a=e.data(t,"datepicker");n.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!1,a.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}))},_disableDatepicker:function(t){var i,s,n=e(t),a=e.data(t,"datepicker");n.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!0,a.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}),this._disabledInputs[this._disabledInputs.length]=t)},_isDisabledDatepicker:function(e){if(!e)return!1;for(var t=0;this._disabledInputs.length>t;t++)if(this._disabledInputs[t]===e)return!0;return!1},_getInst:function(t){try{return e.data(t,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(t,i,s){var n,a,o,h,l=this._getInst(t);return 2===arguments.length&&"string"==typeof i?"defaults"===i?e.extend({},e.datepicker._defaults):l?"all"===i?e.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),a=this._getDateDatepicker(t,!0),o=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),r(l.settings,n),null!==o&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,o)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(t):this._enableDatepicker(t)),this._attachments(e(t),l),this._autoSize(l),this._setDate(l,a),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(e,t,i){this._optionDatepicker(e,t,i)},_refreshDatepicker:function(e){var t=this._getInst(e);t&&this._updateDatepicker(t)},_setDateDatepicker:function(e,t){var i=this._getInst(e);i&&(this._setDate(i,t),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(e,t){var i=this._getInst(e);return i&&!i.inline&&this._setDateFromField(i,t),i?this._getDate(i):null},_doKeyDown:function(t){var i,s,n,a=e.datepicker._getInst(t.target),o=!0,r=a.dpDiv.is(".ui-datepicker-rtl");if(a._keyEvent=!0,e.datepicker._datepickerShowing)switch(t.keyCode){case 9:e.datepicker._hideDatepicker(),o=!1;break;case 13:return n=e("td."+e.datepicker._dayOverClass+":not(."+e.datepicker._currentClass+")",a.dpDiv),n[0]&&e.datepicker._selectDay(t.target,a.selectedMonth,a.selectedYear,n[0]),i=e.datepicker._get(a,"onSelect"),i?(s=e.datepicker._formatDate(a),i.apply(a.input?a.input[0]:null,[s,a])):e.datepicker._hideDatepicker(),!1;case 27:e.datepicker._hideDatepicker();break;case 33:e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(a,"stepBigMonths"):-e.datepicker._get(a,"stepMonths"),"M");break;case 34:e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(a,"stepBigMonths"):+e.datepicker._get(a,"stepMonths"),"M");break;case 35:(t.ctrlKey||t.metaKey)&&e.datepicker._clearDate(t.target),o=t.ctrlKey||t.metaKey;break;case 36:(t.ctrlKey||t.metaKey)&&e.datepicker._gotoToday(t.target),o=t.ctrlKey||t.metaKey;break;case 37:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,r?1:-1,"D"),o=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(a,"stepBigMonths"):-e.datepicker._get(a,"stepMonths"),"M");break;case 38:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,-7,"D"),o=t.ctrlKey||t.metaKey;break;case 39:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,r?-1:1,"D"),o=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(a,"stepBigMonths"):+e.datepicker._get(a,"stepMonths"),"M");break;case 40:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,7,"D"),o=t.ctrlKey||t.metaKey;break;default:o=!1}else 36===t.keyCode&&t.ctrlKey?e.datepicker._showDatepicker(this):o=!1;o&&(t.preventDefault(),t.stopPropagation())},_doKeyPress:function(t){var i,s,n=e.datepicker._getInst(t.target);
return e.datepicker._get(n,"constrainInput")?(i=e.datepicker._possibleChars(e.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==t.charCode?t.keyCode:t.charCode),t.ctrlKey||t.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(t){var i,s=e.datepicker._getInst(t.target);if(s.input.val()!==s.lastVal)try{i=e.datepicker.parseDate(e.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,e.datepicker._getFormatConfig(s)),i&&(e.datepicker._setDateFromField(s),e.datepicker._updateAlternate(s),e.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(t){if(t=t.target||t,"input"!==t.nodeName.toLowerCase()&&(t=e("input",t.parentNode)[0]),!e.datepicker._isDisabledDatepicker(t)&&e.datepicker._lastInput!==t){var i,n,a,o,h,l,u;i=e.datepicker._getInst(t),e.datepicker._curInst&&e.datepicker._curInst!==i&&(e.datepicker._curInst.dpDiv.stop(!0,!0),i&&e.datepicker._datepickerShowing&&e.datepicker._hideDatepicker(e.datepicker._curInst.input[0])),n=e.datepicker._get(i,"beforeShow"),a=n?n.apply(t,[t,i]):{},a!==!1&&(r(i.settings,a),i.lastVal=null,e.datepicker._lastInput=t,e.datepicker._setDateFromField(i),e.datepicker._inDialog&&(t.value=""),e.datepicker._pos||(e.datepicker._pos=e.datepicker._findPos(t),e.datepicker._pos[1]+=t.offsetHeight),o=!1,e(t).parents().each(function(){return o|="fixed"===e(this).css("position"),!o}),h={left:e.datepicker._pos[0],top:e.datepicker._pos[1]},e.datepicker._pos=null,i.dpDiv.empty(),i.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),e.datepicker._updateDatepicker(i),h=e.datepicker._checkOffset(i,h,o),i.dpDiv.css({position:e.datepicker._inDialog&&e.blockUI?"static":o?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),i.inline||(l=e.datepicker._get(i,"showAnim"),u=e.datepicker._get(i,"duration"),i.dpDiv.css("z-index",s(e(t))+1),e.datepicker._datepickerShowing=!0,e.effects&&e.effects.effect[l]?i.dpDiv.show(l,e.datepicker._get(i,"showOptions"),u):i.dpDiv[l||"show"](l?u:null),e.datepicker._shouldFocusInput(i)&&i.input.focus(),e.datepicker._curInst=i))}},_updateDatepicker:function(t){this.maxRows=4,v=t,t.dpDiv.empty().append(this._generateHTML(t)),this._attachHandlers(t);var i,s=this._getNumberOfMonths(t),n=s[1],a=17,r=t.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&t.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),t.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),t.dpDiv[(this._get(t,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),t===e.datepicker._curInst&&e.datepicker._datepickerShowing&&e.datepicker._shouldFocusInput(t)&&t.input.focus(),t.yearshtml&&(i=t.yearshtml,setTimeout(function(){i===t.yearshtml&&t.yearshtml&&t.dpDiv.find("select.ui-datepicker-year:first").replaceWith(t.yearshtml),i=t.yearshtml=null},0))},_shouldFocusInput:function(e){return e.input&&e.input.is(":visible")&&!e.input.is(":disabled")&&!e.input.is(":focus")},_checkOffset:function(t,i,s){var n=t.dpDiv.outerWidth(),a=t.dpDiv.outerHeight(),o=t.input?t.input.outerWidth():0,r=t.input?t.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:e(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:e(document).scrollTop());return i.left-=this._get(t,"isRTL")?n-o:0,i.left-=s&&i.left===t.input.offset().left?e(document).scrollLeft():0,i.top-=s&&i.top===t.input.offset().top+r?e(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+a>l&&l>a?Math.abs(a+r):0),i},_findPos:function(t){for(var i,s=this._getInst(t),n=this._get(s,"isRTL");t&&("hidden"===t.type||1!==t.nodeType||e.expr.filters.hidden(t));)t=t[n?"previousSibling":"nextSibling"];return i=e(t).offset(),[i.left,i.top]},_hideDatepicker:function(t){var i,s,n,a,o=this._curInst;!o||t&&o!==e.data(t,"datepicker")||this._datepickerShowing&&(i=this._get(o,"showAnim"),s=this._get(o,"duration"),n=function(){e.datepicker._tidyDialog(o)},e.effects&&(e.effects.effect[i]||e.effects[i])?o.dpDiv.hide(i,e.datepicker._get(o,"showOptions"),s,n):o.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,a=this._get(o,"onClose"),a&&a.apply(o.input?o.input[0]:null,[o.input?o.input.val():"",o]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),e.blockUI&&(e.unblockUI(),e("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(e){e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(t){if(e.datepicker._curInst){var i=e(t.target),s=e.datepicker._getInst(i[0]);(i[0].id!==e.datepicker._mainDivId&&0===i.parents("#"+e.datepicker._mainDivId).length&&!i.hasClass(e.datepicker.markerClassName)&&!i.closest("."+e.datepicker._triggerClass).length&&e.datepicker._datepickerShowing&&(!e.datepicker._inDialog||!e.blockUI)||i.hasClass(e.datepicker.markerClassName)&&e.datepicker._curInst!==s)&&e.datepicker._hideDatepicker()}},_adjustDate:function(t,i,s){var n=e(t),a=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(a,i+("M"===s?this._get(a,"showCurrentAtPos"):0),s),this._updateDatepicker(a))},_gotoToday:function(t){var i,s=e(t),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(t,i,s){var n=e(t),a=this._getInst(n[0]);a["selected"+("M"===s?"Month":"Year")]=a["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(a),this._adjustDate(n)},_selectDay:function(t,i,s,n){var a,o=e(t);e(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(o[0])||(a=this._getInst(o[0]),a.selectedDay=a.currentDay=e("a",n).html(),a.selectedMonth=a.currentMonth=i,a.selectedYear=a.currentYear=s,this._selectDate(t,this._formatDate(a,a.currentDay,a.currentMonth,a.currentYear)))},_clearDate:function(t){var i=e(t);this._selectDate(i,"")},_selectDate:function(t,i){var s,n=e(t),a=this._getInst(n[0]);i=null!=i?i:this._formatDate(a),a.input&&a.input.val(i),this._updateAlternate(a),s=this._get(a,"onSelect"),s?s.apply(a.input?a.input[0]:null,[i,a]):a.input&&a.input.trigger("change"),a.inline?this._updateDatepicker(a):(this._hideDatepicker(),this._lastInput=a.input[0],"object"!=typeof a.input[0]&&a.input.focus(),this._lastInput=null)},_updateAlternate:function(t){var i,s,n,a=this._get(t,"altField");a&&(i=this._get(t,"altFormat")||this._get(t,"dateFormat"),s=this._getDate(t),n=this.formatDate(i,s,this._getFormatConfig(t)),e(a).each(function(){e(this).val(n)}))},noWeekends:function(e){var t=e.getDay();return[t>0&&6>t,""]},iso8601Week:function(e){var t,i=new Date(e.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),t=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((t-i)/864e5)/7)+1},parseDate:function(t,i,s){if(null==t||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,a,o,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,u="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),d=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,c=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,m=-1,g=-1,v=-1,y=-1,b=!1,_=function(e){var i=t.length>n+1&&t.charAt(n+1)===e;return i&&n++,i},x=function(e){var t=_(e),s="@"===e?14:"!"===e?20:"y"===e&&t?4:"o"===e?3:2,n="y"===e?s:1,a=RegExp("^\\d{"+n+","+s+"}"),o=i.substring(h).match(a);if(!o)throw"Missing number at position "+h;return h+=o[0].length,parseInt(o[0],10)},w=function(t,s,n){var a=-1,o=e.map(_(t)?n:s,function(e,t){return[[t,e]]}).sort(function(e,t){return-(e[1].length-t[1].length)});if(e.each(o,function(e,t){var s=t[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(a=t[0],h+=s.length,!1):void 0}),-1!==a)return a+1;throw"Unknown name at position "+h},k=function(){if(i.charAt(h)!==t.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;t.length>n;n++)if(b)"'"!==t.charAt(n)||_("'")?k():b=!1;else switch(t.charAt(n)){case"d":v=x("d");break;case"D":w("D",d,c);break;case"o":y=x("o");break;case"m":g=x("m");break;case"M":g=w("M",p,f);break;case"y":m=x("y");break;case"@":r=new Date(x("@")),m=r.getFullYear(),g=r.getMonth()+1,v=r.getDate();break;case"!":r=new Date((x("!")-this._ticksTo1970)/1e4),m=r.getFullYear(),g=r.getMonth()+1,v=r.getDate();break;case"'":_("'")?k():b=!0;break;default:k()}if(i.length>h&&(o=i.substr(h),!/^\s+/.test(o)))throw"Extra/unparsed characters found in date: "+o;if(-1===m?m=(new Date).getFullYear():100>m&&(m+=(new Date).getFullYear()-(new Date).getFullYear()%100+(u>=m?0:-100)),y>-1)for(g=1,v=y;;){if(a=this._getDaysInMonth(m,g-1),a>=v)break;g++,v-=a}if(r=this._daylightSavingAdjust(new Date(m,g-1,v)),r.getFullYear()!==m||r.getMonth()+1!==g||r.getDate()!==v)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(e,t,i){if(!t)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,a=(i?i.dayNames:null)||this._defaults.dayNames,o=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(t){var i=e.length>s+1&&e.charAt(s+1)===t;return i&&s++,i},l=function(e,t,i){var s=""+t;if(h(e))for(;i>s.length;)s="0"+s;return s},u=function(e,t,i,s){return h(e)?s[t]:i[t]},d="",c=!1;if(t)for(s=0;e.length>s;s++)if(c)"'"!==e.charAt(s)||h("'")?d+=e.charAt(s):c=!1;else switch(e.charAt(s)){case"d":d+=l("d",t.getDate(),2);break;case"D":d+=u("D",t.getDay(),n,a);break;case"o":d+=l("o",Math.round((new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()-new Date(t.getFullYear(),0,0).getTime())/864e5),3);break;case"m":d+=l("m",t.getMonth()+1,2);break;case"M":d+=u("M",t.getMonth(),o,r);break;case"y":d+=h("y")?t.getFullYear():(10>t.getYear()%100?"0":"")+t.getYear()%100;break;case"@":d+=t.getTime();break;case"!":d+=1e4*t.getTime()+this._ticksTo1970;break;case"'":h("'")?d+="'":c=!0;break;default:d+=e.charAt(s)}return d},_possibleChars:function(e){var t,i="",s=!1,n=function(i){var s=e.length>t+1&&e.charAt(t+1)===i;return s&&t++,s};for(t=0;e.length>t;t++)if(s)"'"!==e.charAt(t)||n("'")?i+=e.charAt(t):s=!1;else switch(e.charAt(t)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=e.charAt(t)}return i},_get:function(e,t){return void 0!==e.settings[t]?e.settings[t]:this._defaults[t]},_setDateFromField:function(e,t){if(e.input.val()!==e.lastVal){var i=this._get(e,"dateFormat"),s=e.lastVal=e.input?e.input.val():null,n=this._getDefaultDate(e),a=n,o=this._getFormatConfig(e);try{a=this.parseDate(i,s,o)||n}catch(r){s=t?"":s}e.selectedDay=a.getDate(),e.drawMonth=e.selectedMonth=a.getMonth(),e.drawYear=e.selectedYear=a.getFullYear(),e.currentDay=s?a.getDate():0,e.currentMonth=s?a.getMonth():0,e.currentYear=s?a.getFullYear():0,this._adjustInstDate(e)}},_getDefaultDate:function(e){return this._restrictMinMax(e,this._determineDate(e,this._get(e,"defaultDate"),new Date))},_determineDate:function(t,i,s){var n=function(e){var t=new Date;return t.setDate(t.getDate()+e),t},a=function(i){try{return e.datepicker.parseDate(e.datepicker._get(t,"dateFormat"),i,e.datepicker._getFormatConfig(t))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?e.datepicker._getDate(t):null)||new Date,a=n.getFullYear(),o=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":o+=parseInt(l[1],10),r=Math.min(r,e.datepicker._getDaysInMonth(a,o));break;case"y":case"Y":a+=parseInt(l[1],10),r=Math.min(r,e.datepicker._getDaysInMonth(a,o))}l=h.exec(i)}return new Date(a,o,r)},o=null==i||""===i?s:"string"==typeof i?a(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return o=o&&"Invalid Date"==""+o?s:o,o&&(o.setHours(0),o.setMinutes(0),o.setSeconds(0),o.setMilliseconds(0)),this._daylightSavingAdjust(o)},_daylightSavingAdjust:function(e){return e?(e.setHours(e.getHours()>12?e.getHours()+2:0),e):null},_setDate:function(e,t,i){var s=!t,n=e.selectedMonth,a=e.selectedYear,o=this._restrictMinMax(e,this._determineDate(e,t,new Date));e.selectedDay=e.currentDay=o.getDate(),e.drawMonth=e.selectedMonth=e.currentMonth=o.getMonth(),e.drawYear=e.selectedYear=e.currentYear=o.getFullYear(),n===e.selectedMonth&&a===e.selectedYear||i||this._notifyChange(e),this._adjustInstDate(e),e.input&&e.input.val(s?"":this._formatDate(e))},_getDate:function(e){var t=!e.currentYear||e.input&&""===e.input.val()?null:this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return t},_attachHandlers:function(t){var i=this._get(t,"stepMonths"),s="#"+t.id.replace(/\\\\/g,"\\");t.dpDiv.find("[data-handler]").map(function(){var t={prev:function(){e.datepicker._adjustDate(s,-i,"M")},next:function(){e.datepicker._adjustDate(s,+i,"M")},hide:function(){e.datepicker._hideDatepicker()},today:function(){e.datepicker._gotoToday(s)},selectDay:function(){return e.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return e.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return e.datepicker._selectMonthYear(s,this,"Y"),!1}};e(this).bind(this.getAttribute("data-event"),t[this.getAttribute("data-handler")])})},_generateHTML:function(e){var t,i,s,n,a,o,r,h,l,u,d,c,p,f,m,g,v,y,b,_,x,w,k,T,D,S,M,C,N,A,P,I,H,z,F,E,O,j,W,L=new Date,R=this._daylightSavingAdjust(new Date(L.getFullYear(),L.getMonth(),L.getDate())),Y=this._get(e,"isRTL"),B=this._get(e,"showButtonPanel"),J=this._get(e,"hideIfNoPrevNext"),q=this._get(e,"navigationAsDateFormat"),K=this._getNumberOfMonths(e),V=this._get(e,"showCurrentAtPos"),U=this._get(e,"stepMonths"),Q=1!==K[0]||1!==K[1],G=this._daylightSavingAdjust(e.currentDay?new Date(e.currentYear,e.currentMonth,e.currentDay):new Date(9999,9,9)),X=this._getMinMaxDate(e,"min"),$=this._getMinMaxDate(e,"max"),Z=e.drawMonth-V,et=e.drawYear;if(0>Z&&(Z+=12,et--),$)for(t=this._daylightSavingAdjust(new Date($.getFullYear(),$.getMonth()-K[0]*K[1]+1,$.getDate())),t=X&&X>t?X:t;this._daylightSavingAdjust(new Date(et,Z,1))>t;)Z--,0>Z&&(Z=11,et--);for(e.drawMonth=Z,e.drawYear=et,i=this._get(e,"prevText"),i=q?this.formatDate(i,this._daylightSavingAdjust(new Date(et,Z-U,1)),this._getFormatConfig(e)):i,s=this._canAdjustMonth(e,-1,et,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":J?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(e,"nextText"),n=q?this.formatDate(n,this._daylightSavingAdjust(new Date(et,Z+U,1)),this._getFormatConfig(e)):n,a=this._canAdjustMonth(e,1,et,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":J?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",o=this._get(e,"currentText"),r=this._get(e,"gotoCurrent")&&e.currentDay?G:R,o=q?this.formatDate(o,r,this._getFormatConfig(e)):o,h=e.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(e,"closeText")+"</button>",l=B?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(e,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+o+"</button>":"")+(Y?"":h)+"</div>":"",u=parseInt(this._get(e,"firstDay"),10),u=isNaN(u)?0:u,d=this._get(e,"showWeek"),c=this._get(e,"dayNames"),p=this._get(e,"dayNamesMin"),f=this._get(e,"monthNames"),m=this._get(e,"monthNamesShort"),g=this._get(e,"beforeShowDay"),v=this._get(e,"showOtherMonths"),y=this._get(e,"selectOtherMonths"),b=this._getDefaultDate(e),_="",w=0;K[0]>w;w++){for(k="",this.maxRows=4,T=0;K[1]>T;T++){if(D=this._daylightSavingAdjust(new Date(et,Z,e.selectedDay)),S=" ui-corner-all",M="",Q){if(M+="<div class='ui-datepicker-group",K[1]>1)switch(T){case 0:M+=" ui-datepicker-group-first",S=" ui-corner-"+(Y?"right":"left");break;case K[1]-1:M+=" ui-datepicker-group-last",S=" ui-corner-"+(Y?"left":"right");break;default:M+=" ui-datepicker-group-middle",S=""}M+="'>"}for(M+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+S+"'>"+(/all|left/.test(S)&&0===w?Y?a:s:"")+(/all|right/.test(S)&&0===w?Y?s:a:"")+this._generateMonthYearHeader(e,Z,et,X,$,w>0||T>0,f,m)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",C=d?"<th class='ui-datepicker-week-col'>"+this._get(e,"weekHeader")+"</th>":"",x=0;7>x;x++)N=(x+u)%7,C+="<th scope='col'"+((x+u+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+c[N]+"'>"+p[N]+"</span></th>";for(M+=C+"</tr></thead><tbody>",A=this._getDaysInMonth(et,Z),et===e.selectedYear&&Z===e.selectedMonth&&(e.selectedDay=Math.min(e.selectedDay,A)),P=(this._getFirstDayOfMonth(et,Z)-u+7)%7,I=Math.ceil((P+A)/7),H=Q?this.maxRows>I?this.maxRows:I:I,this.maxRows=H,z=this._daylightSavingAdjust(new Date(et,Z,1-P)),F=0;H>F;F++){for(M+="<tr>",E=d?"<td class='ui-datepicker-week-col'>"+this._get(e,"calculateWeek")(z)+"</td>":"",x=0;7>x;x++)O=g?g.apply(e.input?e.input[0]:null,[z]):[!0,""],j=z.getMonth()!==Z,W=j&&!y||!O[0]||X&&X>z||$&&z>$,E+="<td class='"+((x+u+6)%7>=5?" ui-datepicker-week-end":"")+(j?" ui-datepicker-other-month":"")+(z.getTime()===D.getTime()&&Z===e.selectedMonth&&e._keyEvent||b.getTime()===z.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(W?" "+this._unselectableClass+" ui-state-disabled":"")+(j&&!v?"":" "+O[1]+(z.getTime()===G.getTime()?" "+this._currentClass:"")+(z.getTime()===R.getTime()?" ui-datepicker-today":""))+"'"+(j&&!v||!O[2]?"":" title='"+O[2].replace(/'/g,"&#39;")+"'")+(W?"":" data-handler='selectDay' data-event='click' data-month='"+z.getMonth()+"' data-year='"+z.getFullYear()+"'")+">"+(j&&!v?"&#xa0;":W?"<span class='ui-state-default'>"+z.getDate()+"</span>":"<a class='ui-state-default"+(z.getTime()===R.getTime()?" ui-state-highlight":"")+(z.getTime()===G.getTime()?" ui-state-active":"")+(j?" ui-priority-secondary":"")+"' href='#'>"+z.getDate()+"</a>")+"</td>",z.setDate(z.getDate()+1),z=this._daylightSavingAdjust(z);M+=E+"</tr>"}Z++,Z>11&&(Z=0,et++),M+="</tbody></table>"+(Q?"</div>"+(K[0]>0&&T===K[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),k+=M}_+=k}return _+=l,e._keyEvent=!1,_},_generateMonthYearHeader:function(e,t,i,s,n,a,o,r){var h,l,u,d,c,p,f,m,g=this._get(e,"changeMonth"),v=this._get(e,"changeYear"),y=this._get(e,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",_="";if(a||!g)_+="<span class='ui-datepicker-month'>"+o[t]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,_+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",u=0;12>u;u++)(!h||u>=s.getMonth())&&(!l||n.getMonth()>=u)&&(_+="<option value='"+u+"'"+(u===t?" selected='selected'":"")+">"+r[u]+"</option>");_+="</select>"}if(y||(b+=_+(!a&&g&&v?"":"&#xa0;")),!e.yearshtml)if(e.yearshtml="",a||!v)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(d=this._get(e,"yearRange").split(":"),c=(new Date).getFullYear(),p=function(e){var t=e.match(/c[+\-].*/)?i+parseInt(e.substring(1),10):e.match(/[+\-].*/)?c+parseInt(e,10):parseInt(e,10);return isNaN(t)?c:t},f=p(d[0]),m=Math.max(f,p(d[1]||"")),f=s?Math.max(f,s.getFullYear()):f,m=n?Math.min(m,n.getFullYear()):m,e.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";m>=f;f++)e.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";e.yearshtml+="</select>",b+=e.yearshtml,e.yearshtml=null}return b+=this._get(e,"yearSuffix"),y&&(b+=(!a&&g&&v?"":"&#xa0;")+_),b+="</div>"},_adjustInstDate:function(e,t,i){var s=e.drawYear+("Y"===i?t:0),n=e.drawMonth+("M"===i?t:0),a=Math.min(e.selectedDay,this._getDaysInMonth(s,n))+("D"===i?t:0),o=this._restrictMinMax(e,this._daylightSavingAdjust(new Date(s,n,a)));e.selectedDay=o.getDate(),e.drawMonth=e.selectedMonth=o.getMonth(),e.drawYear=e.selectedYear=o.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(e)},_restrictMinMax:function(e,t){var i=this._getMinMaxDate(e,"min"),s=this._getMinMaxDate(e,"max"),n=i&&i>t?i:t;return s&&n>s?s:n},_notifyChange:function(e){var t=this._get(e,"onChangeMonthYear");t&&t.apply(e.input?e.input[0]:null,[e.selectedYear,e.selectedMonth+1,e])},_getNumberOfMonths:function(e){var t=this._get(e,"numberOfMonths");return null==t?[1,1]:"number"==typeof t?[1,t]:t},_getMinMaxDate:function(e,t){return this._determineDate(e,this._get(e,t+"Date"),null)},_getDaysInMonth:function(e,t){return 32-this._daylightSavingAdjust(new Date(e,t,32)).getDate()},_getFirstDayOfMonth:function(e,t){return new Date(e,t,1).getDay()},_canAdjustMonth:function(e,t,i,s){var n=this._getNumberOfMonths(e),a=this._daylightSavingAdjust(new Date(i,s+(0>t?t:n[0]*n[1]),1));return 0>t&&a.setDate(this._getDaysInMonth(a.getFullYear(),a.getMonth())),this._isInRange(e,a)},_isInRange:function(e,t){var i,s,n=this._getMinMaxDate(e,"min"),a=this._getMinMaxDate(e,"max"),o=null,r=null,h=this._get(e,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),o=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(o+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||t.getTime()>=n.getTime())&&(!a||t.getTime()<=a.getTime())&&(!o||t.getFullYear()>=o)&&(!r||r>=t.getFullYear())},_getFormatConfig:function(e){var t=this._get(e,"shortYearCutoff");return t="string"!=typeof t?t:(new Date).getFullYear()%100+parseInt(t,10),{shortYearCutoff:t,dayNamesShort:this._get(e,"dayNamesShort"),dayNames:this._get(e,"dayNames"),monthNamesShort:this._get(e,"monthNamesShort"),monthNames:this._get(e,"monthNames")}},_formatDate:function(e,t,i,s){t||(e.currentDay=e.selectedDay,e.currentMonth=e.selectedMonth,e.currentYear=e.selectedYear);var n=t?"object"==typeof t?t:this._daylightSavingAdjust(new Date(s,i,t)):this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return this.formatDate(this._get(e,"dateFormat"),n,this._getFormatConfig(e))}}),e.fn.datepicker=function(t){if(!this.length)return this;e.datepicker.initialized||(e(document).mousedown(e.datepicker._checkExternalClick),e.datepicker.initialized=!0),0===e("#"+e.datepicker._mainDivId).length&&e("body").append(e.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof t||"isDisabled"!==t&&"getDate"!==t&&"widget"!==t?"option"===t&&2===arguments.length&&"string"==typeof arguments[1]?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof t?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this].concat(i)):e.datepicker._attachDatepicker(this,t)}):e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i))},e.datepicker=new n,e.datepicker.initialized=!1,e.datepicker.uuid=(new Date).getTime(),e.datepicker.version="1.11.4",e.datepicker,e.widget("ui.draggable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.options;return this._blurActiveElement(t),this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=e(this);return e("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var i=this.document[0];if(this.handleElement.is(t.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(s){}},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===e(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._normalizeRightBottom(),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(e){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:e.pageX-this.offset.left,top:e.pageY-this.offset.top}},_mouseDrag:function(t,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper),n=s?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options,a=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,e(a).width()-this.helperProportions.width-this.margins.left,(e(a).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=e(n.containment),s=i[0],s&&(t=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)
},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,n,a,o=this.options,r=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,h=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a),"y"===o.axis&&(h=this.originalPageX),"x"===o.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var n=e.extend({},i,{item:s.element});s.sortables=[],e(s.options.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var n=e.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,e.each(s.sortables,function(){var e=this;e.isOver?(e.isOver=0,s.cancelHelperRemoval=!0,e.cancelHelperRemoval=!1,e._storedCSS={position:e.placeholder.css("position"),top:e.placeholder.css("top"),left:e.placeholder.css("left")},e._mouseStop(t),e.options.helper=e.options._helper):(e.cancelHelperRemoval=!0,e._trigger("deactivate",t,n))})},drag:function(t,i,s){e.each(s.sortables,function(){var n=!1,a=this;a.positionAbs=s.positionAbs,a.helperProportions=s.helperProportions,a.offset.click=s.offset.click,a._intersectsWith(a.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==a&&this._intersectsWith(this.containerCache)&&e.contains(a.element[0],this.element[0])&&(n=!1),n})),n?(a.isOver||(a.isOver=1,s._parent=i.helper.parent(),a.currentItem=i.helper.appendTo(a.element).data("ui-sortable-item",!0),a.options._helper=a.options.helper,a.options.helper=function(){return i.helper[0]},t.target=a.currentItem[0],a._mouseCapture(t,!0),a._mouseStart(t,!0,!0),a.offset.click.top=s.offset.click.top,a.offset.click.left=s.offset.click.left,a.offset.parent.left-=s.offset.parent.left-a.offset.parent.left,a.offset.parent.top-=s.offset.parent.top-a.offset.parent.top,s._trigger("toSortable",t),s.dropped=a.element,e.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,a.fromOutside=s),a.currentItem&&(a._mouseDrag(t),i.position=a.position)):a.isOver&&(a.isOver=0,a.cancelHelperRemoval=!0,a.options._revert=a.options.revert,a.options.revert=!1,a._trigger("out",t,a._uiHash(a)),a._mouseStop(t,!0),a.options.revert=a.options._revert,a.options.helper=a.options._helper,a.placeholder&&a.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(t),i.position=s._generatePosition(t,!0),s._trigger("fromSortable",t),s.dropped=!1,e.each(s.sortables,function(){this.refreshPositions()}))})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var n=e("body"),a=s.options;n.css("cursor")&&(a._cursor=n.css("cursor")),n.css("cursor",a.cursor)},stop:function(t,i,s){var n=s.options;n._cursor&&e("body").css("cursor",n._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("opacity")&&(a._opacity=n.css("opacity")),n.css("opacity",a.opacity)},stop:function(t,i,s){var n=s.options;n._opacity&&e(i.helper).css("opacity",n._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,i,s){var n=s.options,a=!1,o=s.scrollParentNotHidden[0],r=s.document[0];o!==r&&"HTML"!==o.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+o.offsetHeight-t.pageY<n.scrollSensitivity?o.scrollTop=a=o.scrollTop+n.scrollSpeed:t.pageY-s.overflowOffset.top<n.scrollSensitivity&&(o.scrollTop=a=o.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+o.offsetWidth-t.pageX<n.scrollSensitivity?o.scrollLeft=a=o.scrollLeft+n.scrollSpeed:t.pageX-s.overflowOffset.left<n.scrollSensitivity&&(o.scrollLeft=a=o.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(t.pageY-e(r).scrollTop()<n.scrollSensitivity?a=e(r).scrollTop(e(r).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<n.scrollSensitivity&&(a=e(r).scrollTop(e(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(t.pageX-e(r).scrollLeft()<n.scrollSensitivity?a=e(r).scrollLeft(e(r).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<n.scrollSensitivity&&(a=e(r).scrollLeft(e(r).scrollLeft()+n.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var n=s.options;s.snapElements=[],e(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var n,a,o,r,h,l,u,d,c,p,f=s.options,m=f.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,b=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left-s.margins.left,l=h+s.snapElements[c].width,u=s.snapElements[c].top-s.margins.top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>b||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==f.snapMode&&(n=m>=Math.abs(u-b),a=m>=Math.abs(d-y),o=m>=Math.abs(h-v),r=m>=Math.abs(l-g),n&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||a||o||r,"outer"!==f.snapMode&&(n=m>=Math.abs(u-y),a=m>=Math.abs(d-b),o=m>=Math.abs(h-g),r=m>=Math.abs(l-v),n&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[c].snapping&&(n||a||o||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=n||a||o||r||p)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var n,a=s.options,o=e.makeArray(e(a.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});o.length&&(n=parseInt(e(o[0]).css("zIndex"),10)||0,e(o).each(function(t){e(this).css("zIndex",n+t)}),this.css("zIndex",n+o.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("zIndex")&&(a._zIndex=n.css("zIndex")),n.css("zIndex",a.zIndex)},stop:function(t,i,s){var n=s.options;n._zIndex&&e(i.helper).css("zIndex",n._zIndex)}}),e.ui.draggable,e.widget("ui.resizable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(e){return parseInt(e,10)||0},_isNumber:function(e){return!isNaN(parseInt(e,10))},_hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return t[s]>0?!0:(t[s]=1,n=t[s]>0,t[s]=0,n)},_create:function(){var t,i,s,n,a,o=this,r=this.options;if(this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!r.aspectRatio,aspectRatio:r.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:r.helper||r.ghost||r.animate?r.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=r.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=e(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),t=this.handles.split(","),this.handles={},i=0;t.length>i;i++)s=e.trim(t[i]),a="ui-resizable-"+s,n=e("<div class='ui-resizable-handle "+a+"'></div>"),n.css({zIndex:r.zIndex}),"se"===s&&n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(n);this._renderAxis=function(t){var i,s,n,a;t=t||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=e(this.handles[i]),this._on(this.handles[i],{mousedown:o._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=e(this.handles[i],this.element),a=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),t.css(n,a),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.mouseover(function(){o.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),o.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){r.disabled||(e(this).removeClass("ui-resizable-autohide"),o._handles.show())}).mouseleave(function(){r.disabled||o.resizing||(e(this).addClass("ui-resizable-autohide"),o._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t,i=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),t=this.element,this.originalElement.css({position:t.css("position"),width:t.outerWidth(),height:t.outerHeight(),top:t.css("top"),left:t.css("left")}).insertAfter(t),t.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_mouseCapture:function(t){var i,s,n=!1;for(i in this.handles)s=e(this.handles[i])[0],(s===t.target||e.contains(s,t.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(t){var i,s,n,a=this.options,o=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),a.containment&&(i+=e(a.containment).scrollLeft()||0,s+=e(a.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:o.width(),height:o.height()},this.originalSize=this._helper?{width:o.outerWidth(),height:o.outerHeight()}:{width:o.width(),height:o.height()},this.sizeDiff={width:o.outerWidth()-o.width(),height:o.outerHeight()-o.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio="number"==typeof a.aspectRatio?a.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=e(".ui-resizable-"+this.axis).css("cursor"),e("body").css("cursor","auto"===n?this.axis+"-resize":n),o.addClass("ui-resizable-resizing"),this._propagate("start",t),!0},_mouseDrag:function(t){var i,s,n=this.originalMousePosition,a=this.axis,o=t.pageX-n.left||0,r=t.pageY-n.top||0,h=this._change[a];return this._updatePrevProperties(),h?(i=h.apply(this,[t,o,r]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(i=this._updateRatio(i,t)),i=this._respectSize(i,t),this._updateCache(i),this._propagate("resize",t),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),e.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",t,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(t){this.resizing=!1;var i,s,n,a,o,r,h,l=this.options,u=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:u.sizeDiff.height,a=s?0:u.sizeDiff.width,o={width:u.helper.width()-a,height:u.helper.height()-n},r=parseInt(u.element.css("left"),10)+(u.position.left-u.originalPosition.left)||null,h=parseInt(u.element.css("top"),10)+(u.position.top-u.originalPosition.top)||null,l.animate||this.element.css(e.extend(o,{top:h,left:r})),u.helper.height(u.size.height),u.helper.width(u.size.width),this._helper&&!l.animate&&this._proportionallyResize()),e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var e={};return this.position.top!==this.prevPosition.top&&(e.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(e.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(e.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(e.height=this.size.height+"px"),this.helper.css(e),e},_updateVirtualBoundaries:function(e){var t,i,s,n,a,o=this.options;a={minWidth:this._isNumber(o.minWidth)?o.minWidth:0,maxWidth:this._isNumber(o.maxWidth)?o.maxWidth:1/0,minHeight:this._isNumber(o.minHeight)?o.minHeight:0,maxHeight:this._isNumber(o.maxHeight)?o.maxHeight:1/0},(this._aspectRatio||e)&&(t=a.minHeight*this.aspectRatio,s=a.minWidth/this.aspectRatio,i=a.maxHeight*this.aspectRatio,n=a.maxWidth/this.aspectRatio,t>a.minWidth&&(a.minWidth=t),s>a.minHeight&&(a.minHeight=s),a.maxWidth>i&&(a.maxWidth=i),a.maxHeight>n&&(a.maxHeight=n)),this._vBoundaries=a},_updateCache:function(e){this.offset=this.helper.offset(),this._isNumber(e.left)&&(this.position.left=e.left),this._isNumber(e.top)&&(this.position.top=e.top),this._isNumber(e.height)&&(this.size.height=e.height),this._isNumber(e.width)&&(this.size.width=e.width)},_updateRatio:function(e){var t=this.position,i=this.size,s=this.axis;return this._isNumber(e.height)?e.width=e.height*this.aspectRatio:this._isNumber(e.width)&&(e.height=e.width/this.aspectRatio),"sw"===s&&(e.left=t.left+(i.width-e.width),e.top=null),"nw"===s&&(e.top=t.top+(i.height-e.height),e.left=t.left+(i.width-e.width)),e},_respectSize:function(e){var t=this._vBoundaries,i=this.axis,s=this._isNumber(e.width)&&t.maxWidth&&t.maxWidth<e.width,n=this._isNumber(e.height)&&t.maxHeight&&t.maxHeight<e.height,a=this._isNumber(e.width)&&t.minWidth&&t.minWidth>e.width,o=this._isNumber(e.height)&&t.minHeight&&t.minHeight>e.height,r=this.originalPosition.left+this.originalSize.width,h=this.position.top+this.size.height,l=/sw|nw|w/.test(i),u=/nw|ne|n/.test(i);return a&&(e.width=t.minWidth),o&&(e.height=t.minHeight),s&&(e.width=t.maxWidth),n&&(e.height=t.maxHeight),a&&l&&(e.left=r-t.minWidth),s&&l&&(e.left=r-t.maxWidth),o&&u&&(e.top=h-t.minHeight),n&&u&&(e.top=h-t.maxHeight),e.width||e.height||e.left||!e.top?e.width||e.height||e.top||!e.left||(e.left=null):e.top=null,e},_getPaddingPlusBorderDimensions:function(e){for(var t=0,i=[],s=[e.css("borderTopWidth"),e.css("borderRightWidth"),e.css("borderBottomWidth"),e.css("borderLeftWidth")],n=[e.css("paddingTop"),e.css("paddingRight"),e.css("paddingBottom"),e.css("paddingLeft")];4>t;t++)i[t]=parseInt(s[t],10)||0,i[t]+=parseInt(n[t],10)||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var e,t=0,i=this.helper||this.element;this._proportionallyResizeElements.length>t;t++)e=this._proportionallyResizeElements[t],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(e)),e.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var t=this.element,i=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||e("<div style='overflow:hidden;'></div>"),this.helper.addClass(this._helper).css({width:this.element.outerWidth()-1,height:this.element.outerHeight()-1,position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(e,t){return{width:this.originalSize.width+t}},w:function(e,t){var i=this.originalSize,s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(e,t,i){return{height:this.originalSize.height+i}},se:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},sw:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,i,s]))},ne:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},nw:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,i,s]))}},_propagate:function(t,i){e.ui.plugin.call(this,t,[i,this.ui()]),"resize"!==t&&this._trigger(t,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),e.ui.plugin.add("resizable","animate",{stop:function(t){var i=e(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,a=n.length&&/textarea/i.test(n[0].nodeName),o=a&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=a?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-o},l=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,u=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(e.extend(h,u&&l?{top:u,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};n&&n.length&&e(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(){var t,i,s,n,a,o,r,h=e(this).resizable("instance"),l=h.options,u=h.element,d=l.containment,c=d instanceof e?d.get(0):/parent/.test(d)?u.parent().get(0):d;c&&(h.containerElement=e(c),/document/.test(d)||d===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}):(t=e(c),i=[],e(["Top","Right","Left","Bottom"]).each(function(e,s){i[e]=h._num(t.css("padding"+s))}),h.containerOffset=t.offset(),h.containerPosition=t.position(),h.containerSize={height:t.innerHeight()-i[3],width:t.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,a=h.containerSize.width,o=h._hasScroll(c,"left")?c.scrollWidth:a,r=h._hasScroll(c)?c.scrollHeight:n,h.parentData={element:c,left:s.left,top:s.top,width:o,height:r}))},resize:function(t){var i,s,n,a,o=e(this).resizable("instance"),r=o.options,h=o.containerOffset,l=o.position,u=o._aspectRatio||t.shiftKey,d={top:0,left:0},c=o.containerElement,p=!0;c[0]!==document&&/static/.test(c.css("position"))&&(d=h),l.left<(o._helper?h.left:0)&&(o.size.width=o.size.width+(o._helper?o.position.left-h.left:o.position.left-d.left),u&&(o.size.height=o.size.width/o.aspectRatio,p=!1),o.position.left=r.helper?h.left:0),l.top<(o._helper?h.top:0)&&(o.size.height=o.size.height+(o._helper?o.position.top-h.top:o.position.top),u&&(o.size.width=o.size.height*o.aspectRatio,p=!1),o.position.top=o._helper?h.top:0),n=o.containerElement.get(0)===o.element.parent().get(0),a=/relative|absolute/.test(o.containerElement.css("position")),n&&a?(o.offset.left=o.parentData.left+o.position.left,o.offset.top=o.parentData.top+o.position.top):(o.offset.left=o.element.offset().left,o.offset.top=o.element.offset().top),i=Math.abs(o.sizeDiff.width+(o._helper?o.offset.left-d.left:o.offset.left-h.left)),s=Math.abs(o.sizeDiff.height+(o._helper?o.offset.top-d.top:o.offset.top-h.top)),i+o.size.width>=o.parentData.width&&(o.size.width=o.parentData.width-i,u&&(o.size.height=o.size.width/o.aspectRatio,p=!1)),s+o.size.height>=o.parentData.height&&(o.size.height=o.parentData.height-s,u&&(o.size.width=o.size.height*o.aspectRatio,p=!1)),p||(o.position.left=o.prevPosition.left,o.position.top=o.prevPosition.top,o.size.width=o.prevSize.width,o.size.height=o.prevSize.height)},stop:function(){var t=e(this).resizable("instance"),i=t.options,s=t.containerOffset,n=t.containerPosition,a=t.containerElement,o=e(t.helper),r=o.offset(),h=o.outerWidth()-t.sizeDiff.width,l=o.outerHeight()-t.sizeDiff.height;t._helper&&!i.animate&&/relative/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l}),t._helper&&!i.animate&&/static/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),e.ui.plugin.add("resizable","alsoResize",{start:function(){var t=e(this).resizable("instance"),i=t.options;e(i.alsoResize).each(function(){var t=e(this);t.data("ui-resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})},resize:function(t,i){var s=e(this).resizable("instance"),n=s.options,a=s.originalSize,o=s.originalPosition,r={height:s.size.height-a.height||0,width:s.size.width-a.width||0,top:s.position.top-o.top||0,left:s.position.left-o.left||0};e(n.alsoResize).each(function(){var t=e(this),s=e(this).data("ui-resizable-alsoresize"),n={},a=t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(a,function(e,t){var i=(s[t]||0)+(r[t]||0);i&&i>=0&&(n[t]=i||null)}),t.css(n)})},stop:function(){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","ghost",{start:function(){var t=e(this).resizable("instance"),i=t.options,s=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),t.ghost.appendTo(t.helper)},resize:function(){var t=e(this).resizable("instance");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=e(this).resizable("instance");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(){var t,i=e(this).resizable("instance"),s=i.options,n=i.size,a=i.originalSize,o=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,u=h[1]||1,d=Math.round((n.width-a.width)/l)*l,c=Math.round((n.height-a.height)/u)*u,p=a.width+d,f=a.height+c,m=s.maxWidth&&p>s.maxWidth,g=s.maxHeight&&f>s.maxHeight,v=s.minWidth&&s.minWidth>p,y=s.minHeight&&s.minHeight>f;s.grid=h,v&&(p+=l),y&&(f+=u),m&&(p-=l),g&&(f-=u),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=o.top-c):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=o.left-d):((0>=f-u||0>=p-l)&&(t=i._getPaddingPlusBorderDimensions(this)),f-u>0?(i.size.height=f,i.position.top=o.top-c):(f=u-t.height,i.size.height=f,i.position.top=o.top+a.height-f),p-l>0?(i.size.width=p,i.position.left=o.left-d):(p=l-t.width,i.size.width=p,i.position.left=o.left+a.width-p))}}),e.ui.resizable,e.widget("ui.dialog",{version:"1.11.4",options:{appendTo:"body",autoOpen:!0,buttons:[],closeOnEscape:!0,closeText:"Close",dialogClass:"",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(t){var i=e(this).css(t).offset().top;0>i&&e(this).css("top",t.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),this.options.title=this.options.title||this.originalTitle,this._createWrapper(),this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&e.fn.draggable&&this._makeDraggable(),this.options.resizable&&e.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var t=this.options.appendTo;return t&&(t.jquery||t.nodeType)?e(t):this.document.find(t||"body").eq(0)},_destroy:function(){var e,t=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(),this.uiDialog.stop(!0,!0).remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),e=t.parent.children().eq(t.index),e.length&&e[0]!==this.element[0]?e.before(this.element):t.parent.append(this.element)},widget:function(){return this.uiDialog},disable:e.noop,enable:e.noop,close:function(t){var i,s=this;if(this._isOpen&&this._trigger("beforeClose",t)!==!1){if(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),!this.opener.filter(":focusable").focus().length)try{i=this.document[0].activeElement,i&&"body"!==i.nodeName.toLowerCase()&&e(i).blur()}catch(n){}this._hide(this.uiDialog,this.options.hide,function(){s._trigger("close",t)})}},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(t,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+e(this).css("z-index")}).get(),a=Math.max.apply(null,n);return a>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",a+1),s=!0),s&&!i&&this._trigger("focus",t),s},open:function(){var t=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=e(this.document[0].activeElement),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){t._focusTabbable(),t._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var e=this._focusedElement;e||(e=this.element.find("[autofocus]")),e.length||(e=this.element.find(":tabbable")),e.length||(e=this.uiDialogButtonPane.find(":tabbable")),e.length||(e=this.uiDialogTitlebarClose.filter(":tabbable")),e.length||(e=this.uiDialog),e.eq(0).focus()},_keepFocus:function(t){function i(){var t=this.document[0].activeElement,i=this.uiDialog[0]===t||e.contains(this.uiDialog[0],t);i||this._focusTabbable()}t.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=e("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front "+this.options.dialogClass).hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._on(this.uiDialog,{keydown:function(t){if(this.options.closeOnEscape&&!t.isDefaultPrevented()&&t.keyCode&&t.keyCode===e.ui.keyCode.ESCAPE)return t.preventDefault(),this.close(t),void 0;
if(t.keyCode===e.ui.keyCode.TAB&&!t.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");t.target!==n[0]&&t.target!==this.uiDialog[0]||t.shiftKey?t.target!==s[0]&&t.target!==this.uiDialog[0]||!t.shiftKey||(this._delay(function(){n.focus()}),t.preventDefault()):(this._delay(function(){s.focus()}),t.preventDefault())}},mousedown:function(e){this._moveToTop(e)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var t;this.uiDialogTitlebar=e("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog),this._on(this.uiDialogTitlebar,{mousedown:function(t){e(t.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.focus()}}),this.uiDialogTitlebarClose=e("<button type='button'></button>").button({label:this.options.closeText,icons:{primary:"ui-icon-closethick"},text:!1}).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar),this._on(this.uiDialogTitlebarClose,{click:function(e){e.preventDefault(),this.close(e)}}),t=e("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar),this._title(t),this.uiDialog.attr({"aria-labelledby":t.attr("id")})},_title:function(e){this.options.title||e.html("&#160;"),e.text(this.options.title)},_createButtonPane:function(){this.uiDialogButtonPane=e("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),this.uiButtonSet=e("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane),this._createButtons()},_createButtons:function(){var t=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),e.isEmptyObject(i)||e.isArray(i)&&!i.length?(this.uiDialog.removeClass("ui-dialog-buttons"),void 0):(e.each(i,function(i,s){var n,a;s=e.isFunction(s)?{click:s,text:i}:s,s=e.extend({type:"button"},s),n=s.click,s.click=function(){n.apply(t.element[0],arguments)},a={icons:s.icons,text:s.showText},delete s.icons,delete s.showText,e("<button></button>",s).button(a).appendTo(t.uiButtonSet)}),this.uiDialog.addClass("ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function t(e){return{position:e.position,offset:e.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){e(this).addClass("ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,t(n))},drag:function(e,s){i._trigger("drag",e,t(s))},stop:function(n,a){var o=a.offset.left-i.document.scrollLeft(),r=a.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(o>=0?"+":"")+o+" "+"top"+(r>=0?"+":"")+r,of:i.window},e(this).removeClass("ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,t(a))}})},_makeResizable:function(){function t(e){return{originalPosition:e.originalPosition,originalSize:e.originalSize,position:e.position,size:e.size}}var i=this,s=this.options,n=s.resizable,a=this.uiDialog.css("position"),o="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:o,start:function(s,n){e(this).addClass("ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,t(n))},resize:function(e,s){i._trigger("resize",e,t(s))},stop:function(n,a){var o=i.uiDialog.offset(),r=o.left-i.document.scrollLeft(),h=o.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},e(this).removeClass("ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,t(a))}}).css("position",a)},_trackFocus:function(){this._on(this.widget(),{focusin:function(t){this._makeFocusTarget(),this._focusedElement=e(t.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var t=this._trackingInstances(),i=e.inArray(this,t);-1!==i&&t.splice(i,1)},_trackingInstances:function(){var e=this.document.data("ui-dialog-instances");return e||(e=[],this.document.data("ui-dialog-instances",e)),e},_minHeight:function(){var e=this.options;return"auto"===e.height?e.minHeight:Math.min(e.minHeight,e.height)},_position:function(){var e=this.uiDialog.is(":visible");e||this.uiDialog.show(),this.uiDialog.position(this.options.position),e||this.uiDialog.hide()},_setOptions:function(t){var i=this,s=!1,n={};e.each(t,function(e,t){i._setOption(e,t),e in i.sizeRelatedOptions&&(s=!0),e in i.resizableRelatedOptions&&(n[e]=t)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,t){var i,s,n=this.uiDialog;"dialogClass"===e&&n.removeClass(this.options.dialogClass).addClass(t),"disabled"!==e&&(this._super(e,t),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:""+t}),"draggable"===e&&(i=n.is(":data(ui-draggable)"),i&&!t&&n.draggable("destroy"),!i&&t&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(s=n.is(":data(ui-resizable)"),s&&!t&&n.resizable("destroy"),s&&"string"==typeof t&&n.resizable("option","handles",t),s||t===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var e,t,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),e=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),t=Math.max(0,s.minHeight-e),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-e):"none","auto"===s.height?this.element.css({minHeight:t,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-e)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var t=e(this);return e("<div>").css({position:"absolute",width:t.outerWidth(),height:t.outerHeight()}).appendTo(t.parent()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(t){return e(t.target).closest(".ui-dialog").length?!0:!!e(t.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var t=!0;this._delay(function(){t=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(e){t||this._allowInteraction(e)||(e.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=e("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var e=this.document.data("ui-dialog-overlays")-1;e?this.document.data("ui-dialog-overlays",e):this.document.unbind("focusin").removeData("ui-dialog-overlays"),this.overlay.remove(),this.overlay=null}}}),e.widget("ui.droppable",{version:"1.11.4",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var t,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=e.isFunction(s)?s:function(e){return e.is(s)},this.proportions=function(){return arguments.length?(t=arguments[0],void 0):t?t:t={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this.element.addClass("ui-droppable")},_addToManager:function(t){e.ui.ddmanager.droppables[t]=e.ui.ddmanager.droppables[t]||[],e.ui.ddmanager.droppables[t].push(this)},_splice:function(e){for(var t=0;e.length>t;t++)e[t]===this&&e.splice(t,1)},_destroy:function(){var t=e.ui.ddmanager.droppables[this.options.scope];this._splice(t),this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(t,i){if("accept"===t)this.accept=e.isFunction(i)?i:function(e){return e.is(i)};else if("scope"===t){var s=e.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(t,i)},_activate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),i&&this._trigger("activate",t,this.ui(i))},_deactivate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),i&&this._trigger("deactivate",t,this.ui(i))},_over:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",t,this.ui(i)))},_out:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",t,this.ui(i)))},_drop:function(t,i){var s=i||e.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=e(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&e.ui.intersect(s,e.extend(i,{offset:i.element.offset()}),i.options.tolerance,t)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",t,this.ui(s)),this.element):!1):!1},ui:function(e){return{draggable:e.currentItem||e.element,helper:e.helper,position:e.position,offset:e.positionAbs}}}),e.ui.intersect=function(){function e(e,t,i){return e>=t&&t+i>e}return function(t,i,s,n){if(!i.offset)return!1;var a=(t.positionAbs||t.position.absolute).left+t.margins.left,o=(t.positionAbs||t.position.absolute).top+t.margins.top,r=a+t.helperProportions.width,h=o+t.helperProportions.height,l=i.offset.left,u=i.offset.top,d=l+i.proportions().width,c=u+i.proportions().height;switch(s){case"fit":return a>=l&&d>=r&&o>=u&&c>=h;case"intersect":return a+t.helperProportions.width/2>l&&d>r-t.helperProportions.width/2&&o+t.helperProportions.height/2>u&&c>h-t.helperProportions.height/2;case"pointer":return e(n.pageY,u,i.proportions().height)&&e(n.pageX,l,i.proportions().width);case"touch":return(o>=u&&c>=o||h>=u&&c>=h||u>o&&h>c)&&(a>=l&&d>=a||r>=l&&d>=r||l>a&&r>d);default:return!1}}}(),e.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(t,i){var s,n,a=e.ui.ddmanager.droppables[t.options.scope]||[],o=i?i.type:null,r=(t.currentItem||t.element).find(":data(ui-droppable)").addBack();e:for(s=0;a.length>s;s++)if(!(a[s].options.disabled||t&&!a[s].accept.call(a[s].element[0],t.currentItem||t.element))){for(n=0;r.length>n;n++)if(r[n]===a[s].element[0]){a[s].proportions().height=0;continue e}a[s].visible="none"!==a[s].element.css("display"),a[s].visible&&("mousedown"===o&&a[s]._activate.call(a[s],i),a[s].offset=a[s].element.offset(),a[s].proportions({width:a[s].element[0].offsetWidth,height:a[s].element[0].offsetHeight}))}},drop:function(t,i){var s=!1;return e.each((e.ui.ddmanager.droppables[t.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&e.ui.intersect(t,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(t,i){t.element.parentsUntil("body").bind("scroll.droppable",function(){t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)})},drag:function(t,i){t.options.refreshPositions&&e.ui.ddmanager.prepareOffsets(t,i),e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,a,o=e.ui.intersect(t,this,this.options.tolerance,i),r=!o&&this.isover?"isout":o&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,a=this.element.parents(":data(ui-droppable)").filter(function(){return e(this).droppable("instance").options.scope===n}),a.length&&(s=e(a[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(t,i){t.element.parentsUntil("body").unbind("scroll.droppable"),t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)}},e.ui.droppable;var y="ui-effects-",b=e;e.effects={effect:{}},function(e,t){function i(e,t,i){var s=d[t.type]||{};return null==e?i||!t.def?null:t.def:(e=s.floor?~~e:parseFloat(e),isNaN(e)?t.def:s.mod?(e+s.mod)%s.mod:0>e?0:e>s.max?s.max:e)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(e,a){var o,r=a.re.exec(i),h=r&&a.parse(r),l=a.space||"rgba";return h?(o=s[l](h),s[u[l].cache]=o[u[l].cache],n=s._rgba=o._rgba,!1):t}),n.length?("0,0,0,0"===n.join()&&e.extend(n,a.transparent),s):a[i]}function n(e,t,i){return i=(i+1)%1,1>6*i?e+6*(t-e)*i:1>2*i?t:2>3*i?e+6*(t-e)*(2/3-i):e}var a,o="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1],e[2],e[3],e[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(e){return[2.55*e[1],2.55*e[2],2.55*e[3],e[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(e){return[parseInt(e[1],16),parseInt(e[2],16),parseInt(e[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(e){return[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(e){return[e[1],e[2]/100,e[3]/100,e[4]]}}],l=e.Color=function(t,i,s,n){return new e.Color.fn.parse(t,i,s,n)},u={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},d={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},c=l.support={},p=e("<p>")[0],f=e.each;p.style.cssText="background-color:rgba(1,1,1,.5)",c.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(u,function(e,t){t.cache="_"+e,t.props.alpha={idx:3,type:"percent",def:1}}),l.fn=e.extend(l.prototype,{parse:function(n,o,r,h){if(n===t)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=e(n).css(o),o=t);var d=this,c=e.type(n),p=this._rgba=[];return o!==t&&(n=[n,o,r,h],c="array"),"string"===c?this.parse(s(n)||a._default):"array"===c?(f(u.rgba.props,function(e,t){p[t.idx]=i(n[t.idx],t)}),this):"object"===c?(n instanceof l?f(u,function(e,t){n[t.cache]&&(d[t.cache]=n[t.cache].slice())}):f(u,function(t,s){var a=s.cache;f(s.props,function(e,t){if(!d[a]&&s.to){if("alpha"===e||null==n[e])return;d[a]=s.to(d._rgba)}d[a][t.idx]=i(n[e],t,!0)}),d[a]&&0>e.inArray(null,d[a].slice(0,3))&&(d[a][3]=1,s.from&&(d._rgba=s.from(d[a])))}),this):t},is:function(e){var i=l(e),s=!0,n=this;return f(u,function(e,a){var o,r=i[a.cache];return r&&(o=n[a.cache]||a.to&&a.to(n._rgba)||[],f(a.props,function(e,i){return null!=r[i.idx]?s=r[i.idx]===o[i.idx]:t})),s}),s},_space:function(){var e=[],t=this;return f(u,function(i,s){t[s.cache]&&e.push(i)}),e.pop()},transition:function(e,t){var s=l(e),n=s._space(),a=u[n],o=0===this.alpha()?l("transparent"):this,r=o[a.cache]||a.to(o._rgba),h=r.slice();return s=s[a.cache],f(a.props,function(e,n){var a=n.idx,o=r[a],l=s[a],u=d[n.type]||{};null!==l&&(null===o?h[a]=l:(u.mod&&(l-o>u.mod/2?o+=u.mod:o-l>u.mod/2&&(o-=u.mod)),h[a]=i((l-o)*t+o,n)))}),this[n](h)},blend:function(t){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(t)._rgba;return l(e.map(i,function(e,t){return(1-s)*n[t]+s*e}))},toRgbaString:function(){var t="rgba(",i=e.map(this._rgba,function(e,t){return null==e?t>2?1:0:e});return 1===i[3]&&(i.pop(),t="rgb("),t+i.join()+")"},toHslaString:function(){var t="hsla(",i=e.map(this.hsla(),function(e,t){return null==e&&(e=t>2?1:0),t&&3>t&&(e=Math.round(100*e)+"%"),e});return 1===i[3]&&(i.pop(),t="hsl("),t+i.join()+")"},toHexString:function(t){var i=this._rgba.slice(),s=i.pop();return t&&i.push(~~(255*s)),"#"+e.map(i,function(e){return e=(e||0).toString(16),1===e.length?"0"+e:e}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,u.hsla.to=function(e){if(null==e[0]||null==e[1]||null==e[2])return[null,null,null,e[3]];var t,i,s=e[0]/255,n=e[1]/255,a=e[2]/255,o=e[3],r=Math.max(s,n,a),h=Math.min(s,n,a),l=r-h,u=r+h,d=.5*u;return t=h===r?0:s===r?60*(n-a)/l+360:n===r?60*(a-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=d?l/u:l/(2-u),[Math.round(t)%360,i,d,null==o?1:o]},u.hsla.from=function(e){if(null==e[0]||null==e[1]||null==e[2])return[null,null,null,e[3]];var t=e[0]/360,i=e[1],s=e[2],a=e[3],o=.5>=s?s*(1+i):s+i-s*i,r=2*s-o;return[Math.round(255*n(r,o,t+1/3)),Math.round(255*n(r,o,t)),Math.round(255*n(r,o,t-1/3)),a]},f(u,function(s,n){var a=n.props,o=n.cache,h=n.to,u=n.from;l.fn[s]=function(s){if(h&&!this[o]&&(this[o]=h(this._rgba)),s===t)return this[o].slice();var n,r=e.type(s),d="array"===r||"object"===r?s:arguments,c=this[o].slice();return f(a,function(e,t){var s=d["object"===r?e:t.idx];null==s&&(s=c[t.idx]),c[t.idx]=i(s,t)}),u?(n=l(u(c)),n[o]=c,n):l(c)},f(a,function(t,i){l.fn[t]||(l.fn[t]=function(n){var a,o=e.type(n),h="alpha"===t?this._hsla?"hsla":"rgba":s,l=this[h](),u=l[i.idx];return"undefined"===o?u:("function"===o&&(n=n.call(this,u),o=e.type(n)),null==n&&i.empty?this:("string"===o&&(a=r.exec(n),a&&(n=u+parseFloat(a[2])*("+"===a[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(t){var i=t.split(" ");f(i,function(t,i){e.cssHooks[i]={set:function(t,n){var a,o,r="";if("transparent"!==n&&("string"!==e.type(n)||(a=s(n)))){if(n=l(a||n),!c.rgba&&1!==n._rgba[3]){for(o="backgroundColor"===i?t.parentNode:t;(""===r||"transparent"===r)&&o&&o.style;)try{r=e.css(o,"backgroundColor"),o=o.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{t.style[i]=n}catch(h){}}},e.fx.step[i]=function(t){t.colorInit||(t.start=l(t.elem,i),t.end=l(t.end),t.colorInit=!0),e.cssHooks[i].set(t.elem,t.start.transition(t.end,t.pos))}})},l.hook(o),e.cssHooks.borderColor={expand:function(e){var t={};return f(["Top","Right","Bottom","Left"],function(i,s){t["border"+s+"Color"]=e}),t}},a=e.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(b),function(){function t(t){var i,s,n=t.ownerDocument.defaultView?t.ownerDocument.defaultView.getComputedStyle(t,null):t.currentStyle,a={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(a[e.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(a[i]=n[i]);return a}function i(t,i){var s,a,o={};for(s in i)a=i[s],t[s]!==a&&(n[s]||(e.fx.step[s]||!isNaN(parseFloat(a)))&&(o[s]=a));return o}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};e.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,i){e.fx.step[i]=function(e){("none"!==e.end&&!e.setAttr||1===e.pos&&!e.setAttr)&&(b.style(e.elem,i,e.end),e.setAttr=!0)}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e.effects.animateClass=function(n,a,o,r){var h=e.speed(a,o,r);return this.queue(function(){var a,o=e(this),r=o.attr("class")||"",l=h.children?o.find("*").addBack():o;l=l.map(function(){var i=e(this);return{el:i,start:t(this)}}),a=function(){e.each(s,function(e,t){n[t]&&o[t+"Class"](n[t])})},a(),l=l.map(function(){return this.end=t(this.el[0]),this.diff=i(this.start,this.end),this}),o.attr("class",r),l=l.map(function(){var t=this,i=e.Deferred(),s=e.extend({},h,{queue:!1,complete:function(){i.resolve(t)}});return this.el.animate(this.diff,s),i.promise()}),e.when.apply(e,l.get()).done(function(){a(),e.each(arguments,function(){var t=this.el;e.each(this.diff,function(e){t.css(e,"")})}),h.complete.call(o[0])})})},e.fn.extend({addClass:function(t){return function(i,s,n,a){return s?e.effects.animateClass.call(this,{add:i},s,n,a):t.apply(this,arguments)}}(e.fn.addClass),removeClass:function(t){return function(i,s,n,a){return arguments.length>1?e.effects.animateClass.call(this,{remove:i},s,n,a):t.apply(this,arguments)}}(e.fn.removeClass),toggleClass:function(t){return function(i,s,n,a,o){return"boolean"==typeof s||void 0===s?n?e.effects.animateClass.call(this,s?{add:i}:{remove:i},n,a,o):t.apply(this,arguments):e.effects.animateClass.call(this,{toggle:i},s,n,a)}}(e.fn.toggleClass),switchClass:function(t,i,s,n,a){return e.effects.animateClass.call(this,{add:i,remove:t},s,n,a)}})}(),function(){function t(t,i,s,n){return e.isPlainObject(t)&&(i=t,t=t.effect),t={effect:t},null==i&&(i={}),e.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||e.fx.speeds[i])&&(n=s,s=i,i={}),e.isFunction(s)&&(n=s,s=null),i&&e.extend(t,i),s=s||i.duration,t.duration=e.fx.off?0:"number"==typeof s?s:s in e.fx.speeds?e.fx.speeds[s]:e.fx.speeds._default,t.complete=n||i.complete,t}function i(t){return!t||"number"==typeof t||e.fx.speeds[t]?!0:"string"!=typeof t||e.effects.effect[t]?e.isFunction(t)?!0:"object"!=typeof t||t.effect?!1:!0:!0}e.extend(e.effects,{version:"1.11.4",save:function(e,t){for(var i=0;t.length>i;i++)null!==t[i]&&e.data(y+t[i],e[0].style[t[i]])},restore:function(e,t){var i,s;for(s=0;t.length>s;s++)null!==t[s]&&(i=e.data(y+t[s]),void 0===i&&(i=""),e.css(t[s],i))},setMode:function(e,t){return"toggle"===t&&(t=e.is(":hidden")?"show":"hide"),t},getBaseline:function(e,t){var i,s;switch(e[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=e[0]/t.height}switch(e[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=e[1]/t.width}return{x:s,y:i}},createWrapper:function(t){if(t.parent().is(".ui-effects-wrapper"))return t.parent();var i={width:t.outerWidth(!0),height:t.outerHeight(!0),"float":t.css("float")},s=e("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:t.width(),height:t.height()},a=document.activeElement;try{a.id}catch(o){a=document.body}return t.wrap(s),(t[0]===a||e.contains(t[0],a))&&e(a).focus(),s=t.parent(),"static"===t.css("position")?(s.css({position:"relative"}),t.css({position:"relative"})):(e.extend(i,{position:t.css("position"),zIndex:t.css("z-index")}),e.each(["top","left","bottom","right"],function(e,s){i[s]=t.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),t.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),t.css(n),s.css(i).show()},removeWrapper:function(t){var i=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),(t[0]===i||e.contains(t[0],i))&&e(i).focus()),t},setTransition:function(t,i,s,n){return n=n||{},e.each(i,function(e,i){var a=t.cssUnit(i);a[0]>0&&(n[i]=a[0]*s+a[1])}),n}}),e.fn.extend({effect:function(){function i(t){function i(){e.isFunction(a)&&a.call(n[0]),e.isFunction(t)&&t()}var n=e(this),a=s.complete,r=s.mode;(n.is(":hidden")?"hide"===r:"show"===r)?(n[r](),i()):o.call(n[0],s,i)}var s=t.apply(this,arguments),n=s.mode,a=s.queue,o=e.effects.effect[s.effect];return e.fx.off||!o?n?this[n](s.duration,s.complete):this.each(function(){s.complete&&s.complete.call(this)}):a===!1?this.each(i):this.queue(a||"fx",i)},show:function(e){return function(s){if(i(s))return e.apply(this,arguments);var n=t.apply(this,arguments);return n.mode="show",this.effect.call(this,n)}}(e.fn.show),hide:function(e){return function(s){if(i(s))return e.apply(this,arguments);var n=t.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(e.fn.hide),toggle:function(e){return function(s){if(i(s)||"boolean"==typeof s)return e.apply(this,arguments);var n=t.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(e.fn.toggle),cssUnit:function(t){var i=this.css(t),s=[];return e.each(["em","px","%","pt"],function(e,t){i.indexOf(t)>0&&(s=[parseFloat(i),t])}),s}})}(),function(){var t={};e.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,i){t[i]=function(t){return Math.pow(t,e+2)}}),e.extend(t,{Sine:function(e){return 1-Math.cos(e*Math.PI/2)},Circ:function(e){return 1-Math.sqrt(1-e*e)},Elastic:function(e){return 0===e||1===e?e:-Math.pow(2,8*(e-1))*Math.sin((80*(e-1)-7.5)*Math.PI/15)},Back:function(e){return e*e*(3*e-2)},Bounce:function(e){for(var t,i=4;((t=Math.pow(2,--i))-1)/11>e;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*t-2)/22-e,2)}}),e.each(t,function(t,i){e.easing["easeIn"+t]=i,e.easing["easeOut"+t]=function(e){return 1-i(1-e)},e.easing["easeInOut"+t]=function(e){return.5>e?i(2*e)/2:1-i(-2*e+2)/2}})}(),e.effects,e.effects.effect.blind=function(t,i){var s,n,a,o=e(this),r=/up|down|vertical/,h=/up|left|vertical|horizontal/,l=["position","top","bottom","left","right","height","width"],u=e.effects.setMode(o,t.mode||"hide"),d=t.direction||"up",c=r.test(d),p=c?"height":"width",f=c?"top":"left",m=h.test(d),g={},v="show"===u;o.parent().is(".ui-effects-wrapper")?e.effects.save(o.parent(),l):e.effects.save(o,l),o.show(),s=e.effects.createWrapper(o).css({overflow:"hidden"}),n=s[p](),a=parseFloat(s.css(f))||0,g[p]=v?n:0,m||(o.css(c?"bottom":"right",0).css(c?"top":"left","auto").css({position:"absolute"}),g[f]=v?a:n+a),v&&(s.css(p,0),m||s.css(f,a+n)),s.animate(g,{duration:t.duration,easing:t.easing,queue:!1,complete:function(){"hide"===u&&o.hide(),e.effects.restore(o,l),e.effects.removeWrapper(o),i()}})},e.effects.effect.bounce=function(t,i){var s,n,a,o=e(this),r=["position","top","bottom","left","right","height","width"],h=e.effects.setMode(o,t.mode||"effect"),l="hide"===h,u="show"===h,d=t.direction||"up",c=t.distance,p=t.times||5,f=2*p+(u||l?1:0),m=t.duration/f,g=t.easing,v="up"===d||"down"===d?"top":"left",y="up"===d||"left"===d,b=o.queue(),_=b.length;for((u||l)&&r.push("opacity"),e.effects.save(o,r),o.show(),e.effects.createWrapper(o),c||(c=o["top"===v?"outerHeight":"outerWidth"]()/3),u&&(a={opacity:1},a[v]=0,o.css("opacity",0).css(v,y?2*-c:2*c).animate(a,m,g)),l&&(c/=Math.pow(2,p-1)),a={},a[v]=0,s=0;p>s;s++)n={},n[v]=(y?"-=":"+=")+c,o.animate(n,m,g).animate(a,m,g),c=l?2*c:c/2;l&&(n={opacity:0},n[v]=(y?"-=":"+=")+c,o.animate(n,m,g)),o.queue(function(){l&&o.hide(),e.effects.restore(o,r),e.effects.removeWrapper(o),i()}),_>1&&b.splice.apply(b,[1,0].concat(b.splice(_,f+1))),o.dequeue()},e.effects.effect.clip=function(t,i){var s,n,a,o=e(this),r=["position","top","bottom","left","right","height","width"],h=e.effects.setMode(o,t.mode||"hide"),l="show"===h,u=t.direction||"vertical",d="vertical"===u,c=d?"height":"width",p=d?"top":"left",f={};e.effects.save(o,r),o.show(),s=e.effects.createWrapper(o).css({overflow:"hidden"}),n="IMG"===o[0].tagName?s:o,a=n[c](),l&&(n.css(c,0),n.css(p,a/2)),f[c]=l?a:0,f[p]=l?0:a/2,n.animate(f,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){l||o.hide(),e.effects.restore(o,r),e.effects.removeWrapper(o),i()}})},e.effects.effect.drop=function(t,i){var s,n=e(this),a=["position","top","bottom","left","right","opacity","height","width"],o=e.effects.setMode(n,t.mode||"hide"),r="show"===o,h=t.direction||"left",l="up"===h||"down"===h?"top":"left",u="up"===h||"left"===h?"pos":"neg",d={opacity:r?1:0};e.effects.save(n,a),n.show(),e.effects.createWrapper(n),s=t.distance||n["top"===l?"outerHeight":"outerWidth"](!0)/2,r&&n.css("opacity",0).css(l,"pos"===u?-s:s),d[l]=(r?"pos"===u?"+=":"-=":"pos"===u?"-=":"+=")+s,n.animate(d,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===o&&n.hide(),e.effects.restore(n,a),e.effects.removeWrapper(n),i()}})},e.effects.effect.explode=function(t,i){function s(){b.push(this),b.length===d*c&&n()}function n(){p.css({visibility:"visible"}),e(b).remove(),m||p.hide(),i()}var a,o,r,h,l,u,d=t.pieces?Math.round(Math.sqrt(t.pieces)):3,c=d,p=e(this),f=e.effects.setMode(p,t.mode||"hide"),m="show"===f,g=p.show().css("visibility","hidden").offset(),v=Math.ceil(p.outerWidth()/c),y=Math.ceil(p.outerHeight()/d),b=[];for(a=0;d>a;a++)for(h=g.top+a*y,u=a-(d-1)/2,o=0;c>o;o++)r=g.left+o*v,l=o-(c-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-o*v,top:-a*y}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:v,height:y,left:r+(m?l*v:0),top:h+(m?u*y:0),opacity:m?0:1}).animate({left:r+(m?0:l*v),top:h+(m?0:u*y),opacity:m?1:0},t.duration||500,t.easing,s)},e.effects.effect.fade=function(t,i){var s=e(this),n=e.effects.setMode(s,t.mode||"toggle");s.animate({opacity:n},{queue:!1,duration:t.duration,easing:t.easing,complete:i})},e.effects.effect.fold=function(t,i){var s,n,a=e(this),o=["position","top","bottom","left","right","height","width"],r=e.effects.setMode(a,t.mode||"hide"),h="show"===r,l="hide"===r,u=t.size||15,d=/([0-9]+)%/.exec(u),c=!!t.horizFirst,p=h!==c,f=p?["width","height"]:["height","width"],m=t.duration/2,g={},v={};e.effects.save(a,o),a.show(),s=e.effects.createWrapper(a).css({overflow:"hidden"}),n=p?[s.width(),s.height()]:[s.height(),s.width()],d&&(u=parseInt(d[1],10)/100*n[l?0:1]),h&&s.css(c?{height:0,width:u}:{height:u,width:0}),g[f[0]]=h?n[0]:u,v[f[1]]=h?n[1]:0,s.animate(g,m,t.easing).animate(v,m,t.easing,function(){l&&a.hide(),e.effects.restore(a,o),e.effects.removeWrapper(a),i()})},e.effects.effect.highlight=function(t,i){var s=e(this),n=["backgroundImage","backgroundColor","opacity"],a=e.effects.setMode(s,t.mode||"show"),o={backgroundColor:s.css("backgroundColor")};"hide"===a&&(o.opacity=0),e.effects.save(s,n),s.show().css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(o,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===a&&s.hide(),e.effects.restore(s,n),i()}})},e.effects.effect.size=function(t,i){var s,n,a,o=e(this),r=["position","top","bottom","left","right","width","height","overflow","opacity"],h=["position","top","bottom","left","right","overflow","opacity"],l=["width","height","overflow"],u=["fontSize"],d=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],c=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],p=e.effects.setMode(o,t.mode||"effect"),f=t.restore||"effect"!==p,m=t.scale||"both",g=t.origin||["middle","center"],v=o.css("position"),y=f?r:h,b={height:0,width:0,outerHeight:0,outerWidth:0};"show"===p&&o.show(),s={height:o.height(),width:o.width(),outerHeight:o.outerHeight(),outerWidth:o.outerWidth()},"toggle"===t.mode&&"show"===p?(o.from=t.to||b,o.to=t.from||s):(o.from=t.from||("show"===p?b:s),o.to=t.to||("hide"===p?b:s)),a={from:{y:o.from.height/s.height,x:o.from.width/s.width},to:{y:o.to.height/s.height,x:o.to.width/s.width}},("box"===m||"both"===m)&&(a.from.y!==a.to.y&&(y=y.concat(d),o.from=e.effects.setTransition(o,d,a.from.y,o.from),o.to=e.effects.setTransition(o,d,a.to.y,o.to)),a.from.x!==a.to.x&&(y=y.concat(c),o.from=e.effects.setTransition(o,c,a.from.x,o.from),o.to=e.effects.setTransition(o,c,a.to.x,o.to))),("content"===m||"both"===m)&&a.from.y!==a.to.y&&(y=y.concat(u).concat(l),o.from=e.effects.setTransition(o,u,a.from.y,o.from),o.to=e.effects.setTransition(o,u,a.to.y,o.to)),e.effects.save(o,y),o.show(),e.effects.createWrapper(o),o.css("overflow","hidden").css(o.from),g&&(n=e.effects.getBaseline(g,s),o.from.top=(s.outerHeight-o.outerHeight())*n.y,o.from.left=(s.outerWidth-o.outerWidth())*n.x,o.to.top=(s.outerHeight-o.to.outerHeight)*n.y,o.to.left=(s.outerWidth-o.to.outerWidth)*n.x),o.css(o.from),("content"===m||"both"===m)&&(d=d.concat(["marginTop","marginBottom"]).concat(u),c=c.concat(["marginLeft","marginRight"]),l=r.concat(d).concat(c),o.find("*[width]").each(function(){var i=e(this),s={height:i.height(),width:i.width(),outerHeight:i.outerHeight(),outerWidth:i.outerWidth()};
f&&e.effects.save(i,l),i.from={height:s.height*a.from.y,width:s.width*a.from.x,outerHeight:s.outerHeight*a.from.y,outerWidth:s.outerWidth*a.from.x},i.to={height:s.height*a.to.y,width:s.width*a.to.x,outerHeight:s.height*a.to.y,outerWidth:s.width*a.to.x},a.from.y!==a.to.y&&(i.from=e.effects.setTransition(i,d,a.from.y,i.from),i.to=e.effects.setTransition(i,d,a.to.y,i.to)),a.from.x!==a.to.x&&(i.from=e.effects.setTransition(i,c,a.from.x,i.from),i.to=e.effects.setTransition(i,c,a.to.x,i.to)),i.css(i.from),i.animate(i.to,t.duration,t.easing,function(){f&&e.effects.restore(i,l)})})),o.animate(o.to,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){0===o.to.opacity&&o.css("opacity",o.from.opacity),"hide"===p&&o.hide(),e.effects.restore(o,y),f||("static"===v?o.css({position:"relative",top:o.to.top,left:o.to.left}):e.each(["top","left"],function(e,t){o.css(t,function(t,i){var s=parseInt(i,10),n=e?o.to.left:o.to.top;return"auto"===i?n+"px":s+n+"px"})})),e.effects.removeWrapper(o),i()}})},e.effects.effect.scale=function(t,i){var s=e(this),n=e.extend(!0,{},t),a=e.effects.setMode(s,t.mode||"effect"),o=parseInt(t.percent,10)||(0===parseInt(t.percent,10)?0:"hide"===a?0:100),r=t.direction||"both",h=t.origin,l={height:s.height(),width:s.width(),outerHeight:s.outerHeight(),outerWidth:s.outerWidth()},u={y:"horizontal"!==r?o/100:1,x:"vertical"!==r?o/100:1};n.effect="size",n.queue=!1,n.complete=i,"effect"!==a&&(n.origin=h||["middle","center"],n.restore=!0),n.from=t.from||("show"===a?{height:0,width:0,outerHeight:0,outerWidth:0}:l),n.to={height:l.height*u.y,width:l.width*u.x,outerHeight:l.outerHeight*u.y,outerWidth:l.outerWidth*u.x},n.fade&&("show"===a&&(n.from.opacity=0,n.to.opacity=1),"hide"===a&&(n.from.opacity=1,n.to.opacity=0)),s.effect(n)},e.effects.effect.puff=function(t,i){var s=e(this),n=e.effects.setMode(s,t.mode||"hide"),a="hide"===n,o=parseInt(t.percent,10)||150,r=o/100,h={height:s.height(),width:s.width(),outerHeight:s.outerHeight(),outerWidth:s.outerWidth()};e.extend(t,{effect:"scale",queue:!1,fade:!0,mode:n,complete:i,percent:a?o:100,from:a?h:{height:h.height*r,width:h.width*r,outerHeight:h.outerHeight*r,outerWidth:h.outerWidth*r}}),s.effect(t)},e.effects.effect.pulsate=function(t,i){var s,n=e(this),a=e.effects.setMode(n,t.mode||"show"),o="show"===a,r="hide"===a,h=o||"hide"===a,l=2*(t.times||5)+(h?1:0),u=t.duration/l,d=0,c=n.queue(),p=c.length;for((o||!n.is(":visible"))&&(n.css("opacity",0).show(),d=1),s=1;l>s;s++)n.animate({opacity:d},u,t.easing),d=1-d;n.animate({opacity:d},u,t.easing),n.queue(function(){r&&n.hide(),i()}),p>1&&c.splice.apply(c,[1,0].concat(c.splice(p,l+1))),n.dequeue()},e.effects.effect.shake=function(t,i){var s,n=e(this),a=["position","top","bottom","left","right","height","width"],o=e.effects.setMode(n,t.mode||"effect"),r=t.direction||"left",h=t.distance||20,l=t.times||3,u=2*l+1,d=Math.round(t.duration/u),c="up"===r||"down"===r?"top":"left",p="up"===r||"left"===r,f={},m={},g={},v=n.queue(),y=v.length;for(e.effects.save(n,a),n.show(),e.effects.createWrapper(n),f[c]=(p?"-=":"+=")+h,m[c]=(p?"+=":"-=")+2*h,g[c]=(p?"-=":"+=")+2*h,n.animate(f,d,t.easing),s=1;l>s;s++)n.animate(m,d,t.easing).animate(g,d,t.easing);n.animate(m,d,t.easing).animate(f,d/2,t.easing).queue(function(){"hide"===o&&n.hide(),e.effects.restore(n,a),e.effects.removeWrapper(n),i()}),y>1&&v.splice.apply(v,[1,0].concat(v.splice(y,u+1))),n.dequeue()},e.effects.effect.slide=function(t,i){var s,n=e(this),a=["position","top","bottom","left","right","width","height"],o=e.effects.setMode(n,t.mode||"show"),r="show"===o,h=t.direction||"left",l="up"===h||"down"===h?"top":"left",u="up"===h||"left"===h,d={};e.effects.save(n,a),n.show(),s=t.distance||n["top"===l?"outerHeight":"outerWidth"](!0),e.effects.createWrapper(n).css({overflow:"hidden"}),r&&n.css(l,u?isNaN(s)?"-"+s:-s:s),d[l]=(r?u?"+=":"-=":u?"-=":"+=")+s,n.animate(d,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===o&&n.hide(),e.effects.restore(n,a),e.effects.removeWrapper(n),i()}})},e.effects.effect.transfer=function(t,i){var s=e(this),n=e(t.to),a="fixed"===n.css("position"),o=e("body"),r=a?o.scrollTop():0,h=a?o.scrollLeft():0,l=n.offset(),u={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},d=s.offset(),c=e("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(t.className).css({top:d.top-r,left:d.left-h,height:s.innerHeight(),width:s.innerWidth(),position:a?"fixed":"absolute"}).animate(u,t.duration,t.easing,function(){c.remove(),i()})},e.widget("ui.progressbar",{version:"1.11.4",options:{max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min}),this.valueDiv=e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element),this._refreshValue()},_destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.valueDiv.remove()},value:function(e){return void 0===e?this.options.value:(this.options.value=this._constrainedValue(e),this._refreshValue(),void 0)},_constrainedValue:function(e){return void 0===e&&(e=this.options.value),this.indeterminate=e===!1,"number"!=typeof e&&(e=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,e))},_setOptions:function(e){var t=e.value;delete e.value,this._super(e),this.options.value=this._constrainedValue(t),this._refreshValue()},_setOption:function(e,t){"max"===e&&(t=Math.max(this.min,t)),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var t=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||t>this.min).toggleClass("ui-corner-right",t===this.options.max).width(i.toFixed(0)+"%"),this.element.toggleClass("ui-progressbar-indeterminate",this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=e("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":t}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==t&&(this.oldValue=t,this._trigger("change")),t===this.options.max&&this._trigger("complete")}}),e.widget("ui.selectable",e.ui.mouse,{version:"1.11.4",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var t,i=this;this.element.addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){t=e(i.options.filter,i.element[0]),t.addClass("ui-selectee"),t.each(function(){var t=e(this),i=t.offset();e.data(this,"selectable-item",{element:this,$element:t,left:i.left,top:i.top,right:i.left+t.outerWidth(),bottom:i.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=t.addClass("ui-selectee"),this._mouseInit(),this.helper=e("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(t){var i=this,s=this.options;this.opos=[t.pageX,t.pageY],this.options.disabled||(this.selectees=e(s.filter,this.element[0]),this._trigger("start",t),e(s.appendTo).append(this.helper),this.helper.css({left:t.pageX,top:t.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=e.data(this,"selectable-item");s.startselected=!0,t.metaKey||t.ctrlKey||(s.$element.removeClass("ui-selected"),s.selected=!1,s.$element.addClass("ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",t,{unselecting:s.element}))}),e(t.target).parents().addBack().each(function(){var s,n=e.data(this,"selectable-item");return n?(s=!t.metaKey&&!t.ctrlKey||!n.$element.hasClass("ui-selected"),n.$element.removeClass(s?"ui-unselecting":"ui-selected").addClass(s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",t,{selecting:n.element}):i._trigger("unselecting",t,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(t){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,a=this.opos[0],o=this.opos[1],r=t.pageX,h=t.pageY;return a>r&&(i=r,r=a,a=i),o>h&&(i=h,h=o,o=i),this.helper.css({left:a,top:o,width:r-a,height:h-o}),this.selectees.each(function(){var i=e.data(this,"selectable-item"),l=!1;i&&i.element!==s.element[0]&&("touch"===n.tolerance?l=!(i.left>r||a>i.right||i.top>h||o>i.bottom):"fit"===n.tolerance&&(l=i.left>a&&r>i.right&&i.top>o&&h>i.bottom),l?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,s._trigger("selecting",t,{selecting:i.element}))):(i.selecting&&((t.metaKey||t.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",t,{unselecting:i.element}))),i.selected&&(t.metaKey||t.ctrlKey||i.startselected||(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",t,{unselecting:i.element})))))}),!1}},_mouseStop:function(t){var i=this;return this.dragged=!1,e(".ui-unselecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",t,{unselected:s.element})}),e(".ui-selecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-selecting").addClass("ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",t,{selected:s.element})}),this._trigger("stop",t),this.helper.remove(),!1}}),e.widget("ui.selectmenu",{version:"1.11.4",defaultElement:"<select>",options:{appendTo:null,disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:null,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this.options.disabled&&this.disable()},_drawButton:function(){var t=this;this.label=e("label[for='"+this.ids.element+"']").attr("for",this.ids.button),this._on(this.label,{click:function(e){this.button.focus(),e.preventDefault()}}),this.element.hide(),this.button=e("<span>",{"class":"ui-selectmenu-button ui-widget ui-state-default ui-corner-all",tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true"}).insertAfter(this.element),e("<span>",{"class":"ui-icon "+this.options.icons.button}).prependTo(this.button),this.buttonText=e("<span>",{"class":"ui-selectmenu-text"}).appendTo(this.button),this._setText(this.buttonText,this.element.find("option:selected").text()),this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){t.menuItems||t._refreshMenu()}),this._hoverable(this.button),this._focusable(this.button)},_drawMenu:function(){var t=this;this.menu=e("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=e("<div>",{"class":"ui-selectmenu-menu ui-front"}).append(this.menu).appendTo(this._appendTo()),this.menuInstance=this.menu.menu({role:"listbox",select:function(e,i){e.preventDefault(),t._setSelection(),t._select(i.item.data("ui-selectmenu-item"),e)},focus:function(e,i){var s=i.item.data("ui-selectmenu-item");null!=t.focusIndex&&s.index!==t.focusIndex&&(t._trigger("focus",e,{item:s}),t.isOpen||t._select(s,e)),t.focusIndex=s.index,t.button.attr("aria-activedescendant",t.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this._setText(this.buttonText,this._getSelectedItem().text()),this.options.width||this._resizeButton()},_refreshMenu:function(){this.menu.empty();var e,t=this.element.find("option");t.length&&(this._parseOptions(t),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup"),e=this._getSelectedItem(),this.menuInstance.focus(null,e),this._setAria(e.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(e){this.options.disabled||(this.menuItems?(this.menu.find(".ui-state-focus").removeClass("ui-state-focus"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",e))},_position:function(){this.menuWrap.position(e.extend({of:this.button},this.options.position))},close:function(e){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",e))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderMenu:function(t,i){var s=this,n="";e.each(i,function(i,a){a.optgroup!==n&&(e("<li>",{"class":"ui-selectmenu-optgroup ui-menu-divider"+(a.element.parent("optgroup").prop("disabled")?" ui-state-disabled":""),text:a.optgroup}).appendTo(t),n=a.optgroup),s._renderItemData(t,a)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-selectmenu-item",t)},_renderItem:function(t,i){var s=e("<li>");return i.disabled&&s.addClass("ui-state-disabled"),this._setText(s,i.label),s.appendTo(t)},_setText:function(e,t){t?e.text(t):e.html("&#160;")},_move:function(e,t){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex):(i=this.menuItems.eq(this.element[0].selectedIndex),n+=":not(.ui-state-disabled)"),s="first"===e||"last"===e?i["first"===e?"prevAll":"nextAll"](n).eq(-1):i[e+"All"](n).eq(0),s.length&&this.menuInstance.focus(t,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex)},_toggle:function(e){this[this.isOpen?"close":"open"](e)},_setSelection:function(){var e;this.range&&(window.getSelection?(e=window.getSelection(),e.removeAllRanges(),e.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(t){this.isOpen&&(e(t.target).closest(".ui-selectmenu-menu, #"+this.ids.button).length||this.close(t))}},_buttonEvents:{mousedown:function(){var e;window.getSelection?(e=window.getSelection(),e.rangeCount&&(this.range=e.getRangeAt(0))):this.range=document.selection.createRange()},click:function(e){this._setSelection(),this._toggle(e)},keydown:function(t){var i=!0;switch(t.keyCode){case e.ui.keyCode.TAB:case e.ui.keyCode.ESCAPE:this.close(t),i=!1;break;case e.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(t);break;case e.ui.keyCode.UP:t.altKey?this._toggle(t):this._move("prev",t);break;case e.ui.keyCode.DOWN:t.altKey?this._toggle(t):this._move("next",t);break;case e.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(t):this._toggle(t);break;case e.ui.keyCode.LEFT:this._move("prev",t);break;case e.ui.keyCode.RIGHT:this._move("next",t);break;case e.ui.keyCode.HOME:case e.ui.keyCode.PAGE_UP:this._move("first",t);break;case e.ui.keyCode.END:case e.ui.keyCode.PAGE_DOWN:this._move("last",t);break;default:this.menu.trigger(t),i=!1}i&&t.preventDefault()}},_selectFocusedItem:function(e){var t=this.menuItems.eq(this.focusIndex);t.hasClass("ui-state-disabled")||this._select(t.data("ui-selectmenu-item"),e)},_select:function(e,t){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=e.index,this._setText(this.buttonText,e.label),this._setAria(e),this._trigger("select",t,{item:e}),e.index!==i&&this._trigger("change",t,{item:e}),this.close(t)},_setAria:function(e){var t=this.menuItems.eq(e.index).attr("id");this.button.attr({"aria-labelledby":t,"aria-activedescendant":t}),this.menu.attr("aria-activedescendant",t)},_setOption:function(e,t){"icons"===e&&this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(t.button),this._super(e,t),"appendTo"===e&&this.menuWrap.appendTo(this._appendTo()),"disabled"===e&&(this.menuInstance.option("disabled",t),this.button.toggleClass("ui-state-disabled",t).attr("aria-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)),"width"===e&&this._resizeButton()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_toggleAttr:function(){this.button.toggleClass("ui-corner-top",this.isOpen).toggleClass("ui-corner-all",!this.isOpen).attr("aria-expanded",this.isOpen),this.menuWrap.toggleClass("ui-selectmenu-open",this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var e=this.options.width;e||(e=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(e)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){return{disabled:this.element.prop("disabled")}},_parseOptions:function(t){var i=[];t.each(function(t,s){var n=e(s),a=n.parent("optgroup");i.push({element:n,index:t,value:n.val(),label:n.text(),optgroup:a.attr("label")||"",disabled:a.prop("disabled")||n.prop("disabled")})}),this.items=i},_destroy:function(){this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.label.attr("for",this.ids.element)}}),e.widget("ui.slider",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"),this._refresh(),this._setOption("disabled",this.options.disabled),this._animateOff=!1},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var t,i,s=this.options,n=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),a="<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",o=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),t=n.length;i>t;t++)o.push(a);this.handles=n.add(e(o.join("")).appendTo(this.element)),this.handle=this.handles.eq(0),this.handles.each(function(t){e(this).data("ui-slider-handle-index",t)})},_createRange:function(){var t=this.options,i="";t.range?(t.range===!0&&(t.values?t.values.length&&2!==t.values.length?t.values=[t.values[0],t.values[0]]:e.isArray(t.values)&&(t.values=t.values.slice(0)):t.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({left:"",bottom:""}):(this.range=e("<div></div>").appendTo(this.element),i="ui-slider-range ui-widget-header ui-corner-all"),this.range.addClass(i+("min"===t.range||"max"===t.range?" ui-slider-range-"+t.range:""))):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"),this._mouseDestroy()},_mouseCapture:function(t){var i,s,n,a,o,r,h,l,u=this,d=this.options;return d.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:t.pageX,y:t.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var i=Math.abs(s-u.values(t));(n>i||n===i&&(t===u._lastChangedValue||u.values(t)===d.min))&&(n=i,a=e(this),o=t)}),r=this._start(t,o),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=o,a.addClass("ui-state-active").focus(),h=a.offset(),l=!e(t.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:t.pageX-h.left-a.width()/2,top:t.pageY-h.top-a.height()/2-(parseInt(a.css("borderTopWidth"),10)||0)-(parseInt(a.css("borderBottomWidth"),10)||0)+(parseInt(a.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,o,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(e){var t={x:e.pageX,y:e.pageY},i=this._normValueFromMouse(t);return this._slide(e,this._handleIndex,i),!1},_mouseStop:function(e){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(e,this._handleIndex),this._change(e,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(e){var t,i,s,n,a;return"horizontal"===this.orientation?(t=this.elementSize.width,i=e.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(t=this.elementSize.height,i=e.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/t,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),a=this._valueMin()+s*n,this._trimAlignValue(a)},_start:function(e,t){var i={handle:this.handles[t],value:this.value()};return this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("start",e,i)},_slide:function(e,t,i){var s,n,a;this.options.values&&this.options.values.length?(s=this.values(t?0:1),2===this.options.values.length&&this.options.range===!0&&(0===t&&i>s||1===t&&s>i)&&(i=s),i!==this.values(t)&&(n=this.values(),n[t]=i,a=this._trigger("slide",e,{handle:this.handles[t],value:i,values:n}),s=this.values(t?0:1),a!==!1&&this.values(t,i))):i!==this.value()&&(a=this._trigger("slide",e,{handle:this.handles[t],value:i}),a!==!1&&this.value(i))},_stop:function(e,t){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("stop",e,i)},_change:function(e,t){if(!this._keySliding&&!this._mouseSliding){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._lastChangedValue=t,this._trigger("change",e,i)}},value:function(e){return arguments.length?(this.options.value=this._trimAlignValue(e),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(t,i){var s,n,a;if(arguments.length>1)return this.options.values[t]=this._trimAlignValue(i),this._refreshValue(),this._change(null,t),void 0;if(!arguments.length)return this._values();if(!e.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(t):this.value();for(s=this.options.values,n=arguments[0],a=0;s.length>a;a+=1)s[a]=this._trimAlignValue(n[a]),this._change(null,a);this._refreshValue()},_setOption:function(t,i){var s,n=0;switch("range"===t&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),e.isArray(this.options.values)&&(n=this.options.values.length),"disabled"===t&&this.element.toggleClass("ui-state-disabled",!!i),this._super(t,i),t){case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue(),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=0;n>s;s+=1)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_value:function(){var e=this.options.value;return e=this._trimAlignValue(e)},_values:function(e){var t,i,s;if(arguments.length)return t=this.options.values[e],t=this._trimAlignValue(t);if(this.options.values&&this.options.values.length){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(e){if(this._valueMin()>=e)return this._valueMin();if(e>=this._valueMax())return this._valueMax();var t=this.options.step>0?this.options.step:1,i=(e-this._valueMin())%t,s=e-i;return 2*Math.abs(i)>=t&&(s+=i>0?t:-t),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var e=this.options.max,t=this._valueMin(),i=this.options.step,s=Math.floor(+(e-t).toFixed(this._precision())/i)*i;e=s+t,this.max=parseFloat(e.toFixed(this._precision()))},_precision:function(){var e=this._precisionOf(this.options.step);return null!==this.options.min&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=""+e,i=t.indexOf(".");return-1===i?0:t.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshValue:function(){var t,i,s,n,a,o=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,u={};this.options.values&&this.options.values.length?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),u["horizontal"===h.orientation?"left":"bottom"]=i+"%",e(this).stop(1,1)[l?"animate":"css"](u,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-t+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-t+"%"},{queue:!1,duration:r.animate}))),t=i}):(s=this.value(),n=this._valueMin(),a=this._valueMax(),i=a!==n?100*((s-n)/(a-n)):0,u["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](u,r.animate),"min"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===o&&"horizontal"===this.orientation&&this.range[l?"animate":"css"]({width:100-i+"%"},{queue:!1,duration:r.animate}),"min"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===o&&"vertical"===this.orientation&&this.range[l?"animate":"css"]({height:100-i+"%"},{queue:!1,duration:r.animate}))},_handleEvents:{keydown:function(t){var i,s,n,a,o=e(t.target).data("ui-slider-handle-index");switch(t.keyCode){case e.ui.keyCode.HOME:case e.ui.keyCode.END:case e.ui.keyCode.PAGE_UP:case e.ui.keyCode.PAGE_DOWN:case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(t.preventDefault(),!this._keySliding&&(this._keySliding=!0,e(t.target).addClass("ui-state-active"),i=this._start(t,o),i===!1))return}switch(a=this.options.step,s=n=this.options.values&&this.options.values.length?this.values(o):this.value(),t.keyCode){case e.ui.keyCode.HOME:n=this._valueMin();break;case e.ui.keyCode.END:n=this._valueMax();break;case e.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+a);break;case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-a)}this._slide(t,o,n)},keyup:function(t){var i=e(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(t,i),this._change(t,i),e(t.target).removeClass("ui-state-active"))}}}),e.widget("ui.sortable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(e,t,i){return e>=t&&t+i>e},_isFloating:function(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))},_create:function(){this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(e,t){this._super(e,t),"handle"===e&&this._setHandleClassName()},_setHandleClassName:function(){this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"),e.each(this.items,function(){(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item).addClass("ui-sortable-handle")})},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,i){var s=null,n=!1,a=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,a.widgetName+"-item")===a?(s=e(this),!1):void 0}),e.data(t.target,a.widgetName+"-item")===a&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var n,a,o=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,o.cursorAt&&this._adjustOffsetFromHelper(o.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),o.containment&&this._setContainment(),o.cursor&&"auto"!==o.cursor&&(a=this.document.find("body"),this.storedCursor=a.css("cursor"),a.css("cursor",o.cursor),this.storedStylesheet=e("<style>*{ cursor: "+o.cursor+" !important; }</style>").appendTo(a)),o.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",o.opacity)),o.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",o.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",t,this._uiHash(this));
return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,n,a,o=this.options,r=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<o.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+o.scrollSpeed:t.pageY-this.overflowOffset.top<o.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-o.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<o.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+o.scrollSpeed:t.pageX-this.overflowOffset.left<o.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-o.scrollSpeed)):(t.pageY-this.document.scrollTop()<o.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-o.scrollSpeed):this.window.height()-(t.pageY-this.document.scrollTop())<o.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+o.scrollSpeed)),t.pageX-this.document.scrollLeft()<o.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-o.scrollSpeed):this.window.width()-(t.pageX-this.document.scrollLeft())<o.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+o.scrollSpeed))),r!==!1&&e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],a=this._intersectsWithPointer(s),a&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===a?"next":"prev"]()[0]!==n&&!e.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],n):!0)){if(this.direction=1===a?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,n=this.placeholder.offset(),a=this.options.axis,o={};a&&"x"!==a||(o.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),a&&"y"!==a||(o.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(o,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,a=e.left,o=a+e.width,r=e.top,h=r+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>r&&h>s+l,c="y"===this.options.axis||t+u>a&&o>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>a&&o>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(e){var t="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top,e.height),i="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left,e.width),s=t&&i,n=this._getDragVerticalDirection(),a=this._getDragHorizontalDirection();return s?this.floating?a&&"right"===a||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(e){var t=this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&t||"up"===s&&!t)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){r.push(this)}var s,n,a,o,r=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(a=e(l[s],this.document[0]),n=a.length-1;n>=0;n--)o=e.data(a[n],this.widgetFullName),o&&o!==this&&!o.options.disabled&&h.push([e.isFunction(o.options.items)?o.options.items.call(o.element):e(o.options.items,o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),o]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(r)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,n,a,o,r,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(n=e(c[i],this.document[0]),s=n.length-1;s>=0;s--)a=e.data(n[s],this.widgetFullName),a&&a!==this&&!a.options.disabled&&(d.push([e.isFunction(a.options.items)?a.options.items.call(a.element[0],t,{item:this.currentItem}):e(a.options.items,a.element),a]),this.containers.push(a));for(i=d.length-1;i>=0;i--)for(o=d[i][1],r=d[i][0],s=0,l=r.length;l>s;s++)h=e(r[s]),h.data(this.widgetName+"-item",o),u.push({item:h,instance:o,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,a;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=n.outerWidth(),s.height=n.outerHeight()),a=n.offset(),s.left=a.left,s.top=a.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)a=this.containers[i].element.offset(),this.containers[i].containerCache.left=a.left,this.containers[i].containerCache.top=a.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),n=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tbody"===s?t._createTrPlaceholder(t.currentItem.find("tr").eq(0),e("<tr>",t.document[0]).appendTo(n)):"tr"===s?t._createTrPlaceholder(t.currentItem,n):"img"===s&&n.attr("src",t.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(e,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_createTrPlaceholder:function(t,i){var s=this;t.children().each(function(){e("<td>&#160;</td>",s.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(t){var i,s,n,a,o,r,h,l,u,d,c=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!e.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(c&&e.contains(this.containers[i].element[0],c.element[0]))continue;c=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",t,this._uiHash(this)),this.containers[i].containerCache.over=0);if(c)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,a=null,u=c.floating||this._isFloating(this.currentItem),o=u?"left":"top",r=u?"width":"height",d=u?"clientX":"clientY",s=this.items.length-1;s>=0;s--)e.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[o],l=!1,t[d]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(t[d]-h)&&(n=Math.abs(t[d]-h),a=this.items[s],this.direction=l?"up":"down"));if(!a&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;a?this._rearrange(t,a,null,!0):this._rearrange(t,null,this.containers[p].element,!0),this._trigger("change",t,this._uiHash()),this.containers[p]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.width():this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(t=e(n.containment)[0],i=e(n.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:n.scrollLeft())*s}},_generatePosition:function(t){var i,s,n=this.options,a=t.pageX,o=t.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(a=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(o=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(a=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(o=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((o-this.originalPageY)/n.grid[1])*n.grid[1],o=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((a-this.originalPageX)/n.grid[0])*n.grid[0],a=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&n.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||n.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(n.push(function(e){this._trigger("remove",e,this._uiHash())}),n.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!t){for(s=0;n.length>s;s++)n[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}}),e.widget("ui.spinner",{version:"1.11.4",defaultElement:"<input>",widgetEventPrefix:"spin",options:{culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var t={},i=this.element;return e.each(["min","max","step"],function(e,s){var n=i.attr(s);void 0!==n&&n.length&&(t[s]=n)}),t},_events:{keydown:function(e){this._start(e)&&this._keydown(e)&&e.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",e),void 0)},mousewheel:function(e,t){if(t){if(!this.spinning&&!this._start(e))return!1;this._spin((t>0?1:-1)*this.options.step,e),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(e)},100),e.preventDefault()}},"mousedown .ui-spinner-button":function(t){function i(){var e=this.element[0]===this.document[0].activeElement;e||(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===this.document[0].activeElement?this.previous:this.element.val(),t.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(t)!==!1&&this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(t){return e(t.currentTarget).hasClass("ui-state-active")?this._start(t)===!1?!1:(this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_draw:function(){var e=this.uiSpinner=this.element.addClass("ui-spinner-input").attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());this.element.attr("role","spinbutton"),this.buttons=e.find(".ui-spinner-button").attr("tabIndex",-1).button().removeClass("ui-corner-all"),this.buttons.height()>Math.ceil(.5*e.height())&&e.height()>0&&e.height(e.height()),this.options.disabled&&this.disable()},_keydown:function(t){var i=this.options,s=e.ui.keyCode;switch(t.keyCode){case s.UP:return this._repeat(null,1,t),!0;case s.DOWN:return this._repeat(null,-1,t),!0;case s.PAGE_UP:return this._repeat(null,i.page,t),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,t),!0}return!1},_uiSpinnerHtml:function(){return"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"},_buttonHtml:function(){return"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon "+this.options.icons.up+"'>&#9650;</span>"+"</a>"+"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>"+"<span class='ui-icon "+this.options.icons.down+"'>&#9660;</span>"+"</a>"},_start:function(e){return this.spinning||this._trigger("start",e)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(e,t,i){e=e||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,t,i)},e),this._spin(t*this.options.step,i)},_spin:function(e,t){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+e*this._increment(this.counter)),this.spinning&&this._trigger("spin",t,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(t){var i=this.options.incremental;return i?e.isFunction(i)?i(t):Math.floor(t*t*t/5e4-t*t/500+17*t/200+1):1},_precision:function(){var e=this._precisionOf(this.options.step);return null!==this.options.min&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=""+e,i=t.indexOf(".");return-1===i?0:t.length-i-1},_adjustValue:function(e){var t,i,s=this.options;return t=null!==s.min?s.min:0,i=e-t,i=Math.round(i/s.step)*s.step,e=t+i,e=parseFloat(e.toFixed(this._precision())),null!==s.max&&e>s.max?s.max:null!==s.min&&s.min>e?s.min:e},_stop:function(e){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",e))},_setOption:function(e,t){if("culture"===e||"numberFormat"===e){var i=this._parse(this.element.val());return this.options[e]=t,this.element.val(this._format(i)),void 0}("max"===e||"min"===e||"step"===e)&&"string"==typeof t&&(t=this._parse(t)),"icons"===e&&(this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(t.up),this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(t.down)),this._super(e,t),"disabled"===e&&(this.widget().toggleClass("ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable"))},_setOptions:h(function(e){this._super(e)}),_parse:function(e){return"string"==typeof e&&""!==e&&(e=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(e,10,this.options.culture):+e),""===e||isNaN(e)?null:e},_format:function(e){return""===e?"":window.Globalize&&this.options.numberFormat?Globalize.format(e,this.options.numberFormat,this.options.culture):e},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var e=this.value();return null===e?!1:e===this._adjustValue(e)},_value:function(e,t){var i;""!==e&&(i=this._parse(e),null!==i&&(t||(i=this._adjustValue(i)),e=this._format(i))),this.element.val(e),this._refresh()},_destroy:function(){this.element.removeClass("ui-spinner-input").prop("disabled",!1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:h(function(e){this._stepUp(e)}),_stepUp:function(e){this._start()&&(this._spin((e||1)*this.options.step),this._stop())},stepDown:h(function(e){this._stepDown(e)}),_stepDown:function(e){this._start()&&(this._spin((e||1)*-this.options.step),this._stop())},pageUp:h(function(e){this._stepUp((e||1)*this.options.page)}),pageDown:h(function(e){this._stepDown((e||1)*this.options.page)}),value:function(e){return arguments.length?(h(this._value).call(this,e),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),e.widget("ui.tabs",{version:"1.11.4",delay:300,options:{active:null,collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var e=/#.*$/;return function(t){var i,s;t=t.cloneNode(!1),i=t.href.replace(e,""),s=location.href.replace(e,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return t.hash.length>1&&i===s}}(),_create:function(){var t=this,i=this.options;this.running=!1,this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible",i.collapsible),this._processTabs(),i.active=this._initialActive(),e.isArray(i.disabled)&&(i.disabled=e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"),function(e){return t.tabs.index(e)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):e(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var t=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===t&&(s&&this.tabs.each(function(i,n){return e(n).attr("aria-controls")===s?(t=i,!1):void 0}),null===t&&(t=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===t||-1===t)&&(t=this.tabs.length?0:!1)),t!==!1&&(t=this.tabs.index(this.tabs.eq(t)),-1===t&&(t=i?!1:0)),!i&&t===!1&&this.anchors.length&&(t=0),t},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):e()}},_tabKeydown:function(t){var i=e(this.document[0].activeElement).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(t)){switch(t.keyCode){case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:s++;break;case e.ui.keyCode.UP:case e.ui.keyCode.LEFT:n=!1,s--;break;case e.ui.keyCode.END:s=this.anchors.length-1;break;case e.ui.keyCode.HOME:s=0;break;case e.ui.keyCode.SPACE:return t.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case e.ui.keyCode.ENTER:return t.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}t.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),t.ctrlKey||t.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(t){this._handlePageNav(t)||t.ctrlKey&&t.keyCode===e.ui.keyCode.UP&&(t.preventDefault(),this.active.focus())},_handlePageNav:function(t){return t.altKey&&t.keyCode===e.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):t.altKey&&t.keyCode===e.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(t,i){function s(){return t>n&&(t=0),0>t&&(t=n),t}for(var n=this.tabs.length-1;-1!==e.inArray(s(),this.options.disabled);)t=i?t+1:t-1;return t},_focusNextTab:function(e,t){return e=this._findNextTab(e,t),this.tabs.eq(e).focus(),e},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):"disabled"===e?(this._setupDisabled(t),void 0):(this._super(e,t),"collapsible"===e&&(this.element.toggleClass("ui-tabs-collapsible",t),t||this.options.active!==!1||this._activate(0)),"event"===e&&this._setupEvents(t),"heightStyle"===e&&this._setupHeightStyle(t),void 0)},_sanitizeSelector:function(e){return e?e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,i=this.tablist.children(":has(a[href])");t.disabled=e.map(i.filter(".ui-state-disabled"),function(e){return i.index(e)}),this._processTabs(),t.active!==!1&&this.anchors.length?this.active.length&&!e.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!1,this.active=e()):this._activate(this._findNextTab(Math.max(0,t.active-1),!1)):t.active=this.tabs.index(this.active):(t.active=!1,this.active=e()),this._refresh()},_refresh:function(){this._setupDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.addClass("ui-tabs-active ui-state-active").attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var t=this,i=this.tabs,s=this.anchors,n=this.panels;
this.tablist=this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role","tablist").delegate("> li","mousedown"+this.eventNamespace,function(t){e(this).is(".ui-state-disabled")&&t.preventDefault()}).delegate(".ui-tabs-anchor","focus"+this.eventNamespace,function(){e(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({role:"tab",tabIndex:-1}),this.anchors=this.tabs.map(function(){return e("a",this)[0]}).addClass("ui-tabs-anchor").attr({role:"presentation",tabIndex:-1}),this.panels=e(),this.anchors.each(function(i,s){var n,a,o,r=e(s).uniqueId().attr("id"),h=e(s).closest("li"),l=h.attr("aria-controls");t._isLocal(s)?(n=s.hash,o=n.substring(1),a=t.element.find(t._sanitizeSelector(n))):(o=h.attr("aria-controls")||e({}).uniqueId()[0].id,n="#"+o,a=t.element.find(n),a.length||(a=t._createPanel(o),a.insertAfter(t.panels[i-1]||t.tablist)),a.attr("aria-live","polite")),a.length&&(t.panels=t.panels.add(a)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":o,"aria-labelledby":r}),a.attr("aria-labelledby",r)}),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role","tabpanel"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol,ul").eq(0)},_createPanel:function(t){return e("<div>").attr("id",t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy",!0)},_setupDisabled:function(t){e.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!0):t=!1);for(var i,s=0;i=this.tabs[s];s++)t===!0||-1!==e.inArray(s,t)?e(i).addClass("ui-state-disabled").attr("aria-disabled","true"):e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");this.options.disabled=t},_setupEvents:function(t){var i={};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(e){e.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var i,s=this.element.parent();"fill"===t?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var t=e(this),s=t.css("position");"absolute"!==s&&"fixed"!==s&&(i-=t.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=e(this).outerHeight(!0)}),this.panels.each(function(){e(this).height(Math.max(0,i-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===t&&(i=0,this.panels.each(function(){i=Math.max(i,e(this).height("").height())}).height(i))},_eventHandler:function(t){var i=this.options,s=this.active,n=e(t.currentTarget),a=n.closest("li"),o=a[0]===s[0],r=o&&i.collapsible,h=r?e():this._getPanelForTab(a),l=s.length?this._getPanelForTab(s):e(),u={oldTab:s,oldPanel:l,newTab:r?e():a,newPanel:h};t.preventDefault(),a.hasClass("ui-state-disabled")||a.hasClass("ui-tabs-loading")||this.running||o&&!i.collapsible||this._trigger("beforeActivate",t,u)===!1||(i.active=r?!1:this.tabs.index(a),this.active=o?e():a,this.xhr&&this.xhr.abort(),l.length||h.length||e.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(a),t),this._toggle(t,u))},_toggle:function(t,i){function s(){a.running=!1,a._trigger("activate",t,i)}function n(){i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"),o.length&&a.options.show?a._show(o,a.options.show,s):(o.show(),s())}var a=this,o=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),n()}):(i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),o.length&&r.length?i.oldTab.attr("tabIndex",-1):o.length&&this.tabs.filter(function(){return 0===e(this).attr("tabIndex")}).attr("tabIndex",-1),o.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(t){var i,s=this._findActive(t);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return t===!1?e():this.tabs.eq(t)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+e+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"),this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"),this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(),this.tablist.unbind(this.eventNamespace),this.tabs.add(this.panels).each(function(){e.data(this,"ui-tabs-destroy")?e(this).remove():e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")}),this.tabs.each(function(){var t=e(this),i=t.data("ui-tabs-aria-controls");i?t.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):t.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(t){var i=this.options.disabled;i!==!1&&(void 0===t?i=!1:(t=this._getIndex(t),i=e.isArray(i)?e.map(i,function(e){return e!==t?e:null}):e.map(this.tabs,function(e,i){return i!==t?i:null})),this._setupDisabled(i))},disable:function(t){var i=this.options.disabled;if(i!==!0){if(void 0===t)i=!0;else{if(t=this._getIndex(t),-1!==e.inArray(t,i))return;i=e.isArray(i)?e.merge([t],i).sort():[t]}this._setupDisabled(i)}},load:function(t,i){t=this._getIndex(t);var s=this,n=this.tabs.eq(t),a=n.find(".ui-tabs-anchor"),o=this._getPanelForTab(n),r={tab:n,panel:o},h=function(e,t){"abort"===t&&s.panels.stop(!1,!0),n.removeClass("ui-tabs-loading"),o.removeAttr("aria-busy"),e===s.xhr&&delete s.xhr};this._isLocal(a[0])||(this.xhr=e.ajax(this._ajaxSettings(a,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(n.addClass("ui-tabs-loading"),o.attr("aria-busy","true"),this.xhr.done(function(e,t,n){setTimeout(function(){o.html(e),s._trigger("load",i,r),h(n,t)},1)}).fail(function(e,t){setTimeout(function(){h(e,t)},1)})))},_ajaxSettings:function(t,i,s){var n=this;return{url:t.attr("href"),beforeSend:function(t,a){return n._trigger("beforeLoad",i,e.extend({jqXHR:t,ajaxSettings:a},s))}}},_getPanelForTab:function(t){var i=e(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),e.widget("ui.tooltip",{version:"1.11.4",options:{content:function(){var t=e(this).attr("title")||"";return e("<a>").text(t).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,tooltipClass:null,track:!1,close:null,open:null},_addDescribedBy:function(t,i){var s=(t.attr("aria-describedby")||"").split(/\s+/);s.push(i),t.data("ui-tooltip-id",i).attr("aria-describedby",e.trim(s.join(" ")))},_removeDescribedBy:function(t){var i=t.data("ui-tooltip-id"),s=(t.attr("aria-describedby")||"").split(/\s+/),n=e.inArray(i,s);-1!==n&&s.splice(n,1),t.removeData("ui-tooltip-id"),s=e.trim(s.join(" ")),s?t.attr("aria-describedby",s):t.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.options.disabled&&this._disable(),this.liveRegion=e("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body)},_setOption:function(t,i){var s=this;return"disabled"===t?(this[i?"_disable":"_enable"](),this.options[t]=i,void 0):(this._super(t,i),"content"===t&&e.each(this.tooltips,function(e,t){s._updateContent(t.element)}),void 0)},_disable:function(){var t=this;e.each(this.tooltips,function(i,s){var n=e.Event("blur");n.target=n.currentTarget=s.element[0],t.close(n,!0)}),this.element.find(this.options.items).addBack().each(function(){var t=e(this);t.is("[title]")&&t.data("ui-tooltip-title",t.attr("title")).removeAttr("title")})},_enable:function(){this.element.find(this.options.items).addBack().each(function(){var t=e(this);t.data("ui-tooltip-title")&&t.attr("title",t.data("ui-tooltip-title"))})},open:function(t){var i=this,s=e(t?t.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),t&&"mouseover"===t.type&&s.parents().each(function(){var t,s=e(this);s.data("ui-tooltip-open")&&(t=e.Event("blur"),t.target=t.currentTarget=this,i.close(t,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(t,s),this._updateContent(s,t))},_updateContent:function(e,t){var i,s=this.options.content,n=this,a=t?t.type:null;return"string"==typeof s?this._open(t,e,s):(i=s.call(e[0],function(i){n._delay(function(){e.data("ui-tooltip-open")&&(t&&(t.type=a),this._open(t,e,i))})}),i&&this._open(t,e,i),void 0)},_open:function(t,i,s){function n(e){l.of=e,o.is(":hidden")||o.position(l)}var a,o,r,h,l=e.extend({},this.options.position);if(s){if(a=this._find(i))return a.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(t&&"mouseover"===t.type?i.attr("title",""):i.removeAttr("title")),a=this._tooltip(i),o=a.tooltip,this._addDescribedBy(i,o.attr("id")),o.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),s.clone?(h=s.clone(),h.removeAttr("id").find("[id]").removeAttr("id")):h=s,e("<div>").html(h).appendTo(this.liveRegion),this.options.track&&t&&/^mouse/.test(t.type)?(this._on(this.document,{mousemove:n}),n(t)):o.position(e.extend({of:i},this.options.position)),o.hide(),this._show(o,this.options.show),this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){o.is(":visible")&&(n(l.of),clearInterval(r))},e.fx.interval)),this._trigger("open",t,{tooltip:o})}},_registerCloseHandlers:function(t,i){var s={keyup:function(t){if(t.keyCode===e.ui.keyCode.ESCAPE){var s=e.Event(t);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),t&&"mouseover"!==t.type||(s.mouseleave="close"),t&&"focusin"!==t.type||(s.focusout="close"),this._on(!0,i,s)},close:function(t){var i,s=this,n=e(t?t.currentTarget:this.element),a=this._find(n);return a?(i=a.tooltip,a.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),a.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(e(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),t&&"mouseleave"===t.type&&e.each(this.parents,function(t,i){e(i.element).attr("title",i.title),delete s.parents[t]}),a.closing=!0,this._trigger("close",t,{tooltip:i}),a.hiding||(a.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(t){var i=e("<div>").attr("role","tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content "+(this.options.tooltipClass||"")),s=i.uniqueId().attr("id");return e("<div>").addClass("ui-tooltip-content").appendTo(i),i.appendTo(this.document[0].body),this.tooltips[s]={element:t,tooltip:i}},_find:function(e){var t=e.data("ui-tooltip-id");return t?this.tooltips[t]:null},_removeTooltip:function(e){e.remove(),delete this.tooltips[e.attr("id")]},_destroy:function(){var t=this;e.each(this.tooltips,function(i,s){var n=e.Event("blur"),a=s.element;n.target=n.currentTarget=a[0],t.close(n,!0),e("#"+i).remove(),a.data("ui-tooltip-title")&&(a.attr("title")||a.attr("title",a.data("ui-tooltip-title")),a.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}})});
/* ==========================================================
 * bootstrap-alert.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#alerts
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* ALERT CLASS DEFINITION
  * ====================== */

  var dismiss = '[data-dismiss="alert"]'
    , Alert = function (el) {
        $(el).on('click', dismiss, this.close)
      }

  Alert.prototype.close = function (e) {
    var $this = $(this)
      , selector = $this.attr('data-target')
      , $parent

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    $parent = $(selector)

    e && e.preventDefault()

    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())

    $parent.trigger(e = $.Event('close'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      $parent
        .trigger('closed')
        .remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent.on($.support.transition.end, removeElement) :
      removeElement()
  }


 /* ALERT PLUGIN DEFINITION
  * ======================= */

  $.fn.alert = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('alert')
      if (!data) $this.data('alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.alert.Constructor = Alert


 /* ALERT DATA-API
  * ============== */

  $(function () {
    $('body').on('click.alert.data-api', dismiss, Alert.prototype.close)
  })

}(window.jQuery);
/* =============================================================
 * bootstrap-collapse.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#collapse
 * =============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* COLLAPSE PUBLIC CLASS DEFINITION
  * ================================ */

  var Collapse = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.collapse.defaults, options)

    if (this.options.parent) {
      this.$parent = $(this.options.parent)
    }

    this.options.toggle && this.toggle()
  }

  Collapse.prototype = {

    constructor: Collapse

  , dimension: function () {
      var hasWidth = this.$element.hasClass('width')
      return hasWidth ? 'width' : 'height'
    }

  , show: function () {
      var dimension
        , scroll
        , actives
        , hasData

      if (this.transitioning) return

      dimension = this.dimension()
      scroll = $.camelCase(['scroll', dimension].join('-'))
      actives = this.$parent && this.$parent.find('> .accordion-group > .in')

      if (actives && actives.length) {
        hasData = actives.data('collapse')
        if (hasData && hasData.transitioning) return
        actives.collapse('hide')
        hasData || actives.data('collapse', null)
      }

      this.$element[dimension](0)
      this.transition('addClass', $.Event('show'), 'shown')
      this.$element[dimension](this.$element[0][scroll])
    }

  , hide: function () {
      var dimension
      if (this.transitioning) return
      dimension = this.dimension()
      this.reset(this.$element[dimension]())
      this.transition('removeClass', $.Event('hide'), 'hidden')
      this.$element[dimension](0)
    }

  , reset: function (size) {
      var dimension = this.dimension()

      this.$element
        .removeClass('collapse')
        [dimension](size || 'auto')
        [0].offsetWidth

      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')

      return this
    }

  , transition: function (method, startEvent, completeEvent) {
      var that = this
        , complete = function () {
            if (startEvent.type == 'show') that.reset()
            that.transitioning = 0
            that.$element.trigger(completeEvent)
          }

      this.$element.trigger(startEvent)

      if (startEvent.isDefaultPrevented()) return

      this.transitioning = 1

      this.$element[method]('in')

      $.support.transition && this.$element.hasClass('collapse') ?
        this.$element.one($.support.transition.end, complete) :
        complete()
    }

  , toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']()
    }

  }


 /* COLLAPSIBLE PLUGIN DEFINITION
  * ============================== */

  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('collapse')
        , options = typeof option == 'object' && option
      if (!data) $this.data('collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.collapse.defaults = {
    toggle: true
  }

  $.fn.collapse.Constructor = Collapse


 /* COLLAPSIBLE DATA-API
  * ==================== */

  $(function () {
    $('body').on('click.collapse.data-api', '[data-toggle=collapse]', function ( e ) {
      var $this = $(this), href
        , target = $this.attr('data-target')
          || e.preventDefault()
          || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
        , option = $(target).data('collapse') ? 'toggle' : $this.data()
      $(target).collapse(option)
    })
  })

}(window.jQuery);
/* ============================================================
 * bootstrap-dropdown.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* DROPDOWN CLASS DEFINITION
  * ========================= */

  var toggle = '[data-toggle="dropdown"]'
    , Dropdown = function (element) {
        var $el = $(element).on('click.dropdown.data-api', this.toggle)
        $('html').on('click.dropdown.data-api', function () {
          $el.parent().removeClass('open')
        })
      }

  Dropdown.prototype = {

    constructor: Dropdown

  , toggle: function (e) {
      var $this = $(this)
        , $parent
        , selector
        , isActive

      if ($this.is('.disabled, :disabled')) return

      selector = $this.attr('data-target')

      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
      }

      $parent = $(selector)
      $parent.length || ($parent = $this.parent())

      isActive = $parent.hasClass('open')

      clearMenus()

      if (!isActive) $parent.toggleClass('open')

      return false
    }

  }

  function clearMenus() {
    $(toggle).parent().removeClass('open')
  }


  /* DROPDOWN PLUGIN DEFINITION
   * ========================== */

  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('dropdown')
      if (!data) $this.data('dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.dropdown.Constructor = Dropdown


  /* APPLY TO STANDARD DROPDOWN ELEMENTS
   * =================================== */

  $(function () {
    $('html').on('click.dropdown.data-api', clearMenus)
    $('body')
      .on('click.dropdown', '.dropdown form', function (e) { e.stopPropagation() })
      .on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle)
  })

}(window.jQuery);
/* =========================================================
 * bootstrap-modal.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#modals
 * =========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

  "use strict"; // jshint ;_;


 /* MODAL CLASS DEFINITION
  * ====================== */

  var Modal = function (content, options) {
    this.options = options
    this.$element = $(content)
      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
  }

  Modal.prototype = {

      constructor: Modal

    , toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']()
      }

    , show: function () {
        var that = this
          , e = $.Event('show')

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        $('body').addClass('modal-open')

        this.isShown = true

        escape.call(this)
        backdrop.call(this, function () {
          var transition = $.support.transition && that.$element.hasClass('fade')

          if (!that.$element.parent().length) {
            that.$element.appendTo(document.body) //don't move modals dom position
          }

          that.$element
            .show()

          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }

          that.$element.addClass('in')

          transition ?
            that.$element.one($.support.transition.end, function () { that.$element.trigger('shown') }) :
            that.$element.trigger('shown')

        })
      }

    , hide: function (e) {
        e && e.preventDefault()

        var that = this

        e = $.Event('hide')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        $('body').removeClass('modal-open')

        escape.call(this)

        this.$element.removeClass('in')

        $.support.transition && this.$element.hasClass('fade') ?
          hideWithTransition.call(this) :
          hideModal.call(this)
      }

  }


 /* MODAL PRIVATE METHODS
  * ===================== */

  function hideWithTransition() {
    var that = this
      , timeout = setTimeout(function () {
          that.$element.off($.support.transition.end)
          hideModal.call(that)
        }, 500)

    this.$element.one($.support.transition.end, function () {
      clearTimeout(timeout)
      hideModal.call(that)
    })
  }

  function hideModal(that) {
    this.$element
      .hide()
      .trigger('hidden')

    backdrop.call(this)
  }

  function backdrop(callback) {
    var that = this
      , animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(document.body)

      if (this.options.backdrop != 'static') {
        this.$backdrop.click($.proxy(this.hide, this))
      }

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      doAnimate ?
        this.$backdrop.one($.support.transition.end, callback) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      $.support.transition && this.$element.hasClass('fade')?
        this.$backdrop.one($.support.transition.end, $.proxy(removeBackdrop, this)) :
        removeBackdrop.call(this)

    } else if (callback) {
      callback()
    }
  }

  function removeBackdrop() {
    this.$backdrop.remove()
    this.$backdrop = null
  }

  function escape() {
    var that = this
    if (this.isShown && this.options.keyboard) {
      $(document).on('keyup.dismiss.modal', function ( e ) {
        e.which == 27 && that.hide()
      })
    } else if (!this.isShown) {
      $(document).off('keyup.dismiss.modal')
    }
  }


 /* MODAL PLUGIN DEFINITION
  * ======================= */

  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('modal')
        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option]()
      else if (options.show) data.show()
    })
  }

  $.fn.modal.defaults = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  $.fn.modal.Constructor = Modal


 /* MODAL DATA-API
  * ============== */

  $(function () {
    $('body').on('click.modal.data-api', '[data-toggle="modal"]', function ( e ) {
      var $this = $(this), href
        , $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
        , option = $target.data('modal') ? 'toggle' : $.extend({}, $target.data(), $this.data())

      e.preventDefault()
      $target.modal(option)
    })
  })

}(window.jQuery);
/* ========================================================
 * bootstrap-tab.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#tabs
 * ========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TAB CLASS DEFINITION
  * ==================== */

  var Tab = function ( element ) {
    this.element = $(element)
  }

  Tab.prototype = {

    constructor: Tab

  , show: function () {
      var $this = this.element
        , $ul = $this.closest('ul:not(.dropdown-menu)')
        , selector = $this.attr('data-target')
        , previous
        , $target
        , e

      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
      }

      if ( $this.parent('li').hasClass('active') ) return

      previous = $ul.find('.active a').last()[0]

      e = $.Event('show', {
        relatedTarget: previous
      })

      $this.trigger(e)

      if (e.isDefaultPrevented()) return

      $target = $(selector)

      this.activate($this.parent('li'), $ul)
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown'
        , relatedTarget: previous
        })
      })
    }

  , activate: function ( element, container, callback) {
      var $active = container.find('> .active')
        , transition = callback
            && $.support.transition
            && $active.hasClass('fade')

      function next() {
        $active
          .removeClass('active')
          .find('> .dropdown-menu > .active')
          .removeClass('active')

        element.addClass('active')

        if (transition) {
          element[0].offsetWidth // reflow for transition
          element.addClass('in')
        } else {
          element.removeClass('fade')
        }

        if ( element.parent('.dropdown-menu') ) {
          element.closest('li.dropdown').addClass('active')
        }

        callback && callback()
      }

      transition ?
        $active.one($.support.transition.end, next) :
        next()

      $active.removeClass('in')
    }
  }


 /* TAB PLUGIN DEFINITION
  * ===================== */

  $.fn.tab = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tab')
      if (!data) $this.data('tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tab.Constructor = Tab


 /* TAB DATA-API
  * ============ */

  $(function () {
    $('body').on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
      e.preventDefault()
      $(this).tab('show')
    })
  })

}(window.jQuery);
/* ===========================================================
 * bootstrap-tooltip.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      if (this.options.trigger != 'manual') {
        eventIn  = this.options.trigger == 'hover' ? 'mouseenter' : 'focus'
        eventOut = this.options.trigger == 'hover' ? 'mouseleave' : 'blur'
        this.$element.on(eventIn, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut, this.options.selector, $.proxy(this.leave, this))
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, options, this.$element.data())

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , inside
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp

      if (this.hasContent() && this.enabled) {
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        inside = /in/.test(placement)

        $tip
          .remove()
          .css({ top: 0, left: 0, display: 'block' })
          .appendTo(inside ? this.$element : document.body)

        pos = this.getPosition(inside)

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (inside ? placement.split(' ')[1] : placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        $tip
          .css(tp)
          .addClass(placement)
          .addClass('in')
      }
    }

  , isHTML: function(text) {
      // html string detection logic adapted from jQuery
      return typeof text != 'string'
        || ( text.charAt(0) === "<"
          && text.charAt( text.length - 1 ) === ">"
          && text.length >= 3
        ) || /^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(text)
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.isHTML(title) ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).remove()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.remove()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.remove()
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').removeAttr('title')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function (inside) {
      return $.extend({}, (inside ? {top: 0, left: 0} : this.$element.offset()), {
        width: this.$element[0].offsetWidth
      , height: this.$element[0].offsetHeight
      })
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function () {
      this[this.tip().hasClass('in') ? 'hide' : 'show']()
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover'
  , title: ''
  , delay: 0
  }

}(window.jQuery);

/* ===========================================================
 * bootstrap-popover.js v2.0.4
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* POPOVER PUBLIC CLASS DEFINITION
  * =============================== */

  var Popover = function ( element, options ) {
    this.init('popover', element, options)
  }


  /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

    constructor: Popover

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()
        , content = this.getContent()

      $tip.find('.popover-title')[this.isHTML(title) ? 'html' : 'text'](title)
      $tip.find('.popover-content > *')[this.isHTML(content) ? 'html' : 'text'](content)

      $tip.removeClass('fade top bottom left right in')
    }

  , hasContent: function () {
      return this.getTitle() || this.getContent()
    }

  , getContent: function () {
      var content
        , $e = this.$element
        , o = this.options

      content = $e.attr('data-content')
        || (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)

      return content
    }

  , tip: function () {
      if (!this.$tip) {
        this.$tip = $(this.options.template)
      }
      return this.$tip
    }

  })


 /* POPOVER PLUGIN DEFINITION
  * ======================= */

  $.fn.popover = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('popover')
        , options = typeof option == 'object' && option
      if (!data) $this.data('popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.popover.Constructor = Popover

  $.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
    placement: 'right'
  , content: ''
  , template: '<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'
  })

}(window.jQuery);
/*!
 * clipboard.js v1.5.15
 * https://zenorocha.github.io/clipboard.js
 *
 * Licensed MIT © Zeno Rocha
 */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.Clipboard=e()}}(function(){var e,t,n;return function e(t,n,i){function o(a,c){if(!n[a]){if(!t[a]){var l="function"==typeof require&&require;if(!c&&l)return l(a,!0);if(r)return r(a,!0);var s=new Error("Cannot find module '"+a+"'");throw s.code="MODULE_NOT_FOUND",s}var u=n[a]={exports:{}};t[a][0].call(u.exports,function(e){var n=t[a][1][e];return o(n?n:e)},u,u.exports,e,t,n,i)}return n[a].exports}for(var r="function"==typeof require&&require,a=0;a<i.length;a++)o(i[a]);return o}({1:[function(e,t,n){function i(e,t){for(;e&&e!==document;){if(e.matches(t))return e;e=e.parentNode}}if(Element&&!Element.prototype.matches){var o=Element.prototype;o.matches=o.matchesSelector||o.mozMatchesSelector||o.msMatchesSelector||o.oMatchesSelector||o.webkitMatchesSelector}t.exports=i},{}],2:[function(e,t,n){function i(e,t,n,i,r){var a=o.apply(this,arguments);return e.addEventListener(n,a,r),{destroy:function(){e.removeEventListener(n,a,r)}}}function o(e,t,n,i){return function(n){n.delegateTarget=r(n.target,t),n.delegateTarget&&i.call(e,n)}}var r=e("./closest");t.exports=i},{"./closest":1}],3:[function(e,t,n){n.node=function(e){return void 0!==e&&e instanceof HTMLElement&&1===e.nodeType},n.nodeList=function(e){var t=Object.prototype.toString.call(e);return void 0!==e&&("[object NodeList]"===t||"[object HTMLCollection]"===t)&&"length"in e&&(0===e.length||n.node(e[0]))},n.string=function(e){return"string"==typeof e||e instanceof String},n.fn=function(e){var t=Object.prototype.toString.call(e);return"[object Function]"===t}},{}],4:[function(e,t,n){function i(e,t,n){if(!e&&!t&&!n)throw new Error("Missing required arguments");if(!c.string(t))throw new TypeError("Second argument must be a String");if(!c.fn(n))throw new TypeError("Third argument must be a Function");if(c.node(e))return o(e,t,n);if(c.nodeList(e))return r(e,t,n);if(c.string(e))return a(e,t,n);throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")}function o(e,t,n){return e.addEventListener(t,n),{destroy:function(){e.removeEventListener(t,n)}}}function r(e,t,n){return Array.prototype.forEach.call(e,function(e){e.addEventListener(t,n)}),{destroy:function(){Array.prototype.forEach.call(e,function(e){e.removeEventListener(t,n)})}}}function a(e,t,n){return l(document.body,e,t,n)}var c=e("./is"),l=e("delegate");t.exports=i},{"./is":3,delegate:2}],5:[function(e,t,n){function i(e){var t;if("SELECT"===e.nodeName)e.focus(),t=e.value;else if("INPUT"===e.nodeName||"TEXTAREA"===e.nodeName)e.focus(),e.setSelectionRange(0,e.value.length),t=e.value;else{e.hasAttribute("contenteditable")&&e.focus();var n=window.getSelection(),i=document.createRange();i.selectNodeContents(e),n.removeAllRanges(),n.addRange(i),t=n.toString()}return t}t.exports=i},{}],6:[function(e,t,n){function i(){}i.prototype={on:function(e,t,n){var i=this.e||(this.e={});return(i[e]||(i[e]=[])).push({fn:t,ctx:n}),this},once:function(e,t,n){function i(){o.off(e,i),t.apply(n,arguments)}var o=this;return i._=t,this.on(e,i,n)},emit:function(e){var t=[].slice.call(arguments,1),n=((this.e||(this.e={}))[e]||[]).slice(),i=0,o=n.length;for(i;i<o;i++)n[i].fn.apply(n[i].ctx,t);return this},off:function(e,t){var n=this.e||(this.e={}),i=n[e],o=[];if(i&&t)for(var r=0,a=i.length;r<a;r++)i[r].fn!==t&&i[r].fn._!==t&&o.push(i[r]);return o.length?n[e]=o:delete n[e],this}},t.exports=i},{}],7:[function(t,n,i){!function(o,r){if("function"==typeof e&&e.amd)e(["module","select"],r);else if("undefined"!=typeof i)r(n,t("select"));else{var a={exports:{}};r(a,o.select),o.clipboardAction=a.exports}}(this,function(e,t){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var o=n(t),r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),c=function(){function e(t){i(this,e),this.resolveOptions(t),this.initSelection()}return a(e,[{key:"resolveOptions",value:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action=t.action,this.emitter=t.emitter,this.target=t.target,this.text=t.text,this.trigger=t.trigger,this.selectedText=""}},{key:"initSelection",value:function e(){this.text?this.selectFake():this.target&&this.selectTarget()}},{key:"selectFake",value:function e(){var t=this,n="rtl"==document.documentElement.getAttribute("dir");this.removeFake(),this.fakeHandlerCallback=function(){return t.removeFake()},this.fakeHandler=document.body.addEventListener("click",this.fakeHandlerCallback)||!0,this.fakeElem=document.createElement("textarea"),this.fakeElem.style.fontSize="12pt",this.fakeElem.style.border="0",this.fakeElem.style.padding="0",this.fakeElem.style.margin="0",this.fakeElem.style.position="absolute",this.fakeElem.style[n?"right":"left"]="-9999px";var i=window.pageYOffset||document.documentElement.scrollTop;this.fakeElem.addEventListener("focus",window.scrollTo(0,i)),this.fakeElem.style.top=i+"px",this.fakeElem.setAttribute("readonly",""),this.fakeElem.value=this.text,document.body.appendChild(this.fakeElem),this.selectedText=(0,o.default)(this.fakeElem),this.copyText()}},{key:"removeFake",value:function e(){this.fakeHandler&&(document.body.removeEventListener("click",this.fakeHandlerCallback),this.fakeHandler=null,this.fakeHandlerCallback=null),this.fakeElem&&(document.body.removeChild(this.fakeElem),this.fakeElem=null)}},{key:"selectTarget",value:function e(){this.selectedText=(0,o.default)(this.target),this.copyText()}},{key:"copyText",value:function e(){var t=void 0;try{t=document.execCommand(this.action)}catch(e){t=!1}this.handleResult(t)}},{key:"handleResult",value:function e(t){this.emitter.emit(t?"success":"error",{action:this.action,text:this.selectedText,trigger:this.trigger,clearSelection:this.clearSelection.bind(this)})}},{key:"clearSelection",value:function e(){this.target&&this.target.blur(),window.getSelection().removeAllRanges()}},{key:"destroy",value:function e(){this.removeFake()}},{key:"action",set:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"copy";if(this._action=t,"copy"!==this._action&&"cut"!==this._action)throw new Error('Invalid "action" value, use either "copy" or "cut"')},get:function e(){return this._action}},{key:"target",set:function e(t){if(void 0!==t){if(!t||"object"!==("undefined"==typeof t?"undefined":r(t))||1!==t.nodeType)throw new Error('Invalid "target" value, use a valid Element');if("copy"===this.action&&t.hasAttribute("disabled"))throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');if("cut"===this.action&&(t.hasAttribute("readonly")||t.hasAttribute("disabled")))throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');this._target=t}},get:function e(){return this._target}}]),e}();e.exports=c})},{select:5}],8:[function(t,n,i){!function(o,r){if("function"==typeof e&&e.amd)e(["module","./clipboard-action","tiny-emitter","good-listener"],r);else if("undefined"!=typeof i)r(n,t("./clipboard-action"),t("tiny-emitter"),t("good-listener"));else{var a={exports:{}};r(a,o.clipboardAction,o.tinyEmitter,o.goodListener),o.clipboard=a.exports}}(this,function(e,t,n,i){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function c(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function l(e,t){var n="data-clipboard-"+e;if(t.hasAttribute(n))return t.getAttribute(n)}var s=o(t),u=o(n),f=o(i),d=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),h=function(e){function t(e,n){r(this,t);var i=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return i.resolveOptions(n),i.listenClick(e),i}return c(t,e),d(t,[{key:"resolveOptions",value:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action="function"==typeof t.action?t.action:this.defaultAction,this.target="function"==typeof t.target?t.target:this.defaultTarget,this.text="function"==typeof t.text?t.text:this.defaultText}},{key:"listenClick",value:function e(t){var n=this;this.listener=(0,f.default)(t,"click",function(e){return n.onClick(e)})}},{key:"onClick",value:function e(t){var n=t.delegateTarget||t.currentTarget;this.clipboardAction&&(this.clipboardAction=null),this.clipboardAction=new s.default({action:this.action(n),target:this.target(n),text:this.text(n),trigger:n,emitter:this})}},{key:"defaultAction",value:function e(t){return l("action",t)}},{key:"defaultTarget",value:function e(t){var n=l("target",t);if(n)return document.querySelector(n)}},{key:"defaultText",value:function e(t){return l("text",t)}},{key:"destroy",value:function e(){this.listener.destroy(),this.clipboardAction&&(this.clipboardAction.destroy(),this.clipboardAction=null)}}]),t}(u.default);e.exports=h})},{"./clipboard-action":7,"good-listener":4,"tiny-emitter":6}]},{},[8])(8)});
// This comes from a fork of the original: https://github.com/Swizec/stickyfill
// Changes have been submitted upstream, but as of 19.2.2015 hadn't been merged yet

(function(doc, _win) {
    var watchArray = [],
        boundingElements = [{node: _win}],
        initialized = false,
        html = doc.documentElement,
        noop = function() {},
        checkTimer,

        //visibility API strings
        hiddenPropertyName = 'hidden',
        visibilityChangeEventName = 'visibilitychange';

    // This fixes an issue in Chrome on Mac Retina screens
    // sticky elements have to be forcefully redrawn,
    // otherwise they are there, but invisible
    function forceRedraw(el) {
        var display = el.node.style.display;
        el.node.style.display = 'none';
        el.node.offsetHeight; // this is important
        el.node.style.display = display;
    }

    //fallback to prefixed names in old webkit browsers
    if (doc.webkitHidden !== undefined) {
        hiddenPropertyName = 'webkitHidden';
        visibilityChangeEventName = 'webkitvisibilitychange';
    }

    //test getComputedStyle
    if (!getComputedStyle) {
        seppuku();
    }

    //test for native support
    var prefixes = ['', '-webkit-', '-moz-', '-ms-'],
        block = document.createElement('div');

    for (var i = prefixes.length - 1; i >= 0; i--) {
        try {
            block.style.position = prefixes[i] + 'sticky';
        }
        catch(e) {}
        if (block.style.position != '') {
            seppuku();
        }
    }

    updateScrollPos();

    //commit seppuku!
    function seppuku() {
        init = add = rebuild = pause = stop = kill = noop;
    }

    function mergeObjects(targetObj, sourceObject) {
        for (var key in sourceObject) {
            if (sourceObject.hasOwnProperty(key)) {
                targetObj[key] = sourceObject[key];
            }
        }
    }

    function parseNumeric(val) {
        return parseFloat(val) || 0;
    }

    function getOffset(el) {
        return {top: el.pageYOffset || el.scrollTop || 0,
                left: el.pageXOffset || el.scrollLeft || 0};
    }

    function updateScrollPos() {
        boundingElements = boundingElements.map(function (el) {
            el.scroll = getOffset(el.node);
            return el;
        });
    }

    function getBoundingElement(el) {
        return boundingElements.filter(function (b) {
            return b.node === el;
        })[0];
    }

    function onScroll(event) {
        var el = event.currentTarget,
            cached = getBoundingElement(el);

        if (getOffset(el).left != cached.scroll.left) {
            updateScrollPos();
            rebuild();
            return;
        }
        
        if (getOffset(el).top != cached.scroll.top) {
            updateScrollPos();
            recalcAllPos();
        }

        watchArray.forEach(forceRedraw);
    }

    //fixes flickering
    function onWheel(event) {
        var el = event.currentTarget,
            cached = getBoundingElement(el);

        setTimeout(function() {
            if (getOffset(el).top != cached.scroll.top) {
                cached.scroll.top = getOffset(el).top;
                recalcAllPos();
            }
        }, 0);
    }

    function recalcAllPos() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            recalcElementPos(watchArray[i]);
        }
    }

    function getBoundingBox(node) {
        if (node === window) {
            return {
                top: 0,
                left: 0,
                bottom: 0,
                width: window.innerWidth || window.clientWidth,
                height: window.innerHeight || window.clientHeight
            };
        }else{
            return node.getBoundingClientRect();
        }
    }

    function recalcElementPos(el) {
        if (!el.inited) return;

        var boundingElement = findBoundingElement(el.node),
            edge = boundingElement.scroll.top+getBoundingBox(boundingElement.node).top;

        var currentMode = (edge <= el.limit.start? 0: edge >= el.limit.end? 2: 1);

        if (el.mode != currentMode) {
            switchElementMode(el, currentMode);
        }
    }

    //checks whether stickies start or stop positions have changed
    function fastCheck() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (!watchArray[i].inited) continue;

            var deltaTop = Math.abs(getDocOffsetTop(watchArray[i].clone) - watchArray[i].docOffsetTop),
                deltaHeight = Math.abs(watchArray[i].parent.node.offsetHeight - watchArray[i].parent.height);

            if (deltaTop >= 2 || deltaHeight >= 2) return false;
        }
        return true;
    }

    function initElement(el) {
        if (isNaN(parseFloat(el.computed.top)) || el.isCell) return;

        el.inited = true;

        if (!el.clone) clone(el);
        if (el.parent.computed.position != 'absolute' &&
            el.parent.computed.position != 'relative') el.parent.node.style.position = 'relative';

        recalcElementPos(el);

        el.parent.height = el.parent.node.offsetHeight;
        el.docOffsetTop = getDocOffsetTop(el.clone);
    }

    function deinitElement(el) {
        var deinitParent = true;

        el.clone && killClone(el);
        mergeObjects(el.node.style, el.css);

        //check whether element's parent is used by other stickies
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (watchArray[i].node !== el.node && watchArray[i].parent.node === el.parent.node) {
                deinitParent = false;
                break;
            }
        };

        if (deinitParent) el.parent.node.style.position = el.parent.css.position;
        el.mode = -1;
    }

    function initAll() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            initElement(watchArray[i]);
        }
    }

    function deinitAll() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            deinitElement(watchArray[i]);
        }
    }

    function switchElementMode(el, mode) {
        var nodeStyle = el.node.style,
            winBounds = getBoundingBox(findBoundingElement(el.node).node);

        switch (mode) {
            case 0:
                nodeStyle.position = 'absolute';
                nodeStyle.left = el.offset.left + 'px';
                nodeStyle.right = el.offset.right + 'px';
                nodeStyle.top = el.offset.top + 'px';
                nodeStyle.bottom = 'auto';
                nodeStyle.width = 'auto';
                nodeStyle.marginLeft = 0;
                nodeStyle.marginRight = 0;
                nodeStyle.marginTop = 0;
                break;

            case 1:
                nodeStyle.position = 'fixed';
                nodeStyle.left = el.box.left + 'px';
                nodeStyle.right = el.box.right + 'px';
                nodeStyle.top = el.numeric.top + winBounds.top + 'px';
                nodeStyle.bottom = 'auto';
                nodeStyle.width = el.computed.width;
                nodeStyle.marginLeft = 0;
                nodeStyle.marginRight = 0;
                nodeStyle.marginTop = 0;
                break;

            case 2:
                nodeStyle.position = 'absolute';
                nodeStyle.left = el.offset.left + 'px';
                nodeStyle.right = el.offset.right + 'px';
                nodeStyle.top = 'auto';
                nodeStyle.bottom = 0;
                nodeStyle.width = 'auto';
                nodeStyle.marginLeft = 0;
                nodeStyle.marginRight = 0;
                break;
        }

        el.mode = mode;
    }

    function clone(el) {
        el.clone = document.createElement('div');

        var refElement = el.node.nextSibling || el.node,
            cloneStyle = el.clone.style;

        cloneStyle.height = el.height + 'px';
        cloneStyle.width = el.width + 'px';
        cloneStyle.marginTop = el.computed.marginTop;
        cloneStyle.marginBottom = el.computed.marginBottom;
        cloneStyle.marginLeft = el.computed.marginLeft;
        cloneStyle.marginRight = el.computed.marginRight;
        cloneStyle.padding = cloneStyle.border = cloneStyle.borderSpacing = 0;
        cloneStyle.fontSize = '1em';
        cloneStyle.position = 'static';
        cloneStyle.cssFloat = el.computed.cssFloat;

        el.node.parentNode.insertBefore(el.clone, refElement);
    }

    function killClone(el) {
        el.clone.parentNode.removeChild(el.clone);
        el.clone = undefined;
    }

    function findBoundingElement(node) {
        if (node == document) {
            node = window;
        }

        var el;
        
        for (var i = 0; i < boundingElements.length; i++) {
            el = boundingElements[i];

            if (el.node == node) {
                return el;
            }
        }
        
        return findBoundingElement(node.parentNode);
    }

    function getElementParams(node) {
        var computedStyle = getComputedStyle(node),
            parentNode = node.parentNode,
            parentComputedStyle = getComputedStyle(parentNode),
            cachedPosition = node.style.position,
            boundingElement = findBoundingElement(node),
            boundingOffset = getOffset(boundingElement.node);

        node.style.position = 'relative';

        var computed = {
                top: computedStyle.top,
                width: computedStyle.width,
                marginTop: computedStyle.marginTop,
                marginBottom: computedStyle.marginBottom,
                marginLeft: computedStyle.marginLeft,
                marginRight: computedStyle.marginRight,
                cssFloat: computedStyle.cssFloat
            },
            numeric = {
                top: parseNumeric(computedStyle.top),
                marginBottom: parseNumeric(computedStyle.marginBottom),
                paddingLeft: parseNumeric(computedStyle.paddingLeft),
                paddingRight: parseNumeric(computedStyle.paddingRight),
                borderLeftWidth: parseNumeric(computedStyle.borderLeftWidth),
                borderRightWidth: parseNumeric(computedStyle.borderRightWidth)
            };

        node.style.position = cachedPosition;

        var css = {
                position: node.style.position,
                top: node.style.top,
                bottom: node.style.bottom,
                left: node.style.left,
                right: node.style.right,
                width: node.style.width,
                marginTop: node.style.marginTop,
                marginLeft: node.style.marginLeft,
                marginRight: node.style.marginRight
            },
            nodeOffset = getElementOffset(node),
            parentOffset = getElementOffset(parentNode),
            
            parent = {
                node: parentNode,
                css: {
                    position: parentNode.style.position
                },
                computed: {
                    position: parentComputedStyle.position
                },
                numeric: {
                    borderLeftWidth: parseNumeric(parentComputedStyle.borderLeftWidth),
                    borderRightWidth: parseNumeric(parentComputedStyle.borderRightWidth),
                    borderTopWidth: parseNumeric(parentComputedStyle.borderTopWidth),
                    borderBottomWidth: parseNumeric(parentComputedStyle.borderBottomWidth)
                }
            },        

            el = {
                node: node,
                box: {
                    left: nodeOffset.win.left,
                    right: html.clientWidth - nodeOffset.win.right
                },
                offset: {
                    top: nodeOffset.win.top - parentOffset.win.top - parent.numeric.borderTopWidth,
                    left: nodeOffset.win.left - parentOffset.win.left - parent.numeric.borderLeftWidth,
                    right: -nodeOffset.win.right + parentOffset.win.right - parent.numeric.borderRightWidth
                },
                css: css,
                isCell: computedStyle.display == 'table-cell',
                computed: computed,
                numeric: numeric,
                width: nodeOffset.win.right - nodeOffset.win.left,
                height: nodeOffset.win.bottom - nodeOffset.win.top,
                mode: -1,
                inited: false,
                parent: parent,
                limit: {
                    start: nodeOffset.doc.top - numeric.top + boundingOffset.top,
                    end: parentOffset.doc.top + parentNode.offsetHeight - parent.numeric.borderBottomWidth -
                        node.offsetHeight - numeric.top - numeric.marginBottom + boundingOffset.top
                }
            };

        return el;
    }

    function getDocOffsetTop(node) {
        var docOffsetTop = 0, 
            boundingBox = {top: 0};

        while (node) {
            docOffsetTop += node.offsetTop;
            node = node.offsetParent;
        }

        if (node) {
            boundingBox = getBoundingBox(findBoundingElement(node).node);
        }

        return docOffsetTop+boundingBox.top;
    }

    function getElementOffset(node) {
        var box = getBoundingBox(node);

        return {
            doc: {
                top: box.top + getOffset(node).top,
                left: box.left + getOffset(node).left
            },
            win: box
        };
    }

    function startFastCheckTimer() {
        checkTimer = setInterval(function() {
            !fastCheck() && rebuild();
        }, 500);
    }

    function stopFastCheckTimer() {
        clearInterval(checkTimer);
    }

    function handlePageVisibilityChange() {
        if (!initialized) return;

        if (document[hiddenPropertyName]) {
            stopFastCheckTimer();
        }
        else {
            startFastCheckTimer();
        }
    }

    function init() {
        if (initialized) return;

        updateScrollPos();
        initAll();

        boundingElements.map(function (el) {
            el.node.addEventListener('scroll', onScroll);
            el.node.addEventListener('wheel', onWheel);
            
            //watch for width changes
            el.node.addEventListener('resize', rebuild);
            el.node.addEventListener('orientationchange', rebuild);
        });

        //watch for page visibility
        doc.addEventListener(visibilityChangeEventName, handlePageVisibilityChange);

        startFastCheckTimer();

        initialized = true;
    }

    function rebuild() {
        if (!initialized) return;

        deinitAll();
        
        for (var i = watchArray.length - 1; i >= 0; i--) {
            watchArray[i] = getElementParams(watchArray[i].node);
        }

        initAll();
    }

    function pause() {
        boundingElements.map(function (el) {
            el.node.removeEventListener('scroll', onScroll);
            el.node.removeEventListener('wheel', onWheel);
            el.node.removeEventListener('resize', rebuild);
            el.node.removeEventListener('orientationchange', rebuild);
        });
        doc.removeEventListener(visibilityChangeEventName, handlePageVisibilityChange);

        stopFastCheckTimer();

        initialized = false;
    }

    function stop() {
        pause();
        deinitAll(); 
    }

    function kill() {
        stop();

        //empty the array without loosing the references,
        //the most performant method according to http://jsperf.com/empty-javascript-array
        while (watchArray.length) {
            watchArray.pop();
        }
    }

    function isOverflown(node) {
        var computed = getComputedStyle(node),
            overflows = ["auto", "scroll"];


        return ["overflow", "overflow-y", "overflow-x"]
            .map(function (key) {
                return overflows.indexOf(computed[key]) > -1;
            })
            .indexOf(true) > -1;
    }

    function addBoundingElements(node) {
        var parent = node.parentNode;

        while (parent != document) {            
            if (isOverflown(parent)) {
                // only add once
                for (var i = 0; i < boundingElements.length; i++) {
                    if (boundingElements[i].node === parent) return;
                }

                boundingElements.push({node: parent,
                                       scroll: getOffset(parent)});
            }

            parent = parent.parentNode;
        }
    }

    function add(node) {
        //check if Stickyfill is already applied to the node
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (watchArray[i].node === node) return;
        };

        var el = getElementParams(node);

        watchArray.push(el);
        addBoundingElements(node);

        if (!initialized) {
            init();
        }
        else {
            initElement(el);
        }
    }

    function remove(node) {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (watchArray[i].node === node) {
                deinitElement(watchArray[i]);
                watchArray.splice(i, 1);
            }
        };
    }

    //expose Stickyfill
    _win.Stickyfill = {
        stickies: watchArray,
        add: add,
        remove: remove,
        init: init,
        rebuild: rebuild,
        pause: pause,
        stop: stop,
        kill: kill
    };
})(document, window);


//if jQuery is available -- create a plugin
if (window.jQuery) {
    (function($) {
        $.fn.Stickyfill = function(options) {
            this.each(function() {
                Stickyfill.add(this);
            });

            return this;
        };
    })(window.jQuery);
}

/* mousetrap v1.5.3 craig.is/killing/mice */
(function(C,r,g){function t(a,b,h){a.addEventListener?a.addEventListener(b,h,!1):a.attachEvent("on"+b,h)}function x(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return l[a.which]?l[a.which]:p[a.which]?p[a.which]:String.fromCharCode(a.which).toLowerCase()}function D(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function u(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function y(a,b){var h,c,e,g=[];h=a;"+"===h?h=["+"]:(h=h.replace(/\+{2}/g,"+plus"),h=h.split("+"));for(e=0;e<h.length;++e)c=h[e],z[c]&&(c=z[c]),b&&"keypress"!=b&&A[c]&&(c=A[c],g.push("shift")),u(c)&&g.push(c);h=c;e=b;if(!e){if(!k){k={};for(var m in l)95<m&&112>m||l.hasOwnProperty(m)&&(k[l[m]]=m)}e=k[h]?"keydown":"keypress"}"keypress"==e&&g.length&&(e="keydown");return{key:c,modifiers:g,action:e}}function B(a,b){return null===a||a===r?!1:a===b?!0:B(a.parentNode,b)}function c(a){function b(a){a=
a||{};var b=!1,n;for(n in q)a[n]?b=!0:q[n]=0;b||(v=!1)}function h(a,b,n,f,c,h){var g,e,l=[],m=n.type;if(!d._callbacks[a])return[];"keyup"==m&&u(a)&&(b=[a]);for(g=0;g<d._callbacks[a].length;++g)if(e=d._callbacks[a][g],(f||!e.seq||q[e.seq]==e.level)&&m==e.action){var k;(k="keypress"==m&&!n.metaKey&&!n.ctrlKey)||(k=e.modifiers,k=b.sort().join(",")===k.sort().join(","));k&&(k=f&&e.seq==f&&e.level==h,(!f&&e.combo==c||k)&&d._callbacks[a].splice(g,1),l.push(e))}return l}function g(a,b,n,f){d.stopCallback(b,
b.target||b.srcElement,n,f)||!1!==a(b,n)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=x(a);b&&("keyup"==a.type&&w===b?w=!1:d.handleKey(b,D(a),a))}function l(a,c,n,f){function e(c){return function(){v=c;++q[a];clearTimeout(k);k=setTimeout(b,1E3)}}function h(c){g(n,c,a);"keyup"!==f&&(w=x(c));setTimeout(b,10)}for(var d=q[a]=0;d<c.length;++d){var p=d+1===c.length?h:e(f||
y(c[d+1]).action);m(c[d],p,f,a,d)}}function m(a,b,c,f,e){d._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var g=a.split(" ");1<g.length?l(a,g,b,c):(c=y(a,c),d._callbacks[c.key]=d._callbacks[c.key]||[],h(c.key,c.modifiers,{type:c.action},f,a,e),d._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:e,combo:a}))}var d=this;a=a||r;if(!(d instanceof c))return new c(a);d.target=a;d._callbacks={};d._directMap={};var q={},k,w=!1,p=!1,v=!1;d._handleKey=function(a,
c,e){var f=h(a,c,e),d;c={};var k=0,l=!1;for(d=0;d<f.length;++d)f[d].seq&&(k=Math.max(k,f[d].level));for(d=0;d<f.length;++d)f[d].seq?f[d].level==k&&(l=!0,c[f[d].seq]=1,g(f[d].callback,e,f[d].combo,f[d].seq)):l||g(f[d].callback,e,f[d].combo);f="keypress"==e.type&&p;e.type!=v||u(a)||f||b(c);p=l&&"keydown"==e.type};d._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)m(a[d],b,c)};t(a,"keypress",e);t(a,"keydown",e);t(a,"keyup",e)}var l={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",18:"alt",
20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},p={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},A={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},z={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},k;for(g=1;20>g;++g)l[111+g]="f"+g;for(g=0;9>=g;++g)l[g+96]=g;c.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};c.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};c.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};c.prototype.reset=function(){this._callbacks={};this._directMap=
{};return this};c.prototype.stopCallback=function(a,b){return-1<(" "+b.className+" ").indexOf(" mousetrap ")||B(b,this.target)?!1:"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};c.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};c.init=function(){var a=c(r),b;for(b in a)"_"!==b.charAt(0)&&(c[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};c.init();C.Mousetrap=c;"undefined"!==typeof module&&module.exports&&(module.exports=
c);"function"===typeof define&&define.amd&&define(function(){return c})})(window,document);

/*! Quill Editor v0.20.1
 *  https://quilljs.com/
 *  Copyright (c) 2014, Jason Chen
 *  Copyright (c) 2013, salesforce.com
 */
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.Quill=a()}}(function(){var a;return function b(a,c,d){function e(g,h){if(!c[g]){if(!a[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};a[g][0].call(k.exports,function(b){var c=a[g][1][b];return e(c?c:b)},k,k.exports,b,a,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(b,c,d){(function(b){(function(){function e(a,b,c){for(var d=a.length,e=c?d:-1;c?e--:++e<d;)if(b(a[e],e,a))return e;return-1}function f(a,b,c){if(b!==b)return i(a,c);for(var d=c-1,e=a.length;++d<e;)if(a[d]===b)return d;return-1}function g(a){return"function"==typeof a||!1}function h(a){return"string"==typeof a?a:null==a?"":a+""}function i(a,b,c){for(var d=a.length,e=b+(c?0:-1);c?e--:++e<d;){var f=a[e];if(f!==f)return e}return-1}function j(a){return!!a&&"object"==typeof a}function k(a,b){for(var c=-1,d=a.length,e=-1,f=[];++c<d;)a[c]===b&&(a[c]=zb,f[++e]=c);return f}function l(){}function m(){}function n(a){this.__wrapped__=a,this.__actions__=null,this.__dir__=1,this.__dropCount__=0,this.__filtered__=!1,this.__iteratees__=null,this.__takeCount__=Jc,this.__views__=null}function o(a){var b=a?a.length:0;for(this.data={hash:Dc(null),set:new zc};b--;)this.push(a[b])}function p(a,b){var c=a.data,d="string"==typeof b||Xa(b)?c.set.has(b):c.hash[b];return d?0:-1}function q(a){var b=this.data;"string"==typeof a||Xa(a)?b.set.add(a):b.hash[a]=!0}function r(a,b){var c=-1,d=a.length;for(b||(b=Array(d));++c<d;)b[c]=a[c];return b}function s(a,b){for(var c=-1,d=a.length;++c<d&&b(a[c],c,a)!==!1;);return a}function t(a,b){for(var c=-1,d=a.length;++c<d;)if(!b(a[c],c,a))return!1;return!0}function u(a,b){for(var c=-1,d=a.length,e=Array(d);++c<d;)e[c]=b(a[c],c,a);return e}function v(a,b,c,d){var e=-1,f=a.length;for(d&&f&&(c=a[++e]);++e<f;)c=b(c,a[e],e,a);return c}function w(a,b){for(var c=-1,d=a.length;++c<d;)if(b(a[c],c,a))return!0;return!1}function x(a,b){return a===lb?b:a}function y(a,b,c){for(var d=-1,e=od(b),f=e.length;++d<f;){var g=e[d],h=a[g],i=c(h,b[g],g,a,b);(i===i?i===h:h!==h)&&(h!==lb||g in a)||(a[g]=i)}return a}function z(a,b){return null==b?a:A(b,od(b),a)}function A(a,b,c){c||(c={});for(var d=-1,e=b.length;++d<e;){var f=b[d];c[f]=a[f]}return c}function B(a,b,c){var d=typeof a;return"function"==d?b===lb?a:Y(a,b,c):null==a?gb:"object"==d?P(a):b===lb?jb(a):Q(a,b)}function C(a,b,c,d,e,f,g){var h;if(c&&(h=e?c(a,d,e):c(a)),h!==lb)return h;if(!Xa(a))return a;var i=jd(a);if(i){if(h=va(a),!b)return r(a,h)}else{var j=tc.call(a),k=j==Fb;if(j!=Ib&&j!=Ab&&(!k||e))return fc[j]?xa(a,j,b):e?a:{};if(h=wa(k?{}:a),!b)return z(h,a)}f||(f=[]),g||(g=[]);for(var l=f.length;l--;)if(f[l]==a)return g[l];return f.push(a),g.push(h),(i?s:J)(a,function(d,e){h[e]=C(d,b,c,e,a,f,g)}),h}function D(a,b,c){if("function"!=typeof a)throw new TypeError(yb);return setTimeout(function(){a.apply(lb,c)},b)}function E(a,b){var c=a?a.length:0,d=[];if(!c)return d;var e=-1,g=sa(),h=g==f,i=h&&b.length>=200?Wc(b):null,j=b.length;i&&(g=p,h=!1,b=i);a:for(;++e<c;){var k=a[e];if(h&&k===k){for(var l=j;l--;)if(b[l]===k)continue a;d.push(k)}else g(b,k,0)<0&&d.push(k)}return d}function F(a,b){var c=!0;return Tc(a,function(a,d,e){return c=!!b(a,d,e)}),c}function G(a,b,c,d){var e;return c(a,function(a,c,f){return b(a,c,f)?(e=d?c:a,!1):void 0}),e}function H(a,b,c){for(var d=-1,e=a.length,f=-1,g=[];++d<e;){var h=a[d];if(j(h)&&za(h)&&(c||jd(h)||Ua(h))){b&&(h=H(h,b,c));for(var i=-1,k=h.length;++i<k;)g[++f]=h[i]}else c||(g[++f]=h)}return g}function I(a,b){return Uc(a,b,ab)}function J(a,b){return Uc(a,b,od)}function K(a,b,c){if(null!=a){c!==lb&&c in Ma(a)&&(b=[c]);for(var d=0,e=b.length;null!=a&&e>d;)a=a[b[d++]];return d&&d==e?a:lb}}function L(a,b,c,d,e,f){return a===b?!0:null==a||null==b||!Xa(a)&&!j(b)?a!==a&&b!==b:M(a,b,L,c,d,e,f)}function M(a,b,c,d,e,f,g){var h=jd(a),i=jd(b),j=Bb,k=Bb;h||(j=tc.call(a),j==Ab?j=Ib:j!=Ib&&(h=_a(a))),i||(k=tc.call(b),k==Ab?k=Ib:k!=Ib&&(i=_a(b)));var l=j==Ib,m=k==Ib,n=j==k;if(n&&!h&&!l)return oa(a,b,j);if(!e){var o=l&&rc.call(a,"__wrapped__"),p=m&&rc.call(b,"__wrapped__");if(o||p)return c(o?a.value():a,p?b.value():b,d,e,f,g)}if(!n)return!1;f||(f=[]),g||(g=[]);for(var q=f.length;q--;)if(f[q]==a)return g[q]==b;f.push(a),g.push(b);var r=(h?na:pa)(a,b,c,d,e,f,g);return f.pop(),g.pop(),r}function N(a,b,c){var d=b.length,e=d,f=!c;if(null==a)return!e;for(a=Ma(a);d--;){var g=b[d];if(f&&g[2]?g[1]!==a[g[0]]:!(g[0]in a))return!1}for(;++d<e;){g=b[d];var h=g[0],i=a[h],j=g[1];if(f&&g[2]){if(i===lb&&!(h in a))return!1}else{var k=c?c(i,j,h):lb;if(!(k===lb?L(j,i,c,!0):k))return!1}}return!0}function O(a,b){var c=-1,d=za(a)?Array(a.length):[];return Tc(a,function(a,e,f){d[++c]=b(a,e,f)}),d}function P(a){var b=ta(a);if(1==b.length&&b[0][2]){var c=b[0][0],d=b[0][1];return function(a){return null==a?!1:a[c]===d&&(d!==lb||c in Ma(a))}}return function(a){return N(a,b)}}function Q(a,b){var c=jd(a),d=Ca(a)&&Fa(b),e=a+"";return a=Na(a),function(f){if(null==f)return!1;var g=e;if(f=Ma(f),(c||!d)&&!(g in f)){if(f=1==a.length?f:K(f,U(a,0,-1)),null==f)return!1;g=Pa(a),f=Ma(f)}return f[g]===b?b!==lb||g in f:L(b,f[g],lb,!0)}}function R(a){return function(b){return null==b?lb:b[a]}}function S(a){var b=a+"";return a=Na(a),function(c){return K(c,a,b)}}function T(a,b,c,d,e){return e(a,function(a,e,f){c=d?(d=!1,a):b(c,a,e,f)}),c}function U(a,b,c){var d=-1,e=a.length;b=null==b?0:+b||0,0>b&&(b=-b>e?0:e+b),c=c===lb||c>e?e:+c||0,0>c&&(c+=e),e=b>c?0:c-b>>>0,b>>>=0;for(var f=Array(e);++d<e;)f[d]=a[d+b];return f}function V(a,b){for(var c=-1,d=b.length,e=Array(d);++c<d;)e[c]=a[b[c]];return e}function W(a,b,c){var d=0,e=a?a.length:d;if("number"==typeof b&&b===b&&Mc>=e){for(;e>d;){var f=d+e>>>1,g=a[f];(c?b>=g:b>g)&&null!==g?d=f+1:e=f}return e}return X(a,b,gb,c)}function X(a,b,c,d){b=c(b);for(var e=0,f=a?a.length:0,g=b!==b,h=null===b,i=b===lb;f>e;){var j=xc((e+f)/2),k=c(a[j]),l=k!==lb,m=k===k;if(g)var n=m||d;else n=h?m&&l&&(d||null!=k):i?m&&(d||l):null==k?!1:d?b>=k:b>k;n?e=j+1:f=j}return Hc(f,Lc)}function Y(a,b,c){if("function"!=typeof a)return gb;if(b===lb)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 3:return function(c,d,e){return a.call(b,c,d,e)};case 4:return function(c,d,e,f){return a.call(b,c,d,e,f)};case 5:return function(c,d,e,f,g){return a.call(b,c,d,e,f,g)}}return function(){return a.apply(b,arguments)}}function Z(a){return wc.call(a,0)}function $(a,b,c){for(var d=c.length,e=-1,f=Gc(a.length-d,0),g=-1,h=b.length,i=Array(f+h);++g<h;)i[g]=b[g];for(;++e<d;)i[c[e]]=a[e];for(;f--;)i[g++]=a[e++];return i}function _(a,b,c){for(var d=-1,e=c.length,f=-1,g=Gc(a.length-e,0),h=-1,i=b.length,j=Array(g+i);++f<g;)j[f]=a[f];for(var k=f;++h<i;)j[k+h]=b[h];for(;++d<e;)j[k+c[d]]=a[f++];return j}function aa(a,b){return function(c,d,e){var f=b?b():{};if(d=qa(d,e,3),jd(c))for(var g=-1,h=c.length;++g<h;){var i=c[g];a(f,i,d(i,g,c),c)}else Tc(c,function(b,c,e){a(f,b,d(b,c,e),e)});return f}}function ba(a){return Sa(function(b,c){var d=-1,e=null==b?0:c.length,f=e>2?c[e-2]:lb,g=e>2?c[2]:lb,h=e>1?c[e-1]:lb;for("function"==typeof f?(f=Y(f,h,5),e-=2):(f="function"==typeof h?h:lb,e-=f?1:0),g&&Ba(c[0],c[1],g)&&(f=3>e?lb:f,e=1);++d<e;){var i=c[d];i&&a(b,i,f)}return b})}function ca(a,b){return function(c,d){var e=c?Yc(c):0;if(!Ea(e))return a(c,d);for(var f=b?e:-1,g=Ma(c);(b?f--:++f<e)&&d(g[f],f,g)!==!1;);return c}}function da(a){return function(b,c,d){for(var e=Ma(b),f=d(b),g=f.length,h=a?g:-1;a?h--:++h<g;){var i=f[h];if(c(e[i],i,e)===!1)break}return b}}function ea(a,b){function c(){var e=this&&this!==nc&&this instanceof c?d:a;return e.apply(b,arguments)}var d=fa(a);return c}function fa(a){return function(){var b=arguments;switch(b.length){case 0:return new a;case 1:return new a(b[0]);case 2:return new a(b[0],b[1]);case 3:return new a(b[0],b[1],b[2]);case 4:return new a(b[0],b[1],b[2],b[3]);case 5:return new a(b[0],b[1],b[2],b[3],b[4])}var c=Sc(a.prototype),d=a.apply(c,b);return Xa(d)?d:c}}function ga(a,b){return function(c,d,f){if(d=qa(d,f,3),jd(c)){var g=e(c,d,b);return g>-1?c[g]:lb}return G(c,d,a)}}function ha(a,b){return function(c,d,e){return"function"==typeof d&&e===lb&&jd(c)?a(c,d):b(c,Y(d,e,3))}}function ia(a){var b=Sa(function(c,d){var e=k(d,b.placeholder);return ma(c,a,null,d,e)});return b}function ja(a,b){return function(c,d,e,f){var g=arguments.length<3;return"function"==typeof d&&f===lb&&jd(c)?a(c,d,e,g):T(c,qa(d,f,4),e,g,b)}}function ka(a,b,c,d,e,f,g,h,i,j){function l(){for(var u=arguments.length,v=u,w=Array(u);v--;)w[v]=arguments[v];if(d&&(w=$(w,d,e)),f&&(w=_(w,f,g)),p||s){var x=l.placeholder,y=k(w,x);if(u-=y.length,j>u){var z=h?r(h):null,A=Gc(j-u,0),B=p?y:null,C=p?null:y,D=p?w:null,E=p?null:w;b|=p?sb:tb,b&=~(p?tb:sb),q||(b&=~(nb|ob));var F=[a,b,c,D,B,E,C,z,i,A],G=ka.apply(lb,F);return Da(a)&&Zc(G,F),G.placeholder=x,G}}var H=n?c:this,I=o?H[a]:a;return h&&(w=Ja(w,h)),m&&i<w.length&&(w.length=i),this&&this!==nc&&this instanceof l&&(I=t||fa(a)),I.apply(H,w)}var m=b&ub,n=b&nb,o=b&ob,p=b&qb,q=b&pb,s=b&rb,t=o?null:fa(a);return l}function la(a,b,c,d){function e(){for(var b=-1,h=arguments.length,i=-1,j=d.length,k=Array(h+j);++i<j;)k[i]=d[i];for(;h--;)k[i++]=arguments[++b];var l=this&&this!==nc&&this instanceof e?g:a;return l.apply(f?c:this,k)}var f=b&nb,g=fa(a);return e}function ma(a,b,c,d,e,f,g,h){var i=b&ob;if(!i&&"function"!=typeof a)throw new TypeError(yb);var j=d?d.length:0;if(j||(b&=~(sb|tb),d=e=null),j-=e?e.length:0,b&tb){var k=d,l=e;d=e=null}var m=i?null:Xc(a),n=[a,b,c,d,e,k,l,f,g,h];if(m&&(Ga(n,m),b=n[1],h=n[9]),n[9]=null==h?i?0:a.length:Gc(h-j,0)||0,b==nb)var o=ea(n[0],n[2]);else o=b!=sb&&b!=(nb|sb)||n[4].length?ka.apply(lb,n):la.apply(lb,n);var p=m?Vc:Zc;return p(o,n)}function na(a,b,c,d,e,f,g){var h=-1,i=a.length,j=b.length;if(i!=j&&!(e&&j>i))return!1;for(;++h<i;){var k=a[h],l=b[h],m=d?d(e?l:k,e?k:l,h):lb;if(m!==lb){if(m)continue;return!1}if(e){if(!w(b,function(a){return k===a||c(k,a,d,e,f,g)}))return!1}else if(k!==l&&!c(k,l,d,e,f,g))return!1}return!0}function oa(a,b,c){switch(c){case Cb:case Db:return+a==+b;case Eb:return a.name==b.name&&a.message==b.message;case Hb:return a!=+a?b!=+b:a==+b;case Jb:case Lb:return a==b+""}return!1}function pa(a,b,c,d,e,f,g){var h=od(a),i=h.length,j=od(b),k=j.length;if(i!=k&&!e)return!1;for(var l=i;l--;){var m=h[l];if(!(e?m in b:rc.call(b,m)))return!1}for(var n=e;++l<i;){m=h[l];var o=a[m],p=b[m],q=d?d(e?p:o,e?o:p,m):lb;if(!(q===lb?c(o,p,d,e,f,g):q))return!1;n||(n="constructor"==m)}if(!n){var r=a.constructor,s=b.constructor;if(r!=s&&"constructor"in a&&"constructor"in b&&!("function"==typeof r&&r instanceof r&&"function"==typeof s&&s instanceof s))return!1}return!0}function qa(a,b,c){var d=l.callback||eb;return d=d===eb?B:d,c?d(a,b,c):d}function ra(a){for(var b=a.name,c=Qc[b],d=c?c.length:0;d--;){var e=c[d],f=e.func;if(null==f||f==a)return e.name}return b}function sa(a,b,c){var d=l.indexOf||Oa;return d=d===Oa?f:d,a?d(a,b,c):d}function ta(a){for(var b=bb(a),c=b.length;c--;)b[c][2]=Fa(b[c][1]);return b}function ua(a,b){var c=null==a?lb:a[b];return Ya(c)?c:lb}function va(a){var b=a.length,c=new a.constructor(b);return b&&"string"==typeof a[0]&&rc.call(a,"index")&&(c.index=a.index,c.input=a.input),c}function wa(a){var b=a.constructor;return"function"==typeof b&&b instanceof b||(b=Object),new b}function xa(a,b,c){var d=a.constructor;switch(b){case Nb:return Z(a);case Cb:case Db:return new d(+a);case Ob:case Pb:case Qb:case Rb:case Sb:case Tb:case Ub:case Vb:case Wb:var e=a.buffer;return new d(c?Z(e):e,a.byteOffset,a.length);case Hb:case Lb:return new d(a);case Jb:var f=new d(a.source,bc.exec(a));f.lastIndex=a.lastIndex}return f}function ya(a,b,c){null==a||Ca(b,a)||(b=Na(b),a=1==b.length?a:K(a,U(b,0,-1)),b=Pa(b));var d=null==a?a:a[b];return null==d?lb:d.apply(a,c)}function za(a){return null!=a&&Ea(Yc(a))}function Aa(a,b){return a="number"==typeof a||dc.test(a)?+a:-1,b=null==b?Oc:b,a>-1&&a%1==0&&b>a}function Ba(a,b,c){if(!Xa(c))return!1;var d=typeof b;if("number"==d?za(c)&&Aa(b,c.length):"string"==d&&b in c){var e=c[b];return a===a?a===e:e!==e}return!1}function Ca(a,b){var c=typeof a;if("string"==c&&Yb.test(a)||"number"==c)return!0;if(jd(a))return!1;var d=!Xb.test(a);return d||null!=b&&a in Ma(b)}function Da(a){var b=ra(a);if(!(b in n.prototype))return!1;var c=l[b];if(a===c)return!0;var d=Xc(c);return!!d&&a===d[0]}function Ea(a){return"number"==typeof a&&a>-1&&a%1==0&&Oc>=a}function Fa(a){return a===a&&!Xa(a)}function Ga(a,b){var c=a[1],d=b[1],e=c|d,f=ub>e,g=d==ub&&c==qb||d==ub&&c==vb&&a[7].length<=b[8]||d==(ub|vb)&&c==qb;if(!f&&!g)return a;d&nb&&(a[2]=b[2],e|=c&nb?0:pb);var h=b[3];if(h){var i=a[3];a[3]=i?$(i,h,b[4]):r(h),a[4]=i?k(a[3],zb):r(b[4])}return h=b[5],h&&(i=a[5],a[5]=i?_(i,h,b[6]):r(h),a[6]=i?k(a[5],zb):r(b[6])),h=b[7],h&&(a[7]=r(h)),d&ub&&(a[8]=null==a[8]?b[8]:Hc(a[8],b[8])),null==a[9]&&(a[9]=b[9]),a[0]=b[0],a[1]=e,a}function Ha(a,b){a=Ma(a);for(var c=-1,d=b.length,e={};++c<d;){var f=b[c];f in a&&(e[f]=a[f])}return e}function Ia(a,b){var c={};return I(a,function(a,d,e){b(a,d,e)&&(c[d]=a)}),c}function Ja(a,b){for(var c=a.length,d=Hc(b.length,c),e=r(a);d--;){var f=b[d];a[d]=Aa(f,c)?e[f]:lb}return a}function Ka(a){var b;l.support;if(!j(a)||tc.call(a)!=Ib||!rc.call(a,"constructor")&&(b=a.constructor,"function"==typeof b&&!(b instanceof b)))return!1;var c;return I(a,function(a,b){c=b}),c===lb||rc.call(a,c)}function La(a){for(var b=ab(a),c=b.length,d=c&&a.length,e=!!d&&Ea(d)&&(jd(a)||Ua(a)),f=-1,g=[];++f<c;){var h=b[f];(e&&Aa(h,d)||rc.call(a,h))&&g.push(h)}return g}function Ma(a){return Xa(a)?a:Object(a)}function Na(a){if(jd(a))return a;var b=[];return h(a).replace(Zb,function(a,c,d,e){b.push(d?e.replace(ac,"$1"):c||a)}),b}function Oa(a,b,c){var d=a?a.length:0;if(!d)return-1;if("number"==typeof c)c=0>c?Gc(d+c,0):c;else if(c){var e=W(a,b),g=a[e];return(b===b?b===g:g!==g)?e:-1}return f(a,b,c||0)}function Pa(a){var b=a?a.length:0;return b?a[b-1]:lb}function Qa(a,b,c){var d=jd(a)?t:F;return c&&Ba(a,b,c)&&(b=null),("function"!=typeof b||c!==lb)&&(b=qa(b,c,3)),d(a,b)}function Ra(a,b,c){var d=jd(a)?u:O;return b=qa(b,c,3),d(a,b)}function Sa(a,b){if("function"!=typeof a)throw new TypeError(yb);return b=Gc(b===lb?a.length-1:+b||0,0),function(){for(var c=arguments,d=-1,e=Gc(c.length-b,0),f=Array(e);++d<e;)f[d]=c[b+d];switch(b){case 0:return a.call(this,f);case 1:return a.call(this,c[0],f);case 2:return a.call(this,c[0],c[1],f)}var g=Array(b+1);for(d=-1;++d<b;)g[d]=c[d];return g[b]=f,a.apply(this,g)}}function Ta(a,b,c,d){return b&&"boolean"!=typeof b&&Ba(a,b,c)?b=!1:"function"==typeof b&&(d=c,c=b,b=!1),"function"==typeof c?C(a,b,Y(c,d,1)):C(a,b)}function Ua(a){return j(a)&&za(a)&&tc.call(a)==Ab}function Va(a){return!!a&&1===a.nodeType&&j(a)&&tc.call(a).indexOf("Element")>-1}function Wa(a,b,c,d){c="function"==typeof c?Y(c,d,3):lb;var e=c?c(a,b):lb;return e===lb?L(a,b,c):!!e}function Xa(a){var b=typeof a;return!!a&&("object"==b||"function"==b)}function Ya(a){return null==a?!1:tc.call(a)==Fb?uc.test(qc.call(a)):j(a)&&cc.test(a)}function Za(a){return"number"==typeof a||j(a)&&tc.call(a)==Hb}function $a(a){return"string"==typeof a||j(a)&&tc.call(a)==Lb}function _a(a){return j(a)&&Ea(a.length)&&!!ec[tc.call(a)]}function ab(a){if(null==a)return[];Xa(a)||(a=Object(a));var b=a.length;b=b&&Ea(b)&&(jd(a)||Ua(a))&&b||0;for(var c=a.constructor,d=-1,e="function"==typeof c&&c.prototype===a,f=Array(b),g=b>0;++d<b;)f[d]=d+"";for(var h in a)g&&Aa(h,b)||"constructor"==h&&(e||!rc.call(a,h))||f.push(h);return f}function bb(a){a=Ma(a);for(var b=-1,c=od(a),d=c.length,e=Array(d);++b<d;){var f=c[b];e[b]=[f,a[f]]}return e}function cb(a){return V(a,od(a))}function db(a){return a=h(a),a&&_b.test(a)?a.replace($b,"\\$&"):a}function eb(a,b,c){return c&&Ba(a,b,c)&&(b=null),j(a)?hb(a):B(a,b)}function fb(a){return function(){return a}}function gb(a){return a}function hb(a){return P(C(a,!0))}function ib(){}function jb(a){return Ca(a)?R(a):S(a)}function kb(a){var b=++sc;return h(a)+b}var lb,mb="3.9.3",nb=1,ob=2,pb=4,qb=8,rb=16,sb=32,tb=64,ub=128,vb=256,wb=150,xb=16,yb="Expected a function",zb="__lodash_placeholder__",Ab="[object Arguments]",Bb="[object Array]",Cb="[object Boolean]",Db="[object Date]",Eb="[object Error]",Fb="[object Function]",Gb="[object Map]",Hb="[object Number]",Ib="[object Object]",Jb="[object RegExp]",Kb="[object Set]",Lb="[object String]",Mb="[object WeakMap]",Nb="[object ArrayBuffer]",Ob="[object Float32Array]",Pb="[object Float64Array]",Qb="[object Int8Array]",Rb="[object Int16Array]",Sb="[object Int32Array]",Tb="[object Uint8Array]",Ub="[object Uint8ClampedArray]",Vb="[object Uint16Array]",Wb="[object Uint32Array]",Xb=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,Yb=/^\w*$/,Zb=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g,$b=/[.*+?^${}()|[\]\/\\]/g,_b=RegExp($b.source),ac=/\\(\\)?/g,bc=/\w*$/,cc=/^\[object .+?Constructor\]$/,dc=/^\d+$/,ec={};ec[Ob]=ec[Pb]=ec[Qb]=ec[Rb]=ec[Sb]=ec[Tb]=ec[Ub]=ec[Vb]=ec[Wb]=!0,ec[Ab]=ec[Bb]=ec[Nb]=ec[Cb]=ec[Db]=ec[Eb]=ec[Fb]=ec[Gb]=ec[Hb]=ec[Ib]=ec[Jb]=ec[Kb]=ec[Lb]=ec[Mb]=!1;var fc={};fc[Ab]=fc[Bb]=fc[Nb]=fc[Cb]=fc[Db]=fc[Ob]=fc[Pb]=fc[Qb]=fc[Rb]=fc[Sb]=fc[Hb]=fc[Ib]=fc[Jb]=fc[Lb]=fc[Tb]=fc[Ub]=fc[Vb]=fc[Wb]=!0,fc[Eb]=fc[Fb]=fc[Gb]=fc[Kb]=fc[Mb]=!1;var gc={"function":!0,object:!0},hc=gc[typeof d]&&d&&!d.nodeType&&d,ic=gc[typeof c]&&c&&!c.nodeType&&c,jc=hc&&ic&&"object"==typeof b&&b&&b.Object&&b,kc=gc[typeof self]&&self&&self.Object&&self,lc=gc[typeof window]&&window&&window.Object&&window,mc=ic&&ic.exports===hc&&hc,nc=jc||lc!==(this&&this.window)&&lc||kc||this,oc=Object.prototype,pc=(pc=nc.window)?pc.document:null,qc=Function.prototype.toString,rc=oc.hasOwnProperty,sc=0,tc=oc.toString,uc=RegExp("^"+db(qc.call(rc)).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),vc=ua(nc,"ArrayBuffer"),wc=ua(vc&&new vc(0),"slice"),xc=Math.floor,yc=ua(Object,"getPrototypeOf"),zc=ua(nc,"Set"),Ac=ua(nc,"Uint8Array"),Bc=ua(nc,"WeakMap"),Cc=function(){try{var a=ua(nc,"Float64Array"),b=new a(new vc(10),0,1)&&a}catch(c){}return b||null}(),Dc=ua(Object,"create"),Ec=ua(Array,"isArray"),Fc=ua(Object,"keys"),Gc=Math.max,Hc=Math.min,Ic=ua(Date,"now"),Jc=Number.POSITIVE_INFINITY,Kc=4294967295,Lc=Kc-1,Mc=Kc>>>1,Nc=Cc?Cc.BYTES_PER_ELEMENT:0,Oc=9007199254740991,Pc=Bc&&new Bc,Qc={},Rc=l.support={};!function(a){var b=function(){this.x=a},c=[];b.prototype={valueOf:a,y:a};for(var d in new b)c.push(d);try{Rc.dom=11===pc.createDocumentFragment().nodeType}catch(e){Rc.dom=!1}}(1,0);var Sc=function(){function a(){}return function(b){if(Xa(b)){a.prototype=b;var c=new a;a.prototype=null}return c||{}}}(),Tc=ca(J),Uc=da(),Vc=Pc?function(a,b){return Pc.set(a,b),a}:gb;wc||(Z=vc&&Ac?function(a){var b=a.byteLength,c=Cc?xc(b/Nc):0,d=c*Nc,e=new vc(b);if(c){var f=new Cc(e,0,c);f.set(new Cc(a,0,c))}return b!=d&&(f=new Ac(e,d),f.set(new Ac(a,d))),e}:fb(null));var Wc=Dc&&zc?function(a){return new o(a)}:fb(null),Xc=Pc?function(a){return Pc.get(a)}:ib,Yc=R("length"),Zc=function(){var a=0,b=0;return function(c,d){var e=fd(),f=xb-(e-b);if(b=e,f>0){if(++a>=wb)return c}else a=0;return Vc(c,d)}}(),$c=Sa(function(a,b){return za(a)?E(a,H(b,!1,!0)):[]}),_c=Sa(function(a){for(var b=a.length,c=b,d=Array(l),e=sa(),g=e==f,h=[];c--;){var i=a[c]=za(i=a[c])?i:[];d[c]=g&&i.length>=120?Wc(c&&i):null}var j=a[0],k=-1,l=j?j.length:0,m=d[0];a:for(;++k<l;)if(i=j[k],(m?p(m,i):e(h,i,0))<0){for(var c=b;--c;){var n=d[c];if((n?p(n,i):e(a[c],i,0))<0)continue a}m&&m.push(i),h.push(i)}return h}),ad=ga(Tc),bd=ha(s,Tc),cd=Sa(function(a,b,c){var d=-1,e="function"==typeof b,f=Ca(b),g=za(a)?Array(a.length):[];return Tc(a,function(a){var h=e?b:f&&null!=a?a[b]:null;g[++d]=h?h.apply(a,c):ya(a,b,c)}),g}),dd=aa(function(a,b,c){a[c?0:1].push(b)},function(){return[[],[]]}),ed=ja(v,Tc),fd=Ic||function(){return(new Date).getTime()},gd=Sa(function(a,b,c){var d=nb;if(c.length){var e=k(c,gd.placeholder);d|=sb}return ma(a,d,b,c,e)}),hd=Sa(function(a,b){return D(a,1,b)}),id=ia(sb),jd=Ec||function(a){return j(a)&&Ea(a.length)&&tc.call(a)==Bb};Rc.dom||(Va=function(a){return!!a&&1===a.nodeType&&j(a)&&!ld(a)});var kd=g(/x/)||Ac&&!g(Ac)?function(a){return tc.call(a)==Fb}:g,ld=yc?function(a){if(!a||tc.call(a)!=Ib)return!1;var b=ua(a,"valueOf"),c=b&&(c=yc(b))&&yc(c);return c?a==c||yc(a)==c:Ka(a)}:Ka,md=ba(function(a,b,c){return c?y(a,b,c):z(a,b)}),nd=Sa(function(a){var b=a[0];return null==b?b:(a.push(x),md.apply(lb,a))}),od=Fc?function(a){var b=null==a?null:a.constructor;return"function"==typeof b&&b.prototype===a||"function"!=typeof a&&za(a)?La(a):Xa(a)?Fc(a):[]}:La,pd=Sa(function(a,b){if(null==a)return{};if("function"!=typeof b[0]){var b=u(H(b),String);return Ha(a,E(ab(a),b))}var c=Y(b[0],b[1],3);return Ia(a,function(a,b,d){return!c(a,b,d)})});n.prototype=Sc(m.prototype),n.prototype.constructor=n,o.prototype.push=q,l.assign=md,l.bind=gd,l.callback=eb,l.constant=fb,l.defaults=nd,l.defer=hd,l.difference=$c,l.forEach=bd,l.intersection=_c,l.invoke=cd,l.keys=od,l.keysIn=ab,l.map=Ra,l.matches=hb,l.omit=pd,l.pairs=bb,l.partial=id,l.partition=dd,l.property=jb,l.restParam=Sa,l.values=cb,l.collect=Ra,l.each=bd,l.extend=md,l.iteratee=eb,l.clone=Ta,l.escapeRegExp=db,l.every=Qa,l.find=ad,l.identity=gb,l.indexOf=Oa,l.isArguments=Ua,l.isArray=jd,l.isElement=Va,l.isEqual=Wa,l.isFunction=kd,l.isNative=Ya,l.isNumber=Za,l.isObject=Xa,l.isPlainObject=ld,l.isString=$a,l.isTypedArray=_a,l.last=Pa,l.noop=ib,l.now=fd,l.reduce=ed,l.uniqueId=kb,l.all=Qa,l.eq=Wa,l.detect=ad,l.foldl=ed,l.inject=ed,l.VERSION=mb,s(["bind","partial"],function(a){l[a].placeholder=l}),"function"==typeof a&&"object"==typeof a.amd&&a.amd?(nc._=l,a(function(){return l})):hc&&ic?mc?(ic.exports=l)._=l:hc._=l:nc._=l}).call(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(b,c,d){!function(b){function c(){this._events={},this._conf&&e.call(this,this._conf)}function e(a){a&&(this._conf=a,a.delimiter&&(this.delimiter=a.delimiter),a.maxListeners&&(this._events.maxListeners=a.maxListeners),a.wildcard&&(this.wildcard=a.wildcard),a.newListener&&(this.newListener=a.newListener),this.wildcard&&(this.listenerTree={}))}function f(a){this._events={},this.newListener=!1,e.call(this,a)}function g(a,b,c,d){if(!c)return[];var e,f,h,i,j,k,l,m=[],n=b.length,o=b[d],p=b[d+1];if(d===n&&c._listeners){if("function"==typeof c._listeners)return a&&a.push(c._listeners),[c];for(e=0,f=c._listeners.length;f>e;e++)a&&a.push(c._listeners[e]);return[c]}if("*"===o||"**"===o||c[o]){if("*"===o){for(h in c)"_listeners"!==h&&c.hasOwnProperty(h)&&(m=m.concat(g(a,b,c[h],d+1)));return m}if("**"===o){l=d+1===n||d+2===n&&"*"===p,l&&c._listeners&&(m=m.concat(g(a,b,c,n)));for(h in c)"_listeners"!==h&&c.hasOwnProperty(h)&&("*"===h||"**"===h?(c[h]._listeners&&!l&&(m=m.concat(g(a,b,c[h],n))),m=m.concat(g(a,b,c[h],d))):m=h===p?m.concat(g(a,b,c[h],d+2)):m.concat(g(a,b,c[h],d)));return m}m=m.concat(g(a,b,c[o],d+1))}if(i=c["*"],i&&g(a,b,i,d+1),j=c["**"])if(n>d){j._listeners&&g(a,b,j,n);for(h in j)"_listeners"!==h&&j.hasOwnProperty(h)&&(h===p?g(a,b,j[h],d+2):h===o?g(a,b,j[h],d+1):(k={},k[h]=j[h],g(a,b,{"**":k},d+1)))}else j._listeners?g(a,b,j,n):j["*"]&&j["*"]._listeners&&g(a,b,j["*"],n);return m}function h(a,b){a="string"==typeof a?a.split(this.delimiter):a.slice();for(var c=0,d=a.length;d>c+1;c++)if("**"===a[c]&&"**"===a[c+1])return;for(var e=this.listenerTree,f=a.shift();f;){if(e[f]||(e[f]={}),e=e[f],0===a.length){if(e._listeners){if("function"==typeof e._listeners)e._listeners=[e._listeners,b];else if(i(e._listeners)&&(e._listeners.push(b),!e._listeners.warned)){var g=j;"undefined"!=typeof this._events.maxListeners&&(g=this._events.maxListeners),g>0&&e._listeners.length>g&&(e._listeners.warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",e._listeners.length),console.trace())}}else e._listeners=b;return!0}f=a.shift()}return!0}var i=Array.isArray?Array.isArray:function(a){return"[object Array]"===Object.prototype.toString.call(a)},j=10;f.prototype.delimiter=".",f.prototype.setMaxListeners=function(a){this._events||c.call(this),this._events.maxListeners=a,this._conf||(this._conf={}),this._conf.maxListeners=a},f.prototype.event="",f.prototype.once=function(a,b){return this.many(a,1,b),this},f.prototype.many=function(a,b,c){function d(){0===--b&&e.off(a,d),c.apply(this,arguments)}var e=this;if("function"!=typeof c)throw new Error("many only accepts instances of Function");return d._origin=c,this.on(a,d),e},f.prototype.emit=function(){this._events||c.call(this);var a=arguments[0];if("newListener"===a&&!this.newListener&&!this._events.newListener)return!1;if(this._all){for(var b=arguments.length,d=new Array(b-1),e=1;b>e;e++)d[e-1]=arguments[e];for(e=0,b=this._all.length;b>e;e++)this.event=a,this._all[e].apply(this,d)}if("error"===a&&!(this._all||this._events.error||this.wildcard&&this.listenerTree.error))throw arguments[1]instanceof Error?arguments[1]:new Error("Uncaught, unspecified 'error' event.");var f;if(this.wildcard){f=[];var h="string"==typeof a?a.split(this.delimiter):a.slice();g.call(this,f,h,this.listenerTree,0)}else f=this._events[a];if("function"==typeof f){if(this.event=a,1===arguments.length)f.call(this);else if(arguments.length>1)switch(arguments.length){case 2:f.call(this,arguments[1]);break;case 3:f.call(this,arguments[1],arguments[2]);break;default:for(var b=arguments.length,d=new Array(b-1),e=1;b>e;e++)d[e-1]=arguments[e];f.apply(this,d)}return!0}if(f){for(var b=arguments.length,d=new Array(b-1),e=1;b>e;e++)d[e-1]=arguments[e];for(var i=f.slice(),e=0,b=i.length;b>e;e++)this.event=a,i[e].apply(this,d);return i.length>0||!!this._all}return!!this._all},f.prototype.on=function(a,b){if("function"==typeof a)return this.onAny(a),this;if("function"!=typeof b)throw new Error("on only accepts instances of Function");if(this._events||c.call(this),this.emit("newListener",a,b),this.wildcard)return h.call(this,a,b),this;if(this._events[a]){if("function"==typeof this._events[a])this._events[a]=[this._events[a],b];else if(i(this._events[a])&&(this._events[a].push(b),!this._events[a].warned)){var d=j;"undefined"!=typeof this._events.maxListeners&&(d=this._events.maxListeners),d>0&&this._events[a].length>d&&(this._events[a].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[a].length),console.trace())}}else this._events[a]=b;return this},f.prototype.onAny=function(a){if("function"!=typeof a)throw new Error("onAny only accepts instances of Function");return this._all||(this._all=[]),this._all.push(a),this},f.prototype.addListener=f.prototype.on,f.prototype.off=function(a,b){if("function"!=typeof b)throw new Error("removeListener only takes instances of Function");var c,d=[];if(this.wildcard){var e="string"==typeof a?a.split(this.delimiter):a.slice();d=g.call(this,null,e,this.listenerTree,0)}else{if(!this._events[a])return this;c=this._events[a],d.push({_listeners:c})}for(var f=0;f<d.length;f++){var h=d[f];if(c=h._listeners,i(c)){for(var j=-1,k=0,l=c.length;l>k;k++)if(c[k]===b||c[k].listener&&c[k].listener===b||c[k]._origin&&c[k]._origin===b){j=k;break}if(0>j)continue;return this.wildcard?h._listeners.splice(j,1):this._events[a].splice(j,1),0===c.length&&(this.wildcard?delete h._listeners:delete this._events[a]),this}(c===b||c.listener&&c.listener===b||c._origin&&c._origin===b)&&(this.wildcard?delete h._listeners:delete this._events[a])}return this},f.prototype.offAny=function(a){var b,c=0,d=0;if(a&&this._all&&this._all.length>0){for(b=this._all,c=0,d=b.length;d>c;c++)if(a===b[c])return b.splice(c,1),this}else this._all=[];return this},f.prototype.removeListener=f.prototype.off,f.prototype.removeAllListeners=function(a){if(0===arguments.length)return!this._events||c.call(this),this;if(this.wildcard)for(var b="string"==typeof a?a.split(this.delimiter):a.slice(),d=g.call(this,null,b,this.listenerTree,0),e=0;e<d.length;e++){var f=d[e];f._listeners=null}else{if(!this._events[a])return this;this._events[a]=null}return this},f.prototype.listeners=function(a){if(this.wildcard){var b=[],d="string"==typeof a?a.split(this.delimiter):a.slice();return g.call(this,b,d,this.listenerTree,0),b}return this._events||c.call(this),this._events[a]||(this._events[a]=[]),i(this._events[a])||(this._events[a]=[this._events[a]]),this._events[a]},f.prototype.listenersAny=function(){return this._all?this._all:[]},"function"==typeof a&&a.amd?a(function(){return f}):"object"==typeof d?d.EventEmitter2=f:window.EventEmitter2=f}()},{}],3:[function(a,b,c){var d=a("fast-diff"),e=a("./is"),f=a("./op"),g=String.fromCharCode(0),h=function(a){e.array(a)?this.ops=a:e.object(a)&&e.array(a.ops)?this.ops=a.ops:this.ops=[]};h.prototype.insert=function(a,b){var c={};return 0===a.length?this:(c.insert=a,e.object(b)&&Object.keys(b).length>0&&(c.attributes=b),this.push(c))},h.prototype["delete"]=function(a){return 0>=a?this:this.push({"delete":a})},h.prototype.retain=function(a,b){if(0>=a)return this;var c={retain:a};return e.object(b)&&Object.keys(b).length>0&&(c.attributes=b),this.push(c)},h.prototype.push=function(a){var b=this.ops.length,c=this.ops[b-1];if(a=f.clone(a),e.object(c)){if(e.number(a["delete"])&&e.number(c["delete"]))return this.ops[b-1]={"delete":c["delete"]+a["delete"]},this;if(e.number(c["delete"])&&null!=a.insert&&(b-=1,c=this.ops[b-1],!e.object(c)))return this.ops.unshift(a),this;if(e.equal(a.attributes,c.attributes)){if(e.string(a.insert)&&e.string(c.insert))return this.ops[b-1]={insert:c.insert+a.insert},e.object(a.attributes)&&(this.ops[b-1].attributes=a.attributes),this;if(e.number(a.retain)&&e.number(c.retain))return this.ops[b-1]={retain:c.retain+a.retain},e.object(a.attributes)&&(this.ops[b-1].attributes=a.attributes),this}}return b===this.ops.length?this.ops.push(a):this.ops.splice(b,0,a),this},h.prototype.chop=function(){var a=this.ops[this.ops.length-1];return a&&a.retain&&!a.attributes&&this.ops.pop(),this},h.prototype.length=function(){return this.ops.reduce(function(a,b){return a+f.length(b)},0)},h.prototype.slice=function(a,b){a=a||0,e.number(b)||(b=1/0);for(var c=new h,d=f.iterator(this.ops),g=0;b>g&&d.hasNext();){var i;a>g?i=d.next(a-g):(i=d.next(b-g),c.push(i)),g+=f.length(i)}return c},h.prototype.compose=function(a){for(var b=f.iterator(this.ops),c=f.iterator(a.ops),d=new h;b.hasNext()||c.hasNext();)if("insert"===c.peekType())d.push(c.next());else if("delete"===b.peekType())d.push(b.next());else{var g=Math.min(b.peekLength(),c.peekLength()),i=b.next(g),j=c.next(g);if(e.number(j.retain)){var k={};e.number(i.retain)?k.retain=g:k.insert=i.insert;var l=f.attributes.compose(i.attributes,j.attributes,e.number(i.retain));l&&(k.attributes=l),d.push(k)}else e.number(j["delete"])&&e.number(i.retain)&&d.push(j)}return d.chop()},h.prototype.concat=function(a){var b=this.slice();return a.ops.length>0&&(b.push(a.ops[0]),b.ops=b.ops.concat(a.ops.slice(1))),b},h.prototype.diff=function(a){var b=new h;if(this.ops===a.ops)return b;var c=[this.ops,a.ops].map(function(b){return b.map(function(c){if(null!=c.insert)return e.string(c.insert)?c.insert:g;var d=b===a.ops?"on":"with";throw new Error("diff() called "+d+" non-document")}).join("")}),i=d(c[0],c[1]),j=f.iterator(this.ops),k=f.iterator(a.ops);return i.forEach(function(a){for(var c=a[1].length;c>0;){var g=0;switch(a[0]){case d.INSERT:g=Math.min(k.peekLength(),c),b.push(k.next(g));break;case d.DELETE:g=Math.min(c,j.peekLength()),j.next(g),b["delete"](g);break;case d.EQUAL:g=Math.min(j.peekLength(),k.peekLength(),c);var h=j.next(g),i=k.next(g);e.equal(h.insert,i.insert)?b.retain(g,f.attributes.diff(h.attributes,i.attributes)):b.push(i)["delete"](g);
}c-=g}}),b.chop()},h.prototype.transform=function(a,b){if(b=!!b,e.number(a))return this.transformPosition(a,b);for(var c=f.iterator(this.ops),d=f.iterator(a.ops),g=new h;c.hasNext()||d.hasNext();)if("insert"!==c.peekType()||!b&&"insert"===d.peekType())if("insert"===d.peekType())g.push(d.next());else{var i=Math.min(c.peekLength(),d.peekLength()),j=c.next(i),k=d.next(i);if(j["delete"])continue;k["delete"]?g.push(k):g.retain(i,f.attributes.transform(j.attributes,k.attributes,b))}else g.retain(f.length(c.next()));return g.chop()},h.prototype.transformPosition=function(a,b){b=!!b;for(var c=f.iterator(this.ops),d=0;c.hasNext()&&a>=d;){var e=c.peekLength(),g=c.peekType();c.next(),"delete"!==g?("insert"===g&&(a>d||!b)&&(a+=e),d+=e):a-=Math.min(e,a-d)}return a},b.exports=h},{"./is":4,"./op":5,"fast-diff":6}],4:[function(a,b,c){b.exports={equal:function(a,b){if(a===b)return!0;if(null==a&&null==b)return!0;if(null==a||null==b)return!1;if(!this.object(a)||!this.object(b))return!1;if(Object.keys(a).length!=Object.keys(b).length)return!1;for(var c in a)if(a[c]!==b[c])return!1;return!0},array:function(a){return Array.isArray(a)},number:function(a){return"number"==typeof a?!0:"object"==typeof a&&"[object Number]"===Object.prototype.toString.call(a)?!0:!1},object:function(a){return a?"function"==typeof a||"object"==typeof a:!1},string:function(a){return"string"==typeof a?!0:"object"==typeof a&&"[object String]"===Object.prototype.toString.call(a)?!0:!1}}},{}],5:[function(a,b,c){function d(a){this.ops=a,this.index=0,this.offset=0}var e=a("./is"),f={attributes:{clone:function(a,b){return e.object(a)?Object.keys(a).reduce(function(c,d){return void 0===a[d]||null===a[d]&&!b||(c[d]=a[d]),c},{}):{}},compose:function(a,b,c){e.object(a)||(a={}),e.object(b)||(b={});var d=this.clone(b,c);for(var f in a)void 0!==a[f]&&void 0===b[f]&&(d[f]=a[f]);return Object.keys(d).length>0?d:void 0},diff:function(a,b){e.object(a)||(a={}),e.object(b)||(b={});var c=Object.keys(a).concat(Object.keys(b)).reduce(function(c,d){return a[d]!==b[d]&&(c[d]=void 0===b[d]?null:b[d]),c},{});return Object.keys(c).length>0?c:void 0},transform:function(a,b,c){if(!e.object(a))return b;if(!e.object(b))return void 0;if(!c)return b;var d=Object.keys(b).reduce(function(c,d){return void 0===a[d]&&(c[d]=b[d]),c},{});return Object.keys(d).length>0?d:void 0}},clone:function(a){var b=this.attributes.clone(a);return e.object(b.attributes)&&(b.attributes=this.attributes.clone(b.attributes,!0)),b},iterator:function(a){return new d(a)},length:function(a){return e.number(a["delete"])?a["delete"]:e.number(a.retain)?a.retain:e.string(a.insert)?a.insert.length:1}};d.prototype.hasNext=function(){return this.peekLength()<1/0},d.prototype.next=function(a){a||(a=1/0);var b=this.ops[this.index];if(b){var c=this.offset,d=f.length(b);if(a>=d-c?(a=d-c,this.index+=1,this.offset=0):this.offset+=a,e.number(b["delete"]))return{"delete":a};var g={};return b.attributes&&(g.attributes=b.attributes),e.number(b.retain)?g.retain=a:e.string(b.insert)?g.insert=b.insert.substr(c,a):g.insert=b.insert,g}return{retain:1/0}},d.prototype.peekLength=function(){return this.ops[this.index]?f.length(this.ops[this.index])-this.offset:1/0},d.prototype.peekType=function(){return this.ops[this.index]?e.number(this.ops[this.index]["delete"])?"delete":e.number(this.ops[this.index].retain)?"retain":"insert":"retain"},b.exports=f},{"./is":4}],6:[function(a,b,c){function d(a,b){if(a==b)return a?[[n,a]]:[];var c=h(a,b),d=a.substring(0,c);a=a.substring(c),b=b.substring(c),c=i(a,b);var f=a.substring(a.length-c);a=a.substring(0,a.length-c),b=b.substring(0,b.length-c);var g=e(a,b);return d&&g.unshift([n,d]),f&&g.push([n,f]),k(g),g}function e(a,b){var c;if(!a)return[[m,b]];if(!b)return[[l,a]];var e=a.length>b.length?a:b,g=a.length>b.length?b:a,h=e.indexOf(g);if(-1!=h)return c=[[m,e.substring(0,h)],[n,g],[m,e.substring(h+g.length)]],a.length>b.length&&(c[0][0]=c[2][0]=l),c;if(1==g.length)return[[l,a],[m,b]];var i=j(a,b);if(i){var k=i[0],o=i[1],p=i[2],q=i[3],r=i[4],s=d(k,p),t=d(o,q);return s.concat([[n,r]],t)}return f(a,b)}function f(a,b){for(var c=a.length,d=b.length,e=Math.ceil((c+d)/2),f=e,h=2*e,i=new Array(h),j=new Array(h),k=0;h>k;k++)i[k]=-1,j[k]=-1;i[f+1]=0,j[f+1]=0;for(var n=c-d,o=n%2!=0,p=0,q=0,r=0,s=0,t=0;e>t;t++){for(var u=-t+p;t-q>=u;u+=2){var v,w=f+u;v=u==-t||u!=t&&i[w-1]<i[w+1]?i[w+1]:i[w-1]+1;for(var x=v-u;c>v&&d>x&&a.charAt(v)==b.charAt(x);)v++,x++;if(i[w]=v,v>c)q+=2;else if(x>d)p+=2;else if(o){var y=f+n-u;if(y>=0&&h>y&&-1!=j[y]){var z=c-j[y];if(v>=z)return g(a,b,v,x)}}}for(var A=-t+r;t-s>=A;A+=2){var z,y=f+A;z=A==-t||A!=t&&j[y-1]<j[y+1]?j[y+1]:j[y-1]+1;for(var B=z-A;c>z&&d>B&&a.charAt(c-z-1)==b.charAt(d-B-1);)z++,B++;if(j[y]=z,z>c)s+=2;else if(B>d)r+=2;else if(!o){var w=f+n-A;if(w>=0&&h>w&&-1!=i[w]){var v=i[w],x=f+v-w;if(z=c-z,v>=z)return g(a,b,v,x)}}}}return[[l,a],[m,b]]}function g(a,b,c,e){var f=a.substring(0,c),g=b.substring(0,e),h=a.substring(c),i=b.substring(e),j=d(f,g),k=d(h,i);return j.concat(k)}function h(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;e>c;)a.substring(f,e)==b.substring(f,e)?(c=e,f=c):d=e,e=Math.floor((d-c)/2+c);return e}function i(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;e>c;)a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f)?(c=e,f=c):d=e,e=Math.floor((d-c)/2+c);return e}function j(a,b){function c(a,b,c){for(var d,e,f,g,j=a.substring(c,c+Math.floor(a.length/4)),k=-1,l="";-1!=(k=b.indexOf(j,k+1));){var m=h(a.substring(c),b.substring(k)),n=i(a.substring(0,c),b.substring(0,k));l.length<n+m&&(l=b.substring(k-n,k)+b.substring(k,k+m),d=a.substring(0,c-n),e=a.substring(c+m),f=b.substring(0,k-n),g=b.substring(k+m))}return 2*l.length>=a.length?[d,e,f,g,l]:null}var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(d.length<4||2*e.length<d.length)return null;var f,g=c(d,e,Math.ceil(d.length/4)),j=c(d,e,Math.ceil(d.length/2));if(!g&&!j)return null;f=j?g&&g[4].length>j[4].length?g:j:g;var k,l,m,n;a.length>b.length?(k=f[0],l=f[1],m=f[2],n=f[3]):(m=f[0],n=f[1],k=f[2],l=f[3]);var o=f[4];return[k,l,m,n,o]}function k(a){a.push([n,""]);for(var b,c=0,d=0,e=0,f="",g="";c<a.length;)switch(a[c][0]){case m:e++,g+=a[c][1],c++;break;case l:d++,f+=a[c][1],c++;break;case n:d+e>1?(0!==d&&0!==e&&(b=h(g,f),0!==b&&(c-d-e>0&&a[c-d-e-1][0]==n?a[c-d-e-1][1]+=g.substring(0,b):(a.splice(0,0,[n,g.substring(0,b)]),c++),g=g.substring(b),f=f.substring(b)),b=i(g,f),0!==b&&(a[c][1]=g.substring(g.length-b)+a[c][1],g=g.substring(0,g.length-b),f=f.substring(0,f.length-b))),0===d?a.splice(c-e,d+e,[m,g]):0===e?a.splice(c-d,d+e,[l,f]):a.splice(c-d-e,d+e,[l,f],[m,g]),c=c-d-e+(d?1:0)+(e?1:0)+1):0!==c&&a[c-1][0]==n?(a[c-1][1]+=a[c][1],a.splice(c,1)):c++,e=0,d=0,f="",g=""}""===a[a.length-1][1]&&a.pop();var j=!1;for(c=1;c<a.length-1;)a[c-1][0]==n&&a[c+1][0]==n&&(a[c][1].substring(a[c][1].length-a[c-1][1].length)==a[c-1][1]?(a[c][1]=a[c-1][1]+a[c][1].substring(0,a[c][1].length-a[c-1][1].length),a[c+1][1]=a[c-1][1]+a[c+1][1],a.splice(c-1,1),j=!0):a[c][1].substring(0,a[c+1][1].length)==a[c+1][1]&&(a[c-1][1]+=a[c+1][1],a[c][1]=a[c][1].substring(a[c+1][1].length)+a[c+1][1],a.splice(c+1,1),j=!0)),c++;j&&k(a)}var l=-1,m=1,n=0,o=d;o.INSERT=m,o.DELETE=l,o.EQUAL=n,b.exports=o},{}],7:[function(a,b,c){b.exports={version:"0.20.1"}},{}],8:[function(a,b,c){var d,e,f,g,h,i,j,k;j=a("lodash"),d=a("rich-text/lib/delta"),k=a("../lib/dom"),f=a("./format"),g=a("./line"),h=a("../lib/linked-list"),i=a("./normalizer"),e=function(){function a(a,b){this.root=a,null==b&&(b={}),this.normalizer=new i,this.formats={},j.each(b.formats,j.bind(this.addFormat,this)),this.setHTML(this.root.innerHTML)}return a.prototype.addFormat=function(a,b){return j.isObject(b)||(b=f.FORMATS[a]),null!=this.formats[a]&&console.warn("Overwriting format",a,this.formats[a]),this.formats[a]=new f(b),this.normalizer.addFormat(b)},a.prototype.appendLine=function(a){return this.insertLineBefore(a,null)},a.prototype.findLeafAt=function(a,b){var c,d,e;return e=this.findLineAt(a),c=e[0],d=e[1],null!=c?c.findLeafAt(d,b):[void 0,d]},a.prototype.findLine=function(a){for(var b;null!=a&&null==k.BLOCK_TAGS[a.tagName];)a=a.parentNode;return b=null!=a?k(a).data(g.DATA_KEY):void 0,(null!=b?b.node:void 0)===a?b:void 0},a.prototype.findLineAt=function(a){var b,c;if(!(this.lines.length>0))return[void 0,a];if(c=this.toDelta().length(),a===c)return[this.lines.last,this.lines.last.length];if(a>c)return[void 0,a-c];for(b=this.lines.first;null!=b;){if(a<b.length)return[b,a];a-=b.length,b=b.next}return[void 0,a]},a.prototype.getHTML=function(){return this.root.innerHTML.replace(/\>\s+\</g,">&nbsp;<")},a.prototype.insertLineBefore=function(a,b){var c;return c=new g(this,a),null!=b?(k(a.parentNode).isElement()||this.root.insertBefore(a,b.node),this.lines.insertAfter(b.prev,c)):(k(a.parentNode).isElement()||this.root.appendChild(a),this.lines.append(c)),c},a.prototype.mergeLines=function(a,b){return b.length>1&&(1===a.length&&k(a.leaves.last.node).remove(),j.each(k(b.node).childNodes(),function(b){return b.tagName!==k.DEFAULT_BREAK_TAG?a.node.appendChild(b):void 0})),this.removeLine(b),a.rebuild()},a.prototype.optimizeLines=function(){return j.each(this.lines.toArray(),function(a,b){return a.optimize(),!0})},a.prototype.rebuild=function(){var a,b,c;for(b=this.lines.toArray(),a=this.root.firstChild,null!=a&&null!=k.LIST_TAGS[a.tagName]&&(a=a.firstChild),j.each(b,function(b){return function(c,d){for(var e,f;c.node!==a;){if(c.node.parentNode!==b.root&&(null!=(f=c.node.parentNode)?f.parentNode:void 0)!==b.root)return b.removeLine(c);a=b.normalizer.normalizeLine(a),e=b.insertLineBefore(a,c),a=k(a).nextLineNode(b.root)}return c.outerHTML!==a.outerHTML&&(c.node=b.normalizer.normalizeLine(c.node),c.rebuild()),a=k(a).nextLineNode(b.root)}}(this)),c=[];null!=a;)a=this.normalizer.normalizeLine(a),this.appendLine(a),c.push(a=k(a).nextLineNode(this.root));return c},a.prototype.removeLine=function(a){return null!=a.node.parentNode&&(k.LIST_TAGS[a.node.parentNode.tagName]&&1===a.node.parentNode.childNodes.length?k(a.node.parentNode).remove():k(a.node).remove()),this.lines.remove(a)},a.prototype.setHTML=function(a){return a=i.stripComments(a),a=i.stripWhitespace(a),this.root.innerHTML=a,this.lines=new h,this.rebuild()},a.prototype.splitLine=function(a,b){var c,d,e,f;return b=Math.min(b,a.length-1),f=k(a.node).split(b,!0),c=f[0],d=f[1],a.node=c,a.rebuild(),e=this.insertLineBefore(d,a.next),e.formats=j.clone(a.formats),e.resetContent(),e},a.prototype.toDelta=function(){var a,b;return b=this.lines.toArray(),a=new d,j.each(b,function(b){return j.each(b.delta.ops,function(b){return a.push(b)})}),a},a}(),b.exports=e},{"../lib/dom":17,"../lib/linked-list":18,"./format":10,"./line":12,"./normalizer":13,lodash:1,"rich-text/lib/delta":3}],9:[function(a,b,c){var d,e,f,g,h,i,j;i=a("lodash"),d=a("rich-text/lib/delta"),j=a("../lib/dom"),e=a("./document"),g=a("./line"),h=a("./selection"),f=function(){function a(a,b,c){this.root=a,this.quill=b,this.options=null!=c?c:{},this.root.setAttribute("id",this.options.id),this.doc=new e(this.root,this.options),this.delta=this.doc.toDelta(),this.length=this.delta.length(),this.selection=new h(this.doc,this.quill),this.timer=setInterval(i.bind(this.checkUpdate,this),this.options.pollInterval),this.savedRange=null,this.quill.on("selection-change",function(a){return function(b){return a.savedRange=b}}(this)),this.options.readOnly||this.enable()}return a.sources={API:"api",SILENT:"silent",USER:"user"},a.prototype.destroy=function(){return clearInterval(this.timer)},a.prototype.disable=function(){return this.enable(!1)},a.prototype.enable=function(a){return null==a&&(a=!0),this.root.setAttribute("contenteditable",a)},a.prototype.applyDelta=function(b,c){var d;return d=this._update(),d&&(b=d.transform(b,!0),d=b.transform(d,!1)),b.ops.length>0&&(b=this._trackDelta(function(a){return function(){var c;return c=0,i.each(b.ops,function(b){return i.isString(b.insert)?(a._insertAt(c,b.insert,b.attributes),c+=b.insert.length):i.isNumber(b.insert)?(a._insertEmbed(c,b.attributes),c+=1):i.isNumber(b["delete"])?a._deleteAt(c,b["delete"]):i.isNumber(b.retain)?(i.each(b.attributes,function(d,e){return a._formatAt(c,b.retain,e,d)}),c+=b.retain):void 0}),a.selection.shiftAfter(0,0,i.bind(a.doc.optimizeLines,a.doc))}}(this)),this.delta=this.doc.toDelta(),this.length=this.delta.length(),this.innerHTML=this.root.innerHTML,b&&c!==a.sources.SILENT&&this.quill.emit(this.quill.constructor.events.TEXT_CHANGE,b,c)),d&&d.ops.length>0&&c!==a.sources.SILENT?this.quill.emit(this.quill.constructor.events.TEXT_CHANGE,d,a.sources.USER):void 0},a.prototype.checkUpdate=function(b){var c;return null==b&&(b="user"),null==this.root.parentNode?clearInterval(this.timer):(c=this._update(),c&&(this.delta=this.delta.compose(c),this.length=this.delta.length(),this.quill.emit(this.quill.constructor.events.TEXT_CHANGE,c,b)),c&&(b=a.sources.SILENT),this.selection.update(b))},a.prototype.focus=function(){return null!=this.selection.range?this.selection.setRange(this.selection.range):this.root.focus()},a.prototype.getBounds=function(a){var b,c,d,e,f,g,h;return this.checkUpdate(),g=this.doc.findLeafAt(a,!0),d=g[0],e=g[1],null==d?null:(c=this.root.parentNode.getBoundingClientRect(),h="left",0===d.length?b=d.node.parentNode.getBoundingClientRect():j.VOID_TAGS[d.node.tagName]?(b=d.node.getBoundingClientRect(),1===e&&(h="right")):(f=document.createRange(),e<d.length?(f.setStart(d.node,e),f.setEnd(d.node,e+1)):(f.setStart(d.node,e-1),f.setEnd(d.node,e),h="right"),b=f.getBoundingClientRect()),{height:b.height,left:b[h]-c.left,top:b.top-c.top})},a.prototype._deleteAt=function(a,b){return 0>=b?void 0:this.selection.shiftAfter(a,-1*b,function(c){return function(){var d,e,f,g,h,i,j;for(j=c.doc.findLineAt(a),f=j[0],i=j[1],d=f,g=f.length-i<=b&&i>0;null!=d&&b>0;)h=d.next,e=Math.min(d.length-i,b),0===i&&b>=d.length?c.doc.removeLine(d):d.deleteText(i,e),b-=e,d=h,i=0;return g&&f.next?c.doc.mergeLines(f,f.next):void 0}}(this))},a.prototype._formatAt=function(a,b,c,d){return this.selection.shiftAfter(a,0,function(e){return function(){var f,g,h,i,j;for(i=e.doc.findLineAt(a),g=i[0],h=i[1],j=[];null!=g&&b>0;)f=Math.min(b,g.length-h-1),g.formatText(h,f,c,d),b-=f,b>0&&g.format(c,d),b-=1,h=0,j.push(g=g.next);return j}}(this))},a.prototype._insertEmbed=function(a,b){return this.selection.shiftAfter(a,1,function(c){return function(){var d,e,f;return f=c.doc.findLineAt(a),d=f[0],e=f[1],d.insertEmbed(e,b)}}(this))},a.prototype._insertAt=function(a,b,c){return null==c&&(c={}),this.selection.shiftAfter(a,b.length,function(d){return function(){var e,f,g,h;return b=b.replace(/\r\n?/g,"\n"),f=b.split("\n"),h=d.doc.findLineAt(a),e=h[0],g=h[1],i.each(f,function(a,b){var h;return null==e||e.length<=g?(b<f.length-1||a.length>0)&&(e=d.doc.appendLine(document.createElement(j.DEFAULT_BLOCK_TAG)),g=0,e.insertText(g,a,c),e.format(c),h=null):(e.insertText(g,a,c),b<f.length-1&&(h=d.doc.splitLine(e,g+a.length),i.each(i.defaults({},c,e.formats),function(a,b){return e.format(b,c[b])}),g=0)),e=h})}}(this))},a.prototype._trackDelta=function(a){var b,c,d,e,f,g,h,j,k,l;g=null!=(k=this.savedRange)?k.start:void 0,a(),c=this.doc.toDelta(),this.savedRange=this.selection.getRange(),d=null!=(l=this.savedRange)?l.start:void 0;try{if(null!=g&&null!=d&&g<=this.delta.length()&&d<=c.length()&&(j=this.delta.slice(g),f=c.slice(d),i.isEqual(j.ops,f.ops)))return h=this.delta.slice(0,g),e=c.slice(0,d),h.diff(e)}catch(m){b=m}return this.delta.diff(c)},a.prototype._update=function(){var a;return this.innerHTML===this.root.innerHTML?!1:(a=this._trackDelta(function(a){return function(){return a.selection.preserve(i.bind(a.doc.rebuild,a.doc)),a.selection.shiftAfter(0,0,i.bind(a.doc.optimizeLines,a.doc))}}(this)),this.innerHTML=this.root.innerHTML,a.ops.length>0?a:!1)},a}(),b.exports=f},{"../lib/dom":17,"./document":8,"./line":12,"./selection":14,lodash:1,"rich-text/lib/delta":3}],10:[function(a,b,c){var d,e,f;e=a("lodash"),f=a("../lib/dom"),d=function(){function a(a){this.config=a}return a.types={LINE:"line",EMBED:"embed"},a.FORMATS={bold:{tag:"B",prepare:"bold"},italic:{tag:"I",prepare:"italic"},underline:{tag:"U",prepare:"underline"},strike:{tag:"S",prepare:"strikeThrough"},color:{style:"color","default":"rgb(0, 0, 0)",prepare:"foreColor"},background:{style:"backgroundColor","default":"rgb(255, 255, 255)",prepare:"backColor"},font:{style:"fontFamily","default":"'Helvetica', 'Arial', sans-serif",prepare:"fontName"},size:{style:"fontSize","default":"13px",prepare:function(a){return document.execCommand("fontSize",!1,f.convertFontSize(a))}},link:{tag:"A",add:function(a,b){return a.setAttribute("href",b),a},remove:function(a){return a.removeAttribute("href"),a},value:function(a){return a.getAttribute("href")}},image:{type:a.types.EMBED,tag:"IMG",attribute:"src"},align:{type:a.types.LINE,style:"textAlign","default":"left"},bullet:{type:a.types.LINE,exclude:"list",parentTag:"UL",tag:"LI"},list:{type:a.types.LINE,exclude:"bullet",parentTag:"OL",tag:"LI"}},a.prototype.add=function(b,c){var d,g,h,i,j;return c?this.value(b)===c?b:(e.isString(this.config.parentTag)&&(h=b.parentNode,h.tagName!==this.config.parentTag&&(h=document.createElement(this.config.parentTag),f(b).wrap(h)),b.parentNode.tagName===(null!=(i=b.parentNode.previousSibling)?i.tagName:void 0)&&f(b.parentNode.previousSibling).merge(b.parentNode),b.parentNode.tagName===(null!=(j=b.parentNode.nextSibling)?j.tagName:void 0)&&f(b.parentNode).merge(b.parentNode.nextSibling)),e.isString(this.config.tag)&&b.tagName!==this.config.tag&&(d=document.createElement(this.config.tag),null!=f.VOID_TAGS[d.tagName]?(null!=b.parentNode&&f(b).replace(d),b=d):this.isType(a.types.LINE)?b=f(b).switchTag(this.config.tag).get():(f(b).wrap(d),b=d)),(e.isString(this.config.style)||e.isString(this.config.attribute)||e.isString(this.config["class"]))&&(e.isString(this.config["class"])&&(b=this.remove(b)),f(b).isTextNode()&&(g=document.createElement(f.DEFAULT_INLINE_TAG),f(b).wrap(g),b=g),e.isString(this.config.style)&&c!==this.config["default"]&&(b.style[this.config.style]=c),e.isString(this.config.attribute)&&b.setAttribute(this.config.attribute,c),e.isString(this.config["class"])&&f(b).addClass(this.config["class"]+c)),e.isFunction(this.config.add)&&(b=this.config.add(b,c)),b):this.remove(b)},a.prototype.isType=function(a){return a===this.config.type},a.prototype.match=function(a){var b,c,d,g,h;if(!f(a).isElement())return!1;if(e.isString(this.config.parentTag)&&(null!=(g=a.parentNode)?g.tagName:void 0)!==this.config.parentTag)return!1;if(e.isString(this.config.tag)&&a.tagName!==this.config.tag)return!1;if(e.isString(this.config.style)&&(!a.style[this.config.style]||a.style[this.config.style]===this.config["default"]))return!1;if(e.isString(this.config.attribute)&&!a.hasAttribute(this.config.attribute))return!1;if(e.isString(this.config["class"])){for(h=f(a).classes(),c=0,d=h.length;d>c;c++)if(b=h[c],0===b.indexOf(this.config["class"]))return!0;return!1}return!0},a.prototype.prepare=function(a){return e.isString(this.config.prepare)?document.execCommand(this.config.prepare,!1,a):e.isFunction(this.config.prepare)?this.config.prepare(a):void 0},a.prototype.remove=function(b){var c,d,g,h;if(!this.match(b))return b;if(e.isString(this.config.style)&&(b.style[this.config.style]="",b.getAttribute("style")||b.removeAttribute("style")),e.isString(this.config.attribute)&&b.removeAttribute(this.config.attribute),e.isString(this.config["class"]))for(h=f(b).classes(),d=0,g=h.length;g>d;d++)c=h[d],0===c.indexOf(this.config["class"])&&f(b).removeClass(c);if(e.isString(this.config.tag))if(this.isType(a.types.LINE))e.isString(this.config.parentTag)&&(null!=b.previousSibling&&f(b).splitBefore(b.parentNode.parentNode),null!=b.nextSibling&&f(b.nextSibling).splitBefore(b.parentNode.parentNode)),b=f(b).switchTag(f.DEFAULT_BLOCK_TAG).get();else{if(this.isType(a.types.EMBED))return void f(b).remove();b=f(b).switchTag(f.DEFAULT_INLINE_TAG).get()}return e.isString(this.config.parentTag)&&f(b.parentNode).unwrap(),e.isFunction(this.config.remove)&&(b=this.config.remove(b)),b.tagName!==f.DEFAULT_INLINE_TAG||b.hasAttributes()||(b=f(b).unwrap()),b},a.prototype.value=function(a){var b,c,d,g;if(!this.match(a))return void 0;if(this.config.value)return this.config.value(a);if(e.isString(this.config.attribute))return a.getAttribute(this.config.attribute)||void 0;if(e.isString(this.config.style))return a.style[this.config.style]||void 0;if(e.isString(this.config["class"])){for(g=f(a).classes(),c=0,d=g.length;d>c;c++)if(b=g[c],0===b.indexOf(this.config["class"]))return b.slice(this.config["class"].length)}else if(e.isString(this.config.tag))return!0;return void 0},a}(),b.exports=d},{"../lib/dom":17,lodash:1}],11:[function(a,b,c){var d,e,f,g,h,i=function(a,b){function c(){this.constructor=a}for(var d in b)j.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},j={}.hasOwnProperty;g=a("lodash"),h=a("../lib/dom"),d=a("./format"),f=a("../lib/linked-list"),e=function(a){function b(a,c){this.node=a,this.formats=g.clone(c),this.text=h(this.node).text(),this.length=this.text.length,h(this.node).data(b.DATA_KEY,this)}return i(b,a),b.DATA_KEY="leaf",b.isLeafNode=function(a){return h(a).isTextNode()||null==a.firstChild},b.prototype.deleteText=function(a,c){var d;if(c>0)return this.text=this.text.slice(0,a)+this.text.slice(a+c),this.length=this.text.length,null!=h.EMBED_TAGS[this.node.tagName]?(d=document.createTextNode(this.text),h(d).data(b.DATA_KEY,this),this.node=h(this.node).replace(d).get()):h(this.node).text(this.text)},b.prototype.insertText=function(a,c){var d;return this.text=this.text.slice(0,a)+c+this.text.slice(a),h(this.node).isTextNode()?h(this.node).text(this.text):(d=document.createTextNode(c),h(d).data(b.DATA_KEY,this),this.node.tagName===h.DEFAULT_BREAK_TAG?this.node=h(this.node).replace(d).get():(this.node.appendChild(d),this.node=d)),this.length=this.text.length},b}(f.Node),b.exports=e},{"../lib/dom":17,"../lib/linked-list":18,"./format":10,lodash:1}],12:[function(a,b,c){var d,e,f,g,h,i,j,k,l=function(a,b){function c(){this.constructor=a}for(var d in b)m.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},m={}.hasOwnProperty;j=a("lodash"),d=a("rich-text/lib/delta"),k=a("../lib/dom"),e=a("./format"),f=a("./leaf"),g=a("./line"),h=a("../lib/linked-list"),i=a("./normalizer"),g=function(a){function b(a,c){this.doc=a,this.node=c,this.formats={},this.rebuild(),b.__super__.constructor.call(this,this.node)}return l(b,a),b.DATA_KEY="line",b.prototype.buildLeaves=function(a,b){return j.each(k(a).childNodes(),function(a){return function(c){var d;return c=a.doc.normalizer.normalizeNode(c),d=j.clone(b),j.each(a.doc.formats,function(a,b){return!a.isType(e.types.LINE)&&a.match(c)?d[b]=a.value(c):void 0}),f.isLeafNode(c)?a.leaves.append(new f(c,d)):a.buildLeaves(c,d)}}(this))},b.prototype.deleteText=function(a,b){var c,d,e;if(b>0){for(e=this.findLeafAt(a),d=e[0],a=e[1];null!=d&&b>0;)c=Math.min(b,d.length-a),d.deleteText(a,c),b-=c,d=d.next,a=0;return this.rebuild()}},b.prototype.findLeaf=function(a){return null!=a?k(a).data(f.DATA_KEY):void 0},b.prototype.findLeafAt=function(a,b){var c;if(null==b&&(b=!1),a>=this.length-1)return[this.leaves.last,this.leaves.last.length];for(c=this.leaves.first;null!=c;){if(a<c.length||a===c.length&&b)return[c,a];a-=c.length,c=c.next}return[this.leaves.last,a-this.leaves.last.length]},b.prototype.format=function(a,b){var c;return j.isObject(a)?c=a:(c={},c[a]=b),j.each(c,function(a){return function(b,c){var d,f;return f=a.doc.formats[c],null!=f?(f.isType(e.types.LINE)&&(f.config.exclude&&a.formats[f.config.exclude]&&(d=a.doc.formats[f.config.exclude],null!=d&&(a.node=d.remove(a.node),delete a.formats[f.config.exclude])),a.node=f.add(a.node,b)),b?a.formats[c]=b:delete a.formats[c]):void 0}}(this)),this.resetContent()},b.prototype.formatText=function(a,b,c,d){var f,g,h,i,j,l,m,n,o,p;if(l=this.findLeafAt(a),g=l[0],h=l[1],f=this.doc.formats[c],null!=f&&f.config.type!==e.types.LINE){for(;null!=g&&b>0;){if(j=g.next,d&&g.formats[c]!==d||!d&&null!=g.formats[c]){if(p=g.node,null!=g.formats[c]){for(k(p).splitBefore(this.node);!f.match(p);)p=p.parentNode;k(p).split(g.length)}h>0&&(m=k(p).split(h),i=m[0],p=m[1]),g.length>h+b&&(n=k(p).split(b),p=n[0],o=n[1]),f.add(p,d)}b-=g.length-h,h=0,g=j}return this.rebuild()}},b.prototype._insert=function(a,b,c){var d,f,g,h,i,l;return i=this.findLeafAt(a),d=i[0],f=i[1],b=j.reduce(c,function(a){return function(b,c,d){var f;return f=a.doc.formats[d],null==f||f.isType(e.types.LINE)||(b=f.add(b,c)),b}}(this),b),l=k(d.node).split(f),h=l[0],g=l[1],g&&(g=k(g).splitBefore(this.node).get()),this.node.insertBefore(b,g),this.rebuild()},b.prototype.insertEmbed=function(a,b){var c,d,f,g,h,i,l,m;return l=this.findLeafAt(a),d=l[0],f=l[1],m=k(d.node).split(f),i=m[0],g=m[1],c=j.find(Object.keys(b),function(a){return function(b){return a.doc.formats[b].isType(e.types.EMBED)}}(this)),h=this.doc.formats[c].add({},b[c]),b=j.clone(b),delete b[c],this._insert(a,h,b)},b.prototype.insertText=function(a,b,c){var d,e,f;return null==c&&(c={}),b.length>0?(f=this.findLeafAt(a),d=f[0],e=f[1],j.isEqual(d.formats,c)?(d.insertText(e,b),this.resetContent()):this._insert(a,document.createTextNode(b),c)):void 0},b.prototype.optimize=function(){return i.optimizeLine(this.node),this.rebuild()},b.prototype.rebuild=function(a){return null==a&&(a=!1),!a&&null!=this.outerHTML&&this.outerHTML===this.node.outerHTML&&j.all(this.leaves.toArray(),function(a){return function(b){return k(b.node).isAncestor(a.node)}}(this))?!1:(this.node=this.doc.normalizer.normalizeNode(this.node),0!==k(this.node).length()||this.node.querySelector(k.DEFAULT_BREAK_TAG)||this.node.appendChild(document.createElement(k.DEFAULT_BREAK_TAG)),this.leaves=new h,this.formats=j.reduce(this.doc.formats,function(a){return function(b,c,d){return c.isType(e.types.LINE)&&(c.match(a.node)?b[d]=c.value(a.node):delete b[d]),b}}(this),this.formats),this.buildLeaves(this.node,{}),this.resetContent(),!0)},b.prototype.resetContent=function(){return k(this.node).data(b.DATA_KEY,this),this.outerHTML=this.node.outerHTML,this.length=1,this.delta=new d,j.each(this.leaves.toArray(),function(a){return function(b){return a.length+=b.length,null!=k.EMBED_TAGS[b.node.tagName]?a.delta.insert(1,b.formats):a.delta.insert(b.text,b.formats)}}(this)),this.delta.insert("\n",this.formats)},b}(h.Node),b.exports=g},{"../lib/dom":17,"../lib/linked-list":18,"./format":10,"./leaf":11,"./line":12,"./normalizer":13,lodash:1,"rich-text/lib/delta":3}],13:[function(a,b,c){var d,e,f,g;e=a("lodash"),g=a("../lib/dom"),f=function(a){return a=a.replace(/(?:^|[-_])(\w)/g,function(a,b){return b?b.toUpperCase():""}),a.charAt(0).toLowerCase()+a.slice(1)},d=function(){function a(){this.whitelist={styles:{},tags:{}},this.whitelist.tags[g.DEFAULT_BREAK_TAG]=!0,this.whitelist.tags[g.DEFAULT_BLOCK_TAG]=!0,this.whitelist.tags[g.DEFAULT_INLINE_TAG]=!0}return a.ALIASES={STRONG:"B",EM:"I",DEL:"S",STRIKE:"S"},a.ATTRIBUTES={color:"color",face:"fontFamily",size:"fontSize"},a.prototype.addFormat=function(a){return null!=a.tag&&(this.whitelist.tags[a.tag]=!0),null!=a.parentTag&&(this.whitelist.tags[a.parentTag]=!0),null!=a.style?this.whitelist.styles[a.style]=!0:void 0},a.prototype.normalizeLine=function(b){return b=a.wrapInline(b),b=a.handleBreaks(b),"LI"===b.tagName&&a.flattenList(b),b=a.pullBlocks(b),b=this.normalizeNode(b),a.unwrapText(b),null!=b&&null!=g.LIST_TAGS[b.tagName]&&(b=b.firstChild),b},a.prototype.normalizeNode=function(b){return g(b).isTextNode()?b:(e.each(a.ATTRIBUTES,function(a,c){var d;return b.hasAttribute(c)?(d=b.getAttribute(c),"size"===c&&(d=g.convertFontSize(d)),b.style[a]=d,b.removeAttribute(c)):void 0}),("bold"===b.style.fontWeight||b.style.fontWeight>500)&&(b.style.fontWeight="",g(b).wrap(document.createElement("b")),b=b.parentNode),this.whitelistStyles(b),this.whitelistTags(b))},a.prototype.whitelistStyles=function(a){var b,c;return b=g(a).styles(),c=e.omit(b,function(a){return function(b,c){return null==a.whitelist.styles[f(c)]}}(this)),Object.keys(c).length<Object.keys(b).length?Object.keys(c).length>0?g(a).styles(c,!0):a.removeAttribute("style"):void 0},a.prototype.whitelistTags=function(b){return g(b).isElement()?(null!=a.ALIASES[b.tagName]?b=g(b).switchTag(a.ALIASES[b.tagName]).get():null==this.whitelist.tags[b.tagName]&&(b=null!=g.BLOCK_TAGS[b.tagName]?g(b).switchTag(g.DEFAULT_BLOCK_TAG).get():b.hasAttributes()||null==b.firstChild?g(b).switchTag(g.DEFAULT_INLINE_TAG).get():g(b).unwrap()),b):b},a.flattenList=function(a){var b,c,d;return d=a.nextSibling,b=e.map(a.querySelectorAll("li")),b.forEach(function(b){return a.parentNode.insertBefore(b,d),d=b.nextSibling}),c=e.map(a.querySelectorAll(Object.keys(g.LIST_TAGS).join(","))),c.forEach(function(a){return g(a).remove()})},a.handleBreaks=function(a){var b;return b=e.map(a.querySelectorAll(g.DEFAULT_BREAK_TAG)),e.each(b,function(b){return function(b){return null==b.nextSibling||g.isIE(10)&&null==b.previousSibling?void 0:g(b.nextSibling).splitBefore(a.parentNode)}}(this)),a},a.optimizeLine=function(a){var b,c,d,f;for(a.normalize(),b=g(a).length(),d=g(a).descendants(),f=[];d.length>0;)c=d.pop(),null!=(null!=c?c.parentNode:void 0)&&null==g.EMBED_TAGS[c.tagName]&&(c.tagName===g.DEFAULT_BREAK_TAG?0!==b?f.push(g(c).remove()):f.push(void 0):0===g(c).length()?(d.push(c.nextSibling),f.push(g(c).unwrap())):null!=c.previousSibling&&c.tagName===c.previousSibling.tagName&&e.isEqual(g(c).attributes(),g(c.previousSibling).attributes())?(d.push(c.firstChild),f.push(g(c.previousSibling).merge(c))):f.push(void 0));return f},a.pullBlocks=function(b){var c;for(c=b.firstChild;null!=c;){if(null!=g.BLOCK_TAGS[c.tagName]&&"LI"!==c.tagName){g(c).isolate(b.parentNode),null!=g.LIST_TAGS[c.tagName]&&c.firstChild?(g(c.parentNode).unwrap(),null==b.parentNode&&(b=c)):(g(c).unwrap(),a.pullBlocks(b));break}c=c.nextSibling}return b},a.stripComments=function(a){return a.replace(/<!--[\s\S]*?-->/g,"")},a.stripWhitespace=function(a){return a=a.trim(),a=a.replace(/(\r?\n|\r)+/g," "),a=a.replace(/\>\s+\</g,"><")},a.wrapInline=function(a){var b,c;if(null!=g.BLOCK_TAGS[a.tagName])return a;for(b=document.createElement(g.DEFAULT_BLOCK_TAG),a.parentNode.insertBefore(b,a);null!=a&&null==g.BLOCK_TAGS[a.tagName];)c=a.nextSibling,b.appendChild(a),a=c;return b},a.unwrapText=function(a){var b;return b=e.map(a.querySelectorAll(g.DEFAULT_INLINE_TAG)),e.each(b,function(a){return a.hasAttributes()?void 0:g(a).unwrap()})},a}(),b.exports=d},{"../lib/dom":17,lodash:1}],14:[function(a,b,c){var d,e,f,g,h,i;h=a("lodash"),i=a("../lib/dom"),d=a("./leaf"),e=a("./normalizer"),f=a("../lib/range"),g=function(){function a(a,b){this.doc=a,this.emitter=b,this.focus=!1,this.range=new f(0,0),this.nullDelay=!1,this.update("silent")}return a.prototype.checkFocus=function(){return document.activeElement===this.doc.root},a.prototype.getRange=function(a){var b,c,d;return null==a&&(a=!1),this.checkFocus()?(c=this._getNativeRange(),null==c?null:(d=this._positionToIndex(c.startContainer,c.startOffset),b=c.startContainer===c.endContainer&&c.startOffset===c.endOffset?d:this._positionToIndex(c.endContainer,c.endOffset),new f(Math.min(d,b),Math.max(d,b)))):a?this.range:null},a.prototype.preserve=function(a){var b,c,d,e,f,g,h,i,j;return d=this._getNativeRange(),null!=d&&this.checkFocus()?(e=this._encodePosition(d.startContainer,d.startOffset),i=e[0],j=e[1],f=this._encodePosition(d.endContainer,d.endOffset),b=f[0],c=f[1],a(),g=this._decodePosition(i,j),i=g[0],j=g[1],h=this._decodePosition(b,c),b=h[0],c=h[1],this._setNativeRange(i,j,b,c)):a()},a.prototype.scrollIntoView=function(){var a,b,c,d,e,f,g,h,i;if(this.range)return c=this.emitter.editor,i=c.getBounds(this.range.start),d=this.range.isCollapsed()?i:c.getBounds(this.range.end),a=c.root.parentNode.getBoundingClientRect(),b=a.bottom-a.top,
b<d.top+d.height?(g=c.doc.findLineAt(this.range.end),e=g[0],f=g[1],e.node.scrollIntoView(!1)):i.top<0?(h=c.doc.findLineAt(this.range.start),e=h[0],f=h[1],e.node.scrollIntoView()):void 0},a.prototype.setRange=function(a,b){var c,d,e,f,g,h,i;return null!=a?(e=this._indexToPosition(a.start),h=e[0],i=e[1],a.isCollapsed()?(f=[h,i],c=f[0],d=f[1]):(g=this._indexToPosition(a.end),c=g[0],d=g[1]),this._setNativeRange(h,i,c,d)):this._setNativeRange(null),this.update(b)},a.prototype.shiftAfter=function(a,b,c){var d;return d=this.getRange(),c(),null!=d?(d.shift(a,b),this.setRange(d,"silent")):void 0},a.prototype.update=function(a){var b,c,d,e;return c=this.checkFocus(),d=this.getRange(!0),b="silent"!==a&&(!f.compare(d,this.range)||c!==this.focus),e=c?d:null,null!==e||"user"!==a||this.nullDelay?(this.nullDelay=!1,this.range=d,this.focus=c,b?this.emitter.emit(this.emitter.constructor.events.SELECTION_CHANGE,e,a):void 0):this.nullDelay=!0},a.prototype._decodePosition=function(a,b){var c;return i(a).isElement()&&(c=i(a.parentNode).childNodes().indexOf(a),b+=c,a=a.parentNode),[a,b]},a.prototype._encodePosition=function(a,b){for(var c;;){if(i(a).isTextNode()||a.tagName===i.DEFAULT_BREAK_TAG||null!=i.EMBED_TAGS[a.tagName])return[a,b];if(b<a.childNodes.length)a=a.childNodes[b],b=0;else{if(0===a.childNodes.length)return null==this.doc.normalizer.whitelist.tags[a.tagName]&&(c=document.createTextNode(""),a.appendChild(c),a=c),[a,0];if(a=a.lastChild,!i(a).isElement())return[a,i(a).length()];if(a.tagName===i.DEFAULT_BREAK_TAG||null!=i.EMBED_TAGS[a.tagName])return[a,1];b=a.childNodes.length}}},a.prototype._getNativeRange=function(){var a,b;return b=document.getSelection(),(null!=b?b.rangeCount:void 0)>0&&(a=b.getRangeAt(0),i(a.startContainer).isAncestor(this.doc.root,!0)&&(a.startContainer===a.endContainer||i(a.endContainer).isAncestor(this.doc.root,!0)))?a:null},a.prototype._indexToPosition=function(a){var b,c,d;return 0===this.doc.lines.length?[this.doc.root,0]:(d=this.doc.findLeafAt(a,!0),b=d[0],c=d[1],this._decodePosition(b.node,c))},a.prototype._positionToIndex=function(a,b){var c,d,e,f,g,h;if(i.isIE(10)&&"BR"===a.tagName&&1===b&&(b=0),h=this._encodePosition(a,b),d=h[0],b=h[1],f=this.doc.findLine(d),null==f)return 0;for(c=f.findLeaf(d),g=0;null!=f.prev;)f=f.prev,g+=f.length;if(null==c)return g;for(e=0;null!=c.prev;)c=c.prev,e+=c.length;return g+e+b},a.prototype._setNativeRange=function(a,b,c,d){var e,f;if(f=document.getSelection())if(null!=a){if(this.checkFocus()||this.doc.root.focus(),e=this._getNativeRange(),null==e||a!==e.startContainer||b!==e.startOffset||c!==e.endContainer||d!==e.endOffset)return f.removeAllRanges(),e=document.createRange(),e.setStart(a,b),e.setEnd(c,d),f.addRange(e)}else if(f.removeAllRanges(),this.doc.root.blur(),i.isIE(11)&&!i.isIE(9))return document.body.focus()},a}(),b.exports=g},{"../lib/dom":17,"../lib/range":20,"./leaf":11,"./normalizer":13,lodash:1}],15:[function(a,b,c){a("./modules/authorship"),a("./modules/image-tooltip"),a("./modules/keyboard"),a("./modules/link-tooltip"),a("./modules/multi-cursor"),a("./modules/paste-manager"),a("./modules/toolbar"),a("./modules/tooltip"),a("./modules/undo-manager"),b.exports=a("./quill")},{"./modules/authorship":21,"./modules/image-tooltip":22,"./modules/keyboard":23,"./modules/link-tooltip":24,"./modules/multi-cursor":25,"./modules/paste-manager":26,"./modules/toolbar":27,"./modules/tooltip":28,"./modules/undo-manager":29,"./quill":30}],16:[function(a,b,c){var d,e,f,g=function(a,b){function c(){this.constructor=a}for(var d in b)h.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},h={}.hasOwnProperty;f=a("./dom"),e=a("./picker"),d=function(a){function b(){b.__super__.constructor.apply(this,arguments),f(this.container).addClass("ql-color-picker")}return g(b,a),b.prototype.buildItem=function(a,c,d){var e;return e=b.__super__.buildItem.call(this,a,c,d),e.style.backgroundColor=c.value,e},b}(e),b.exports=d},{"./dom":17,"./picker":19}],17:[function(a,b,c){var d,e,f,g,h,i=function(a,b){return function(){return a.apply(b,arguments)}},j=function(a,b){function c(){this.constructor=a}for(var d in b)k.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},k={}.hasOwnProperty;f=a("lodash"),h=null,e=function(){function a(a){this.node=a,this.trigger=i(this.trigger,this)}return a.prototype.addClass=function(a){return this.hasClass(a)?void 0:(null!=this.node.classList?this.node.classList.add(a):null!=this.node.className&&(this.node.className=(this.node.className+" "+a).trim()),this)},a.prototype.attributes=function(a){var b,c,d,e,g,h;if(a)return f.each(a,function(a){return function(b,c){return a.node.setAttribute(c,b)}}(this)),this;if(null==this.node.attributes)return{};for(a={},g=this.node.attributes,c=d=0,e=g.length;e>d;c=++d)h=g[c],b=this.node.attributes[c],a[b.name]=b.value;return a},a.prototype.child=function(a){var b,c;for(b=this.node.firstChild,c=g(b).length();null!=b&&!(c>a);)a-=c,b=b.nextSibling,c=g(b).length();return null==b&&(b=this.node.lastChild,a=g(b).length()),[b,a]},a.prototype.childNodes=function(){return f.map(this.node.childNodes)},a.prototype.classes=function(){return this.node.className.split(/\s+/)},a.prototype.data=function(a,b){var c;return null!=b?(null==this.node["ql-data"]&&(this.node["ql-data"]={}),this.node["ql-data"][a]=b,this):null!=(c=this.node["ql-data"])?c[a]:void 0},a.prototype.descendants=function(){return f.map(this.node.getElementsByTagName("*"))},a.prototype.get=function(){return this.node},a.prototype.hasClass=function(a){return null!=this.node.classList?this.node.classList.contains(a):null!=this.node.className?this.classes().indexOf(a)>-1:!1},a.prototype.isAncestor=function(a,b){var c;if(null==b&&(b=!1),a===this.node)return b;for(c=this.node;c;){if(c===a)return!0;c=c.parentNode}return!1},a.prototype.isElement=function(){var a;return(null!=(a=this.node)?a.nodeType:void 0)===g.ELEMENT_NODE},a.prototype.isTextNode=function(){var a;return(null!=(a=this.node)?a.nodeType:void 0)===g.TEXT_NODE},a.prototype.isolate=function(a){return null!=this.node.nextSibling&&g(this.node.nextSibling).splitBefore(a),this.splitBefore(a),this},a.prototype.length=function(){var a;return null==this.node?0:(a=this.text().length,this.isElement()&&(a+=this.node.querySelectorAll(Object.keys(g.EMBED_TAGS).join(",")).length),a)},a.prototype.merge=function(a){var b;return b=g(a),this.isElement()?(b.moveChildren(this.node),this.normalize()):this.text(this.text()+b.text()),b.remove(),this},a.prototype.moveChildren=function(a){return f.each(this.childNodes(),function(b){return a.appendChild(b)}),this},a.prototype.nextLineNode=function(a){var b;return b=this.node.nextSibling,null==b&&this.node.parentNode!==a&&(b=this.node.parentNode.nextSibling),null!=b&&null!=g.LIST_TAGS[b.tagName]&&(b=b.firstChild),b},a.prototype.normalize=function(){var a,b,c,d;for(b=this.node.firstChild;null!=b;)d=b.nextSibling,a=g(b),null!=d&&g(d).isTextNode()&&(0===a.text().length?a.remove():a.isTextNode()&&(c=d.nextSibling,a.merge(d),d=c)),b=d;return this},a.prototype.on=function(a,b){return this.node.addEventListener(a,function(c){return function(d){var e,f;return e=!h||"keydown"!==a&&"keyup"!==a?d:h,f=b.call(c.node,e),f||(d.preventDefault(),d.stopPropagation()),f}}(this)),this},a.prototype.remove=function(){var a;return null!=(a=this.node.parentNode)&&a.removeChild(this.node),this.node=null,null},a.prototype.removeClass=function(a){var b;if(this.hasClass(a))return null!=this.node.classList?this.node.classList.remove(a):null!=this.node.className&&(b=this.classes(),b.splice(b.indexOf(a),1),this.node.className=b.join(" ")),this.node.getAttribute("class")||this.node.removeAttribute("class"),this},a.prototype.replace=function(a){return this.node.parentNode.replaceChild(a,this.node),this.node=a,this},a.prototype.splitBefore=function(a,b){var c,d,e,f;if(null==b&&(b=!1),this.node===a||this.node.parentNode===a)return this;if(null!=this.node.previousSibling||b){for(e=this.node.parentNode,d=e.cloneNode(!1),e.parentNode.insertBefore(d,e.nextSibling),f=this.node;null!=f;)c=f.nextSibling,d.appendChild(f),f=c;return g(d).splitBefore(a)}return g(this.node.parentNode).splitBefore(a)},a.prototype.split=function(a,b){var c,d,e,f,h,i,j,k,l,m;if(null==b&&(b=!1),j=this.length(),a=Math.max(0,a),a=Math.min(a,j),!b&&0===a)return[this.node.previousSibling,this.node,!1];if(!b&&a===j)return[this.node,this.node.nextSibling,!1];if(this.node.nodeType===g.TEXT_NODE)return c=this.node.splitText(a),[this.node,c,!0];for(h=this.node,m=this.node.cloneNode(!1),this.node.parentNode.insertBefore(m,h.nextSibling),k=this.child(a),d=k[0],a=k[1],l=g(d).split(a),e=l[0],f=l[1];null!==f;)i=f.nextSibling,m.appendChild(f),f=i;return[h,m,!0]},a.prototype.styles=function(a,b){var c,d;return null==b&&(b=!1),a?(b||(a=f.defaults(a,this.styles())),d=f.map(a,function(a,b){return b+": "+a}).join("; ")+";",this.node.setAttribute("style",d),this):(d=this.node.getAttribute("style")||"",c=f.reduce(d.split(";"),function(a,b){var c,d,e;return d=b.split(":"),c=d[0],e=d[1],c&&e&&(c=c.trim(),e=e.trim(),a[c.toLowerCase()]=e),a},{}))},a.prototype.switchTag=function(a){var b,c;return a=a.toUpperCase(),this.node.tagName===a?this:(c=document.createElement(a),b=this.attributes(),null==g.VOID_TAGS[a]&&this.moveChildren(c),this.replace(c),this.node=c,this.attributes(b))},a.prototype.text=function(a){if(null!=a){switch(this.node.nodeType){case g.ELEMENT_NODE:this.node.textContent=a;break;case g.TEXT_NODE:this.node.data=a}return this}switch(this.node.nodeType){case g.ELEMENT_NODE:return this.node.tagName===g.DEFAULT_BREAK_TAG?"":null!=g.EMBED_TAGS[this.node.tagName]?g.EMBED_TEXT:null!=this.node.textContent?this.node.textContent:"";case g.TEXT_NODE:return this.node.data||"";default:return""}},a.prototype.textNodes=function(){var a,b,c;for(c=document.createTreeWalker(this.node,NodeFilter.SHOW_TEXT,null,!1),b=[];a=c.nextNode();)b.push(a);return b},a.prototype.toggleClass=function(a,b){return null==b&&(b=!this.hasClass(a)),b?this.addClass(a):this.removeClass(a),this},a.prototype.trigger=function(a,b){var c,d,e;return null==b&&(b={}),["keypress","keydown","keyup"].indexOf(a)<0?(c=document.createEvent("Event"),c.initEvent(a,b.bubbles,b.cancelable)):(c=document.createEvent("KeyboardEvent"),h=f.clone(b),f.isNumber(b.key)?h.which=b.key:f.isString(b.key)?h.which=b.key.toUpperCase().charCodeAt(0):h.which=0,g.isIE(10)?(e=[],b.altKey&&e.push("Alt"),b.ctrlKey&&e.push("Control"),b.metaKey&&e.push("Meta"),b.shiftKey&&e.push("Shift"),c.initKeyboardEvent(a,b.bubbles,b.cancelable,window,0,0,e.join(" "),null,null)):(d=f.isFunction(c.initKeyboardEvent)?"initKeyboardEvent":"initKeyEvent",c[d](a,b.bubbles,b.cancelable,window,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey,0,0))),this.node.dispatchEvent(c),h=null,this},a.prototype.unwrap=function(){var a,b;return b=this.node.firstChild,a=this.node.nextSibling,f.each(this.childNodes(),function(b){return function(c){return b.node.parentNode.insertBefore(c,a)}}(this)),this.remove(),b},a.prototype.wrap=function(a){var b;for(null!=this.node.parentNode&&this.node.parentNode.insertBefore(a,this.node),b=a;null!=b.firstChild;)b=a.firstChild;return b.appendChild(this.node),this},a}(),d=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return j(b,a),b.prototype["default"]=function(){return this.node.querySelector("option[selected]")},b.prototype.option=function(a,b){var c,d,e,g,h,i;if(null==b&&(b=!0),i=f.isElement(a)?a.value:a){for(i=i.replace(/[^\w]+/g,""),h=this.node.children,d=e=0,g=h.length;g>e;d=++e)if(c=h[d],c.value.replace(/[^\w]+/g,"")===i){this.node.selectedIndex=d;break}}else this.node.selectedIndex=-1;return b&&this.trigger("change"),this},b.prototype.reset=function(a){var b;return null==a&&(a=!0),b=this["default"](),null!=b?b.selected=!0:this.node.selectedIndex=0,a&&this.trigger("change"),this},b.prototype.value=function(){return this.node.selectedIndex>-1?this.node.options[this.node.selectedIndex].value:""},b}(e),g=function(a){return"SELECT"===(null!=a?a.tagName:void 0)?new d(a):new e(a)},g=f.extend(g,{ELEMENT_NODE:1,NOBREAK_SPACE:"&nbsp;",TEXT_NODE:3,ZERO_WIDTH_NOBREAK_SPACE:"\ufeff",DEFAULT_BLOCK_TAG:"DIV",DEFAULT_BREAK_TAG:"BR",DEFAULT_INLINE_TAG:"SPAN",EMBED_TEXT:"!",FONT_SIZES:{"10px":1,"13px":2,"16px":3,"18px":4,"24px":5,"32px":6,"48px":7},KEYS:{BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46},BLOCK_TAGS:{ADDRESS:"ADDRESS",ARTICLE:"ARTICLE",ASIDE:"ASIDE",AUDIO:"AUDIO",BLOCKQUOTE:"BLOCKQUOTE",CANVAS:"CANVAS",DD:"DD",DIV:"DIV",DL:"DL",FIGCAPTION:"FIGCAPTION",FIGURE:"FIGURE",FOOTER:"FOOTER",FORM:"FORM",H1:"H1",H2:"H2",H3:"H3",H4:"H4",H5:"H5",H6:"H6",HEADER:"HEADER",HGROUP:"HGROUP",LI:"LI",OL:"OL",OUTPUT:"OUTPUT",P:"P",PRE:"PRE",SECTION:"SECTION",TABLE:"TABLE",TBODY:"TBODY",TD:"TD",TFOOT:"TFOOT",TH:"TH",THEAD:"THEAD",TR:"TR",UL:"UL",VIDEO:"VIDEO"},EMBED_TAGS:{IMG:"IMG"},LINE_TAGS:{DIV:"DIV",LI:"LI"},LIST_TAGS:{OL:"OL",UL:"UL"},VOID_TAGS:{AREA:"AREA",BASE:"BASE",BR:"BR",COL:"COL",COMMAND:"COMMAND",EMBED:"EMBED",HR:"HR",IMG:"IMG",INPUT:"INPUT",KEYGEN:"KEYGEN",LINK:"LINK",META:"META",PARAM:"PARAM",SOURCE:"SOURCE",TRACK:"TRACK",WBR:"WBR"},convertFontSize:function(a){var b,c,d,e;f.isString(a)&&a.indexOf("px")>-1?(d=Object.keys(g.FONT_SIZES),e=f.values(g.FONT_SIZES)):(e=Object.keys(g.FONT_SIZES),d=f.values(g.FONT_SIZES));for(b in d)if(c=d[b],parseInt(a)<=parseInt(c))return e[b];return f.last(e)},isIE:function(a){var b;return b=document.documentMode,b&&a>=b},isIOS:function(){return/iPhone|iPad/i.test(navigator.userAgent)},isMac:function(){return/Mac/i.test(navigator.platform)}}),b.exports=g},{lodash:1}],18:[function(a,b,c){var d,e;e=function(){function a(a){this.data=a,this.prev=this.next=null}return a}(),d=function(){function a(){this.length=0,this.first=this.last=null}return a.Node=e,a.prototype.append=function(a){return null!=this.first?(a.next=null,this.last.next=a):this.first=a,a.prev=this.last,this.last=a,this.length+=1},a.prototype.insertAfter=function(a,b){return b.prev=a,null!=a?(b.next=a.next,null!=a.next&&(a.next.prev=b),a.next=b,a===this.last&&(this.last=b)):(b.next=this.first,this.first.prev=b,this.first=b),this.length+=1},a.prototype.remove=function(a){return this.length>1?(null!=a.prev&&(a.prev.next=a.next),null!=a.next&&(a.next.prev=a.prev),a===this.first&&(this.first=a.next),a===this.last&&(this.last=a.prev)):this.first=this.last=null,a.prev=a.next=null,this.length-=1},a.prototype.toArray=function(){var a,b;for(a=[],b=this.first;null!=b;)a.push(b),b=b.next;return a},a}(),b.exports=d},{}],19:[function(a,b,c){var d,e,f;e=a("lodash"),f=a("./dom"),d=function(){function a(a){this.select=a,this.container=document.createElement("span"),this.buildPicker(),f(this.container).addClass("ql-picker"),this.select.style.display="none",this.select.parentNode.insertBefore(this.container,this.select),f(document).on("click",function(a){return function(){return a.close(),!0}}(this)),f(this.label).on("click",function(a){return function(){return e.defer(function(){return f(a.container).toggleClass("ql-expanded")}),!1}}(this)),f(this.select).on("change",function(a){return function(){var b,c;return a.select.selectedIndex>-1&&(b=a.container.querySelectorAll(".ql-picker-item")[a.select.selectedIndex],c=a.select.options[a.select.selectedIndex]),a.selectItem(b,!1),f(a.label).toggleClass("ql-active",c!==f(a.select)["default"]())}}(this))}return a.TEMPLATE='<span class="ql-picker-label"></span><span class="ql-picker-options"></span>',a.prototype.buildItem=function(a,b,c){var d;return d=document.createElement("span"),d.setAttribute("data-value",b.getAttribute("value")),f(d).addClass("ql-picker-item").text(f(b).text()).on("click",function(a){return function(){return a.selectItem(d,!0),a.close()}}(this)),this.select.selectedIndex===c&&this.selectItem(d,!1),d},a.prototype.buildPicker=function(){var b;return e.each(f(this.select).attributes(),function(a){return function(b,c){return a.container.setAttribute(c,b)}}(this)),this.container.innerHTML=a.TEMPLATE,this.label=this.container.querySelector(".ql-picker-label"),b=this.container.querySelector(".ql-picker-options"),e.each(this.select.options,function(a){return function(c,d){var e;return e=a.buildItem(b,c,d),b.appendChild(e)}}(this))},a.prototype.close=function(){return f(this.container).removeClass("ql-expanded")},a.prototype.selectItem=function(a,b){var c,d;return c=this.container.querySelector(".ql-selected"),null!=c&&f(c).removeClass("ql-selected"),null!=a?(d=a.getAttribute("data-value"),f(a).addClass("ql-selected"),f(this.label).text(f(a).text()),f(this.select).option(d,b),this.label.setAttribute("data-value",d)):(this.label.innerHTML="&nbsp;",this.label.removeAttribute("data-value"))},a}(),b.exports=d},{"./dom":17,lodash:1}],20:[function(a,b,c){var d,e;e=a("lodash"),d=function(){function a(a,b){this.start=a,this.end=b}return a.compare=function(a,b){return a===b?!0:null==a||null==b?!1:a.equals(b)},a.prototype.equals=function(a){return null==a?!1:this.start===a.start&&this.end===a.end},a.prototype.shift=function(a,b){var c;return c=e.map([this.start,this.end],function(c){return a>c?c:b>=0?c+b:Math.max(a,c+b)}),this.start=c[0],this.end=c[1],c},a.prototype.isCollapsed=function(){return this.start===this.end},a}(),b.exports=d},{lodash:1}],21:[function(a,b,c){var d,e,f,g,h;f=a("../quill"),g=f.require("lodash"),h=f.require("dom"),e=f.require("delta"),d=function(){function a(a,b){this.quill=a,this.options=b,null!=this.options.button&&this.attachButton(this.options.button),this.options.enabled&&this.enable(),this.quill.addFormat("author",{"class":"author-"}),null!=this.options.authorId&&(this.quill.on(this.quill.constructor.events.PRE_EVENT,function(a){return function(b,c,d){var h,i;return b===a.quill.constructor.events.TEXT_CHANGE&&"user"===d?(h=new e,i={author:a.options.authorId},g.each(c.ops,function(b){return null==b["delete"]?null!=b.insert||null!=b.retain&&null!=b.attributes?(b.attributes||(b.attributes={}),b.attributes.author=a.options.authorId,h.retain(b.retain||b.insert.length||1,i)):h.retain(b.retain):void 0}),a.quill.updateContents(h,f.sources.SILENT)):void 0}}(this)),this.addAuthor(this.options.authorId,this.options.color))}return a.DEFAULTS={authorId:null,color:"transparent",enabled:!1},a.prototype.addAuthor=function(a,b){var c;return c={},c[".authorship .author-"+a]={"background-color":""+b},this.quill.theme.addStyles(c)},a.prototype.attachButton=function(a){var b;return b=h(a),b.on("click",function(a){return function(){return b.toggleClass("ql-on"),a.enable($dom.hasClass("ql-on"))}}(this))},a.prototype.enable=function(a){return null==a&&(a=!0),h(this.quill.root).toggleClass("authorship",a)},a.prototype.disable=function(){return this.enable(!1)},a}(),f.registerModule("authorship",d),b.exports=d},{"../quill":30}],22:[function(a,b,c){var d,e,f,g,h,i,j,k=function(a,b){function c(){this.constructor=a}for(var d in b)l.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},l={}.hasOwnProperty;f=a("../quill"),h=a("./tooltip"),i=f.require("lodash"),j=f.require("dom"),d=f.require("delta"),g=f.require("range"),e=function(a){function b(a,c){this.quill=a,this.options=c,this.options=i.defaults(this.options,h.DEFAULTS),b.__super__.constructor.call(this,this.quill,this.options),this.preview=this.container.querySelector(".preview"),this.textbox=this.container.querySelector(".input"),j(this.container).addClass("ql-image-tooltip"),this.initListeners()}return k(b,a),b.DEFAULTS={template:'<input class="input" type="textbox"> <div class="preview"> <span>Preview</span> </div> <a href="javascript:;" class="cancel">Cancel</a> <a href="javascript:;" class="insert">Insert</a>'},b.prototype.initListeners=function(){return j(this.quill.root).on("focus",i.bind(this.hide,this)),j(this.container.querySelector(".insert")).on("click",i.bind(this.insertImage,this)),j(this.container.querySelector(".cancel")).on("click",i.bind(this.hide,this)),j(this.textbox).on("input",i.bind(this._preview,this)),this.initTextbox(this.textbox,this.insertImage,this.hide),this.quill.onModuleLoad("toolbar",function(a){return function(b){return a.toolbar=b,b.initFormat("image",i.bind(a._onToolbar,a))}}(this))},b.prototype.insertImage=function(){var a,b;return b=this._normalizeURL(this.textbox.value),null==this.range&&(this.range=new g(0,0)),this.range&&(this.preview.innerHTML="<span>Preview</span>",this.textbox.value="",a=this.range.end,this.quill.insertEmbed(a,"image",b,"user"),this.quill.setSelection(a+1,a+1)),this.hide()},b.prototype._onToolbar=function(a,b){return b?(this.textbox.value||(this.textbox.value="http://"),this.show(),this.textbox.focus(),i.defer(function(a){return function(){return a.textbox.setSelectionRange(a.textbox.value.length,a.textbox.value.length)}}(this))):(this.quill.deleteText(a,"user"),this.toolbar.setActive("image",!1))},b.prototype._preview=function(){var a;if(this._matchImageURL(this.textbox.value))return"IMG"===this.preview.firstChild.tagName?this.preview.firstChild.setAttribute("src",this.textbox.value):(a=document.createElement("img"),a.setAttribute("src",this.textbox.value),this.preview.replaceChild(a,this.preview.firstChild))},b.prototype._matchImageURL=function(a){return/^https?:\/\/.+\.(jpe?g|gif|png)$/.test(a)},b.prototype._normalizeURL=function(a){return/^https?:\/\//.test(a)||(a="http://"+a),a},b}(h),f.registerModule("image-tooltip",e),b.exports=e},{"../quill":30,"./tooltip":28}],23:[function(a,b,c){var d,e,f,g,h;f=a("../quill"),g=f.require("lodash"),h=f.require("dom"),d=f.require("delta"),e=function(){function a(a,b){this.quill=a,this.hotkeys={},this._initListeners(),this._initHotkeys(),this.quill.onModuleLoad("toolbar",function(a){return function(b){return a.toolbar=b}}(this))}return a.hotkeys={BOLD:{key:"B",metaKey:!0},INDENT:{key:h.KEYS.TAB},ITALIC:{key:"I",metaKey:!0},OUTDENT:{key:h.KEYS.TAB,shiftKey:!0},UNDERLINE:{key:"U",metaKey:!0}},a.prototype.addHotkey=function(a,b){return Array.isArray(a)||(a=[a]),g.each(a,function(a){return function(c){var d,e;return c=g.isObject(c)?g.clone(c):{key:c},c.callback=b,e=g.isNumber(c.key)?c.key:c.key.toUpperCase().charCodeAt(0),null==(d=a.hotkeys)[e]&&(d[e]=[]),a.hotkeys[e].push(c)}}(this))},a.prototype.removeHotkeys=function(b,c){var d,e,f,h,i;return b=g.isString(b)?b.toUpperCase():b,b=a.hotkeys[b]?a.hotkeys[b]:b,b=g.isObject(b)?b:{key:b},i=g.isNumber(b.key)?b.key:b.key.charCodeAt(0),null==(d=this.hotkeys)[i]&&(d[i]=[]),f=g.partition(this.hotkeys[i],function(a){return g.isEqual(b,g.omit(a,"callback"))&&(!c||c===a.callback)}),h=f[0],e=f[1],this.hotkeys[i]=e,g.map(h,"callback")},a.prototype.toggleFormat=function(a,b){var c,d;return c=a.isCollapsed()?this.quill.getContents(Math.max(0,a.start-1),a.end):this.quill.getContents(a),d=0===c.ops.length||!g.all(c.ops,function(a){var c;return null!=(c=a.attributes)?c[b]:void 0}),a.isCollapsed()?this.quill.prepareFormat(b,d,f.sources.USER):this.quill.formatText(a,b,d,f.sources.USER),null!=this.toolbar?this.toolbar.setActive(b,d):void 0},a.prototype._initEnter=function(){var a;return a=[{key:h.KEYS.ENTER},{key:h.KEYS.ENTER,shiftKey:!0}],this.addHotkey(a,function(a){return function(b,c){var e,h,i,j,k,l;return null==b?!0:(k=a.quill.editor.doc.findLineAt(b.start),i=k[0],j=k[1],l=i.findLeafAt(j),h=l[0],j=l[1],e=(new d).retain(b.start).insert("\n",i.formats)["delete"](b.end-b.start),a.quill.updateContents(e,f.sources.USER),g.each(h.formats,function(b,c){a.quill.prepareFormat(c,b),null!=a.toolbar&&a.toolbar.setActive(c,b)}),a.quill.editor.selection.scrollIntoView(),!1)}}(this))},a.prototype._initDeletes=function(){return this.addHotkey([h.KEYS.DELETE,h.KEYS.BACKSPACE],function(a){return function(b,c){var d,e,g,i;return null!=b&&a.quill.getLength()>0&&(b.start!==b.end?a.quill.deleteText(b.start,b.end,f.sources.USER):c.key===h.KEYS.BACKSPACE?(i=a.quill.editor.doc.findLineAt(b.start),e=i[0],g=i[1],0===g&&(e.formats.bullet||e.formats.list)?(d=e.formats.bullet?"bullet":"list",a.quill.formatLine(b.start,b.start,d,!1,f.sources.USER)):b.start>0&&a.quill.deleteText(b.start-1,b.start,f.sources.USER)):b.start<a.quill.getLength()-1&&a.quill.deleteText(b.start,b.start+1,f.sources.USER)),a.quill.editor.selection.scrollIntoView(),!1}}(this))},a.prototype._initHotkeys=function(){return this.addHotkey(a.hotkeys.INDENT,function(a){return function(b){return a._onTab(b,!1),!1}}(this)),this.addHotkey(a.hotkeys.OUTDENT,function(a){return function(a){return!1}}(this)),g.each(["bold","italic","underline"],function(b){return function(c){return b.addHotkey(a.hotkeys[c.toUpperCase()],function(a){return b.quill.editor.doc.formats[c]&&b.toggleFormat(a,c),!1})}}(this)),this._initDeletes(),this._initEnter()},a.prototype._initListeners=function(){return h(this.quill.root).on("keydown",function(a){return function(b){var c;return c=!1,g.each(a.hotkeys[b.which],function(d){var e;return e=h.isMac()?b.metaKey:b.metaKey||b.ctrlKey,!!d.metaKey==!!e&&!!d.shiftKey==!!b.shiftKey&&!!d.altKey==!!b.altKey?(c=d.callback(a.quill.getSelection(),d,b)===!1||c,!0):void 0}),!c}}(this))},a.prototype._onTab=function(a,b){var c;return null==b&&(b=!1),c=(new d).retain(a.start).insert("	")["delete"](a.end-a.start).retain(this.quill.getLength()-a.end),this.quill.updateContents(c,f.sources.USER),this.quill.setSelection(a.start+1,a.start+1)},a}(),f.registerModule("keyboard",e),b.exports=e},{"../quill":30}],24:[function(a,b,c){var d,e,f,g,h,i=function(a,b){function c(){this.constructor=a}for(var d in b)j.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},j={}.hasOwnProperty;e=a("../quill"),f=a("./tooltip"),g=e.require("lodash"),h=e.require("dom"),d=function(a){function b(a,c){this.quill=a,this.options=c,this.options=g.defaults(this.options,f.DEFAULTS),b.__super__.constructor.call(this,this.quill,this.options),h(this.container).addClass("ql-link-tooltip"),this.textbox=this.container.querySelector(".input"),this.link=this.container.querySelector(".url"),this.initListeners()}return i(b,a),b.DEFAULTS={maxLength:50,template:'<span class="title">Visit URL:&nbsp;</span> <a href="#" class="url" target="_blank" href="about:blank"></a> <input class="input" type="text"> <span>&nbsp;&#45;&nbsp;</span> <a href="javascript:;" class="change">Change</a> <a href="javascript:;" class="remove">Remove</a> <a href="javascript:;" class="done">Done</a>'},b.hotkeys={LINK:{key:"K",metaKey:!0}},b.prototype.initListeners=function(){return this.quill.on(this.quill.constructor.events.SELECTION_CHANGE,function(a){return function(b){var c;if(null!=b&&b.isCollapsed())return c=a._findAnchor(b),c?(a.setMode(c.href,!1),a.show(c)):a.container.style.left!==f.HIDE_MARGIN?(a.range=null,a.hide()):void 0}}(this)),h(this.container.querySelector(".done")).on("click",g.bind(this.saveLink,this)),h(this.container.querySelector(".remove")).on("click",function(a){return function(){return a.removeLink(a.range)}}(this)),h(this.container.querySelector(".change")).on("click",function(a){return function(){return a.setMode(a.link.href,!0)}}(this)),this.initTextbox(this.textbox,this.saveLink,this.hide),this.quill.onModuleLoad("toolbar",function(a){return function(b){return a.toolbar=b,b.initFormat("link",g.bind(a._onToolbar,a))}}(this)),this.quill.onModuleLoad("keyboard",function(a){return function(c){return c.addHotkey(b.hotkeys.LINK,g.bind(a._onKeyboard,a))}}(this))},b.prototype.saveLink=function(){var a,b,c;return c=this._normalizeURL(this.textbox.value),null!=this.range&&(b=this.range.end,this.range.isCollapsed()?(a=this._findAnchor(this.range),null!=a&&(a.href=c)):this.quill.formatText(this.range,"link",c,"user"),this.quill.setSelection(b,b)),this.setMode(c,!1)},b.prototype.removeLink=function(a){return a.isCollapsed()&&(a=this._expandRange(a)),this.hide(),this.quill.formatText(a,"link",!1,"user"),null!=this.toolbar?this.toolbar.setActive("link",!1):void 0},b.prototype.setMode=function(a,b){var c;return null==b&&(b=!1),b?(this.textbox.value=a,g.defer(function(b){return function(){return b.textbox.focus(),b.textbox.setSelectionRange(0,a.length)}}(this))):(this.link.href=a,a=this.link.href,c=a.length>this.options.maxLength?a.slice(0,this.options.maxLength)+"...":a,h(this.link).text(c)),h(this.container).toggleClass("editing",b)},b.prototype._findAnchor=function(a){var b,c,d,e;for(e=this.quill.editor.doc.findLeafAt(a.start,!0),b=e[0],d=e[1],null!=b&&(c=b.node);null!=c&&c!==this.quill.root;){if("A"===c.tagName)return c;c=c.parentNode}return null},b.prototype._expandRange=function(a){var b,c,d,e,f;return e=this.quill.editor.doc.findLeafAt(a.start,!0),c=e[0],d=e[1],f=a.start-d,b=f+c.length,{start:f,end:b}},b.prototype._onToolbar=function(a,b){return this._toggle(a,b)},b.prototype._onKeyboard=function(){var a;return a=this.quill.getSelection(),this._toggle(a,!this._findAnchor(a))},b.prototype._toggle=function(a,b){var c;if(a)return b?a.isCollapsed()?void 0:(this.setMode(this._suggestURL(a),!0),c=this.quill.editor.selection._getNativeRange(),this.show(c)):this.removeLink(a)},b.prototype._normalizeURL=function(a){return/^(https?:\/\/|mailto:)/.test(a)||(a="http://"+a),a},b.prototype._suggestURL=function(a){var b;return b=this.quill.getText(a),this._normalizeURL(b)},b}(f),e.registerModule("link-tooltip",d),b.exports=d},{"../quill":30,"./tooltip":28}],25:[function(a,b,c){var d,e,f,g,h,i=function(a,b){function c(){this.constructor=a}for(var d in b)j.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},j={}.hasOwnProperty;f=a("../quill"),d=a("eventemitter2").EventEmitter2,g=f.require("lodash"),h=f.require("dom"),e=function(a){function b(a,b){this.quill=a,this.options=b,this.cursors={},this.container=this.quill.addContainer("ql-multi-cursor",!0),this.quill.on(this.quill.constructor.events.TEXT_CHANGE,g.bind(this._applyDelta,this))}return i(b,a),b.DEFAULTS={template:'<span class="cursor-flag"> <span class="cursor-name"></span> </span> <span class="cursor-caret"></span>',timeout:2500},b.events={CURSOR_ADDED:"cursor-addded",CURSOR_MOVED:"cursor-moved",CURSOR_REMOVED:"cursor-removed"},b.prototype.clearCursors=function(){return g.each(Object.keys(this.cursors),g.bind(this.removeCursor,this)),this.cursors={}},b.prototype.moveCursor=function(a,b){var c;return c=this.cursors[a],null!=c?(c.index=b,h(c.elem).removeClass("hidden"),clearTimeout(c.timer),c.timer=setTimeout(function(a){return function(){return h(c.elem).addClass("hidden"),c.timer=null}}(this),this.options.timeout),this._updateCursor(c),c):void 0},b.prototype.removeCursor=function(a){var c;return c=this.cursors[a],this.emit(b.events.CURSOR_REMOVED,c),null!=c&&c.elem.parentNode.removeChild(c.elem),delete this.cursors[a]},b.prototype.setCursor=function(a,c,d,e){var f;return null==this.cursors[a]&&(this.cursors[a]=f={userId:a,index:c,color:e,elem:this._buildCursor(d,e)},this.emit(b.events.CURSOR_ADDED,f)),g.defer(function(b){return function(){return b.moveCursor(a,c)}}(this)),this.cursors[a]},b.prototype.shiftCursors=function(a,b,c){return null==c&&(c=null),g.each(this.cursors,function(d){return function(e,f){var g;if(e)return g=Math.max(b,a-e.index),e.userId===c?d.moveCursor(c,e.index+g):e.index>a?e.index+=g:void 0}}(this))},b.prototype.update=function(){return g.each(this.cursors,function(a){return function(b,c){return null!=b?(a._updateCursor(b),!0):void 0}}(this))},b.prototype._applyDelta=function(a){var b;return b=0,g.each(a.ops,function(a){return function(c){var d,e;return d=0,null!=c.insert?(d=c.insert.length||1,a.shiftCursors(b,d,null!=(e=c.attributes)?e.author:void 0)):null!=c["delete"]?a.shiftCursors(b,-1*c["delete"],null):null!=c.retain&&(a.shiftCursors(b,0,null),d=c.retain),b+=d}}(this)),this.update()},b.prototype._buildCursor=function(a,b){var c,d,e,f;return c=document.createElement("span"),h(c).addClass("cursor"),c.innerHTML=this.options.template,e=c.querySelector(".cursor-flag"),f=c.querySelector(".cursor-name"),h(f).text(a),d=c.querySelector(".cursor-caret"),d.style.backgroundColor=f.style.backgroundColor=b,
this.container.appendChild(c),c},b.prototype._updateCursor=function(a){var c,d;return c=this.quill.getBounds(a.index),null==c?this.removeCursor(a.userId):(a.elem.style.top=c.top+this.quill.container.scrollTop+"px",a.elem.style.left=c.left+"px",a.elem.style.height=c.height+"px",d=a.elem.querySelector(".cursor-flag"),h(a.elem).toggleClass("top",parseInt(a.elem.style.top)<=d.offsetHeight).toggleClass("left",parseInt(a.elem.style.left)<=d.offsetWidth).toggleClass("right",this.quill.root.offsetWidth-parseInt(a.elem.style.left)<=d.offsetWidth),this.emit(b.events.CURSOR_MOVED,a))},b}(d),f.registerModule("multi-cursor",e),b.exports=e},{"../quill":30,eventemitter2:2}],26:[function(a,b,c){var d,e,f,g,h,i,j=function(a,b){return function(){return a.apply(b,arguments)}};g=a("../quill"),e=a("../core/document"),h=g.require("lodash"),i=g.require("dom"),d=g.require("delta"),f=function(){function a(b,c){var d;this.quill=b,this._onConvert=j(this._onConvert,this),this.container=this.quill.addContainer("ql-paste-manager"),this.container.setAttribute("contenteditable",!0),this.container.setAttribute("tabindex","-1"),i(this.quill.root).on("paste",h.bind(this._paste,this)),this.options=h.defaults(c,a.DEFAULTS),null==(d=this.options).onConvert&&(d.onConvert=this._onConvert)}return a.DEFAULTS={onConvert:null},a.prototype._onConvert=function(a){var b,c,f;return c=new e(a,this.quill.options),b=c.toDelta(),f=b.length(),0===f?b:b.compose((new d).retain(f-1)["delete"](1))},a.prototype._paste=function(){var a,b;return a=this.quill.getLength(),b=this.quill.getSelection(),null!=b?(this.container.focus(),h.defer(function(a){return function(){var c,d;return c=a.options.onConvert(a.container),d=c.length(),d>0&&(b.start>0&&c.ops.unshift({retain:b.start}),c["delete"](b.end-b.start),a.quill.updateContents(c,"user")),a.quill.setSelection(b.start+d,b.start+d),a.quill.editor.selection.scrollIntoView(),a.container.innerHTML=""}}(this))):void 0},a}(),g.registerModule("paste-manager",f),b.exports=f},{"../core/document":8,"../quill":30}],27:[function(a,b,c){var d,e,f,g;d=a("../quill"),f=d.require("lodash"),g=d.require("dom"),e=function(){function a(b,c){if(this.quill=b,this.options=c,(f.isString(this.options)||f.isElement(this.options))&&(this.options={container:this.options}),null==this.options.container)throw new Error("container required for toolbar",this.options);this.container=f.isString(this.options.container)?document.querySelector(this.options.container):this.options.container,this.inputs={},this.preventUpdate=!1,this.triggering=!1,f.each(this.quill.options.formats,function(b){return function(c){return null==a.formats.TOOLTIP[c]?b.initFormat(c,f.bind(b._applyFormat,b,c)):void 0}}(this)),this.quill.on(d.events.FORMAT_INIT,function(b){return function(c){return null==a.formats.TOOLTIP[c]?b.initFormat(c,f.bind(b._applyFormat,b,c)):void 0}}(this)),this.quill.on(d.events.SELECTION_CHANGE,function(a){return function(b){return null!=b?a.updateActive(b):void 0}}(this)),this.quill.on(d.events.TEXT_CHANGE,function(a){return function(){return a.updateActive()}}(this)),this.quill.onModuleLoad("keyboard",function(a){return function(b){return b.addHotkey([g.KEYS.BACKSPACE,g.KEYS.DELETE],function(){return f.defer(f.bind(a.updateActive,a))})}}(this)),g(this.container).addClass("ql-toolbar"),g.isIOS()&&g(this.container).addClass("ios")}return a.DEFAULTS={container:null},a.formats={LINE:{align:"align",bullet:"bullet",list:"list"},SELECT:{align:"align",background:"background",color:"color",font:"font",size:"size"},TOGGLE:{bold:"bold",bullet:"bullet",image:"image",italic:"italic",link:"link",list:"list",strike:"strike",underline:"underline"},TOOLTIP:{image:"image",link:"link"}},a.prototype.initFormat=function(b,c){var d,e,f;return f=".ql-"+b,null!=a.formats.SELECT[b]?(f="select"+f,d="change"):d="click",e=this.container.querySelector(f),null!=e?(this.inputs[b]=e,g(e).on(d,function(a){return function(){var b,f;return f="change"===d?g(e).value():!g(e).hasClass("ql-active"),a.preventUpdate=!0,a.quill.focus(),b=a.quill.getSelection(),null!=b&&c(b,f),g.isIE(11)&&a.quill.editor.selection.scrollIntoView(),a.preventUpdate=!1,!1}}(this))):void 0},a.prototype.setActive=function(a,b){var c,d,e,f;return"image"===a&&(b=!1),d=this.inputs[a],null!=d?(c=g(d),"SELECT"===d.tagName?(this.triggering=!0,f=c.value(d),null==b&&(b=null!=(e=c["default"]())?e.value:void 0),Array.isArray(b)&&(b=""),b!==f&&(null!=b?c.option(b):c.reset()),this.triggering=!1):c.toggleClass("ql-active",b||!1)):void 0},a.prototype.updateActive=function(a,b){var c;return null==b&&(b=null),a||(a=this.quill.getSelection()),null==a||this.preventUpdate?void 0:(c=this._getActive(a),f.each(this.inputs,function(a){return function(d,e){return(!Array.isArray(b)||b.indexOf(e)>-1)&&a.setActive(e,c[e]),!0}}(this)))},a.prototype._applyFormat=function(b,c,d){return this.triggering?void 0:(c.isCollapsed()?this.quill.prepareFormat(b,d,"user"):null!=a.formats.LINE[b]?this.quill.formatLine(c,b,d,"user"):this.quill.formatText(c,b,d,"user"),f.defer(function(a){return function(){return a.updateActive(c,["bullet","list"]),a.setActive(b,d)}}(this)))},a.prototype._getActive=function(a){var b,c;return b=this._getLeafActive(a),c=this._getLineActive(a),f.defaults({},b,c)},a.prototype._getLeafActive=function(a){var b,c,d,e,g;return a.isCollapsed()?(g=this.quill.editor.doc.findLineAt(a.start),d=g[0],e=g[1],b=0===e?this.quill.getContents(a.start,a.end+1):this.quill.getContents(a.start-1,a.end)):b=this.quill.getContents(a),c=f.map(b.ops,"attributes"),this._intersectFormats(c)},a.prototype._getLineActive=function(a){var b,c,d,e,g,h;for(c=[],g=this.quill.editor.doc.findLineAt(a.start),b=g[0],e=g[1],h=this.quill.editor.doc.findLineAt(a.end),d=h[0],e=h[1],null!=d&&d===b&&(d=d.next);null!=b&&b!==d;)c.push(f.clone(b.formats)),b=b.next;return this._intersectFormats(c)},a.prototype._intersectFormats=function(b){return f.reduce(b.slice(1),function(b,c){var d,e,g,h,i;return null==c&&(c={}),d=Object.keys(b),g=null!=c?Object.keys(c):{},h=f.intersection(d,g),i=f.difference(d,g),e=f.difference(g,d),f.each(h,function(d){if(null!=a.formats.SELECT[d])if(Array.isArray(b[d])){if(b[d].indexOf(c[d])<0)return b[d].push(c[d])}else if(b[d]!==c[d])return b[d]=[b[d],c[d]]}),f.each(i,function(c){return null!=a.formats.TOGGLE[c]?delete b[c]:null==a.formats.SELECT[c]||Array.isArray(b[c])?void 0:b[c]=[b[c]]}),f.each(e,function(d){return null!=a.formats.SELECT[d]?b[d]=[c[d]]:void 0}),b},b[0]||{})},a}(),d.registerModule("toolbar",e),b.exports=e},{"../quill":30}],28:[function(a,b,c){var d,e,f,g;d=a("../quill"),f=d.require("lodash"),g=d.require("dom"),e=function(){function a(b,c){this.quill=b,this.options=c,this.container=this.quill.addContainer("ql-tooltip"),this.container.innerHTML=this.options.template,this.hide(),this.quill.on(this.quill.constructor.events.TEXT_CHANGE,function(b){return function(c,d){return b.container.style.left!==a.HIDE_MARGIN?(b.range=null,b.hide()):void 0}}(this))}return a.DEFAULTS={offset:10,template:""},a.HIDE_MARGIN="-10000px",a.prototype.initTextbox=function(a,b,c){return g(a).on("keydown",function(a){return function(d){switch(d.which){case g.KEYS.ENTER:return d.preventDefault(),b.call(a);case g.KEYS.ESCAPE:return d.preventDefault(),c.call(a);default:return!0}}}(this))},a.prototype.hide=function(){return this.container.style.left=a.HIDE_MARGIN,this.range&&this.quill.setSelection(this.range),this.range=null},a.prototype.position=function(a){var b,c,d,e,f,g,h;return null!=a?(g=a.getBoundingClientRect(),f=this.quill.container.getBoundingClientRect(),d=g.left-f.left,e=g.top-f.top,c=g.bottom-f.bottom,b=d+g.width/2-this.container.offsetWidth/2,h=e+g.height+this.options.offset,h+this.container.offsetHeight>this.quill.container.offsetHeight&&(h=e-this.container.offsetHeight-this.options.offset),b=Math.max(0,Math.min(b,this.quill.container.offsetWidth-this.container.offsetWidth)),h=Math.max(0,Math.min(h,this.quill.container.offsetHeight-this.container.offsetHeight))):(b=this.quill.container.offsetWidth/2-this.container.offsetWidth/2,h=this.quill.container.offsetHeight/2-this.container.offsetHeight/2),h+=this.quill.container.scrollTop,[b,h]},a.prototype.show=function(a){var b,c,d;return this.range=this.quill.getSelection(),c=this.position(a),b=c[0],d=c[1],this.container.style.left=b+"px",this.container.style.top=d+"px",this.container.focus()},a}(),d.registerModule("tooltip",e),b.exports=e},{"../quill":30}],29:[function(a,b,c){var d,e,f,g;e=a("../quill"),g=e.require("lodash"),d=e.require("delta"),f=function(){function a(a,b){this.quill=a,this.options=null!=b?b:{},this.lastRecorded=0,this.ignoreChange=!1,this.clear(),this.initListeners()}return a.DEFAULTS={delay:1e3,maxStack:100,userOnly:!1},a.hotkeys={UNDO:{key:"Z",metaKey:!0},REDO:{key:"Z",metaKey:!0,shiftKey:!0}},a.prototype.initListeners=function(){return this.quill.onModuleLoad("keyboard",function(b){return function(c){var d;return c.addHotkey(a.hotkeys.UNDO,function(){return b.quill.editor.checkUpdate(),b.undo(),!1}),d=[a.hotkeys.REDO],navigator.platform.indexOf("Win")>-1&&d.push({key:"Y",metaKey:!0}),c.addHotkey(d,function(){return b.quill.editor.checkUpdate(),b.redo(),!1})}}(this)),this.quill.on(this.quill.constructor.events.TEXT_CHANGE,function(a){return function(b,c){return a.ignoreChange?void 0:(a.options.userOnly&&c!==e.sources.USER?a._transform(b):a.record(b,a.oldDelta),a.oldDelta=a.quill.getContents())}}(this))},a.prototype.clear=function(){return this.stack={undo:[],redo:[]},this.oldDelta=this.quill.getContents()},a.prototype.record=function(a,b){var c,d,e,f;if(a.ops.length>0){this.stack.redo=[];try{if(f=this.quill.getContents().diff(this.oldDelta),e=(new Date).getTime(),this.lastRecorded+this.options.delay>e&&this.stack.undo.length>0?(c=this.stack.undo.pop(),f=f.compose(c.undo),a=c.redo.compose(a)):this.lastRecorded=e,this.stack.undo.push({redo:a,undo:f}),this.stack.undo.length>this.options.maxStack)return this.stack.undo.unshift()}catch(g){return d=g,console.warn("Could not record change... clearing undo stack."),this.clear()}}},a.prototype.redo=function(){return this._change("redo","undo")},a.prototype.undo=function(){return this._change("undo","redo")},a.prototype._getLastChangeIndex=function(a){var b,c;return c=0,b=0,g.each(a.ops,function(a){return null!=a.insert?c=Math.max(b+(a.insert.length||1),c):null!=a["delete"]?c=Math.max(b,c):null!=a.retain?(null!=a.attributes&&(c=Math.max(b+a.retain,c)),b+=a.retain):void 0}),c},a.prototype._change=function(a,b){var c,d;return this.stack[a].length>0?(c=this.stack[a].pop(),this.lastRecorded=0,this.ignoreChange=!0,this.quill.updateContents(c[a],e.sources.USER),this.ignoreChange=!1,d=this._getLastChangeIndex(c[a]),this.quill.setSelection(d,d),this.oldDelta=this.quill.getContents(),this.stack[b].push(c)):void 0},a.prototype._transform=function(a){var b,c,d,e,f,g,h,i;for(this.oldDelta=a.transform(this.oldDelta,!0),g=this.stack.undo,c=0,e=g.length;e>c;c++)b=g[c],b.undo=a.transform(b.undo,!0),b.redo=a.transform(b.redo,!0);for(h=this.stack.redo,i=[],d=0,f=h.length;f>d;d++)b=h[d],b.undo=a.transform(b.undo,!0),i.push(b.redo=a.transform(b.redo,!0));return i},a}(),e.registerModule("undo-manager",f),b.exports=f},{"../quill":30}],30:[function(a,b,c){var d,e,f,g,h,i,j,k,l,m,n,o=function(a,b){function c(){this.constructor=a}for(var d in b)p.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},p={}.hasOwnProperty,q=[].slice;l=a("lodash"),n=a("../package.json"),d=a("rich-text/lib/delta"),g=a("eventemitter2").EventEmitter2,m=a("./lib/dom"),e=a("./core/document"),f=a("./core/editor"),h=a("./core/format"),i=a("./core/normalizer"),k=a("./lib/range"),j=function(a){function b(a,c){var d,e,g;if(this.container=a,null==c&&(c={}),l.isString(this.container)&&(this.container=document.querySelector(this.container)),null==this.container)throw new Error("Invalid Quill container");if(e=l.defaults(c.modules||{},b.DEFAULTS.modules),d=this.container.innerHTML,this.container.innerHTML="",this.options=l.defaults(c,b.DEFAULTS),this.options.modules=e,this.options.id=this.id="ql-editor-"+(b.editors.length+1),this.modules={},this.root=this.addContainer("ql-editor"),this.editor=new f(this.root,this,this.options),b.editors.push(this),this.setHTML(d,b.sources.SILENT),g=b.themes[this.options.theme],null==g)throw new Error("Cannot load "+this.options.theme+" theme. Are you sure you registered it?");this.theme=new g(this,this.options),l.each(this.options.modules,function(a){return function(b,c){return a.addModule(c,b)}}(this))}return o(b,a),b.version=n.version,b.editors=[],b.modules=[],b.themes=[],b.DEFAULTS={formats:["align","bold","italic","strike","underline","color","background","font","size","link","image","bullet","list"],modules:{keyboard:!0,"paste-manager":!0,"undo-manager":!0},pollInterval:100,readOnly:!1,styles:{},theme:"base"},b.events={FORMAT_INIT:"format-init",MODULE_INIT:"module-init",POST_EVENT:"post-event",PRE_EVENT:"pre-event",SELECTION_CHANGE:"selection-change",TEXT_CHANGE:"text-change"},b.sources=f.sources,b.registerModule=function(a,c){return null!=b.modules[a]&&console.warn("Overwriting "+a+" module"),b.modules[a]=c},b.registerTheme=function(a,c){return null!=b.themes[a]&&console.warn("Overwriting "+a+" theme"),b.themes[a]=c},b.require=function(a){switch(a){case"lodash":return l;case"delta":return d;case"format":return h;case"normalizer":return i;case"dom":return m;case"document":return e;case"range":return k;default:return null}},b.prototype.destroy=function(){var a;return a=this.getHTML(),l.each(this.modules,function(a,b){return l.isFunction(a.destroy)?a.destroy():void 0}),this.editor.destroy(),this.removeAllListeners(),b.editors.splice(l.indexOf(b.editors,this),1),this.container.innerHTML=a},b.prototype.addContainer=function(a,b){var c,d;return null==b&&(b=!1),d=b?this.root:null,c=document.createElement("div"),m(c).addClass(a),this.container.insertBefore(c,d),c},b.prototype.addFormat=function(a,c){return this.editor.doc.addFormat(a,c),this.emit(b.events.FORMAT_INIT,a)},b.prototype.addModule=function(a,c){var d;if(d=b.modules[a],null==d)throw new Error("Cannot load "+a+" module. Are you sure you registered it?");return c===!0&&(c={}),c=l.defaults(c,this.theme.constructor.OPTIONS[a]||{},d.DEFAULTS||{}),this.modules[a]=new d(this,c),this.emit(b.events.MODULE_INIT,a,this.modules[a]),this.modules[a]},b.prototype.deleteText=function(a,c,e){var f,g,h;return null==e&&(e=b.sources.API),h=this._buildParams(a,c,{},e),a=h[0],c=h[1],g=h[2],e=h[3],c>a?(f=(new d).retain(a)["delete"](c-a),this.editor.applyDelta(f,e)):void 0},b.prototype.emit=function(){var a,c;return c=arguments[0],a=2<=arguments.length?q.call(arguments,1):[],b.__super__.emit.apply(this,[b.events.PRE_EVENT,c].concat(q.call(a))),b.__super__.emit.apply(this,[c].concat(q.call(a))),b.__super__.emit.apply(this,[b.events.POST_EVENT,c].concat(q.call(a)))},b.prototype.focus=function(){return this.editor.focus()},b.prototype.formatLine=function(a,b,c,d,e){var f,g,h,i,j;return i=this._buildParams(a,b,c,d,e),a=i[0],b=i[1],f=i[2],e=i[3],j=this.editor.doc.findLineAt(b),g=j[0],h=j[1],null!=g&&(b+=g.length-h),this.formatText(a,b,f,e)},b.prototype.formatText=function(a,b,c,e,f){var g,h,i;return i=this._buildParams(a,b,c,e,f),a=i[0],b=i[1],h=i[2],f=i[3],h=l.reduce(h,function(a){return function(b,c,d){var e;return e=a.editor.doc.formats[d],c&&c!==e.config["default"]||(b[d]=null),b}}(this),h),g=(new d).retain(a).retain(b-a,h),this.editor.applyDelta(g,f)},b.prototype.getBounds=function(a){return this.editor.getBounds(a)},b.prototype.getContents=function(a,b){return null==a&&(a=0),null==b&&(b=null),l.isObject(a)&&(b=a.end,a=a.start),this.editor.delta.slice(a,b)},b.prototype.getHTML=function(){return this.editor.doc.getHTML()},b.prototype.getLength=function(){return this.editor.length},b.prototype.getModule=function(a){return this.modules[a]},b.prototype.getSelection=function(){return this.editor.checkUpdate(),this.editor.selection.getRange()},b.prototype.getText=function(a,b){return null==a&&(a=0),null==b&&(b=null),l.map(this.getContents(a,b).ops,function(a){return l.isString(a.insert)?a.insert:""}).join("")},b.prototype.insertEmbed=function(a,b,c,e){var f,g,h,i;return i=this._buildParams(a,0,b,c,e),a=i[0],g=i[1],h=i[2],e=i[3],f=(new d).retain(a).insert(1,h),this.editor.applyDelta(f,e)},b.prototype.insertText=function(a,b,c,e,f){var g,h,i,j;return j=this._buildParams(a,0,c,e,f),a=j[0],h=j[1],i=j[2],f=j[3],b.length>0?(g=(new d).retain(a).insert(b,i),this.editor.applyDelta(g,f)):void 0},b.prototype.onModuleLoad=function(a,c){return this.modules[a]?c(this.modules[a]):this.on(b.events.MODULE_INIT,function(b,d){return b===a?c(d):void 0})},b.prototype.prepareFormat=function(a,c,d){var e,f;return null==d&&(d=b.sources.API),e=this.editor.doc.formats[a],null!=e&&(f=this.getSelection(),null!=f?f.isCollapsed():void 0)?e.isType(h.types.LINE)?this.formatLine(f,a,c,d):e.prepare(c):void 0},b.prototype.setContents=function(a,c){var e;return null==c&&(c=b.sources.API),a=new d(Array.isArray(a)?a.slice():a.ops.slice()),e=l.last(a.slice(a.length()-1).ops),a["delete"](this.getLength()-1),null!=e&&l.isString(e.insert)&&"\n"===l.last(e.insert)&&a["delete"](1),this.updateContents(a,c)},b.prototype.setHTML=function(a,c){return null==c&&(c=b.sources.API),a.trim()||(a="<"+m.DEFAULT_BLOCK_TAG+"><"+m.DEFAULT_BREAK_TAG+"></"+m.DEFAULT_BLOCK_TAG+">"),this.editor.doc.setHTML(a),this.editor.checkUpdate(c)},b.prototype.setSelection=function(a,c,d){var e;return null==d&&(d=b.sources.API),l.isNumber(a)&&l.isNumber(c)?e=new k(a,c):(e=a,d=c||d),this.editor.selection.setRange(e,d)},b.prototype.setText=function(a,c){var e;return null==c&&(c=b.sources.API),e=(new d).insert(a),this.setContents(e,c)},b.prototype.updateContents=function(a,c){return null==c&&(c=b.sources.API),Array.isArray(a)&&(a={ops:a}),this.editor.applyDelta(a,c)},b.prototype._buildParams=function(){var a,c;return c=1<=arguments.length?q.call(arguments,0):[],l.isObject(c[0])&&c.splice(0,1,c[0].start,c[0].end),l.isString(c[2])&&(a={},a[c[2]]=c[3],c.splice(2,2,a)),null==c[3]&&(c[3]=b.sources.API),c},b}(g),j.registerTheme("base",a("./themes/base")),j.registerTheme("snow",a("./themes/snow")),b.exports=j},{"../package.json":7,"./core/document":8,"./core/editor":9,"./core/format":10,"./core/normalizer":13,"./lib/dom":17,"./lib/range":20,"./themes/base":32,"./themes/snow":33,eventemitter2:2,lodash:1,"rich-text/lib/delta":3}],31:[function(a,b,c){b.exports='.ql-image-tooltip{padding:10px;width:300px}.ql-image-tooltip:after{clear:both;content:"";display:table}.ql-image-tooltip a{border:1px solid #000;box-sizing:border-box;display:inline-block;float:left;padding:5px;text-align:center;width:50%}.ql-image-tooltip img{bottom:0;left:0;margin:auto;max-height:100%;max-width:100%;position:absolute;right:0;top:0}.ql-image-tooltip .input{box-sizing:border-box;width:100%}.ql-image-tooltip .preview{margin:10px 0;position:relative;border:1px dashed #000;height:200px}.ql-image-tooltip .preview span{display:inline-block;position:absolute;text-align:center;top:40%;width:100%}.ql-link-tooltip{padding:5px 10px}.ql-link-tooltip input.input{width:170px}.ql-link-tooltip a.done,.ql-link-tooltip input.input{display:none}.ql-link-tooltip a.change{margin-right:4px}.ql-link-tooltip.editing a.done,.ql-link-tooltip.editing input.input{display:inline-block}.ql-link-tooltip.editing a.change,.ql-link-tooltip.editing a.remove,.ql-link-tooltip.editing a.url{display:none}.ql-multi-cursor{position:absolute;left:0;top:0;z-index:1000}.ql-multi-cursor .cursor{margin-left:-1px;position:absolute}.ql-multi-cursor .cursor-flag{bottom:100%;position:absolute;white-space:nowrap}.ql-multi-cursor .cursor-name{display:inline-block;color:#fff;padding:2px 8px}.ql-multi-cursor .cursor-caret{height:100%;position:absolute;width:2px}.ql-multi-cursor .cursor.hidden .cursor-flag{display:none}.ql-multi-cursor .cursor.top .cursor-flag{bottom:auto;top:100%}.ql-multi-cursor .cursor.right .cursor-flag{right:-2px}.ql-paste-manager{left:-100000px;position:absolute;top:50%}.ql-toolbar{box-sizing:border-box}.ql-tooltip{background-color:#fff;border:1px solid #000;box-sizing:border-box;position:absolute;top:0;white-space:nowrap;z-index:2000}.ql-tooltip a{cursor:pointer;text-decoration:none}.ql-container{box-sizing:border-box;cursor:text;font-family:Helvetica,Arial,sans-serif;font-size:13px;height:100%;line-height:1.42;margin:0;overflow-x:hidden;overflow-y:auto;padding:12px 15px;position:relative}.ql-editor{box-sizing:border-box;min-height:100%;outline:0;tab-size:4;white-space:pre-wrap}.ql-editor div{margin:0;padding:0}.ql-editor a{text-decoration:underline}.ql-editor b{font-weight:700}.ql-editor i{font-style:italic}.ql-editor s{text-decoration:line-through}.ql-editor u{text-decoration:underline}.ql-editor a,.ql-editor b,.ql-editor i,.ql-editor s,.ql-editor span,.ql-editor u{background-color:inherit}.ql-editor img{max-width:100%}.ql-editor blockquote,.ql-editor ol,.ql-editor ul{margin:0 0 0 2em;padding:0}.ql-editor ol{list-style-type:decimal}.ql-editor ul{list-style-type:disc}.ql-editor.ql-ie-10 br,.ql-editor.ql-ie-9 br{display:none}'},{}],32:[function(a,b,c){var d,e,f,g;e=a("lodash"),g=a("../../lib/dom"),f=a("./base.styl"),d=function(){function a(b,c){var d;this.quill=b,this.options=c,g(this.quill.container).addClass("ql-container"),this.options.styles&&this.addStyles(f+a.objToCss(this.options.styles)),g.isIE(10)&&(d=g.isIE(9)?"9":"10",g(this.quill.root).addClass("ql-ie-"+d))}return a.OPTIONS={},a.objToCss=function(a){return e.map(a,function(a,b){var c;return c=e.map(a,function(a,b){return b+": "+a+";"}).join(" "),b+" { "+c+" }"}).join("\n")},a.prototype.addStyles=function(b){var c;return e.isObject(b)&&(b=a.objToCss(b)),c=document.createElement("style"),c.type="text/css",c.appendChild(document.createTextNode(b)),document.head.appendChild(c)},a}(),b.exports=d},{"../../lib/dom":17,"./base.styl":31,lodash:1}],33:[function(a,b,c){var d,e,f,g,h,i,j=function(a,b){function c(){this.constructor=a}for(var d in b)k.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},k={}.hasOwnProperty;h=a("lodash"),e=a("../../lib/color-picker"),d=a("../base"),i=a("../../lib/dom"),f=a("../../lib/picker"),g=function(a){function b(a,c){this.quill=a,this.options=c,b.__super__.constructor.apply(this,arguments),i(this.quill.container).addClass("ql-snow"),this.pickers=[],this.quill.on(this.quill.constructor.events.SELECTION_CHANGE,function(a){return function(b){return null!=b?h.invoke(a.pickers,"close"):void 0}}(this)),this.quill.onModuleLoad("multi-cursor",h.bind(this.extendMultiCursor,this)),this.quill.onModuleLoad("toolbar",h.bind(this.extendToolbar,this))}return j(b,a),b.COLORS=["#000000","#e60000","#ff9900","#ffff00","#008A00","#0066cc","#9933ff","#ffffff","#facccc","#ffebcc","#ffffcc","#cce8cc","#cce0f5","#ebd6ff","#bbbbbb","#f06666","#ffc266","#ffff66","#66b966","#66a3e0","#c285ff","#888888","#a10000","#b26b00","#b2b200","#006100","#0047b2","#6b24b2","#444444","#5c0000","#663d00","#666600","#003700","#002966","#3d1466"],b.OPTIONS={"multi-cursor":{template:'<span class="cursor-flag"> <span class="cursor-triangle top"></span> <span class="cursor-name"></span> <span class="cursor-triangle bottom"></span> </span> <span class="cursor-caret"></span>'}},b.prototype.extendMultiCursor=function(a){return a.on(a.constructor.events.CURSOR_ADDED,function(a){var b,c;return b=a.elem.querySelector(".cursor-triangle.bottom"),c=a.elem.querySelector(".cursor-triangle.top"),b.style.borderTopColor=c.style.borderBottomColor=a.color})},b.prototype.extendToolbar=function(a){return i(a.container).addClass("ql-snow"),h.each(["color","background","font","size","align"],function(b){return function(c){var d,g;if(g=a.container.querySelector(".ql-"+c),null!=g){switch(c){case"font":case"size":case"align":d=new f(g);break;case"color":case"background":d=new e(g),h.each(d.container.querySelectorAll(".ql-picker-item"),function(a,b){return 7>b?i(a).addClass("ql-primary-color"):void 0})}return null!=d?b.pickers.push(d):void 0}}}(this)),h.each(i(a.container).textNodes(),function(a){return 0===i(a).text().trim().length?i(a).remove():void 0})},b}(d),b.exports=g},{"../../lib/color-picker":16,"../../lib/dom":17,"../../lib/picker":19,"../base":32,lodash:1}]},{},[15])(15)});
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/component,can/construct,can/map,can/list,can/observe,can/compute,can/model,can/view,can/control,can/route,can/control/route,can/view/mustache,can/view/bindings,can/view/live,can/view/scope,can/util/string
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## util/can.js
    var __m4 = (function() {

        var can = window.can || {};
        if (typeof GLOBALCAN === 'undefined' || GLOBALCAN !== false) {
            window.can = can;
        }

        can.isDeferred = function(obj) {
            var isFunction = this.isFunction;
            // Returns `true` if something looks like a deferred.
            return obj && isFunction(obj.then) && isFunction(obj.pipe);
        };

        var cid = 0;
        can.cid = function(object, name) {
            if (!object._cid) {
                cid++;
                object._cid = (name || '') + cid;
            }
            return object._cid;
        };
        can.VERSION = '2.0.7';

        can.simpleExtend = function(d, s) {
            for (var prop in s) {
                d[prop] = s[prop];
            }
            return d;
        };

        return can;
    })();

    // ## util/array/each.js
    var __m5 = (function(can) {
        can.each = function(elements, callback, context) {
            var i = 0,
                key;
            if (elements) {
                if (typeof elements.length === 'number' && elements.pop) {
                    if (elements.attr) {
                        elements.attr('length');
                    }
                    for (key = elements.length; i < key; i++) {
                        if (callback.call(context || elements[i], elements[i], i, elements) === false) {
                            break;
                        }
                    }
                } else if (elements.hasOwnProperty) {
                    if (can.Map && elements instanceof can.Map) {
                        if (can.__reading) {
                            can.__reading(elements, '__keys');
                        }
                        elements = elements.__get();
                    }
                    for (key in elements) {
                        if (elements.hasOwnProperty(key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                            break;
                        }
                    }
                }
            }
            return elements;
        };
        return can;
    })(__m4);

    // ## util/inserted/inserted.js
    var __m6 = (function(can) {
        // Given a list of elements, check if they are in the dom, if they 
        // are in the dom, trigger inserted on them.
        can.inserted = function(elems) {
            // prevent mutations from changing the looping
            elems = can.makeArray(elems);
            var inDocument = false,
                // Not all browsers implement document.contains (Android)
                doc = can.$(document.contains ? document : document.body),
                children;
            for (var i = 0, elem;
                (elem = elems[i]) !== undefined; i++) {
                if (!inDocument) {
                    if (elem.getElementsByTagName) {
                        if (can.has(doc, elem)
                            .length) {
                            inDocument = true;
                        } else {
                            return;
                        }
                    } else {
                        continue;
                    }
                }

                if (inDocument && elem.getElementsByTagName) {
                    children = can.makeArray(elem.getElementsByTagName("*"));
                    can.trigger(elem, "inserted", [], false);
                    for (var j = 0, child;
                        (child = children[j]) !== undefined; j++) {
                        // Trigger the destroyed event
                        can.trigger(child, "inserted", [], false);
                    }
                }
            }
        };

        can.appendChild = function(el, child) {
            var children;
            if (child.nodeType === 11) {
                children = can.makeArray(child.childNodes);
            } else {
                children = [child];
            }
            el.appendChild(child);
            can.inserted(children);
        };
        can.insertBefore = function(el, child, ref) {
            var children;
            if (child.nodeType === 11) {
                children = can.makeArray(child.childNodes);
            } else {
                children = [child];
            }
            el.insertBefore(child, ref);
            can.inserted(children);
        };

    })(__m4);

    // ## util/event.js
    var __m7 = (function(can) {
        // event.js
        // ---------
        // _Basic event wrapper._
        can.addEvent = function(event, fn) {
            var allEvents = this.__bindEvents || (this.__bindEvents = {}),
                eventList = allEvents[event] || (allEvents[event] = []);
            eventList.push({
                    handler: fn,
                    name: event
                });
            return this;
        };
        // can.listenTo works without knowing how bind works
        // the API was heavily influenced by BackboneJS: 
        // http://backbonejs.org/
        can.listenTo = function(other, event, handler) {
            var idedEvents = this.__listenToEvents;
            if (!idedEvents) {
                idedEvents = this.__listenToEvents = {};
            }
            var otherId = can.cid(other);
            var othersEvents = idedEvents[otherId];
            if (!othersEvents) {
                othersEvents = idedEvents[otherId] = {
                    obj: other,
                    events: {}
                };
            }
            var eventsEvents = othersEvents.events[event];
            if (!eventsEvents) {
                eventsEvents = othersEvents.events[event] = [];
            }
            eventsEvents.push(handler);
            can.bind.call(other, event, handler);
        };
        can.stopListening = function(other, event, handler) {
            var idedEvents = this.__listenToEvents,
                iterIdedEvents = idedEvents,
                i = 0;
            if (!idedEvents) {
                return this;
            }
            if (other) {
                var othercid = can.cid(other);
                (iterIdedEvents = {})[othercid] = idedEvents[othercid];
                // you might be trying to listen to something that is not there
                if (!idedEvents[othercid]) {
                    return this;
                }
            }
            for (var cid in iterIdedEvents) {
                var othersEvents = iterIdedEvents[cid],
                    eventsEvents;
                other = idedEvents[cid].obj;
                if (!event) {
                    eventsEvents = othersEvents.events;
                } else {
                    (eventsEvents = {})[event] = othersEvents.events[event];
                }
                for (var eventName in eventsEvents) {
                    var handlers = eventsEvents[eventName] || [];
                    i = 0;
                    while (i < handlers.length) {
                        if (handler && handler === handlers[i] || !handler) {
                            can.unbind.call(other, eventName, handlers[i]);
                            handlers.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                    // no more handlers?
                    if (!handlers.length) {
                        delete othersEvents.events[eventName];
                    }
                }
                if (can.isEmptyObject(othersEvents.events)) {
                    delete idedEvents[cid];
                }
            }
            return this;
        };
        can.removeEvent = function(event, fn) {
            if (!this.__bindEvents) {
                return this;
            }
            var events = this.__bindEvents[event] || [],
                i = 0,
                ev, isFunction = typeof fn === 'function';
            while (i < events.length) {
                ev = events[i];
                if (isFunction && ev.handler === fn || !isFunction && ev.cid === fn) {
                    events.splice(i, 1);
                } else {
                    i++;
                }
            }
            return this;
        };
        can.dispatch = function(event, args) {
            if (!this.__bindEvents) {
                return;
            }
            if (typeof event === 'string') {
                event = {
                    type: event
                };
            }
            var eventName = event.type,
                handlers = (this.__bindEvents[eventName] || [])
                    .slice(0),
                ev;
            args = [event].concat(args || []);
            for (var i = 0, len = handlers.length; i < len; i++) {
                ev = handlers[i];
                ev.handler.apply(this, args);
            }
        };
        return can;
    })(__m4);

    // ## util/jquery/jquery.js
    var __m2 = (function($, can) {
        var isBindableElement = function(node) {
            // In IE8 window.window !== window.window, so we allow == here.

            return (node.nodeName && (node.nodeType === 1 || node.nodeType === 9)) || node == window;
        };
        // _jQuery node list._
        $.extend(can, $, {
                trigger: function(obj, event, args) {
                    if (isBindableElement(obj)) {
                        $.event.trigger(event, args, obj, true);
                    } else if (obj.trigger) {
                        obj.trigger(event, args);
                    } else {
                        if (typeof event === 'string') {
                            event = {
                                type: event
                            };
                        }
                        event.target = event.target || obj;
                        can.dispatch.call(obj, event, args);
                    }
                },
                addEvent: can.addEvent,
                removeEvent: can.removeEvent,
                buildFragment: function(elems, context) {
                    var oldFragment = $.buildFragment,
                        ret;
                    elems = [elems];
                    // Set context per 1.8 logic
                    context = context || document;
                    context = !context.nodeType && context[0] || context;
                    context = context.ownerDocument || context;
                    ret = oldFragment.call(jQuery, elems, context);
                    return ret.cacheable ? $.clone(ret.fragment) : ret.fragment || ret;
                },
                $: $,
                each: can.each,
                bind: function(ev, cb) {
                    // If we can bind to it...
                    if (this.bind && this.bind !== can.bind) {
                        this.bind(ev, cb);
                    } else if (isBindableElement(this)) {
                        $.event.add(this, ev, cb);
                    } else {
                        // Make it bind-able...
                        can.addEvent.call(this, ev, cb);
                    }
                    return this;
                },
                unbind: function(ev, cb) {
                    // If we can bind to it...
                    if (this.unbind && this.unbind !== can.unbind) {
                        this.unbind(ev, cb);
                    } else if (isBindableElement(this)) {
                        $.event.remove(this, ev, cb);
                    } else {
                        // Make it bind-able...
                        can.removeEvent.call(this, ev, cb);
                    }
                    return this;
                },
                delegate: function(selector, ev, cb) {
                    if (this.delegate) {
                        this.delegate(selector, ev, cb);
                    } else if (isBindableElement(this)) {
                        $(this)
                            .delegate(selector, ev, cb);
                    } else {
                        // make it bind-able ...
                    }
                    return this;
                },
                undelegate: function(selector, ev, cb) {
                    if (this.undelegate) {
                        this.undelegate(selector, ev, cb);
                    } else if (isBindableElement(this)) {
                        $(this)
                            .undelegate(selector, ev, cb);
                    } else {
                        // make it bind-able ...

                    }
                    return this;
                },
                proxy: function(fn, context) {
                    return function() {
                        return fn.apply(context, arguments);
                    };
                }
            });
        // Wrap binding functions.

        // Aliases
        can.on = can.bind;
        can.off = can.unbind;
        // Wrap modifier functions.
        $.each([
                'append',
                'filter',
                'addClass',
                'remove',
                'data',
                'get',
                'has'
            ], function(i, name) {
                can[name] = function(wrapped) {
                    return wrapped[name].apply(wrapped, can.makeArray(arguments)
                        .slice(1));
                };
            });
        // Memory safe destruction.
        var oldClean = $.cleanData;
        $.cleanData = function(elems) {
            $.each(elems, function(i, elem) {
                if (elem) {
                    can.trigger(elem, 'removed', [], false);
                }
            });
            oldClean(elems);
        };
        var oldDomManip = $.fn.domManip,
            cbIndex;
        // feature detect which domManip we are using
        $.fn.domManip = function(args, cb1, cb2) {
            for (var i = 1; i < arguments.length; i++) {
                if (typeof arguments[i] === 'function') {
                    cbIndex = i;
                    break;
                }
            }
            return oldDomManip.apply(this, arguments);
        };
        $(document.createElement('div'))
            .append(document.createElement('div'));
        $.fn.domManip = cbIndex === 2 ? function(args, table, callback) {
            return oldDomManip.call(this, args, table, function(elem) {
                var elems = elem.nodeType === 11 ? can.makeArray(elem.childNodes) : null;
                var ret = callback.apply(this, arguments);
                can.inserted(elems ? elems : [elem]);
                return ret;
            });
        } : function(args, callback) {
            return oldDomManip.call(this, args, function(elem) {
                var elems = elem.nodeType === 11 ? can.makeArray(elem.childNodes) : null;
                var ret = callback.apply(this, arguments);
                can.inserted(elems ? elems : [elem]);
                return ret;
            });
        };
        $.event.special.inserted = {};
        $.event.special.removed = {};
        return can;
    })(jQuery, __m4, __m5, __m6, __m7);

    // ## util/string/string.js
    var __m10 = (function(can) {
        // ##string.js
        // _Miscellaneous string utility functions._  
        // Several of the methods in this plugin use code adapated from Prototype
        // Prototype JavaScript framework, version 1.6.0.1.
        // © 2005-2007 Sam Stephenson
        var strUndHash = /_|-/,
            strColons = /\=\=/,
            strWords = /([A-Z]+)([A-Z][a-z])/g,
            strLowUp = /([a-z\d])([A-Z])/g,
            strDash = /([a-z\d])([A-Z])/g,
            strReplacer = /\{([^\}]+)\}/g,
            strQuote = /"/g,
            strSingleQuote = /'/g,
            strHyphenMatch = /-+(.)?/g,
            strCamelMatch = /[a-z][A-Z]/g,
            // Returns the `prop` property from `obj`.
            // If `add` is true and `prop` doesn't exist in `obj`, create it as an
            // empty object.
            getNext = function(obj, prop, add) {
                var result = obj[prop];
                if (result === undefined && add === true) {
                    result = obj[prop] = {};
                }
                return result;
            },
            // Returns `true` if the object can have properties (no `null`s).
            isContainer = function(current) {
                return /^f|^o/.test(typeof current);
            }, convertBadValues = function(content) {
                // Convert bad values into empty strings
                var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
                return '' + (isInvalid ? '' : content);
            };
        can.extend(can, {
                esc: function(content) {
                    return convertBadValues(content)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(strQuote, '&#34;')
                        .replace(strSingleQuote, '&#39;');
                },
                getObject: function(name, roots, add) {
                    // The parts of the name we are looking up
                    // `['App','Models','Recipe']`
                    var parts = name ? name.split('.') : [],
                        length = parts.length,
                        current, r = 0,
                        i, container, rootsLength;
                    // Make sure roots is an `array`.
                    roots = can.isArray(roots) ? roots : [roots || window];
                    rootsLength = roots.length;
                    if (!length) {
                        return roots[0];
                    }
                    // For each root, mark it as current.
                    for (r; r < rootsLength; r++) {
                        current = roots[r];
                        container = undefined;
                        // Walk current to the 2nd to last object or until there
                        // is not a container.
                        for (i = 0; i < length && isContainer(current); i++) {
                            container = current;
                            current = getNext(container, parts[i]);
                        }
                        // If we found property break cycle
                        if (container !== undefined && current !== undefined) {
                            break;
                        }
                    }
                    // Remove property from found container
                    if (add === false && current !== undefined) {
                        delete container[parts[i - 1]];
                    }
                    // When adding property add it to the first root
                    if (add === true && current === undefined) {
                        current = roots[0];
                        for (i = 0; i < length && isContainer(current); i++) {
                            current = getNext(current, parts[i], true);
                        }
                    }
                    return current;
                },
                capitalize: function(s, cache) {
                    // Used to make newId.
                    return s.charAt(0)
                        .toUpperCase() + s.slice(1);
                },
                camelize: function(str) {
                    return convertBadValues(str)
                        .replace(strHyphenMatch, function(match, chr) {
                            return chr ? chr.toUpperCase() : '';
                        });
                },
                hyphenate: function(str) {
                    return convertBadValues(str)
                        .replace(strCamelMatch, function(str, offset) {
                            return str.charAt(0) + '-' + str.charAt(1)
                                .toLowerCase();
                        });
                },
                underscore: function(s) {
                    return s.replace(strColons, '/')
                        .replace(strWords, '$1_$2')
                        .replace(strLowUp, '$1_$2')
                        .replace(strDash, '_')
                        .toLowerCase();
                },
                sub: function(str, data, remove) {
                    var obs = [];
                    str = str || '';
                    obs.push(str.replace(strReplacer, function(whole, inside) {
                                // Convert inside to type.
                                var ob = can.getObject(inside, data, remove === true ? false : undefined);
                                if (ob === undefined || ob === null) {
                                    obs = null;
                                    return '';
                                }
                                // If a container, push into objs (which will return objects found).
                                if (isContainer(ob) && obs) {
                                    obs.push(ob);
                                    return '';
                                }
                                return '' + ob;
                            }));
                    return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
                },
                replacer: strReplacer,
                undHash: strUndHash
            });
        return can;
    })(__m2);

    // ## construct/construct.js
    var __m9 = (function(can) {
        // ## construct.js
        // `can.Construct`  
        // _This is a modified version of
        // [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).  
        // It provides class level inheritance and callbacks._
        // A private flag used to initialize a new class instance without
        // initializing it's bindings.
        var initializing = 0;

        can.Construct = function() {
            if (arguments.length) {
                return can.Construct.extend.apply(can.Construct, arguments);
            }
        };

        can.extend(can.Construct, {

                constructorExtends: true,

                newInstance: function() {
                    // Get a raw instance object (`init` is not called).
                    var inst = this.instance(),
                        args;
                    // Call `setup` if there is a `setup`
                    if (inst.setup) {
                        args = inst.setup.apply(inst, arguments);
                    }
                    // Call `init` if there is an `init`  
                    // If `setup` returned `args`, use those as the arguments
                    if (inst.init) {
                        inst.init.apply(inst, args || arguments);
                    }
                    return inst;
                },
                // Overwrites an object with methods. Used in the `super` plugin.
                // `newProps` - New properties to add.
                // `oldProps` - Where the old properties might be (used with `super`).
                // `addTo` - What we are adding to.
                _inherit: function(newProps, oldProps, addTo) {
                    can.extend(addTo || newProps, newProps || {});
                },
                // used for overwriting a single property.
                // this should be used for patching other objects
                // the super plugin overwrites this
                _overwrite: function(what, oldProps, propName, val) {
                    what[propName] = val;
                },
                // Set `defaults` as the merger of the parent `defaults` and this
                // object's `defaults`. If you overwrite this method, make sure to
                // include option merging logic.

                setup: function(base, fullName) {
                    this.defaults = can.extend(true, {}, base.defaults, this.defaults);
                },
                // Create's a new `class` instance without initializing by setting the
                // `initializing` flag.
                instance: function() {
                    // Prevents running `init`.
                    initializing = 1;
                    var inst = new this();
                    // Allow running `init`.
                    initializing = 0;
                    return inst;
                },
                // Extends classes.

                extend: function(fullName, klass, proto) {
                    // Figure out what was passed and normalize it.
                    if (typeof fullName !== 'string') {
                        proto = klass;
                        klass = fullName;
                        fullName = null;
                    }
                    if (!proto) {
                        proto = klass;
                        klass = null;
                    }
                    proto = proto || {};
                    var _super_class = this,
                        _super = this.prototype,
                        parts, current, _fullName, _shortName, name, shortName, namespace, prototype;
                    // Instantiate a base class (but only create the instance,
                    // don't run the init constructor).
                    prototype = this.instance();
                    // Copy the properties over onto the new prototype.
                    can.Construct._inherit(proto, _super, prototype);
                    // The dummy class constructor.

                    function Constructor() {
                        // All construction is actually done in the init method.
                        if (!initializing) {
                            return this.constructor !== Constructor &&
                            // We are being called without `new` or we are extending.
                            arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :
                            // We are being called with `new`.
                            Constructor.newInstance.apply(Constructor, arguments);
                        }
                    }
                    // Copy old stuff onto class (can probably be merged w/ inherit)
                    for (name in _super_class) {
                        if (_super_class.hasOwnProperty(name)) {
                            Constructor[name] = _super_class[name];
                        }
                    }
                    // Copy new static properties on class.
                    can.Construct._inherit(klass, _super_class, Constructor);
                    // Setup namespaces.
                    if (fullName) {

                        parts = fullName.split('.');
                        shortName = parts.pop();
                        current = can.getObject(parts.join('.'), window, true);
                        namespace = current;
                        _fullName = can.underscore(fullName.replace(/\./g, "_"));
                        _shortName = can.underscore(shortName);



                        current[shortName] = Constructor;
                    }
                    // Set things that shouldn't be overwritten.
                    can.extend(Constructor, {
                            constructor: Constructor,
                            prototype: prototype,

                            namespace: namespace,

                            _shortName: _shortName,

                            fullName: fullName,
                            _fullName: _fullName
                        });
                    // Dojo and YUI extend undefined
                    if (shortName !== undefined) {
                        Constructor.shortName = shortName;
                    }
                    // Make sure our prototype looks nice.
                    Constructor.prototype.constructor = Constructor;
                    // Call the class `setup` and `init`
                    var t = [_super_class].concat(can.makeArray(arguments)),
                        args = Constructor.setup.apply(Constructor, t);
                    if (Constructor.init) {
                        Constructor.init.apply(Constructor, args || t);
                    }

                    return Constructor;
                }
            });

        can.Construct.prototype.setup = function() {};

        can.Construct.prototype.init = function() {};
        return can.Construct;
    })(__m10);

    // ## control/control.js
    var __m8 = (function(can) {
        // ## control.js
        // `can.Control`  
        // _Controller_

        // Binds an element, returns a function that unbinds.
        var bind = function(el, ev, callback) {

            can.bind.call(el, ev, callback);

            return function() {
                can.unbind.call(el, ev, callback);
            };
        },
            isFunction = can.isFunction,
            extend = can.extend,
            each = can.each,
            slice = [].slice,
            paramReplacer = /\{([^\}]+)\}/g,
            special = can.getObject("$.event.special", [can]) || {},

            // Binds an element, returns a function that unbinds.
            delegate = function(el, selector, ev, callback) {
                can.delegate.call(el, selector, ev, callback);
                return function() {
                    can.undelegate.call(el, selector, ev, callback);
                };
            },

            // Calls bind or unbind depending if there is a selector.
            binder = function(el, ev, callback, selector) {
                return selector ?
                    delegate(el, can.trim(selector), ev, callback) :
                    bind(el, ev, callback);
            },

            basicProcessor;

        var Control = can.Control = can.Construct(

            {
                // Setup pre-processes which methods are event listeners.

                setup: function() {

                    // Allow contollers to inherit "defaults" from super-classes as it 
                    // done in `can.Construct`
                    can.Construct.setup.apply(this, arguments);

                    // If you didn't provide a name, or are `control`, don't do anything.
                    if (can.Control) {

                        // Cache the underscored names.
                        var control = this,
                            funcName;

                        // Calculate and cache actions.
                        control.actions = {};
                        for (funcName in control.prototype) {
                            if (control._isAction(funcName)) {
                                control.actions[funcName] = control._action(funcName);
                            }
                        }
                    }
                },
                // Moves `this` to the first argument, wraps it with `jQuery` if it's an element
                _shifter: function(context, name) {

                    var method = typeof name === "string" ? context[name] : name;

                    if (!isFunction(method)) {
                        method = context[method];
                    }

                    return function() {
                        context.called = name;
                        return method.apply(context, [this.nodeName ? can.$(this) : this].concat(slice.call(arguments, 0)));
                    };
                },

                // Return `true` if is an action.

                _isAction: function(methodName) {

                    var val = this.prototype[methodName],
                        type = typeof val;
                    // if not the constructor
                    return (methodName !== 'constructor') &&
                    // and is a function or links to a function
                    (type === "function" || (type === "string" && isFunction(this.prototype[val]))) &&
                    // and is in special, a processor, or has a funny character
                    !! (special[methodName] || processors[methodName] || /[^\w]/.test(methodName));
                },
                // Takes a method name and the options passed to a control
                // and tries to return the data necessary to pass to a processor
                // (something that binds things).

                _action: function(methodName, options) {

                    // If we don't have options (a `control` instance), we'll run this 
                    // later.  
                    paramReplacer.lastIndex = 0;
                    if (options || !paramReplacer.test(methodName)) {
                        // If we have options, run sub to replace templates `{}` with a
                        // value from the options or the window
                        var convertedName = options ? can.sub(methodName, this._lookup(options)) : methodName;
                        if (!convertedName) {

                            return null;
                        }
                        // If a `{}` template resolves to an object, `convertedName` will be
                        // an array
                        var arr = can.isArray(convertedName),

                            // Get the name
                            name = arr ? convertedName[1] : convertedName,

                            // Grab the event off the end
                            parts = name.split(/\s+/g),
                            event = parts.pop();

                        return {
                            processor: processors[event] || basicProcessor,
                            parts: [name, parts.join(" "), event],
                            delegate: arr ? convertedName[0] : undefined
                        };
                    }
                },
                _lookup: function(options) {
                    return [options, window];
                },
                // An object of `{eventName : function}` pairs that Control uses to 
                // hook up events auto-magically.

                processors: {},
                // A object of name-value pairs that act as default values for a 
                // control instance
                defaults: {}

            }, {

                // Sets `this.element`, saves the control in `data, binds event
                // handlers.

                setup: function(element, options) {

                    var cls = this.constructor,
                        pluginname = cls.pluginName || cls._fullName,
                        arr;

                    // Want the raw element here.
                    this.element = can.$(element);

                    if (pluginname && pluginname !== 'can_control') {
                        // Set element and `className` on element.
                        this.element.addClass(pluginname);
                    }
                    arr = can.data(this.element, 'controls');
                    if (!arr) {
                        arr = [];
                        can.data(this.element, 'controls', arr);
                    }
                    arr.push(this);

                    // Option merging.

                    this.options = extend({}, cls.defaults, options);

                    // Bind all event handlers.
                    this.on();

                    // Gets passed into `init`.

                    return [this.element, this.options];
                },

                on: function(el, selector, eventName, func) {
                    if (!el) {

                        // Adds bindings.
                        this.off();

                        // Go through the cached list of actions and use the processor 
                        // to bind
                        var cls = this.constructor,
                            bindings = this._bindings,
                            actions = cls.actions,
                            element = this.element,
                            destroyCB = can.Control._shifter(this, "destroy"),
                            funcName, ready;

                        for (funcName in actions) {
                            // Only push if we have the action and no option is `undefined`
                            if (actions.hasOwnProperty(funcName) &&
                                (ready = actions[funcName] || cls._action(funcName, this.options))) {
                                bindings.push(ready.processor(ready.delegate || element,
                                        ready.parts[2], ready.parts[1], funcName, this));
                            }
                        }

                        // Setup to be destroyed...  
                        // don't bind because we don't want to remove it.
                        can.bind.call(element, "removed", destroyCB);
                        bindings.push(function(el) {
                            can.unbind.call(el, "removed", destroyCB);
                        });
                        return bindings.length;
                    }

                    if (typeof el === 'string') {
                        func = eventName;
                        eventName = selector;
                        selector = el;
                        el = this.element;
                    }

                    if (func === undefined) {
                        func = eventName;
                        eventName = selector;
                        selector = null;
                    }

                    if (typeof func === 'string') {
                        func = can.Control._shifter(this, func);
                    }

                    this._bindings.push(binder(el, eventName, func, selector));

                    return this._bindings.length;
                },
                // Unbinds all event handlers on the controller.

                off: function() {
                    var el = this.element[0];
                    each(this._bindings || [], function(value) {
                        value(el);
                    });
                    // Adds bindings.
                    this._bindings = [];
                },
                // Prepares a `control` for garbage collection

                destroy: function() {
                    //Control already destroyed
                    if (this.element === null) {

                        return;
                    }
                    var Class = this.constructor,
                        pluginName = Class.pluginName || Class._fullName,
                        controls;

                    // Unbind bindings.
                    this.off();

                    if (pluginName && pluginName !== 'can_control') {
                        // Remove the `className`.
                        this.element.removeClass(pluginName);
                    }

                    // Remove from `data`.
                    controls = can.data(this.element, "controls");
                    controls.splice(can.inArray(this, controls), 1);

                    can.trigger(this, "destroyed"); // In case we want to know if the `control` is removed.

                    this.element = null;
                }
            });

        var processors = can.Control.processors;
        // Processors do the binding.
        // They return a function that unbinds when called.
        // The basic processor that binds events.
        basicProcessor = function(el, event, selector, methodName, control) {
            return binder(el, event, can.Control._shifter(control, methodName), selector);
        };

        // Set common events to be processed as a `basicProcessor`
        each(["change", "click", "contextmenu", "dblclick", "keydown", "keyup",
                "keypress", "mousedown", "mousemove", "mouseout", "mouseover",
                "mouseup", "reset", "resize", "scroll", "select", "submit", "focusin",
                "focusout", "mouseenter", "mouseleave",
                // #104 - Add touch events as default processors
                // TOOD feature detect?
                "touchstart", "touchmove", "touchcancel", "touchend", "touchleave"
            ], function(v) {
                processors[v] = basicProcessor;
            });

        return Control;
    })(__m2, __m9);

    // ## util/bind/bind.js
    var __m13 = (function(can) {

        // ## Bind helpers
        can.bindAndSetup = function() {
            // Add the event to this object
            can.addEvent.apply(this, arguments);
            // If not initializing, and the first binding
            // call bindsetup if the function exists.
            if (!this._init) {
                if (!this._bindings) {
                    this._bindings = 1;
                    // setup live-binding
                    if (this._bindsetup) {
                        this._bindsetup();
                    }
                } else {
                    this._bindings++;
                }
            }
            return this;
        };
        can.unbindAndTeardown = function(ev, handler) {
            // Remove the event handler
            can.removeEvent.apply(this, arguments);
            if (this._bindings === null) {
                this._bindings = 0;
            } else {
                this._bindings--;
            }
            // If there are no longer any bindings and
            // there is a bindteardown method, call it.
            if (!this._bindings && this._bindteardown) {
                this._bindteardown();
            }
            return this;
        };
        return can;
    })(__m2);

    // ## util/batch/batch.js
    var __m14 = (function(can) {
        // Which batch of events this is for -- might not want to send multiple
        // messages on the same batch.  This is mostly for event delegation.
        var batchNum = 1,
            // how many times has start been called without a stop
            transactions = 0,
            // an array of events within a transaction
            batchEvents = [],
            stopCallbacks = [];
        can.batch = {

            start: function(batchStopHandler) {
                transactions++;
                if (batchStopHandler) {
                    stopCallbacks.push(batchStopHandler);
                }
            },

            stop: function(force, callStart) {
                if (force) {
                    transactions = 0;
                } else {
                    transactions--;
                }
                if (transactions === 0) {
                    var items = batchEvents.slice(0),
                        callbacks = stopCallbacks.slice(0);
                    batchEvents = [];
                    stopCallbacks = [];
                    batchNum++;
                    if (callStart) {
                        can.batch.start();
                    }
                    can.each(items, function(args) {
                        can.trigger.apply(can, args);
                    });
                    can.each(callbacks, function(cb) {
                        cb();
                    });
                }
            },

            trigger: function(item, event, args) {
                // Don't send events if initalizing.
                if (!item._init) {
                    if (transactions === 0) {
                        return can.trigger(item, event, args);
                    } else {
                        event = typeof event === 'string' ? {
                            type: event
                        } : event;
                        event.batchNum = batchNum;
                        batchEvents.push([
                                item,
                                event,
                                args
                            ]);
                    }
                }
            }
        };
    })(__m4);

    // ## map/map.js
    var __m12 = (function(can, bind) {
        // ## map.js  
        // `can.Map`  
        // _Provides the observable pattern for JavaScript Objects._  
        // Removes all listeners.
        var bindToChildAndBubbleToParent = function(child, prop, parent) {
            can.listenTo.call(parent, child, "change", function() {
                // `batchTrigger` the type on this...
                var args = can.makeArray(arguments),
                    ev = args.shift();
                args[0] = (prop === "*" ? [parent.indexOf(child), args[0]] : [prop, args[0]])
                    .join(".");

                // track objects dispatched on this map		
                ev.triggeredNS = ev.triggeredNS || {};

                // if it has already been dispatched exit
                if (ev.triggeredNS[parent._cid]) {
                    return;
                }

                ev.triggeredNS[parent._cid] = true;
                // send change event with modified attr to parent	
                can.trigger(parent, ev, args);
                // send modified attr event to parent
                //can.trigger(parent, args[0], args);
            });
        };
        var attrParts = function(attr, keepKey) {
            if (keepKey) {
                return [attr];
            }
            return can.isArray(attr) ? attr : ("" + attr)
                .split(".");
        };
        var makeBindSetup = function(wildcard) {
            return function() {
                var parent = this;
                this._each(function(child, prop) {
                    if (child && child.bind) {
                        bindToChildAndBubbleToParent(child, wildcard || prop, parent);
                    }
                });
            };
        };
        // A map that temporarily houses a reference
        // to maps that have already been made for a plain ole JS object
        var madeMap = null;
        var teardownMap = function() {
            for (var cid in madeMap) {
                if (madeMap[cid].added) {
                    delete madeMap[cid].obj._cid;
                }
            }
            madeMap = null;
        };
        var getMapFromObject = function(obj) {
            return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
        };


        var Map = can.Map = can.Construct.extend({

                setup: function() {

                    can.Construct.setup.apply(this, arguments);

                    if (can.Map) {
                        if (!this.defaults) {
                            this.defaults = {};
                        }
                        // a list of the compute properties
                        this._computes = [];
                        for (var prop in this.prototype) {
                            if (typeof this.prototype[prop] !== "function") {
                                this.defaults[prop] = this.prototype[prop];
                            } else if (this.prototype[prop].isComputed) {
                                this._computes.push(prop);
                            }
                        }
                    }
                    // if we inerit from can.Map, but not can.List
                    if (can.List && !(this.prototype instanceof can.List)) {
                        this.List = Map.List({
                                Map: this
                            }, {});
                    }

                },
                _computes: [],
                // keep so it can be overwritten
                bind: can.bindAndSetup,
                on: can.bindAndSetup,
                unbind: can.unbindAndTeardown,
                off: can.unbindAndTeardown,
                id: "id",
                helpers: {
                    addToMap: function(obj, instance) {
                        var teardown;
                        if (!madeMap) {
                            teardown = teardownMap;
                            madeMap = {};
                        }
                        // record if it has a Cid before we add one
                        var hasCid = obj._cid;
                        var cid = can.cid(obj);

                        // only update if there already isn't one
                        if (!madeMap[cid]) {

                            madeMap[cid] = {
                                obj: obj,
                                instance: instance,
                                added: !hasCid
                            };
                        }
                        return teardown;
                    },

                    canMakeObserve: function(obj) {
                        return obj && !can.isDeferred(obj) && (can.isArray(obj) || can.isPlainObject(obj) || (obj instanceof can.Map));
                    },
                    unhookup: function(items, parent) {
                        return can.each(items, function(item) {
                            if (item && item.unbind) {
                                can.stopListening.call(parent, item, "change");
                            }
                        });
                    },
                    // Listens to changes on `child` and "bubbles" the event up.  
                    // `child` - The object to listen for changes on.  
                    // `prop` - The property name is at on.  
                    // `parent` - The parent object of prop.
                    // `ob` - (optional) The Map object constructor
                    // `list` - (optional) The observable list constructor
                    hookupBubble: function(child, prop, parent, Ob, List) {
                        Ob = Ob || Map;
                        List = List || can.List;

                        // If it's an `array` make a list, otherwise a child.
                        if (child instanceof Map) {
                            // We have an `map` already...
                            // Make sure it is not listening to this already
                            // It's only listening if it has bindings already.
                            if (parent._bindings) {
                                Map.helpers.unhookup([child], parent);
                            }
                        } else if (can.isArray(child)) {
                            child = getMapFromObject(child) || new List(child);
                        } else {
                            child = getMapFromObject(child) || new Ob(child);
                        }
                        // only listen if something is listening to you
                        if (parent._bindings) {
                            // Listen to all changes and `batchTrigger` upwards.
                            bindToChildAndBubbleToParent(child, prop, parent);
                        }

                        return child;
                    },
                    // A helper used to serialize an `Map` or `Map.List`.  
                    // `map` - The observable.  
                    // `how` - To serialize with `attr` or `serialize`.  
                    // `where` - To put properties, in an `{}` or `[]`.
                    serialize: function(map, how, where) {
                        // Go through each property.
                        map.each(function(val, name) {
                            // If the value is an `object`, and has an `attrs` or `serialize` function.
                            where[name] = Map.helpers.canMakeObserve(val) && can.isFunction(val[how]) ?
                            // Call `attrs` or `serialize` to get the original data back.
                            val[how]() :
                            // Otherwise return the value.
                            val;

                            if (can.__reading) {
                                can.__reading(map, name);
                            }
                        });

                        if (can.__reading) {
                            can.__reading(map, '__keys');
                        }

                        return where;
                    },
                    makeBindSetup: makeBindSetup
                },

                // starts collecting events
                // takes a callback for after they are updated
                // how could you hook into after ejs

                keys: function(map) {
                    var keys = [];
                    if (can.__reading) {
                        can.__reading(map, '__keys');
                    }
                    for (var keyName in map._data) {
                        keys.push(keyName);
                    }
                    return keys;
                }
            },

            {
                setup: function(obj) {
                    // `_data` is where we keep the properties.
                    this._data = {};

                    // The namespace this `object` uses to listen to events.
                    can.cid(this, ".map");
                    // Sets all `attrs`.
                    this._init = 1;
                    this._setupComputes();
                    var teardownMapping = obj && can.Map.helpers.addToMap(obj, this);

                    var data = can.extend(can.extend(true, {}, this.constructor.defaults || {}), obj);
                    this.attr(data);

                    if (teardownMapping) {
                        teardownMapping();
                    }

                    this.bind('change', can.proxy(this._changes, this));

                    delete this._init;
                },

                _setupComputes: function() {
                    var computes = this.constructor._computes;
                    this._computedBindings = {};
                    for (var i = 0, len = computes.length, prop; i < len; i++) {
                        prop = computes[i];
                        this[prop] = this[prop].clone(this);
                        this._computedBindings[prop] = {
                            count: 0
                        };
                    }
                },
                _bindsetup: makeBindSetup(),
                _bindteardown: function() {
                    var self = this;
                    this._each(function(child) {
                        Map.helpers.unhookup([child], self);
                    });
                },
                _changes: function(ev, attr, how, newVal, oldVal) {
                    can.batch.trigger(this, {
                            type: attr,
                            batchNum: ev.batchNum
                        }, [newVal, oldVal]);
                },
                _triggerChange: function(attr, how, newVal, oldVal) {
                    can.batch.trigger(this, "change", can.makeArray(arguments));
                },
                // no live binding iterator
                _each: function(callback) {
                    var data = this.__get();
                    for (var prop in data) {
                        if (data.hasOwnProperty(prop)) {
                            callback(data[prop], prop);
                        }
                    }
                },

                attr: function(attr, val) {
                    // This is super obfuscated for space -- basically, we're checking
                    // if the type of the attribute is not a `number` or a `string`.
                    var type = typeof attr;
                    if (type !== "string" && type !== "number") {
                        return this._attrs(attr, val);
                    } else if (arguments.length === 1) { // If we are getting a value.
                        // Let people know we are reading.
                        if (can.__reading) {
                            can.__reading(this, attr);
                        }
                        return this._get(attr);
                    } else {
                        // Otherwise we are setting.
                        this._set(attr, val);
                        return this;
                    }
                },

                each: function() {
                    if (can.__reading) {
                        can.__reading(this, '__keys');
                    }
                    return can.each.apply(undefined, [this.__get()].concat(can.makeArray(arguments)));
                },

                removeAttr: function(attr) {
                    // Info if this is List or not
                    var isList = can.List && this instanceof can.List,
                        // Convert the `attr` into parts (if nested).
                        parts = attrParts(attr),
                        // The actual property to remove.
                        prop = parts.shift(),
                        // The current value.
                        current = isList ? this[prop] : this._data[prop];

                    // If we have more parts, call `removeAttr` on that part.
                    if (parts.length && current) {
                        return current.removeAttr(parts);
                    } else {
                        if ( !! ~attr.indexOf('.')) {
                            prop = attr;
                        }
                        if (isList) {
                            this.splice(prop, 1);
                        } else if (prop in this._data) {
                            // Otherwise, `delete`.
                            delete this._data[prop];
                            // Create the event.
                            if (!(prop in this.constructor.prototype)) {
                                delete this[prop];
                            }
                            // Let others know the number of keys have changed
                            can.batch.trigger(this, "__keys");
                            this._triggerChange(prop, "remove", undefined, current);

                        }
                        return current;
                    }
                },
                // Reads a property from the `object`.
                _get: function(attr) {
                    var value;
                    if (typeof attr === 'string' && !! ~attr.indexOf('.')) {
                        value = this.__get(attr);
                        if (value !== undefined) {
                            return value;
                        }
                    }

                    // break up the attr (`"foo.bar"`) into `["foo","bar"]`
                    var parts = attrParts(attr),
                        // get the value of the first attr name (`"foo"`)
                        current = this.__get(parts.shift());
                    // if there are other attributes to read
                    return parts.length ?
                    // and current has a value
                    current ?
                    // lookup the remaining attrs on current
                    current._get(parts) :
                    // or if there's no current, return undefined
                    undefined :
                    // if there are no more parts, return current
                    current;
                },
                // Reads a property directly if an `attr` is provided, otherwise
                // returns the "real" data object itself.
                __get: function(attr) {
                    if (attr) {
                        if (this[attr] && this[attr].isComputed && can.isFunction(this.constructor.prototype[attr])) {
                            return this[attr]();
                        } else {
                            return this._data[attr];
                        }
                    } else {
                        return this._data;
                    }
                },
                // Sets `attr` prop as value on this object where.
                // `attr` - Is a string of properties or an array  of property values.
                // `value` - The raw value to set.
                _set: function(attr, value, keepKey) {
                    // Convert `attr` to attr parts (if it isn't already).
                    var parts = attrParts(attr, keepKey),
                        // The immediate prop we are setting.
                        prop = parts.shift(),
                        // The current value.
                        current = this.__get(prop);

                    // If we have an `object` and remaining parts.
                    if (parts.length && Map.helpers.canMakeObserve(current)) {
                        // That `object` should set it (this might need to call attr).
                        current._set(parts, value);
                    } else if (!parts.length) {
                        // We're in "real" set territory.
                        if (this.__convert) {
                            value = this.__convert(prop, value);
                        }
                        this.__set(prop, value, current);
                    } else {
                        throw "can.Map: Object does not exist";
                    }
                },
                __set: function(prop, value, current) {

                    // Otherwise, we are setting it on this `object`.
                    // TODO: Check if value is object and transform
                    // are we changing the value.
                    if (value !== current) {
                        // Check if we are adding this for the first time --
                        // if we are, we need to create an `add` event.
                        var changeType = this.__get()
                            .hasOwnProperty(prop) ? "set" : "add";

                        // Set the value on data.
                        this.___set(prop,

                            // If we are getting an object.
                            Map.helpers.canMakeObserve(value) ?

                            // Hook it up to send event.
                            Map.helpers.hookupBubble(value, prop, this) :
                            // Value is normal.
                            value);

                        if (changeType === "add") {
                            // If there is no current value, let others know that
                            // the the number of keys have changed

                            can.batch.trigger(this, "__keys", undefined);

                        }
                        // `batchTrigger` the change event.
                        this._triggerChange(prop, changeType, value, current);

                        //can.batch.trigger(this, prop, [value, current]);
                        // If we can stop listening to our old value, do it.
                        if (current) {
                            Map.helpers.unhookup([current], this);
                        }
                    }

                },
                // Directly sets a property on this `object`.
                ___set: function(prop, val) {

                    if (this[prop] && this[prop].isComputed && can.isFunction(this.constructor.prototype[prop])) {
                        this[prop](val);
                    }

                    this._data[prop] = val;
                    // Add property directly for easy writing.
                    // Check if its on the `prototype` so we don't overwrite methods like `attrs`.
                    if (!(can.isFunction(this.constructor.prototype[prop]))) {
                        this[prop] = val;
                    }
                },


                bind: function(eventName, handler) {
                    var computedBinding = this._computedBindings && this._computedBindings[eventName];
                    if (computedBinding) {
                        if (!computedBinding.count) {
                            computedBinding.count = 1;
                            var self = this;
                            computedBinding.handler = function(ev, newVal, oldVal) {
                                can.batch.trigger(self, {
                                        type: eventName,
                                        batchNum: ev.batchNum
                                    }, [newVal, oldVal]);
                            };
                            this[eventName].bind("change", computedBinding.handler);
                        } else {
                            computedBinding.count++;
                        }

                    }
                    return can.bindAndSetup.apply(this, arguments);

                },

                unbind: function(eventName, handler) {
                    var computedBinding = this._computedBindings && this._computedBindings[eventName];
                    if (computedBinding) {
                        if (computedBinding.count === 1) {
                            computedBinding.count = 0;
                            this[eventName].unbind("change", computedBinding.handler);
                            delete computedBinding.handler;
                        } else {
                            computedBinding.count++;
                        }

                    }
                    return can.unbindAndTeardown.apply(this, arguments);

                },

                serialize: function() {
                    return can.Map.helpers.serialize(this, 'serialize', {});
                },

                _attrs: function(props, remove) {
                    var self = this,
                        newVal;

                    if (props === undefined) {
                        return Map.helpers.serialize(this, 'attr', {});
                    }

                    props = can.simpleExtend({}, props);

                    can.batch.start();
                    this.each(function(curVal, prop) {
                        // you can not have a _cid property!
                        if (prop === "_cid") {
                            return;
                        }
                        newVal = props[prop];

                        // If we are merging...
                        if (newVal === undefined) {
                            if (remove) {
                                self.removeAttr(prop);
                            }
                            return;
                        }

                        if (self.__convert) {
                            newVal = self.__convert(prop, newVal);
                        }

                        // if we're dealing with models, want to call _set to let converter run
                        if (newVal instanceof can.Map) {
                            self.__set(prop, newVal, curVal);
                            // if its an object, let attr merge
                        } else if (Map.helpers.canMakeObserve(curVal) && Map.helpers.canMakeObserve(newVal) && curVal.attr) {
                            curVal.attr(newVal, remove);
                            // otherwise just set
                        } else if (curVal !== newVal) {
                            self.__set(prop, newVal, curVal);
                        }

                        delete props[prop];
                    });
                    // Add remaining props.
                    for (var prop in props) {
                        if (prop !== "_cid") {
                            newVal = props[prop];
                            this._set(prop, newVal, true);
                        }

                    }
                    can.batch.stop();
                    return this;
                },


                compute: function(prop) {
                    if (can.isFunction(this.constructor.prototype[prop])) {
                        return can.compute(this[prop], this);
                    } else {
                        var reads = prop.split("."),
                            last = reads.length - 1,
                            options = {
                                args: []
                            };
                        return can.compute(function(newVal) {
                            if (arguments.length) {
                                can.compute.read(this, reads.slice(0, last))
                                    .value.attr(reads[last], newVal);
                            } else {
                                return can.compute.read(this, reads, options)
                                    .value;
                            }
                        }, this);
                    }

                }
            });

        Map.prototype.on = Map.prototype.bind;
        Map.prototype.off = Map.prototype.unbind;

        return Map;
    })(__m2, __m13, __m9, __m14);

    // ## list/list.js
    var __m15 = (function(can, Map) {

        // Helpers for `observable` lists.
        var splice = [].splice,
            // test if splice works correctly
            spliceRemovesProps = (function() {
                // IE's splice doesn't remove properties
                var obj = {
                    0: "a",
                    length: 1
                };
                splice.call(obj, 0, 1);
                return !obj[0];
            })();

        var list = Map(

            {

                Map: Map

            },

            {
                setup: function(instances, options) {
                    this.length = 0;
                    can.cid(this, ".map");
                    this._init = 1;
                    instances = instances || [];
                    var teardownMapping;

                    if (can.isDeferred(instances)) {
                        this.replace(instances);
                    } else {
                        teardownMapping = instances.length && can.Map.helpers.addToMap(instances, this);
                        this.push.apply(this, can.makeArray(instances || []));
                    }

                    if (teardownMapping) {
                        teardownMapping();
                    }

                    // this change needs to be ignored
                    this.bind('change', can.proxy(this._changes, this));
                    can.simpleExtend(this, options);
                    delete this._init;
                },
                _triggerChange: function(attr, how, newVal, oldVal) {

                    Map.prototype._triggerChange.apply(this, arguments);
                    // `batchTrigger` direct add and remove events...
                    if (!~attr.indexOf('.')) {

                        if (how === 'add') {
                            can.batch.trigger(this, how, [newVal, +attr]);
                            can.batch.trigger(this, 'length', [this.length]);
                        } else if (how === 'remove') {
                            can.batch.trigger(this, how, [oldVal, +attr]);
                            can.batch.trigger(this, 'length', [this.length]);
                        } else {
                            can.batch.trigger(this, how, [newVal, +attr]);
                        }

                    }

                },
                __get: function(attr) {
                    return attr ? this[attr] : this;
                },
                ___set: function(attr, val) {
                    this[attr] = val;
                    if (+attr >= this.length) {
                        this.length = (+attr + 1);
                    }
                },
                _each: function(callback) {
                    var data = this.__get();
                    for (var i = 0; i < data.length; i++) {
                        callback(data[i], i);
                    }
                },
                _bindsetup: Map.helpers.makeBindSetup("*"),
                // Returns the serialized form of this list.

                serialize: function() {
                    return Map.helpers.serialize(this, 'serialize', []);
                },

                splice: function(index, howMany) {
                    var args = can.makeArray(arguments),
                        i;

                    for (i = 2; i < args.length; i++) {
                        var val = args[i];
                        if (Map.helpers.canMakeObserve(val)) {
                            args[i] = Map.helpers.hookupBubble(val, "*", this, this.constructor.Map, this.constructor);
                        }
                    }
                    if (howMany === undefined) {
                        howMany = args[1] = this.length - index;
                    }
                    var removed = splice.apply(this, args);

                    if (!spliceRemovesProps) {
                        for (i = this.length; i < removed.length + this.length; i++) {
                            delete this[i];
                        }
                    }

                    can.batch.start();
                    if (howMany > 0) {
                        this._triggerChange("" + index, "remove", undefined, removed);
                        Map.helpers.unhookup(removed, this);
                    }
                    if (args.length > 2) {
                        this._triggerChange("" + index, "add", args.slice(2), removed);
                    }
                    can.batch.stop();
                    return removed;
                },

                _attrs: function(items, remove) {
                    if (items === undefined) {
                        return Map.helpers.serialize(this, 'attr', []);
                    }

                    // Create a copy.
                    items = can.makeArray(items);

                    can.batch.start();
                    this._updateAttrs(items, remove);
                    can.batch.stop();
                },

                _updateAttrs: function(items, remove) {
                    var len = Math.min(items.length, this.length);

                    for (var prop = 0; prop < len; prop++) {
                        var curVal = this[prop],
                            newVal = items[prop];

                        if (Map.helpers.canMakeObserve(curVal) && Map.helpers.canMakeObserve(newVal)) {
                            curVal.attr(newVal, remove);
                            //changed from a coercion to an explicit
                        } else if (curVal !== newVal) {
                            this._set(prop, newVal);
                        } else {

                        }
                    }
                    if (items.length > this.length) {
                        // Add in the remaining props.
                        this.push.apply(this, items.slice(this.length));
                    } else if (items.length < this.length && remove) {
                        this.splice(items.length);
                    }
                }
            }),

            // Converts to an `array` of arguments.
            getArgs = function(args) {
                return args[0] && can.isArray(args[0]) ?
                    args[0] :
                    can.makeArray(args);
            };
        // Create `push`, `pop`, `shift`, and `unshift`
        can.each({

                push: "length",

                unshift: 0
            },
            // Adds a method
            // `name` - The method name.
            // `where` - Where items in the `array` should be added.

            function(where, name) {
                var orig = [][name];
                list.prototype[name] = function() {
                    // Get the items being added.
                    var args = [],
                        // Where we are going to add items.
                        len = where ? this.length : 0,
                        i = arguments.length,
                        res, val;

                    // Go through and convert anything to an `map` that needs to be converted.
                    while (i--) {
                        val = arguments[i];
                        args[i] = Map.helpers.canMakeObserve(val) ?
                            Map.helpers.hookupBubble(val, "*", this, this.constructor.Map, this.constructor) :
                            val;
                    }

                    // Call the original method.
                    res = orig.apply(this, args);

                    if (!this.comparator || args.length) {

                        this._triggerChange("" + len, "add", args, undefined);
                    }

                    return res;
                };
            });

        can.each({

                pop: "length",

                shift: 0
            },
            // Creates a `remove` type method

            function(where, name) {
                list.prototype[name] = function() {

                    var args = getArgs(arguments),
                        len = where && this.length ? this.length - 1 : 0;

                    var res = [][name].apply(this, args);

                    // Create a change where the args are
                    // `len` - Where these items were removed.
                    // `remove` - Items removed.
                    // `undefined` - The new values (there are none).
                    // `res` - The old, removed values (should these be unbound).
                    this._triggerChange("" + len, "remove", undefined, [res]);

                    if (res && res.unbind) {
                        can.stopListening.call(this, res, "change");
                    }
                    return res;
                };
            });

        can.extend(list.prototype, {

                indexOf: function(item, fromIndex) {
                    this.attr('length');
                    return can.inArray(item, this, fromIndex);
                },


                join: function() {
                    return [].join.apply(this.attr(), arguments);
                },


                reverse: [].reverse,


                slice: function() {
                    var temp = Array.prototype.slice.apply(this, arguments);
                    return new this.constructor(temp);
                },


                concat: function() {
                    var args = [];
                    can.each(can.makeArray(arguments), function(arg, i) {
                        args[i] = arg instanceof can.List ? arg.serialize() : arg;
                    });
                    return new this.constructor(Array.prototype.concat.apply(this.serialize(), args));
                },


                forEach: function(cb, thisarg) {
                    return can.each(this, cb, thisarg || this);
                },


                replace: function(newList) {
                    if (can.isDeferred(newList)) {
                        newList.then(can.proxy(this.replace, this));
                    } else {
                        this.splice.apply(this, [0, this.length].concat(can.makeArray(newList || [])));
                    }

                    return this;
                }
            });
        can.List = Map.List = list;
        return can.List;
    })(__m2, __m12);

    // ## compute/compute.js
    var __m16 = (function(can, bind) {
        var names = [
            '__reading',
            '__clearReading',
            '__setReading'
        ],
            setup = function(observed) {
                var old = {};
                for (var i = 0; i < names.length; i++) {
                    old[names[i]] = can[names[i]];
                }
                can.__reading = function(obj, attr) {
                    // Add the observe and attr that was read
                    // to `observed`
                    observed.push({
                            obj: obj,
                            attr: attr + ''
                        });
                };
                can.__clearReading = function() {
                    return observed.splice(0, observed.length);
                };
                can.__setReading = function(o) {
                    [].splice.apply(observed, [
                            0,
                            observed.length
                        ].concat(o));
                };
                return old;
            },
            // empty default function
            k = function() {};
        // returns the
        // - observes and attr methods are called by func
        // - the value returned by func
        // ex: `{value: 100, observed: [{obs: o, attr: "completed"}]}`
        var getValueAndObserved = function(func, self) {
            var observed = [],
                old = setup(observed),
                // Call the "wrapping" function to get the value. `observed`
                // will have the observe/attribute pairs that were read.
                value = func.call(self);
            // Set back so we are no longer reading.
            can.simpleExtend(can, old);
            return {
                value: value,
                observed: observed
            };
        },
            // Calls `callback(newVal, oldVal)` everytime an observed property
            // called within `getterSetter` is changed and creates a new result of `getterSetter`.
            // Also returns an object that can teardown all event handlers.
            computeBinder = function(getterSetter, context, callback, computeState) {
                // track what we are observing
                var observing = {},
                    // a flag indicating if this observe/attr pair is already bound
                    matched = true,
                    // the data to return
                    data = {
                        value: undefined,
                        teardown: function() {
                            for (var name in observing) {
                                var ob = observing[name];
                                ob.observe.obj.unbind(ob.observe.attr, onchanged);
                                delete observing[name];
                            }
                        }
                    }, batchNum;
                // when a property value is changed
                var onchanged = function(ev) {
                    // If the compute is no longer bound (because the same change event led to an unbind)
                    // then do not call getValueAndBind, or we will leak bindings.
                    if (computeState && !computeState.bound) {
                        return;
                    }
                    if (ev.batchNum === undefined || ev.batchNum !== batchNum) {
                        // store the old value
                        var oldValue = data.value,
                            // get the new value
                            newvalue = getValueAndBind();
                        // update the value reference (in case someone reads)
                        data.value = newvalue;
                        // if a change happened
                        if (newvalue !== oldValue) {
                            callback(newvalue, oldValue);
                        }
                        batchNum = batchNum = ev.batchNum;
                    }
                };
                // gets the value returned by `getterSetter` and also binds to any attributes
                // read by the call
                var getValueAndBind = function() {
                    var info = getValueAndObserved(getterSetter, context),
                        newObserveSet = info.observed;
                    var value = info.value,
                        ob;
                    matched = !matched;
                    // go through every attribute read by this observe
                    for (var i = 0, len = newObserveSet.length; i < len; i++) {
                        ob = newObserveSet[i];
                        // if the observe/attribute pair is being observed
                        if (observing[ob.obj._cid + '|' + ob.attr]) {
                            // mark at as observed
                            observing[ob.obj._cid + '|' + ob.attr].matched = matched;
                        } else {
                            // otherwise, set the observe/attribute on oldObserved, marking it as being observed
                            observing[ob.obj._cid + '|' + ob.attr] = {
                                matched: matched,
                                observe: ob
                            };
                            ob.obj.bind(ob.attr, onchanged);
                        }
                    }
                    // Iterate through oldObserved, looking for observe/attributes
                    // that are no longer being bound and unbind them
                    for (var name in observing) {
                        ob = observing[name];
                        if (ob.matched !== matched) {
                            ob.observe.obj.unbind(ob.observe.attr, onchanged);
                            delete observing[name];
                        }
                    }
                    return value;
                };
                // set the initial value
                data.value = getValueAndBind();
                data.isListening = !can.isEmptyObject(observing);
                return data;
            };
        var isObserve = function(obj) {
            return obj instanceof can.Map || obj && obj.__get;
        };
        // if no one is listening ... we can not calculate every time
        can.compute = function(getterSetter, context, eventName) {
            if (getterSetter && getterSetter.isComputed) {
                return getterSetter;
            }
            // stores the result of computeBinder
            var computedData,
                // the computed object
                computed,
                // an object that keeps track if the computed is bound
                // onchanged needs to know this. It's possible a change happens and results in
                // something that unbinds the compute, it needs to not to try to recalculate who it
                // is listening to
                computeState = {
                    bound: false,
                    hasDependencies: false
                },
                // The following functions are overwritten depending on how compute() is called
                // a method to setup listening
                on = k,
                // a method to teardown listening
                off = k,
                // the current cached value (only valid if bound = true)
                value,
                // how to read the value
                get = function() {
                    return value;
                },
                // sets the value
                set = function(newVal) {
                    value = newVal;
                },
                // this compute can be a dependency of other computes
                canReadForChangeEvent = true,
                // save for clone
                args = can.makeArray(arguments),
                updater = function(newValue, oldValue) {
                    value = newValue;
                    // might need a way to look up new and oldVal
                    can.batch.trigger(computed, 'change', [
                            newValue,
                            oldValue
                        ]);
                },
                // the form of the arguments
                form;
            computed = function(newVal) {
                // setting ...
                if (arguments.length) {
                    // save a reference to the old value
                    var old = value;
                    // setter may return a value if
                    // setter is for a value maintained exclusively by this compute
                    var setVal = set.call(context, newVal, old);
                    // if this has dependencies return the current value
                    if (computed.hasDependencies) {
                        return get.call(context);
                    }
                    if (setVal === undefined) {
                        // it's possible, like with the DOM, setting does not
                        // fire a change event, so we must read
                        value = get.call(context);
                    } else {
                        value = setVal;
                    }
                    // fire the change
                    if (old !== value) {
                        can.batch.trigger(computed, 'change', [
                                value,
                                old
                            ]);
                    }
                    return value;
                } else {
                    // Another compute wants to bind to this compute
                    if (can.__reading && canReadForChangeEvent) {
                        // Tell the compute to listen to change on this computed
                        can.__reading(computed, 'change');
                        // We are going to bind on this compute.
                        // If we are not bound, we should bind so that
                        // we don't have to re-read to get the value of this compute.
                        if (!computeState.bound) {
                            can.compute.temporarilyBind(computed);
                        }
                    }
                    // if we are bound, use the cached value
                    if (computeState.bound) {
                        return value;
                    } else {
                        return get.call(context);
                    }
                }
            };
            if (typeof getterSetter === 'function') {
                set = getterSetter;
                get = getterSetter;
                canReadForChangeEvent = eventName === false ? false : true;
                computed.hasDependencies = false;
                on = function(update) {
                    computedData = computeBinder(getterSetter, context || this, update, computeState);
                    computed.hasDependencies = computedData.isListening;
                    value = computedData.value;
                };
                off = function() {
                    if (computedData) {
                        computedData.teardown();
                    }
                };
            } else if (context) {
                if (typeof context === 'string') {
                    // `can.compute(obj, "propertyName", [eventName])`
                    var propertyName = context,
                        isObserve = getterSetter instanceof can.Map;
                    if (isObserve) {
                        computed.hasDependencies = true;
                    }
                    get = function() {
                        if (isObserve) {
                            return getterSetter.attr(propertyName);
                        } else {
                            return getterSetter[propertyName];
                        }
                    };
                    set = function(newValue) {
                        if (isObserve) {
                            getterSetter.attr(propertyName, newValue);
                        } else {
                            getterSetter[propertyName] = newValue;
                        }
                    };
                    var handler;
                    on = function(update) {
                        handler = function() {
                            update(get(), value);
                        };
                        can.bind.call(getterSetter, eventName || propertyName, handler);
                        // use getValueAndObserved because
                        // we should not be indicating that some parent
                        // reads this property if it happens to be binding on it
                        value = getValueAndObserved(get)
                            .value;
                    };
                    off = function() {
                        can.unbind.call(getterSetter, eventName || propertyName, handler);
                    };
                } else {
                    // `can.compute(initialValue, setter)`
                    if (typeof context === 'function') {
                        value = getterSetter;
                        set = context;
                        context = eventName;
                        form = 'setter';
                    } else {
                        // `can.compute(initialValue,{get:, set:, on:, off:})`
                        value = getterSetter;
                        var options = context,
                            oldUpdater = updater;

                        updater = function() {
                            var newVal = get.call(context);
                            if (newVal !== value) {
                                oldUpdater(newVal, value);
                            }
                        };
                        get = options.get || get;
                        set = options.set || set;
                        on = options.on || on;
                        off = options.off || off;
                    }
                }
            } else {
                // `can.compute(5)`
                value = getterSetter;
            }
            can.cid(computed, 'compute');
            return can.simpleExtend(computed, {

                    isComputed: true,
                    _bindsetup: function() {
                        computeState.bound = true;
                        // setup live-binding
                        // while binding, this does not count as a read
                        var oldReading = can.__reading;
                        delete can.__reading;
                        on.call(this, updater);
                        can.__reading = oldReading;
                    },
                    _bindteardown: function() {
                        off.call(this, updater);
                        computeState.bound = false;
                    },

                    bind: can.bindAndSetup,

                    unbind: can.unbindAndTeardown,
                    clone: function(context) {
                        if (context) {
                            if (form === 'setter') {
                                args[2] = context;
                            } else {
                                args[1] = context;
                            }
                        }
                        return can.compute.apply(can, args);
                    }
                });
        };
        // a list of temporarily bound computes
        var computes, unbindComputes = function() {
                for (var i = 0, len = computes.length; i < len; i++) {
                    computes[i].unbind('change', k);
                }
                computes = null;
            };
        // Binds computes for a moment to retain their value and prevent caching
        can.compute.temporarilyBind = function(compute) {
            compute.bind('change', k);
            if (!computes) {
                computes = [];
                setTimeout(unbindComputes, 10);
            }
            computes.push(compute);
        };
        can.compute.binder = computeBinder;
        can.compute.truthy = function(compute) {
            return can.compute(function() {
                var res = compute();
                if (typeof res === 'function') {
                    res = res();
                }
                return !!res;
            });
        };

        can.compute.read = function(parent, reads, options) {
            options = options || {};
            // `cur` is the current value.
            var cur = parent,
                type,
                // `prev` is the object we are reading from.
                prev,
                // `foundObs` did we find an observable.
                foundObs;
            for (var i = 0, readLength = reads.length; i < readLength; i++) {
                // Update what we are reading from.
                prev = cur;
                // Read from the compute. We can't read a property yet.
                if (prev && prev.isComputed) {
                    if (options.foundObservable) {
                        options.foundObservable(prev, i);
                    }
                    prev = prev();
                }
                // Look to read a property from something.
                if (isObserve(prev)) {
                    if (!foundObs && options.foundObservable) {
                        options.foundObservable(prev, i);
                    }
                    foundObs = 1;
                    // is it a method on the prototype?
                    if (typeof prev[reads[i]] === 'function' && prev.constructor.prototype[reads[i]] === prev[reads[i]]) {
                        // call that method
                        if (options.returnObserveMethods) {
                            cur = cur[reads[i]];
                        } else if (reads[i] === 'constructor' && prev instanceof can.Construct) {
                            cur = prev[reads[i]];
                        } else {
                            cur = prev[reads[i]].apply(prev, options.args || []);
                        }
                    } else {
                        // use attr to get that value
                        cur = cur.attr(reads[i]);
                    }
                } else {
                    // just do the dot operator
                    cur = prev[reads[i]];
                }
                // If it's a compute, get the compute's value
                // unless we are at the end of the 
                if (cur && cur.isComputed && (!options.isArgument && i < readLength - 1)) {
                    if (!foundObs && options.foundObservable) {
                        options.foundObservable(prev, i + 1);
                    }
                    cur = cur();
                }
                type = typeof cur;
                // if there are properties left to read, and we don't have an object, early exit
                if (i < reads.length - 1 && (cur === null || type !== 'function' && type !== 'object')) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i, cur);
                    }
                    // return undefined so we know this isn't the right value
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            // handle an ending function
            if (typeof cur === 'function') {
                if (options.isArgument) {
                    if (!cur.isComputed && options.proxyMethods !== false) {
                        cur = can.proxy(cur, prev);
                    }
                } else {
                    if (cur.isComputed && !foundObs && options.foundObservable) {
                        options.foundObservable(cur, i);
                    }
                    cur = cur.call(prev);
                }
            }
            // if we don't have a value, exit early.
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        };

        return can.compute;
    })(__m2, __m13, __m14);

    // ## observe/observe.js
    var __m11 = (function(can) {
        can.Observe = can.Map;
        can.Observe.startBatch = can.batch.start;
        can.Observe.stopBatch = can.batch.stop;
        can.Observe.triggerBatch = can.batch.trigger;
        return can;
    })(__m2, __m12, __m15, __m16);

    // ## view/view.js
    var __m19 = (function(can) {
        // ## view.js
        // `can.view`  
        // _Templating abstraction._

        var isFunction = can.isFunction,
            makeArray = can.makeArray,
            // Used for hookup `id`s.
            hookupId = 1,

            $view = can.view = can.template = function(view, data, helpers, callback) {
                // If helpers is a `function`, it is actually a callback.
                if (isFunction(helpers)) {
                    callback = helpers;
                    helpers = undefined;
                }

                var pipe = function(result) {
                    return $view.frag(result);
                },
                    // In case we got a callback, we need to convert the can.view.render
                    // result to a document fragment
                    wrapCallback = isFunction(callback) ? function(frag) {
                        callback(pipe(frag));
                    } : null,
                    // Get the result, if a renderer function is passed in, then we just use that to render the data
                    result = isFunction(view) ? view(data, helpers, wrapCallback) : $view.render(view, data, helpers, wrapCallback),
                    deferred = can.Deferred();

                if (isFunction(result)) {
                    return result;
                }

                if (can.isDeferred(result)) {
                    result.then(function(result, data) {
                        deferred.resolve.call(deferred, pipe(result), data);
                    }, function() {
                        deferred.fail.apply(deferred, arguments);
                    });
                    return deferred;
                }

                // Convert it into a dom frag.
                return pipe(result);
            };

        can.extend($view, {
                // creates a frag and hooks it up all at once

                frag: function(result, parentNode) {
                    return $view.hookup($view.fragment(result), parentNode);
                },

                // simply creates a frag
                // this is used internally to create a frag
                // insert it
                // then hook it up
                fragment: function(result) {
                    var frag = can.buildFragment(result, document.body);
                    // If we have an empty frag...
                    if (!frag.childNodes.length) {
                        frag.appendChild(document.createTextNode(''));
                    }
                    return frag;
                },

                // Convert a path like string into something that's ok for an `element` ID.
                toId: function(src) {
                    return can.map(src.toString()
                        .split(/\/|\./g), function(part) {
                            // Dont include empty strings in toId functions
                            if (part) {
                                return part;
                            }
                        })
                        .join('_');
                },

                hookup: function(fragment, parentNode) {
                    var hookupEls = [],
                        id,
                        func;

                    // Get all `childNodes`.
                    can.each(fragment.childNodes ? can.makeArray(fragment.childNodes) : fragment, function(node) {
                        if (node.nodeType === 1) {
                            hookupEls.push(node);
                            hookupEls.push.apply(hookupEls, can.makeArray(node.getElementsByTagName('*')));
                        }
                    });

                    // Filter by `data-view-id` attribute.
                    can.each(hookupEls, function(el) {
                        if (el.getAttribute && (id = el.getAttribute('data-view-id')) && (func = $view.hookups[id])) {
                            func(el, parentNode, id);
                            delete $view.hookups[id];
                            el.removeAttribute('data-view-id');
                        }
                    });

                    return fragment;
                },


                // auj

                // heir

                hookups: {},


                hook: function(cb) {
                    $view.hookups[++hookupId] = cb;
                    return ' data-view-id=\'' + hookupId + '\'';
                },


                cached: {},

                cachedRenderers: {},


                cache: true,


                register: function(info) {
                    this.types['.' + info.suffix] = info;
                },

                types: {},


                ext: ".ejs",


                registerScript: function() {},


                preload: function() {},


                render: function(view, data, helpers, callback) {
                    // If helpers is a `function`, it is actually a callback.
                    if (isFunction(helpers)) {
                        callback = helpers;
                        helpers = undefined;
                    }

                    // See if we got passed any deferreds.
                    var deferreds = getDeferreds(data);
                    var reading, deferred, dataCopy, async, response;
                    if (deferreds.length) {
                        // Does data contain any deferreds?
                        // The deferred that resolves into the rendered content...
                        deferred = new can.Deferred();
                        dataCopy = can.extend({}, data);

                        // Add the view request to the list of deferreds.
                        deferreds.push(get(view, true));
                        // Wait for the view and all deferreds to finish...
                        can.when.apply(can, deferreds)
                            .then(function(resolved) {
                                // Get all the resolved deferreds.
                                var objs = makeArray(arguments),
                                    // Renderer is the last index of the data.
                                    renderer = objs.pop(),
                                    // The result of the template rendering with data.
                                    result;

                                // Make data look like the resolved deferreds.
                                if (can.isDeferred(data)) {
                                    dataCopy = usefulPart(resolved);
                                } else {
                                    // Go through each prop in data again and
                                    // replace the defferreds with what they resolved to.
                                    for (var prop in data) {
                                        if (can.isDeferred(data[prop])) {
                                            dataCopy[prop] = usefulPart(objs.shift());
                                        }
                                    }
                                }

                                // Get the rendered result.
                                result = renderer(dataCopy, helpers);

                                // Resolve with the rendered view.
                                deferred.resolve(result, dataCopy);

                                // If there's a `callback`, call it back with the result.
                                if (callback) {
                                    callback(result, dataCopy);
                                }
                            }, function() {
                                deferred.reject.apply(deferred, arguments);
                            });
                        // Return the deferred...
                        return deferred;
                    } else {
                        // get is called async but in 
                        // ff will be async so we need to temporarily reset
                        if (can.__reading) {
                            reading = can.__reading;
                            can.__reading = null;
                        }

                        // No deferreds! Render this bad boy.

                        // If there's a `callback` function
                        async = isFunction(callback);
                        // Get the `view` type
                        deferred = get(view, async);
                        if (can.Map && reading) {
                            can.__reading = reading;
                        }

                        // If we are `async`...
                        if (async) {
                            // Return the deferred
                            response = deferred;
                            // And fire callback with the rendered result.
                            deferred.then(function(renderer) {
                                callback(data ? renderer(data, helpers) : renderer);
                            });
                        } else {
                            // if the deferred is resolved, call the cached renderer instead
                            // this is because it's possible, with recursive deferreds to
                            // need to render a view while its deferred is _resolving_.  A _resolving_ deferred
                            // is a deferred that was just resolved and is calling back it's success callbacks.
                            // If a new success handler is called while resoliving, it does not get fired by
                            // jQuery's deferred system.  So instead of adding a new callback
                            // we use the cached renderer.
                            // We also add __view_id on the deferred so we can look up it's cached renderer.
                            // In the future, we might simply store either a deferred or the cached result.
                            if (deferred.state() === 'resolved' && deferred.__view_id) {
                                var currentRenderer = $view.cachedRenderers[deferred.__view_id];
                                return data ? currentRenderer(data, helpers) : currentRenderer;
                            } else {
                                // Otherwise, the deferred is complete, so
                                // set response to the result of the rendering.
                                deferred.then(function(renderer) {
                                    response = data ? renderer(data, helpers) : renderer;
                                });
                            }
                        }

                        return response;
                    }
                },


                registerView: function(id, text, type, def) {
                    // Get the renderer function.
                    var func = (type || $view.types[$view.ext])
                        .renderer(id, text);
                    def = def || new can.Deferred();

                    // Cache if we are caching.
                    if ($view.cache) {
                        $view.cached[id] = def;
                        def.__view_id = id;
                        $view.cachedRenderers[id] = func;
                    }

                    // Return the objects for the response's `dataTypes`
                    // (in this case view).
                    return def.resolve(func);
                }
            });

        // Makes sure there's a template, if not, have `steal` provide a warning.
        var checkText = function(text, url) {
            if (!text.length) {



                throw "can.view: No template or empty template:" + url;
            }
        },
            // `Returns a `view` renderer deferred.  
            // `url` - The url to the template.  
            // `async` - If the ajax request should be asynchronous.  
            // Returns a deferred.
            get = function(obj, async) {
                var url = typeof obj === 'string' ? obj : obj.url,
                    suffix = obj.engine || url.match(/\.[\w\d]+$/),
                    type,
                    // If we are reading a script element for the content of the template,
                    // `el` will be set to that script element.
                    el,
                    // A unique identifier for the view (used for caching).
                    // This is typically derived from the element id or
                    // the url for the template.
                    id;

                //If the url has a #, we assume we want to use an inline template
                //from a script element and not current page's HTML
                if (url.match(/^#/)) {
                    url = url.substr(1);
                }
                // If we have an inline template, derive the suffix from the `text/???` part.
                // This only supports `<script>` tags.
                if (el = document.getElementById(url)) {
                    suffix = '.' + el.type.match(/\/(x\-)?(.+)/)[2];
                }

                // If there is no suffix, add one.
                if (!suffix && !$view.cached[url]) {
                    url += suffix = $view.ext;
                }

                if (can.isArray(suffix)) {
                    suffix = suffix[0];
                }

                // Convert to a unique and valid id.
                id = $view.toId(url);

                // If an absolute path, use `steal`/`require` to get it.
                // You should only be using `//` if you are using an AMD loader like `steal` or `require` (not almond).
                if (url.match(/^\/\//)) {
                    url = url.substr(2);
                    url = !window.steal ?
                        url :
                        steal.config()
                        .root.mapJoin("" + steal.id(url));
                }

                // Localize for `require` (not almond)
                if (window.require) {
                    if (require.toUrl) {
                        url = require.toUrl(url);
                    }
                }

                // Set the template engine type.
                type = $view.types[suffix];

                // If it is cached, 
                if ($view.cached[id]) {
                    // Return the cached deferred renderer.
                    return $view.cached[id];

                    // Otherwise if we are getting this from a `<script>` element.
                } else if (el) {
                    // Resolve immediately with the element's `innerHTML`.
                    return $view.registerView(id, el.innerHTML, type);
                } else {
                    // Make an ajax request for text.
                    var d = new can.Deferred();
                    can.ajax({
                            async: async,
                            url: url,
                            dataType: 'text',
                            error: function(jqXHR) {
                                checkText('', url);
                                d.reject(jqXHR);
                            },
                            success: function(text) {
                                // Make sure we got some text back.
                                checkText(text, url);
                                $view.registerView(id, text, type, d);
                            }
                        });
                    return d;
                }
            },
            // Gets an `array` of deferreds from an `object`.
            // This only goes one level deep.
            getDeferreds = function(data) {
                var deferreds = [];

                // pull out deferreds
                if (can.isDeferred(data)) {
                    return [data];
                } else {
                    for (var prop in data) {
                        if (can.isDeferred(data[prop])) {
                            deferreds.push(data[prop]);
                        }
                    }
                }
                return deferreds;
            },
            // Gets the useful part of a resolved deferred.
            // This is for `model`s and `can.ajax` that resolve to an `array`.
            usefulPart = function(resolved) {
                return can.isArray(resolved) && resolved[1] === 'success' ? resolved[0] : resolved;
            };

        can.extend($view, {
                register: function(info) {
                    this.types['.' + info.suffix] = info;



                    $view[info.suffix] = function(id, text) {
                        if (!text) {
                            // Return a nameless renderer
                            var renderer = function() {
                                return $view.frag(renderer.render.apply(this, arguments));
                            };
                            renderer.render = function() {
                                var renderer = info.renderer(null, id);
                                return renderer.apply(renderer, arguments);
                            };
                            return renderer;
                        }

                        return $view.preload(id, info.renderer(id, text));
                    };
                },
                registerScript: function(type, id, src) {
                    return 'can.view.preload(\'' + id + '\',' + $view.types['.' + type].script(id, src) + ');';
                },
                preload: function(id, renderer) {
                    var def = $view.cached[id] = new can.Deferred()
                        .resolve(function(data, helpers) {
                            return renderer.call(data, data, helpers);
                        });

                    function frag() {
                        return $view.frag(renderer.apply(this, arguments));
                    }
                    // expose the renderer for mustache
                    frag.render = renderer;

                    // set cache references (otherwise preloaded recursive views won't recurse properly)
                    def.__view_id = id;
                    $view.cachedRenderers[id] = renderer;

                    return frag;
                }

            });

        return can;
    })(__m2);

    // ## view/scope/scope.js
    var __m18 = (function(can) {
        var escapeReg = /(\\)?\./g;
        var escapeDotReg = /\\\./g;
        var getNames = function(attr) {
            var names = [],
                last = 0;
            attr.replace(escapeReg, function(first, second, index) {
                if (!second) {
                    names.push(attr.slice(last, index)
                        .replace(escapeDotReg, '.'));
                    last = index + first.length;
                }
            });
            names.push(attr.slice(last)
                .replace(escapeDotReg, '.'));
            return names;
        };

        var Scope = can.Construct.extend(


            {
                // reads properties from a parent.  A much more complex version of getObject.

                read: can.compute.read
            },

            {
                init: function(context, parent) {
                    this._context = context;
                    this._parent = parent;
                },

                attr: function(key) {
                    // reads for whatever called before attr.  It's possible
                    // that this.read clears them.  We want to restore them.
                    var previousReads = can.__clearReading && can.__clearReading(),
                        res = this.read(key, {
                                isArgument: true,
                                returnObserveMethods: true,
                                proxyMethods: false
                            })
                            .value;
                    if (can.__setReading) {
                        can.__setReading(previousReads);
                    }
                    return res;
                },

                add: function(context) {
                    if (context !== this._context) {
                        return new this.constructor(context, this);
                    } else {
                        return this;
                    }
                },

                computeData: function(key, options) {
                    options = options || {
                        args: []
                    };
                    var self = this,
                        rootObserve, rootReads, computeData = {
                            compute: can.compute(function(newVal) {
                                if (arguments.length) {
                                    // check that there's just a compute with nothing from it ...
                                    if (rootObserve.isComputed && !rootReads.length) {
                                        rootObserve(newVal);
                                    } else {
                                        var last = rootReads.length - 1;
                                        Scope.read(rootObserve, rootReads.slice(0, last))
                                            .value.attr(rootReads[last], newVal);
                                    }
                                } else {
                                    if (rootObserve) {
                                        return Scope.read(rootObserve, rootReads, options)
                                            .value;
                                    }
                                    // otherwise, go get the value
                                    var data = self.read(key, options);
                                    rootObserve = data.rootObserve;
                                    rootReads = data.reads;
                                    computeData.scope = data.scope;
                                    computeData.initialValue = data.value;
                                    return data.value;
                                }
                            })
                        };
                    return computeData;
                },

                read: function(attr, options) {
                    // check if we should be running this on a parent.
                    if (attr.substr(0, 3) === '../') {
                        return this._parent.read(attr.substr(3), options);
                    } else if (attr === '..') {
                        return {
                            value: this._parent._context
                        };
                    } else if (attr === '.' || attr === 'this') {
                        return {
                            value: this._context
                        };
                    }
                    // Split the name up.
                    var names = attr.indexOf('\\.') === -1 ?
                    // Reference doesn't contain escaped periods
                    attr.split('.')
                    // Reference contains escaped periods (`a.b\c.foo` == `a["b.c"].foo)
                    : getNames(attr),
                        // The current context (a scope is just data and a parent scope).
                        context,
                        // The current scope.
                        scope = this,
                        // While we are looking for a value, we track the most likely place this value will be found.  
                        // This is so if there is no me.name.first, we setup a listener on me.name.
                        // The most likely canidate is the one with the most "read matches" "lowest" in the
                        // context chain.
                        // By "read matches", we mean the most number of values along the key.
                        // By "lowest" in the context chain, we mean the closest to the current context.
                        // We track the starting position of the likely place with `defaultObserve`.
                        defaultObserve,
                        // Tracks how to read from the defaultObserve.
                        defaultReads = [],
                        // Tracks the highest found number of "read matches".
                        defaultPropertyDepth = -1,
                        // `scope.read` is designed to be called within a compute, but
                        // for performance reasons only listens to observables within one context.
                        // This is to say, if you have me.name in the current context, but me.name.first and
                        // we are looking for me.name.first, we don't setup bindings on me.name and me.name.first.
                        // To make this happen, we clear readings if they do not find a value.  But,
                        // if that path turns out to be the default read, we need to restore them.  This
                        // variable remembers those reads so they can be restored.
                        defaultComputeReadings,
                        // Tracks the default's scope.
                        defaultScope,
                        // Tracks the first found observe.
                        currentObserve,
                        // Tracks the reads to get the value for a scope.
                        currentReads;
                    // While there is a scope/context to look in.
                    while (scope) {
                        // get the context
                        context = scope._context;
                        if (context !== null) {
                            // Lets try this context
                            var data = Scope.read(context, names, can.simpleExtend({
                                        // Called when an observable is found.
                                        foundObservable: function(observe, nameIndex) {
                                            // Save the current observe.
                                            currentObserve = observe;
                                            currentReads = names.slice(nameIndex);
                                        },
                                        // Called when we were unable to find a value.
                                        earlyExit: function(parentValue, nameIndex) {
                                            // If this has more matching values,
                                            if (nameIndex > defaultPropertyDepth) {
                                                // save the state.
                                                defaultObserve = currentObserve;
                                                defaultReads = currentReads;
                                                defaultPropertyDepth = nameIndex;
                                                defaultScope = scope;
                                                // Clear and save readings so next attempt does not use these readings
                                                defaultComputeReadings = can.__clearReading && can.__clearReading();
                                            }
                                        }
                                    }, options));
                            // Found a matched reference.
                            if (data.value !== undefined) {
                                return {
                                    scope: scope,
                                    rootObserve: currentObserve,
                                    value: data.value,
                                    reads: currentReads
                                };
                            }
                        }
                        // Prevent prior readings.
                        if (can.__clearReading) {
                            can.__clearReading();
                        }
                        // Move up to the next scope.
                        scope = scope._parent;
                    }
                    // If there was a likely observe.
                    if (defaultObserve) {
                        // Restore reading for previous compute
                        if (can.__setReading) {
                            can.__setReading(defaultComputeReadings);
                        }
                        return {
                            scope: defaultScope,
                            rootObserve: defaultObserve,
                            reads: defaultReads,
                            value: undefined
                        };
                    } else {
                        // we found nothing and no observable
                        return {
                            names: names,
                            value: undefined
                        };
                    }
                }
            });
        can.view.Scope = Scope;
        return Scope;
    })(__m2, __m9, __m12, __m15, __m19, __m16);

    // ## view/elements.js
    var __m21 = (function(can) {

        var elements = {
            tagToContentPropMap: {
                option: 'textContent' in document.createElement('option') ? 'textContent' : 'innerText',
                textarea: 'value'
            },

            attrMap: {
                'class': 'className',
                'value': 'value',
                'innerText': 'innerText',
                'textContent': 'textContent',
                'checked': true,
                'disabled': true,
                'readonly': true,
                'required': true,
                src: function(el, val) {
                    if (val === null || val === '') {
                        el.removeAttribute('src');
                    } else {
                        el.setAttribute('src', val);
                    }
                }
            },
            attrReg: /([^\s=]+)[\s]*=[\s]*/,
            // elements whos default value we should set
            defaultValue: ["input", "textarea"],
            // a map of parent element to child elements

            tagMap: {
                '': 'span',
                table: 'tbody',
                tr: 'td',
                ol: 'li',
                ul: 'li',
                tbody: 'tr',
                thead: 'tr',
                tfoot: 'tr',
                select: 'option',
                optgroup: 'option'
            },
            // a tag's parent element
            reverseTagMap: {
                tr: 'tbody',
                option: 'select',
                td: 'tr',
                th: 'tr',
                li: 'ul'
            },
            // Used to determine the parentNode if el is directly within a documentFragment
            getParentNode: function(el, defaultParentNode) {
                return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
            },
            // Set an attribute on an element
            setAttr: function(el, attrName, val) {
                var tagName = el.nodeName.toString()
                    .toLowerCase(),
                    prop = elements.attrMap[attrName];
                // if this is a special property
                if (typeof prop === "function") {
                    prop(el, val);
                } else if (prop === true && attrName === "checked" && el.type === "radio") {
                    // IE7 bugs sometimes if defaultChecked isn't set first
                    if (can.inArray(tagName, elements.defaultValue) >= 0) {
                        el.defaultChecked = true;
                    }
                    el[attrName] = true;
                } else if (prop === true) {
                    el[attrName] = true;
                } else if (prop) {
                    // set the value as true / false
                    el[prop] = val;
                    if (prop === 'value' && can.inArray(tagName, elements.defaultValue) >= 0) {
                        el.defaultValue = val;
                    }
                } else {
                    el.setAttribute(attrName, val);
                }
            },
            // Gets the value of an attribute.
            getAttr: function(el, attrName) {
                // Default to a blank string for IE7/8
                return (elements.attrMap[attrName] && el[elements.attrMap[attrName]] ? el[elements.attrMap[attrName]] : el.getAttribute(attrName)) || '';
            },
            // Removes the attribute.
            removeAttr: function(el, attrName) {
                var setter = elements.attrMap[attrName];
                if (setter === true) {
                    el[attrName] = false;
                } else if (typeof setter === 'string') {
                    el[setter] = '';
                } else {
                    el.removeAttribute(attrName);
                }
            },
            // Gets a "pretty" value for something
            contentText: function(text) {
                if (typeof text === 'string') {
                    return text;
                }
                // If has no value, return an empty string.
                if (!text && text !== 0) {
                    return '';
                }
                return '' + text;
            },

            after: function(oldElements, newFrag) {
                var last = oldElements[oldElements.length - 1];
                // Insert it in the `document` or `documentFragment`
                if (last.nextSibling) {
                    can.insertBefore(last.parentNode, newFrag, last.nextSibling);
                } else {
                    can.appendChild(last.parentNode, newFrag);
                }
            },

            replace: function(oldElements, newFrag) {
                elements.after(oldElements, newFrag);
                can.remove(can.$(oldElements));
            }
        };
        // TODO: this doesn't seem to be doing anything
        // feature detect if setAttribute works with styles
        (function() {
            // feature detect if
            var div = document.createElement('div');
            div.setAttribute('style', 'width: 5px');
            div.setAttribute('style', 'width: 10px');
            // make style use cssText
            elements.attrMap.style = function(el, val) {
                el.style.cssText = val || '';
            };
        }());
        return elements;
    })(__m2);

    // ## view/scanner.js
    var __m20 = (function(can, elements) {


        var newLine = /(\r|\n)+/g,
            // Escapes characters starting with `\`.
            clean = function(content) {
                return content.split('\\')
                    .join('\\\\')
                    .split('\n')
                    .join('\\n')
                    .split('"')
                    .join('\\"')
                    .split('\t')
                    .join('\\t');
            },
            // Returns a tagName to use as a temporary placeholder for live content
            // looks forward ... could be slow, but we only do it when necessary
            getTag = function(tagName, tokens, i) {
                // if a tagName is provided, use that
                if (tagName) {
                    return tagName;
                } else {
                    // otherwise go searching for the next two tokens like "<",TAG
                    while (i < tokens.length) {
                        if (tokens[i] === '<' && elements.reverseTagMap[tokens[i + 1]]) {
                            return elements.reverseTagMap[tokens[i + 1]];
                        }
                        i++;
                    }
                }
                return '';
            }, bracketNum = function(content) {
                return content.split('{')
                    .length - content.split('}')
                    .length;
            }, myEval = function(script) {
                eval(script);
            },
            attrReg = /([^\s]+)[\s]*=[\s]*$/,
            // Commands for caching.
            startTxt = 'var ___v1ew = [];',
            finishTxt = 'return ___v1ew.join(\'\')',
            put_cmd = '___v1ew.push(\n',
            insert_cmd = put_cmd,
            // Global controls (used by other functions to know where we are).
            // Are we inside a tag?
            htmlTag = null,
            // Are we within a quote within a tag?
            quote = null,
            // What was the text before the current quote? (used to get the `attr` name)
            beforeQuote = null,
            // Whether a rescan is in progress
            rescan = null,
            getAttrName = function() {
                var matches = beforeQuote.match(attrReg);
                return matches && matches[1];
            },
            // Used to mark where the element is.
            status = function() {
                // `t` - `1`.
                // `h` - `0`.
                // `q` - String `beforeQuote`.
                return quote ? '\'' + getAttrName() + '\'' : htmlTag ? 1 : 0;
            },
            // returns the top of a stack
            top = function(stack) {
                return stack[stack.length - 1];
            },
            // characters that automatically mean a custom element
            automaticCustomElementCharacters = /[-\:]/,
            Scanner;


        can.view.Scanner = Scanner = function(options) {
            // Set options on self
            can.extend(this, {

                    text: {},
                    tokens: []
                }, options);
            // make sure it's an empty string if it's not
            this.text.options = this.text.options || '';
            // Cache a token lookup
            this.tokenReg = [];
            this.tokenSimple = {
                "<": "<",
                ">": ">",
                '"': '"',
                "'": "'"
            };
            this.tokenComplex = [];
            this.tokenMap = {};
            for (var i = 0, token; token = this.tokens[i]; i++) {


                // Save complex mappings (custom regexp)
                if (token[2]) {
                    this.tokenReg.push(token[2]);
                    this.tokenComplex.push({
                            abbr: token[1],
                            re: new RegExp(token[2]),
                            rescan: token[3]
                        });
                }
                // Save simple mappings (string only, no regexp)
                else {
                    this.tokenReg.push(token[1]);
                    this.tokenSimple[token[1]] = token[0];
                }
                this.tokenMap[token[0]] = token[1];
            }

            // Cache the token registry.
            this.tokenReg = new RegExp("(" + this.tokenReg.slice(0)
                .concat(["<", ">", '"', "'"])
                .join("|") + ")", "g");
        };

        Scanner.attributes = {};
        Scanner.regExpAttributes = {};

        Scanner.attribute = function(attribute, callback) {
            if (typeof attribute === 'string') {
                Scanner.attributes[attribute] = callback;
            } else {
                Scanner.regExpAttributes[attribute] = {
                    match: attribute,
                    callback: callback
                };
            }
        };
        Scanner.hookupAttributes = function(options, el) {
            can.each(options && options.attrs || [], function(attr) {
                options.attr = attr;
                if (Scanner.attributes[attr]) {
                    Scanner.attributes[attr](options, el);
                } else {
                    can.each(Scanner.regExpAttributes, function(attrMatcher) {
                        if (attrMatcher.match.test(attr)) {
                            attrMatcher.callback(options, el);
                        }
                    });
                }
            });
        };
        Scanner.tag = function(tagName, callback) {
            // if we have html5shive ... re-generate
            if (window.html5) {
                window.html5.elements += ' ' + tagName;
                window.html5.shivDocument();
            }

            Scanner.tags[tagName.toLowerCase()] = callback;
        };
        Scanner.tags = {};
        // This is called when there is a special tag
        Scanner.hookupTag = function(hookupOptions) {
            // we need to call any live hookups
            // so get that and return the hook
            // a better system will always be called with the same stuff
            var hooks = can.view.getHooks();
            return can.view.hook(function(el) {
                can.each(hooks, function(fn) {
                    fn(el);
                });

                var tagName = hookupOptions.tagName,
                    helperTagCallback = hookupOptions.options.read('helpers._tags.' + tagName, {
                            isArgument: true,
                            proxyMethods: false
                        })
                        .value,
                    tagCallback = helperTagCallback || Scanner.tags[tagName];

                // If this was an element like <foo-bar> that doesn't have a component, just render its content
                var scope = hookupOptions.scope,
                    res = tagCallback ? tagCallback(el, hookupOptions) : scope;



                // If the tagCallback gave us something to render with, and there is content within that element
                // render it!
                if (res && hookupOptions.subtemplate) {

                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var frag = can.view.frag(hookupOptions.subtemplate(scope, hookupOptions.options));
                    can.appendChild(el, frag);
                }
                can.view.Scanner.hookupAttributes(hookupOptions, el);
            });
        };

        Scanner.prototype = {
            // a default that can be overwritten
            helpers: [],

            scan: function(source, name) {
                var tokens = [],
                    last = 0,
                    simple = this.tokenSimple,
                    complex = this.tokenComplex;
                var cleanedTagName;
                source = source.replace(newLine, '\n');
                if (this.transform) {
                    source = this.transform(source);
                }
                source.replace(this.tokenReg, function(whole, part) {
                    // offset is the second to last argument
                    var offset = arguments[arguments.length - 2];

                    // if the next token starts after the last token ends
                    // push what's in between
                    if (offset > last) {
                        tokens.push(source.substring(last, offset));
                    }

                    // push the simple token (if there is one)
                    if (simple[whole]) {
                        tokens.push(whole);
                    }
                    // otherwise lookup complex tokens
                    else {
                        for (var i = 0, token; token = complex[i]; i++) {
                            if (token.re.test(whole)) {
                                tokens.push(token.abbr);
                                // Push a rescan function if one exists
                                if (token.rescan) {
                                    tokens.push(token.rescan(part));
                                }
                                break;
                            }
                        }
                    }

                    // update the position of the last part of the last token
                    last = offset + part.length;
                });

                // if there's something at the end, add it
                if (last < source.length) {
                    tokens.push(source.substr(last));
                }

                var content = '',
                    buff = [startTxt + (this.text.start || '')],
                    // Helper `function` for putting stuff in the view concat.
                    put = function(content, bonus) {
                        buff.push(put_cmd, '"', clean(content), '"' + (bonus || '') + ');');
                    },
                    // A stack used to keep track of how we should end a bracket
                    // `}`.
                    // Once we have a `<%= %>` with a `leftBracket`,
                    // we store how the file should end here (either `))` or `;`).
                    endStack = [],
                    // The last token, used to remember which tag we are in.
                    lastToken,
                    // The corresponding magic tag.
                    startTag = null,
                    // Was there a magic tag inside an html tag?
                    magicInTag = false,
                    // was there a special state
                    specialStates = {
                        attributeHookups: [],
                        // a stack of tagHookups
                        tagHookups: [],
                        //last tag hooked up
                        lastTagHookup: ''
                    },
                    // Helper `function` for removing tagHookups from the hookup stack
                    popTagHookup = function() {
                        // The length of tagHookups is the nested depth which can be used to uniquely identify custom tags of the same type
                        specialStates.lastTagHookup = specialStates.tagHookups.pop() + specialStates.tagHookups.length;
                    },
                    // The current tag name.
                    tagName = '',
                    // stack of tagNames
                    tagNames = [],
                    // Pop from tagNames?
                    popTagName = false,
                    // Declared here.
                    bracketCount,
                    // in a special attr like src= or style=
                    specialAttribute = false,

                    i = 0,
                    token,
                    tmap = this.tokenMap,
                    attrName;

                // Reinitialize the tag state goodness.
                htmlTag = quote = beforeQuote = null;
                for (;
                    (token = tokens[i++]) !== undefined;) {
                    if (startTag === null) {
                        switch (token) {
                            case tmap.left:
                            case tmap.escapeLeft:
                            case tmap.returnLeft:
                                magicInTag = htmlTag && 1;

                            case tmap.commentLeft:
                                // A new line -- just add whatever content within a clean.
                                // Reset everything.
                                startTag = token;
                                if (content.length) {
                                    put(content);
                                }
                                content = '';
                                break;
                            case tmap.escapeFull:
                                // This is a full line escape (a line that contains only whitespace and escaped logic)
                                // Break it up into escape left and right
                                magicInTag = htmlTag && 1;
                                rescan = 1;
                                startTag = tmap.escapeLeft;
                                if (content.length) {
                                    put(content);
                                }
                                rescan = tokens[i++];
                                content = rescan.content || rescan;
                                if (rescan.before) {
                                    put(rescan.before);
                                }
                                tokens.splice(i, 0, tmap.right);
                                break;
                            case tmap.commentFull:
                                // Ignore full line comments.
                                break;
                            case tmap.templateLeft:
                                content += tmap.left;
                                break;
                            case '<':
                                // Make sure we are not in a comment.
                                if (tokens[i].indexOf('!--') !== 0) {
                                    htmlTag = 1;
                                    magicInTag = 0;
                                }

                                content += token;

                                break;
                            case '>':
                                htmlTag = 0;
                                // content.substr(-1) doesn't work in IE7/8
                                var emptyElement = content.substr(content.length - 1) === '/' || content.substr(content.length - 2) === '--',
                                    attrs = '';
                                // if there was a magic tag
                                // or it's an element that has text content between its tags,
                                // but content is not other tags add a hookup
                                // TODO: we should only add `can.EJS.pending()` if there's a magic tag
                                // within the html tags.
                                if (specialStates.attributeHookups.length) {
                                    attrs = "attrs: ['" + specialStates.attributeHookups.join("','") + "'], ";
                                    specialStates.attributeHookups = [];
                                }
                                // this is the > of a special tag
                                // comparison to lastTagHookup makes sure the same custom tags can be nested
                                if ((tagName + specialStates.tagHookups.length) !== specialStates.lastTagHookup && tagName === top(specialStates.tagHookups)) {
                                    // If it's a self closing tag (like <content/>) make sure we put the / at the end.
                                    if (emptyElement) {
                                        content = content.substr(0, content.length - 1);
                                    }
                                    // Put the start of the end
                                    buff.push(put_cmd,
                                        '"', clean(content), '"',
                                        ",can.view.Scanner.hookupTag({tagName:'" + tagName + "'," + (attrs) + "scope: " + (this.text.scope || "this") + this.text.options);

                                    // if it's a self closing tag (like <content/>) close and end the tag
                                    if (emptyElement) {
                                        buff.push("}));");
                                        content = "/>";
                                        popTagHookup();
                                    }
                                    // if it's an empty tag
                                    else if (tokens[i] === "<" && tokens[i + 1] === "/" + tagName) {
                                        buff.push("}));");
                                        content = token;
                                        popTagHookup();
                                    } else {
                                        // it has content
                                        buff.push(",subtemplate: function(" + this.text.argNames + "){\n" + startTxt + (this.text.start || ''));
                                        content = '';
                                    }
                                } else if (magicInTag || !popTagName && elements.tagToContentPropMap[tagNames[tagNames.length - 1]] || attrs) {
                                    // make sure / of /> is on the right of pending
                                    var pendingPart = ",can.view.pending({" + attrs + "scope: " + (this.text.scope || "this") + this.text.options + "}),\"";
                                    if (emptyElement) {
                                        put(content.substr(0, content.length - 1), pendingPart + "/>\"");
                                    } else {
                                        put(content, pendingPart + ">\"");
                                    }
                                    content = '';
                                    magicInTag = 0;
                                } else {
                                    content += token;
                                }

                                // if it's a tag like <input/>
                                if (emptyElement || popTagName) {
                                    // remove the current tag in the stack
                                    tagNames.pop();
                                    // set the current tag to the previous parent
                                    tagName = tagNames[tagNames.length - 1];
                                    // Don't pop next time
                                    popTagName = false;
                                }
                                specialStates.attributeHookups = [];
                                break;
                            case "'":
                            case '"':
                                // If we are in an html tag, finding matching quotes.
                                if (htmlTag) {
                                    // We have a quote and it matches.
                                    if (quote && quote === token) {
                                        // We are exiting the quote.
                                        quote = null;
                                        // Otherwise we are creating a quote.
                                        // TODO: does this handle `\`?
                                        var attr = getAttrName();
                                        if (Scanner.attributes[attr]) {
                                            specialStates.attributeHookups.push(attr);
                                        } else {
                                            can.each(Scanner.regExpAttributes, function(attrMatcher) {
                                                if (attrMatcher.match.test(attr)) {
                                                    specialStates.attributeHookups.push(attr);
                                                }
                                            });
                                        }

                                        if (specialAttribute) {

                                            content += token;
                                            put(content);
                                            buff.push(finishTxt, "}));\n");
                                            content = "";
                                            specialAttribute = false;

                                            break;
                                        }

                                    } else if (quote === null) {
                                        quote = token;
                                        beforeQuote = lastToken;
                                        attrName = getAttrName();
                                        // TODO: check if there's magic!!!!
                                        if (tagName === 'img' && attrName === 'src' || attrName === 'style') {
                                            // put content that was before the attr name, but don't include the src=
                                            put(content.replace(attrReg, ""));
                                            content = '';
                                            specialAttribute = true;

                                            buff.push(insert_cmd, "can.view.txt(2,'" + getTag(tagName, tokens, i) + "'," + status() + ",this,function(){", startTxt);
                                            put(attrName + "=" + token);
                                            break;
                                        }

                                    }
                                }
                                //default is meant to run on all cases

                            default:
                                // Track the current tag
                                if (lastToken === '<') {

                                    tagName = token.substr(0, 3) === "!--" ?
                                        "!--" : token.split(/\s/)[0];

                                    var isClosingTag = false;

                                    if (tagName.indexOf("/") === 0) {
                                        isClosingTag = true;
                                        cleanedTagName = tagName.substr(1);
                                    }

                                    if (isClosingTag) { // </tag>

                                        // when we enter a new tag, pop the tag name stack
                                        if (top(tagNames) === cleanedTagName) {
                                            // set tagName to the last tagName
                                            // if there are no more tagNames, we'll rely on getTag.
                                            tagName = cleanedTagName;
                                            popTagName = true;
                                        }
                                        // if we are in a closing tag of a custom tag
                                        if (top(specialStates.tagHookups) === cleanedTagName) {
                                            // remove the last < from the content
                                            put(content.substr(0, content.length - 1));

                                            // finish the "section"
                                            buff.push(finishTxt + "}}) );");
                                            // the < belongs to the outside
                                            content = "><";
                                            popTagHookup();
                                        }

                                    } else {
                                        if (tagName.lastIndexOf('/') === tagName.length - 1) {
                                            tagName = tagName.substr(0, tagName.length - 1);

                                        }

                                        if (tagName !== "!--" && (Scanner.tags[tagName] || automaticCustomElementCharacters.test(tagName))) {
                                            // if the content tag is inside something it doesn't belong ...
                                            if (tagName === 'content' && elements.tagMap[top(tagNames)]) {
                                                // convert it to an element that will work
                                                token = token.replace('content', elements.tagMap[top(tagNames)]);
                                            }
                                            // we will hookup at the ending tag>
                                            specialStates.tagHookups.push(tagName);
                                        }

                                        tagNames.push(tagName);

                                    }

                                }
                                content += token;
                                break;
                        }
                    } else {
                        // We have a start tag.
                        switch (token) {
                            case tmap.right:
                            case tmap.returnRight:
                                switch (startTag) {
                                    case tmap.left:
                                        // Get the number of `{ minus }`
                                        bracketCount = bracketNum(content);

                                        // We are ending a block.
                                        if (bracketCount === 1) {
                                            // We are starting on.
                                            buff.push(insert_cmd, 'can.view.txt(0,\'' + getTag(tagName, tokens, i) + '\',' + status() + ',this,function(){', startTxt, content);
                                            endStack.push({
                                                    before: '',
                                                    after: finishTxt + '}));\n'
                                                });
                                        } else {

                                            // How are we ending this statement?
                                            last = endStack.length && bracketCount === -1 ? endStack.pop() : {
                                                after: ';'
                                            };

                                            // If we are ending a returning block,
                                            // add the finish text which returns the result of the
                                            // block.
                                            if (last.before) {
                                                buff.push(last.before);
                                            }
                                            // Add the remaining content.
                                            buff.push(content, ';', last.after);
                                        }
                                        break;
                                    case tmap.escapeLeft:
                                    case tmap.returnLeft:
                                        // We have an extra `{` -> `block`.
                                        // Get the number of `{ minus }`.
                                        bracketCount = bracketNum(content);
                                        // If we have more `{`, it means there is a block.
                                        if (bracketCount) {
                                            // When we return to the same # of `{` vs `}` end with a `doubleParent`.
                                            endStack.push({
                                                    before: finishTxt,
                                                    after: '}));\n'
                                                });
                                        }

                                        var escaped = startTag === tmap.escapeLeft ? 1 : 0,
                                            commands = {
                                                insert: insert_cmd,
                                                tagName: getTag(tagName, tokens, i),
                                                status: status(),
                                                specialAttribute: specialAttribute
                                            };

                                        for (var ii = 0; ii < this.helpers.length; ii++) {
                                            // Match the helper based on helper
                                            // regex name value
                                            var helper = this.helpers[ii];
                                            if (helper.name.test(content)) {
                                                content = helper.fn(content, commands);

                                                // dont escape partials
                                                if (helper.name.source === /^>[\s]*\w*/.source) {
                                                    escaped = 0;
                                                }
                                                break;
                                            }
                                        }

                                        // Handle special cases
                                        if (typeof content === 'object') {
                                            if (content.raw) {
                                                buff.push(content.raw);
                                            }
                                        } else if (specialAttribute) {
                                            buff.push(insert_cmd, content, ');');
                                        } else {
                                            // If we have `<%== a(function(){ %>` then we want
                                            // `can.EJS.text(0,this, function(){ return a(function(){ var _v1ew = [];`.
                                            buff.push(insert_cmd, "can.view.txt(\n" +
                                                (typeof status() === "string" || escaped) + ",\n'" +
                                                tagName + "',\n" +
                                                status() + ",\n" +
                                                "this,\nfunction(){ " +
                                                (this.text.escape || '') +
                                                "return ", content,
                                                // If we have a block.
                                                bracketCount ?
                                                // Start with startTxt `"var _v1ew = [];"`.
                                                startTxt :
                                                // If not, add `doubleParent` to close push and text.
                                                "}));\n");
                                        }

                                        if (rescan && rescan.after && rescan.after.length) {
                                            put(rescan.after.length);
                                            rescan = null;
                                        }
                                        break;
                                }
                                startTag = null;
                                content = '';
                                break;
                            case tmap.templateLeft:
                                content += tmap.left;
                                break;
                            default:
                                content += token;
                                break;
                        }
                    }
                    lastToken = token;
                }

                // Put it together...
                if (content.length) {
                    // Should be `content.dump` in Ruby.
                    put(content);
                }
                buff.push(';');
                var template = buff.join(''),
                    out = {
                        out: (this.text.outStart || '') + template + ' ' + finishTxt + (this.text.outEnd || '')
                    };
                // Use `eval` instead of creating a function, because it is easier to debug.
                myEval.call(out, 'this.fn = (function(' + this.text.argNames + '){' + out.out + '});\r\n//# sourceURL=' + name + '.js');
                return out;
            }
        };
        can.view.Scanner.tag('content', function(el, options) {
            return options.scope;
        });

        return Scanner;
    })(__m19, __m21);

    // ## view/node_lists/node_lists.js
    var __m24 = (function(can) {
        // In some browsers, text nodes can not take expando properties.
        // We test that here.
        var canExpando = true;
        try {
            document.createTextNode('')
                ._ = 0;
        } catch (ex) {
            canExpando = false;
        }
        // A mapping of element ids to nodeList id
        var nodeMap = {},
            // A mapping of ids to text nodes
            textNodeMap = {}, expando = 'ejs_' + Math.random(),
            _id = 0,
            id = function(node) {
                if (canExpando || node.nodeType !== 3) {
                    if (node[expando]) {
                        return node[expando];
                    } else {
                        ++_id;
                        return node[expando] = (node.nodeName ? 'element_' : 'obj_') + _id;
                    }
                } else {
                    for (var textNodeID in textNodeMap) {
                        if (textNodeMap[textNodeID] === node) {
                            return textNodeID;
                        }
                    }
                    ++_id;
                    textNodeMap['text_' + _id] = node;
                    return 'text_' + _id;
                }
            }, splice = [].splice;

        var nodeLists = {
            id: id,


            update: function(nodeList, newNodes) {
                // Unregister all childNodes.
                can.each(nodeList.childNodeLists, function(nodeList) {
                    nodeLists.unregister(nodeList);
                });
                nodeList.childNodeLists = [];
                // Remove old node pointers to this list.
                can.each(nodeList, function(node) {
                    delete nodeMap[id(node)];
                });
                newNodes = can.makeArray(newNodes);
                // indicate the new nodes belong to this list
                can.each(newNodes, function(node) {
                    nodeMap[id(node)] = nodeList;
                });
                var oldListLength = nodeList.length,
                    firstNode = nodeList[0];
                // Replace oldNodeLists's contents'
                splice.apply(nodeList, [
                        0,
                        oldListLength
                    ].concat(newNodes));
                // update all parent nodes so they are able to replace the correct elements
                var parentNodeList = nodeList;
                while (parentNodeList = parentNodeList.parentNodeList) {
                    splice.apply(parentNodeList, [
                            can.inArray(firstNode, parentNodeList),
                            oldListLength
                        ].concat(newNodes));
                }
            },

            register: function(nodeList, unregistered, parent) {
                // add an id to the nodeList
                nodeList.unregistered = unregistered;
                nodeList.childNodeLists = [];
                if (!parent) {
                    // find the parent by looking up where this node is
                    if (nodeList.length > 1) {
                        throw 'does not work';
                    }
                    var nodeId = id(nodeList[0]);
                    parent = nodeMap[nodeId];
                }
                nodeList.parentNodeList = parent;
                if (parent) {
                    parent.childNodeLists.push(nodeList);
                }
                return nodeList;
            },
            // removes node in all parent nodes and unregisters all childNodes

            unregister: function(nodeList) {
                if (!nodeList.isUnregistered) {
                    nodeList.isUnregistered = true;
                    // unregister all childNodeLists
                    delete nodeList.parentNodeList;
                    can.each(nodeList, function(node) {
                        var nodeId = id(node);
                        delete nodeMap[nodeId];
                    });
                    // this can unbind which will call itself
                    if (nodeList.unregistered) {
                        nodeList.unregistered();
                    }
                    can.each(nodeList.childNodeLists, function(nodeList) {
                        nodeLists.unregister(nodeList);
                    });
                }
            },
            nodeMap: nodeMap
        };
        return nodeLists;
    })(__m2, __m21);

    // ## view/live/live.js
    var __m23 = (function(can, elements, view, nodeLists) {
        // ## live.js
        // The live module provides live binding for computes
        // and can.List.
        // Currently, it's API is designed for `can/view/render`, but
        // it could easily be used for other purposes.
        // ### Helper methods
        // #### setup
        // `setup(HTMLElement, bind(data), unbind(data)) -> data`
        // Calls bind right away, but will call unbind
        // if the element is "destroyed" (removed from the DOM).
        var setup = function(el, bind, unbind) {
            // Removing an element can call teardown which
            // unregister the nodeList which calls teardown
            var tornDown = false,
                teardown = function() {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        can.unbind.call(el, 'removed', teardown);
                    }
                    return true;
                }, data = {
                    teardownCheck: function(parent) {
                        return parent ? false : teardown();
                    }
                };
            can.bind.call(el, 'removed', teardown);
            bind(data);
            return data;
        },
            // #### listen
            // Calls setup, but presets bind and unbind to
            // operate on a compute
            listen = function(el, compute, change) {
                return setup(el, function() {
                    compute.bind('change', change);
                }, function(data) {
                    compute.unbind('change', change);
                    if (data.nodeList) {
                        nodeLists.unregister(data.nodeList);
                    }
                });
            },
            // #### getAttributeParts
            // Breaks up a string like foo='bar' into ["foo","'bar'""]
            getAttributeParts = function(newVal) {
                return (newVal || '')
                    .replace(/['"]/g, '')
                    .split('=');
            }, splice = [].splice;

        var live = {
            list: function(el, compute, render, context, parentNode) {
                // A nodeList of all elements this live-list manages.
                // This is here so that if this live list is within another section
                // that section is able to remove the items in this list.
                var masterNodeList = [el],
                    // A mapping of the index of an item to an array
                    // of elements that represent the item.
                    // Each array is registered so child or parent
                    // live structures can update the elements.
                    itemIndexToNodeListsMap = [],
                    // A mapping of items to their indicies'
                    indexMap = [],
                    // Called when items are added to the list.
                    add = function(ev, items, index) {
                        // Collect new html and mappings
                        var frag = document.createDocumentFragment(),
                            newNodeLists = [],
                            newIndicies = [];
                        // For each new item,
                        can.each(items, function(item, key) {
                            var itemIndex = can.compute(key + index),
                                // get its string content
                                itemHTML = render.call(context, item, itemIndex),
                                // and convert it into elements.
                                itemFrag = can.view.fragment(itemHTML);
                            // Add those elements to the mappings.
                            newNodeLists.push(nodeLists.register(can.makeArray(itemFrag.childNodes), undefined, masterNodeList));
                            // Hookup the fragment (which sets up child live-bindings) and
                            // add it to the collection of all added elements.
                            frag.appendChild(can.view.hookup(itemFrag));
                            newIndicies.push(itemIndex);
                        });
                        // Check if we are adding items at the end
                        if (!itemIndexToNodeListsMap[index]) {
                            elements.after(index === 0 ? [text] : itemIndexToNodeListsMap[index - 1], frag);
                        } else {
                            // Add elements before the next index's first element.
                            var el = itemIndexToNodeListsMap[index][0];
                            can.insertBefore(el.parentNode, frag, el);
                        }
                        splice.apply(itemIndexToNodeListsMap, [
                                index,
                                0
                            ].concat(newNodeLists));
                        // update indices after insert point
                        splice.apply(indexMap, [
                                index,
                                0
                            ].concat(newIndicies));
                        for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                            indexMap[i](i);
                        }
                    },
                    // Called when items are removed or when the bindings are torn down.
                    remove = function(ev, items, index, duringTeardown) {
                        // If this is because an element was removed, we should
                        // check to make sure the live elements are still in the page.
                        // If we did this during a teardown, it would cause an infinite loop.
                        if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                            return;
                        }
                        var removedMappings = itemIndexToNodeListsMap.splice(index, items.length),
                            itemsToRemove = [];
                        can.each(removedMappings, function(nodeList) {
                            // add items that we will remove all at once
                            [].push.apply(itemsToRemove, nodeList);
                            // Update any parent lists to remove these items
                            nodeLists.update(nodeList, []);
                            // unregister the list
                            nodeLists.unregister(nodeList);
                        });
                        // update indices after remove point
                        indexMap.splice(index, items.length);
                        for (var i = index, len = indexMap.length; i < len; i++) {
                            indexMap[i](i);
                        }
                        can.remove(can.$(itemsToRemove));
                    }, text = document.createTextNode(''),
                    // The current list.
                    list,
                    // Called when the list is replaced with a new list or the binding is torn-down.
                    teardownList = function() {
                        // there might be no list right away, and the list might be a plain
                        // array
                        if (list && list.unbind) {
                            list.unbind('add', add)
                                .unbind('remove', remove);
                        }
                        // use remove to clean stuff up for us
                        remove({}, {
                                length: itemIndexToNodeListsMap.length
                            }, 0, true);
                    },
                    // Called when the list is replaced or setup.
                    updateList = function(ev, newList, oldList) {
                        teardownList();
                        // make an empty list if the compute returns null or undefined
                        list = newList || [];
                        // list might be a plain array
                        if (list.bind) {
                            list.bind('add', add)
                                .bind('remove', remove);
                        }
                        add({}, list, 0);
                    };
                parentNode = elements.getParentNode(el, parentNode);
                // Setup binding and teardown to add and remove events
                var data = setup(parentNode, function() {
                    if (can.isFunction(compute)) {
                        compute.bind('change', updateList);
                    }
                }, function() {
                    if (can.isFunction(compute)) {
                        compute.unbind('change', updateList);
                    }
                    teardownList();
                });
                live.replace(masterNodeList, text, data.teardownCheck);
                // run the list setup
                updateList({}, can.isFunction(compute) ? compute() : compute);
            },
            html: function(el, compute, parentNode) {
                var data;
                parentNode = elements.getParentNode(el, parentNode);
                data = listen(parentNode, compute, function(ev, newVal, oldVal) {
                    // TODO: remove teardownCheck in 2.1
                    var attached = nodes[0].parentNode;
                    // update the nodes in the DOM with the new rendered value
                    if (attached) {
                        makeAndPut(newVal);
                    }
                    data.teardownCheck(nodes[0].parentNode);
                });
                var nodes = [el],
                    makeAndPut = function(val) {
                        var frag = can.view.fragment('' + val),
                            oldNodes = can.makeArray(nodes);
                        // We need to mark each node as belonging to the node list.
                        nodeLists.update(nodes, frag.childNodes);
                        frag = can.view.hookup(frag, parentNode);
                        elements.replace(oldNodes, frag);
                    };
                data.nodeList = nodes;
                // register the span so nodeLists knows the parentNodeList
                nodeLists.register(nodes, data.teardownCheck);
                makeAndPut(compute());
            },
            replace: function(nodes, val, teardown) {
                var oldNodes = nodes.slice(0),
                    frag;
                nodeLists.register(nodes, teardown);
                if (typeof val === 'string') {
                    frag = can.view.fragment(val);
                } else if (val.nodeType !== 11) {
                    frag = document.createDocumentFragment();
                    frag.appendChild(val);
                } else {
                    frag = val;
                }
                // We need to mark each node as belonging to the node list.
                nodeLists.update(nodes, frag.childNodes);
                if (typeof val === 'string') {
                    // if it was a string, check for hookups
                    frag = can.view.hookup(frag, nodes[0].parentNode);
                }
                elements.replace(oldNodes, frag);
                return nodes;
            },
            text: function(el, compute, parentNode) {
                var parent = elements.getParentNode(el, parentNode);
                // setup listening right away so we don't have to re-calculate value
                var data = listen(parent, compute, function(ev, newVal, oldVal) {
                    // Sometimes this is 'unknown' in IE and will throw an exception if it is

                    if (typeof node.nodeValue !== 'unknown') {
                        node.nodeValue = '' + newVal;
                    }

                    // TODO: remove in 2.1
                    data.teardownCheck(node.parentNode);
                }),
                    // The text node that will be updated
                    node = document.createTextNode(compute());
                // Replace the placeholder with the live node and do the nodeLists thing.
                // Add that node to nodeList so we can remove it when the parent element is removed from the page
                data.nodeList = live.replace([el], node, data.teardownCheck);
            },

            attributes: function(el, compute, currentValue) {
                var setAttrs = function(newVal) {
                    var parts = getAttributeParts(newVal),
                        newAttrName = parts.shift();
                    // Remove if we have a change and used to have an `attrName`.
                    if (newAttrName !== attrName && attrName) {
                        elements.removeAttr(el, attrName);
                    }
                    // Set if we have a new `attrName`.
                    if (newAttrName) {
                        elements.setAttr(el, newAttrName, parts.join('='));
                        attrName = newAttrName;
                    }
                };
                listen(el, compute, function(ev, newVal) {
                    setAttrs(newVal);
                });
                // current value has been set
                if (arguments.length >= 3) {
                    var attrName = getAttributeParts(currentValue)[0];
                } else {
                    setAttrs(compute());
                }
            },
            attributePlaceholder: '__!!__',
            attributeReplace: /__!!__/g,
            attribute: function(el, attributeName, compute) {
                listen(el, compute, function(ev, newVal) {
                    elements.setAttr(el, attributeName, hook.render());
                });
                var wrapped = can.$(el),
                    hooks;
                // Get the list of hookups or create one for this element.
                // Hooks is a map of attribute names to hookup `data`s.
                // Each hookup data has:
                // `render` - A `function` to render the value of the attribute.
                // `funcs` - A list of hookup `function`s on that attribute.
                // `batchNum` - The last event `batchNum`, used for performance.
                hooks = can.data(wrapped, 'hooks');
                if (!hooks) {
                    can.data(wrapped, 'hooks', hooks = {});
                }
                // Get the attribute value.
                var attr = elements.getAttr(el, attributeName),
                    // Split the attribute value by the template.
                    // Only split out the first __!!__ so if we have multiple hookups in the same attribute,
                    // they will be put in the right spot on first render
                    parts = attr.split(live.attributePlaceholder),
                    goodParts = [],
                    hook;
                goodParts.push(parts.shift(), parts.join(live.attributePlaceholder));
                // If we already had a hookup for this attribute...
                if (hooks[attributeName]) {
                    // Just add to that attribute's list of `function`s.
                    hooks[attributeName].computes.push(compute);
                } else {
                    // Create the hookup data.
                    hooks[attributeName] = {
                        render: function() {
                            var i = 0,
                                // attr doesn't have a value in IE
                                newAttr = attr ? attr.replace(live.attributeReplace, function() {
                                    return elements.contentText(hook.computes[i++]());
                                }) : elements.contentText(hook.computes[i++]());
                            return newAttr;
                        },
                        computes: [compute],
                        batchNum: undefined
                    };
                }
                // Save the hook for slightly faster performance.
                hook = hooks[attributeName];
                // Insert the value in parts.
                goodParts.splice(1, 0, compute());
                // Set the attribute.
                elements.setAttr(el, attributeName, goodParts.join(''));
            },
            specialAttribute: function(el, attributeName, compute) {
                listen(el, compute, function(ev, newVal) {
                    elements.setAttr(el, attributeName, getValue(newVal));
                });
                elements.setAttr(el, attributeName, getValue(compute()));
            }
        };
        var newLine = /(\r|\n)+/g;
        var getValue = function(val) {
            var regexp = /^["'].*["']$/;
            val = val.replace(elements.attrReg, '')
                .replace(newLine, '');
            // check if starts and ends with " or '
            return regexp.test(val) ? val.substr(1, val.length - 2) : val;
        };
        can.view.live = live;
        can.view.nodeLists = nodeLists;
        can.view.elements = elements;
        return live;
    })(__m2, __m21, __m19, __m24);

    // ## view/render.js
    var __m22 = (function(can, elements, live) {


        var pendingHookups = [],
            tagChildren = function(tagName) {
                var newTag = elements.tagMap[tagName] || "span";
                if (newTag === "span") {
                    //innerHTML in IE doesn't honor leading whitespace after empty elements
                    return "@@!!@@";
                }
                return "<" + newTag + ">" + tagChildren(newTag) + "</" + newTag + ">";
            },
            contentText = function(input, tag) {

                // If it's a string, return.
                if (typeof input === 'string') {
                    return input;
                }
                // If has no value, return an empty string.
                if (!input && input !== 0) {
                    return '';
                }

                // If it's an object, and it has a hookup method.
                var hook = (input.hookup &&

                    // Make a function call the hookup method.

                    function(el, id) {
                        input.hookup.call(input, el, id);
                    }) ||

                // Or if it's a `function`, just use the input.
                (typeof input === 'function' && input);

                // Finally, if there is a `function` to hookup on some dom,
                // add it to pending hookups.
                if (hook) {
                    if (tag) {
                        return "<" + tag + " " + can.view.hook(hook) + "></" + tag + ">";
                    } else {
                        pendingHookups.push(hook);
                    }

                    return '';
                }

                // Finally, if all else is `false`, `toString()` it.
                return '' + input;
            },
            // Returns escaped/sanatized content for anything other than a live-binding
            contentEscape = function(txt, tag) {
                return (typeof txt === 'string' || typeof txt === 'number') ?
                    can.esc(txt) :
                    contentText(txt, tag);
            },
            // A flag to indicate if .txt was called within a live section within an element like the {{name}}
            // within `<div {{#person}}{{name}}{{/person}}/>`.
            withinTemplatedSectionWithinAnElement = false,
            emptyHandler = function() {};

        var lastHookups;

        can.extend(can.view, {
                live: live,
                // called in text to make a temporary 
                // can.view.lists function that can be called with
                // the list to iterate over and the template
                // used to produce the content within the list
                setupLists: function() {

                    var old = can.view.lists,
                        data;

                    can.view.lists = function(list, renderer) {
                        data = {
                            list: list,
                            renderer: renderer
                        };
                        return Math.random();
                    };
                    // sets back to the old data
                    return function() {
                        can.view.lists = old;
                        return data;
                    };
                },
                pending: function(data) {
                    // TODO, make this only run for the right tagName
                    var hooks = can.view.getHooks();
                    return can.view.hook(function(el) {
                        can.each(hooks, function(fn) {
                            fn(el);
                        });
                        can.view.Scanner.hookupAttributes(data, el);
                    });
                },
                getHooks: function() {
                    var hooks = pendingHookups.slice(0);
                    lastHookups = hooks;
                    pendingHookups = [];
                    return hooks;
                },
                onlytxt: function(self, func) {
                    return contentEscape(func.call(self));
                },

                txt: function(escape, tagName, status, self, func) {
                    // the temporary tag needed for any live setup
                    var tag = (elements.tagMap[tagName] || "span"),
                        // should live-binding be setup
                        setupLiveBinding = false,
                        // the compute's value
                        compute, value, unbind, listData, attributeName;

                    // Are we currently within a live section within an element like the {{name}}
                    // within `<div {{#person}}{{name}}{{/person}}/>`.
                    if (withinTemplatedSectionWithinAnElement) {
                        value = func.call(self);
                    } else {

                        // If this magic tag is within an attribute or an html element,
                        // set the flag to true so we avoid trying to live bind
                        // anything that func might be setup.
                        // TODO: the scanner should be able to set this up.
                        if (typeof status === "string" || status === 1) {
                            withinTemplatedSectionWithinAnElement = true;
                        }

                        // Sets up a listener so we know any can.view.lists called 
                        // when func is called
                        var listTeardown = can.view.setupLists();
                        unbind = function() {
                            compute.unbind("change", emptyHandler);
                        };
                        // Create a compute that calls func and looks for dependencies.
                        // By passing `false`, this compute can not be a dependency of other 
                        // computes.  This is because live-bits are nested, but 
                        // handle their own updating. For example:
                        //     {{#if items.length}}{{#items}}{{.}}{{/items}}{{/if}}
                        // We do not want `{{#if items.length}}` changing the DOM if
                        // `{{#items}}` text changes.
                        compute = can.compute(func, self, false);

                        // Bind to get and temporarily cache the value of the compute.
                        compute.bind("change", emptyHandler);

                        // Call the "wrapping" function and get the binding information
                        listData = listTeardown();

                        // Get the value of the compute
                        value = compute();

                        // Let people know we are no longer within an element.
                        withinTemplatedSectionWithinAnElement = false;

                        // If we should setup live-binding.
                        setupLiveBinding = compute.hasDependencies;
                    }

                    if (listData) {
                        if (unbind) {
                            unbind();
                        }
                        return "<" + tag + can.view.hook(function(el, parentNode) {
                            live.list(el, listData.list, listData.renderer, self, parentNode);
                        }) + "></" + tag + ">";
                    }

                    // If we had no observes just return the value returned by func.
                    if (!setupLiveBinding || typeof value === "function") {
                        if (unbind) {
                            unbind();
                        }
                        return ((withinTemplatedSectionWithinAnElement || escape === 2 || !escape) ?
                            contentText :
                            contentEscape)(value, status === 0 && tag);
                    }

                    // the property (instead of innerHTML elements) to adjust. For
                    // example options should use textContent
                    var contentProp = elements.tagToContentPropMap[tagName];

                    // The magic tag is outside or between tags.
                    if (status === 0 && !contentProp) {
                        // Return an element tag with a hookup in place of the content
                        return "<" + tag + can.view.hook(
                            // if value is an object, it's likely something returned by .safeString
                            escape && typeof value !== "object" ?
                            // If we are escaping, replace the parentNode with 
                            // a text node who's value is `func`'s return value.

                            function(el, parentNode) {
                                live.text(el, compute, parentNode);
                                unbind();
                            } :
                            // If we are not escaping, replace the parentNode with a
                            // documentFragment created as with `func`'s return value.

                            function(el, parentNode) {
                                live.html(el, compute, parentNode);
                                unbind();
                                //children have to be properly nested HTML for buildFragment to work properly
                            }) + ">" + tagChildren(tag) + "</" + tag + ">";
                        // In a tag, but not in an attribute
                    } else if (status === 1) {
                        // remember the old attr name
                        pendingHookups.push(function(el) {
                            live.attributes(el, compute, compute());
                            unbind();
                        });

                        return compute();
                    } else if (escape === 2) { // In a special attribute like src or style

                        attributeName = status;
                        pendingHookups.push(function(el) {
                            live.specialAttribute(el, attributeName, compute);
                            unbind();
                        });
                        return compute();
                    } else { // In an attribute...
                        attributeName = status === 0 ? contentProp : status;
                        // if the magic tag is inside the element, like `<option><% TAG %></option>`,
                        // we add this hookup to the last element (ex: `option`'s) hookups.
                        // Otherwise, the magic tag is in an attribute, just add to the current element's
                        // hookups.
                        (status === 0 ? lastHookups : pendingHookups)
                            .push(function(el) {
                                live.attribute(el, attributeName, compute);
                                unbind();
                            });
                        return live.attributePlaceholder;
                    }
                }
            });

        return can;
    })(__m19, __m21, __m23, __m10);

    // ## view/mustache/mustache.js
    var __m17 = (function(can) {

        // # mustache.js
        // `can.Mustache`: The Mustache templating engine.
        // See the [Transformation](#section-29) section within *Scanning Helpers* for a detailed explanation 
        // of the runtime render code design. The majority of the Mustache engine implementation 
        // occurs within the *Transformation* scanning helper.

        // ## Initialization
        // Define the view extension.
        can.view.ext = ".mustache";

        // ### Setup internal helper variables and functions.
        // An alias for the context variable used for tracking a stack of contexts.
        // This is also used for passing to helper functions to maintain proper context.
        var SCOPE = 'scope',
            // An alias for the variable used for the hash object that can be passed
            // to helpers via `options.hash`.
            HASH = '___h4sh',
            // An alias for the most used context stacking call.
            CONTEXT_OBJ = '{scope:' + SCOPE + ',options:options}',
            // argument names used to start the function (used by scanner and steal)
            ARG_NAMES = SCOPE + ",options",

            // matches arguments inside a {{ }}
            argumentsRegExp = /((([^\s]+?=)?('.*?'|".*?"))|.*?)\s/g,

            // matches a literal number, string, null or regexp
            literalNumberStringBooleanRegExp = /^(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)|((.+?)=(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false)|(.+))))$/,

            // returns an object literal that we can use to look up a value in the current scope
            makeLookupLiteral = function(type) {
                return '{get:"' + type.replace(/"/g, '\\"') + '"}';
            },
            // returns if the object is a lookup
            isLookup = function(obj) {
                return obj && typeof obj.get === "string";
            },


            isObserveLike = function(obj) {
                return obj instanceof can.Map || (obj && !! obj._get);
            },


            isArrayLike = function(obj) {
                return obj && obj.splice && typeof obj.length === 'number';
            },
            // used to make sure .fn and .inverse are always called with a Scope like object
            makeConvertToScopes = function(orignal, scope, options) {
                return function(updatedScope, updatedOptions) {
                    if (updatedScope !== undefined && !(updatedScope instanceof can.view.Scope)) {
                        updatedScope = scope.add(updatedScope);
                    }
                    if (updatedOptions !== undefined && !(updatedOptions instanceof OptionsScope)) {
                        updatedOptions = options.add(updatedOptions);
                    }
                    return orignal(updatedScope, updatedOptions || options);
                };
            };

        // ## Mustache

        var Mustache = function(options, helpers) {
            // Support calling Mustache without the constructor.
            // This returns a function that renders the template.
            if (this.constructor !== Mustache) {
                var mustache = new Mustache(options);
                return function(data, options) {
                    return mustache.render(data, options);
                };
            }

            // If we get a `function` directly, it probably is coming from
            // a `steal`-packaged view.
            if (typeof options === "function") {
                this.template = {
                    fn: options
                };
                return;
            }

            // Set options on self.
            can.extend(this, options);
            this.template = this.scanner.scan(this.text, this.name);
        };


        // Put Mustache on the `can` object.
        can.Mustache = window.Mustache = Mustache;


        Mustache.prototype.

        render = function(data, options) {
            if (!(data instanceof can.view.Scope)) {
                data = new can.view.Scope(data || {});
            }
            if (!(options instanceof OptionsScope)) {
                options = new OptionsScope(options || {});
            }
            options = options || {};

            return this.template.fn.call(data, data, options);
        };

        can.extend(Mustache.prototype, {
                // Share a singleton scanner for parsing templates.
                scanner: new can.view.Scanner({
                        // A hash of strings for the scanner to inject at certain points.
                        text: {
                            // This is the logic to inject at the beginning of a rendered template. 
                            // This includes initializing the `context` stack.
                            start: "", //"var "+SCOPE+"= this instanceof can.view.Scope? this : new can.view.Scope(this);\n",
                            scope: SCOPE,
                            options: ",options: options",
                            argNames: ARG_NAMES
                        },

                        // An ordered token registry for the scanner.
                        // This needs to be ordered by priority to prevent token parsing errors.
                        // Each token follows the following structure:
                        //		[
                        //			// Which key in the token map to match.
                        //			"tokenMapName",
                        //			// A simple token to match, like "{{".
                        //			"token",
                        //			// Optional. A complex (regexp) token to match that 
                        //			// overrides the simple token.
                        //			"[\\s\\t]*{{",
                        //			// Optional. A function that executes advanced 
                        //			// manipulation of the matched content. This is 
                        //			// rarely used.
                        //			function(content){   
                        //				return content;
                        //			}
                        //		]
                        tokens: [

                            // Return unescaped
                            ["returnLeft", "{{{", "{{[{&]"],
                            // Full line comments
                            ["commentFull", "{{!}}", "^[\\s\\t]*{{!.+?}}\\n"],

                            // Inline comments
                            ["commentLeft", "{{!", "(\\n[\\s\\t]*{{!|{{!)"],

                            // Full line escapes
                            // This is used for detecting lines with only whitespace and an escaped tag
                            ["escapeFull", "{{}}", "(^[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}$)",
                                function(content) {
                                    return {
                                        before: /^\n.+?\n$/.test(content) ? '\n' : '',
                                        content: content.match(/\{\{(.+?)\}\}/)[1] || ''
                                    };
                                }
                            ],
                            // Return escaped
                            ["escapeLeft", "{{"],
                            // Close return unescaped
                            ["returnRight", "}}}"],
                            // Close tag
                            ["right", "}}"]
                        ],

                        // ## Scanning Helpers
                        // This is an array of helpers that transform content that is within escaped tags like `{{token}}`. These helpers are solely for the scanning phase; they are unrelated to Mustache/Handlebars helpers which execute at render time. Each helper has a definition like the following:
                        //		{
                        //			// The content pattern to match in order to execute.
                        //			// Only the first matching helper is executed.
                        //			name: /pattern to match/,
                        //			// The function to transform the content with.
                        //			// @param {String} content   The content to transform.
                        //			// @param {Object} cmd       Scanner helper data.
                        //			//                           {
                        //			//                             insert: "insert command",
                        //			//                             tagName: "div",
                        //			//                             status: 0
                        //			//                           }
                        //			fn: function(content, cmd) {
                        //				return 'for text injection' || 
                        //					{ raw: 'to bypass text injection' };
                        //			}
                        //		}
                        helpers: [
                            // ### Partials
                            // Partials begin with a greater than sign, like {{> box}}.
                            // Partials are rendered at runtime (as opposed to compile time), 
                            // so recursive partials are possible. Just avoid infinite loops.
                            // For example, this template and partial:
                            //		base.mustache:
                            //			<h2>Names</h2>
                            //			{{#names}}
                            //				{{> user}}
                            //			{{/names}}
                            //		user.mustache:
                            //		<strong>{{name}}</strong>
                            {
                                name: /^>[\s]*\w*/,
                                fn: function(content, cmd) {
                                    // Get the template name and call back into the render method,
                                    // passing the name and the current context.
                                    var templateName = can.trim(content.replace(/^>\s?/, ''))
                                        .replace(/["|']/g, "");
                                    return "can.Mustache.renderPartial('" + templateName + "'," + ARG_NAMES + ")";
                                }
                            },

                            // ### Data Hookup
                            // This will attach the data property of `this` to the element
                            // its found on using the first argument as the data attribute
                            // key.
                            // For example:
                            //		<li id="nameli" {{ data 'name' }}></li>
                            // then later you can access it like:
                            //		can.$('#nameli').data('name');

                            {
                                name: /^\s*data\s/,
                                fn: function(content, cmd) {
                                    var attr = content.match(/["|'](.*)["|']/)[1];
                                    // return a function which calls `can.data` on the element
                                    // with the attribute name with the current context.
                                    return "can.proxy(function(__){" +
                                    // "var context = this[this.length-1];" +
                                    // "context = context." + STACKED + " ? context[context.length-2] : context; console.warn(this, context);" +
                                    "can.data(can.$(__),'" + attr + "', this.attr('.')); }, " + SCOPE + ")";
                                }
                            }, {
                                name: /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
                                fn: function(content) {
                                    var quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
                                        parts = content.match(quickFunc);

                                    //find 
                                    return "can.proxy(function(__){var " + parts[1] + "=can.$(__);with(" + SCOPE + ".attr('.')){" + parts[2] + "}}, this);";
                                }
                            },
                            // ### Transformation (default)
                            // This transforms all content to its interpolated equivalent,
                            // including calls to the corresponding helpers as applicable. 
                            // This outputs the render code for almost all cases.
                            // #### Definitions
                            // * `context` - This is the object that the current rendering context operates within. 
                            //		Each nested template adds a new `context` to the context stack.
                            // * `stack` - Mustache supports nested sections, 
                            //		each of which add their own context to a stack of contexts.
                            //		Whenever a token gets interpolated, it will check for a match against the 
                            //		last context in the stack, then iterate through the rest of the stack checking for matches.
                            //		The first match is the one that gets returned.
                            // * `Mustache.txt` - This serializes a collection of logic, optionally contained within a section.
                            //		If this is a simple interpolation, only the interpolation lookup will be passed.
                            //		If this is a section, then an `options` object populated by the truthy (`options.fn`) and 
                            //		falsey (`options.inverse`) encapsulated functions will also be passed. This section handling 
                            //		exists to support the runtime context nesting that Mustache supports.
                            // * `Mustache.get` - This resolves an interpolation reference given a stack of contexts.
                            // * `options` - An object containing methods for executing the inner contents of sections or helpers.  
                            //		`options.fn` - Contains the inner template logic for a truthy section.  
                            //		`options.inverse` - Contains the inner template logic for a falsey section.  
                            //		`options.hash` - Contains the merged hash object argument for custom helpers.
                            // #### Design
                            // This covers the design of the render code that the transformation helper generates.
                            // ##### Pseudocode
                            // A detailed explanation is provided in the following sections, but here is some brief pseudocode
                            // that gives a high level overview of what the generated render code does (with a template similar to  
                            // `"{{#a}}{{b.c.d.e.name}}{{/a}}" == "Phil"`).
                            // *Initialize the render code.*
                            //		view = []
                            //		context = []
                            //		stack = fn { context.concat([this]) }
                            //	*Render the root section.*
                            //	view.push( "string" )
                            //	view.push( can.view.txt(
                            // *Render the nested section with `can.Mustache.txt`.*
                            //			txt(
                            // *Add the current context to the stack.*
                            //			stack(),
                            // *Flag this for truthy section mode.*
                            //			"#",
                            // *Interpolate and check the `a` variable for truthyness using the stack with `can.Mustache.get`.*
                            //			get( "a", stack() ),
                            // *Include the nested section's inner logic.
                            // The stack argument is usually the parent section's copy of the stack, 
                            // but it can be an override context that was passed by a custom helper.
                            // Sections can nest `0..n` times -- **NESTCEPTION**.*
                            //			{ fn: fn(stack) {
                            // *Render the nested section (everything between the `{{#a}}` and `{{/a}}` tokens).*
                            //			view = []
                            //			view.push( "string" )
                            //			view.push(
                            // *Add the current context to the stack.*
                            //			stack(),
                            // *Flag this as interpolation-only mode.*
                            //			null,
                            // *Interpolate the `b.c.d.e.name` variable using the stack.*
                            //			get( "b.c.d.e.name", stack() ),
                            //			)
                            //			view.push( "string" )
                            // *Return the result for the nested section.*
                            //					return view.join()
                            //			}}
                            //			)
                            //		))
                            //		view.push( "string" )
                            // *Return the result for the root section, which includes all nested sections.*
                            //		return view.join()
                            // ##### Initialization
                            // Each rendered template is started with the following initialization code:
                            //		var ___v1ew = [];
                            //		var ___c0nt3xt = [];
                            //		___c0nt3xt.__sc0pe = true;
                            //		var __sc0pe = function(context, self) {
                            //		var s;
                            //		if (arguments.length == 1 && context) {
                            //			s = !context.__sc0pe ? [context] : context;
                            //			} else {
                            //			s = context && context.__sc0pe
                            //					? context.concat([self]) 
                            //					: __sc0pe(context).concat([self]);
                            //			}
                            //			return (s.__sc0pe = true) && s;
                            //		};
                            // The `___v1ew` is the the array used to serialize the view.
                            // The `___c0nt3xt` is a stacking array of contexts that slices and expands with each nested section.
                            // The `__sc0pe` function is used to more easily update the context stack in certain situations.
                            // Usually, the stack function simply adds a new context (`self`/`this`) to a context stack. 
                            // However, custom helpers will occasionally pass override contexts that need their own context stack.
                            // ##### Sections
                            // Each section, `{{#section}} content {{/section}}`, within a Mustache template generates a section 
                            // context in the resulting render code. The template itself is treated like a root section, with the 
                            // same execution logic as any others. Each section can have `0..n` nested sections within it.
                            // Here's an example of a template without any descendent sections.  
                            // Given the template: `"{{a.b.c.d.e.name}}" == "Phil"`  
                            // Would output the following render code:
                            //		___v1ew.push("\"");
                            //		___v1ew.push(can.view.txt(1, '', 0, this, function() {
                            //			return can.Mustache.txt(__sc0pe(___c0nt3xt, this), null,
                            //				can.Mustache.get("a.b.c.d.e.name", 
                            //					__sc0pe(___c0nt3xt, this))
                            //			);
                            //		}));
                            //		___v1ew.push("\" == \"Phil\"");
                            // The simple strings will get appended to the view. Any interpolated references (like `{{a.b.c.d.e.name}}`) 
                            // will be pushed onto the view via `can.view.txt` in order to support live binding.
                            // The function passed to `can.view.txt` will call `can.Mustache.txt`, which serializes the object data by doing 
                            // a context lookup with `can.Mustache.get`.
                            // `can.Mustache.txt`'s first argument is a copy of the context stack with the local context `this` added to it.
                            // This stack will grow larger as sections nest.
                            // The second argument is for the section type. This will be `"#"` for truthy sections, `"^"` for falsey, 
                            // or `null` if it is an interpolation instead of a section.
                            // The third argument is the interpolated value retrieved with `can.Mustache.get`, which will perform the 
                            // context lookup and return the approriate string or object.
                            // Any additional arguments, if they exist, are used for passing arguments to custom helpers.
                            // For nested sections, the last argument is an `options` object that contains the nested section's logic.
                            // Here's an example of a template with a single nested section.  
                            // Given the template: `"{{#a}}{{b.c.d.e.name}}{{/a}}" == "Phil"`  
                            // Would output the following render code:
                            //		___v1ew.push("\"");
                            //		___v1ew.push(can.view.txt(0, '', 0, this, function() {
                            //			return can.Mustache.txt(__sc0pe(___c0nt3xt, this), "#",
                            //				can.Mustache.get("a", __sc0pe(___c0nt3xt, this)), 
                            //					[{
                            //					_: function() {
                            //						return ___v1ew.join("");
                            //					}
                            //				}, {
                            //				fn: function(___c0nt3xt) {
                            //					var ___v1ew = [];
                            //					___v1ew.push(can.view.txt(1, '', 0, this,
                            //								function() {
                            //								return can.Mustache.txt(
                            //								__sc0pe(___c0nt3xt, this),
                            //								null,
                            //								can.Mustache.get("b.c.d.e.name",
                            //								__sc0pe(___c0nt3xt, this))
                            //								);
                            //						}
                            //						));
                            //						return ___v1ew.join("");
                            //					}
                            //				}]
                            //			)
                            //		}));
                            //		___v1ew.push("\" == \"Phil\"");
                            // This is specified as a truthy section via the `"#"` argument. The last argument includes an array of helper methods used with `options`.
                            // These act similarly to custom helpers: `options.fn` will be called for truthy sections, `options.inverse` will be called for falsey sections.
                            // The `options._` function only exists as a dummy function to make generating the section nesting easier (a section may have a `fn`, `inverse`,
                            // or both, but there isn't any way to determine that at compilation time).
                            // Within the `fn` function is the section's render context, which in this case will render anything between the `{{#a}}` and `{{/a}}` tokens.
                            // This function has `___c0nt3xt` as an argument because custom helpers can pass their own override contexts. For any case where custom helpers
                            // aren't used, `___c0nt3xt` will be equivalent to the `__sc0pe(___c0nt3xt, this)` stack created by its parent section. The `inverse` function
                            // works similarly, except that it is added when `{{^a}}` and `{{else}}` are used. `var ___v1ew = []` is specified in `fn` and `inverse` to 
                            // ensure that live binding in nested sections works properly.
                            // All of these nested sections will combine to return a compiled string that functions similar to EJS in its uses of `can.view.txt`.
                            // #### Implementation
                            {
                                name: /^.*$/,
                                fn: function(content, cmd) {
                                    var mode = false,
                                        result = [];

                                    // Trim the content so we don't have any trailing whitespace.
                                    content = can.trim(content);

                                    // Determine what the active mode is.
                                    // * `#` - Truthy section
                                    // * `^` - Falsey section
                                    // * `/` - Close the prior section
                                    // * `else` - Inverted section (only exists within a truthy/falsey section)
                                    if (content.length && (mode = content.match(/^([#^/]|else$)/))) {
                                        mode = mode[0];
                                        switch (mode) {

                                            // Open a new section.
                                            case '#':

                                            case '^':
                                                if (cmd.specialAttribute) {
                                                    result.push(cmd.insert + 'can.view.onlytxt(this,function(){ return ');
                                                } else {
                                                    result.push(cmd.insert + 'can.view.txt(0,\'' + cmd.tagName + '\',' + cmd.status + ',this,function(){ return ');
                                                }
                                                break;
                                                // Close the prior section.

                                            case '/':
                                                return {
                                                    raw: 'return ___v1ew.join("");}}])}));'
                                                };
                                        }

                                        // Trim the mode off of the content.
                                        content = content.substring(1);
                                    }

                                    // `else` helpers are special and should be skipped since they don't 
                                    // have any logic aside from kicking off an `inverse` function.
                                    if (mode !== 'else') {
                                        var args = [],
                                            i = 0,
                                            m;

                                        // Start the content render block.
                                        result.push('can.Mustache.txt(\n' + CONTEXT_OBJ + ',\n' + (mode ? '"' + mode + '"' : 'null') + ',');

                                        // Parse the helper arguments.
                                        // This needs uses this method instead of a split(/\s/) so that 
                                        // strings with spaces can be correctly parsed.
                                        var hashes = [];

                                        (can.trim(content) + ' ')
                                            .replace(argumentsRegExp, function(whole, arg) {

                                                // Check for special helper arguments (string/number/boolean/hashes).
                                                if (i && (m = arg.match(literalNumberStringBooleanRegExp))) {
                                                    // Found a native type like string/number/boolean.
                                                    if (m[2]) {
                                                        args.push(m[0]);
                                                    }
                                                    // Found a hash object.
                                                    else {
                                                        // Addd to the hash object.

                                                        hashes.push(m[4] + ":" + (m[6] ? m[6] : makeLookupLiteral(m[5])));
                                                    }
                                                }
                                                // Otherwise output a normal interpolation reference.
                                                else {
                                                    args.push(makeLookupLiteral(arg));
                                                }
                                                i++;
                                            });

                                        result.push(args.join(","));
                                        if (hashes.length) {
                                            result.push(",{" + HASH + ":{" + hashes.join(",") + "}}");
                                        }

                                    }

                                    // Create an option object for sections of code.
                                    if (mode && mode !== 'else') {
                                        result.push(',[\n\n');
                                    }
                                    switch (mode) {
                                        // Truthy section
                                        case '#':
                                            result.push('{fn:function(' + ARG_NAMES + '){var ___v1ew = [];');
                                            break;
                                            // If/else section
                                            // Falsey section

                                        case 'else':
                                            result.push('return ___v1ew.join("");}},\n{inverse:function(' + ARG_NAMES + '){\nvar ___v1ew = [];');
                                            break;
                                        case '^':
                                            result.push('{inverse:function(' + ARG_NAMES + '){\nvar ___v1ew = [];');
                                            break;

                                            // Not a section, no mode
                                        default:
                                            result.push(')');
                                            break;
                                    }

                                    // Return a raw result if there was a section, otherwise return the default string.
                                    result = result.join('');
                                    return mode ? {
                                        raw: result
                                    } : result;
                                }
                            }
                        ]
                    })
            });

        // Add in default scanner helpers first.
        // We could probably do this differently if we didn't 'break' on every match.
        var helpers = can.view.Scanner.prototype.helpers;
        for (var i = 0; i < helpers.length; i++) {
            Mustache.prototype.scanner.helpers.unshift(helpers[i]);
        }


        Mustache.txt = function(scopeAndOptions, mode, name) {
            var scope = scopeAndOptions.scope,
                options = scopeAndOptions.options,
                args = [],
                helperOptions = {
                    fn: function() {},
                    inverse: function() {}
                },
                hash,
                context = scope.attr("."),
                getHelper = true;

            // An array of arguments to check for truthyness when evaluating sections.
            var validArgs,
                // Whether the arguments meet the condition of the section.
                valid = true,
                result = [],
                helper, argIsObserve, arg;

            // convert lookup values to actual values in name, arguments, and hash
            for (var i = 3; i < arguments.length; i++) {
                arg = arguments[i];
                if (mode && can.isArray(arg)) {
                    // merge into options
                    helperOptions = can.extend.apply(can, [helperOptions].concat(arg));
                } else if (arg && arg[HASH]) {
                    hash = arg[HASH];
                    // get values on hash
                    for (var prop in hash) {
                        if (isLookup(hash[prop])) {
                            hash[prop] = Mustache.get(hash[prop].get, scopeAndOptions);
                        }
                    }
                } else if (arg && isLookup(arg)) {
                    args.push(Mustache.get(arg.get, scopeAndOptions, false, true));
                } else {
                    args.push(arg);
                }
            }

            if (isLookup(name)) {
                var get = name.get;
                name = Mustache.get(name.get, scopeAndOptions, args.length, false);

                // Base whether or not we will get a helper on whether or not the original
                // name.get and Mustache.get resolve to the same thing. Saves us from running
                // into issues like {{text}} / {text: 'with'}
                getHelper = (get === name);
            }

            // overwrite fn and inverse to always convert to scopes
            helperOptions.fn = makeConvertToScopes(helperOptions.fn, scope, options);
            helperOptions.inverse = makeConvertToScopes(helperOptions.inverse, scope, options);

            // Check for a registered helper or a helper-like function.
            if (helper = (getHelper && (typeof name === "string" && Mustache.getHelper(name, options)) || (can.isFunction(name) && !name.isComputed && {
                            fn: name
                        }))) {
                // Add additional data to be used by helper functions

                can.extend(helperOptions, {
                        context: context,
                        scope: scope,
                        contexts: scope,
                        hash: hash
                    });

                args.push(helperOptions);
                // Call the helper.
                return helper.fn.apply(context, args) || '';
            }

            if (can.isFunction(name)) {
                if (name.isComputed) {
                    name = name();
                }
            }

            validArgs = args.length ? args : [name];
            // Validate the arguments based on the section mode.
            if (mode) {
                for (i = 0; i < validArgs.length; i++) {
                    arg = validArgs[i];
                    argIsObserve = typeof arg !== 'undefined' && isObserveLike(arg);
                    // Array-like objects are falsey if their length = 0.
                    if (isArrayLike(arg)) {
                        // Use .attr to trigger binding on empty lists returned from function
                        if (mode === '#') {
                            valid = valid && !! (argIsObserve ? arg.attr('length') : arg.length);
                        } else if (mode === '^') {
                            valid = valid && !(argIsObserve ? arg.attr('length') : arg.length);
                        }
                    }
                    // Otherwise just check if it is truthy or not.
                    else {
                        valid = mode === '#' ?
                            valid && !! arg : mode === '^' ?
                            valid && !arg : valid;
                    }
                }
            }

            // Otherwise interpolate like normal.
            if (valid) {
                switch (mode) {
                    // Truthy section.
                    case '#':
                        // Iterate over arrays
                        if (isArrayLike(name)) {
                            var isObserveList = isObserveLike(name);

                            // Add the reference to the list in the contexts.
                            for (i = 0; i < name.length; i++) {
                                result.push(helperOptions.fn(name[i]));

                                // Ensure that live update works on observable lists
                                if (isObserveList) {
                                    name.attr('' + i);
                                }
                            }
                            return result.join('');
                        }
                        // Normal case.
                        else {
                            return helperOptions.fn(name || {}) || '';
                        }
                        break;
                        // Falsey section.
                    case '^':
                        return helperOptions.inverse(name || {}) || '';
                    default:
                        // Add + '' to convert things like numbers to strings.
                        // This can cause issues if you are trying to
                        // eval on the length but this is the more
                        // common case.
                        return '' + (name != null ? name : '');
                }
            }

            return '';
        };


        Mustache.get = function(key, scopeAndOptions, isHelper, isArgument) {

            // Cache a reference to the current context and options, we will use them a bunch.
            var context = scopeAndOptions.scope.attr('.'),
                options = scopeAndOptions.options || {};

            // If key is called as a helper,
            if (isHelper) {
                // try to find a registered helper.
                if (Mustache.getHelper(key, options)) {
                    return key;
                }
                // Support helper-like functions as anonymous helpers.
                // Check if there is a method directly in the "top" context.
                if (scopeAndOptions.scope && can.isFunction(context[key])) {
                    return context[key];
                }

            }

            // Get a compute (and some helper data) that represents key's value in the current scope
            var computeData = scopeAndOptions.scope.computeData(key, {
                    isArgument: isArgument,
                    args: [context, scopeAndOptions.scope]
                }),
                compute = computeData.compute;

            // Bind on the compute to cache its value. We will unbind in a timeout later.
            can.compute.temporarilyBind(compute);

            // computeData gives us an initial value
            var initialValue = computeData.initialValue;

            // Use helper over the found value if the found value isn't in the current context
            if ((initialValue === undefined || computeData.scope !== scopeAndOptions.scope) && Mustache.getHelper(key, options)) {
                return key;
            }

            // If there are no dependencies, just return the value.
            if (!compute.hasDependencies) {
                return initialValue;
            } else {
                return compute;
            }
        };


        Mustache.resolve = function(value) {
            if (isObserveLike(value) && isArrayLike(value) && value.attr('length')) {
                return value;
            } else if (can.isFunction(value)) {
                return value();
            } else {
                return value;
            }
        };



        var OptionsScope = can.view.Scope.extend({
                init: function(data, parent) {
                    if (!data.helpers && !data.partials) {
                        data = {
                            helpers: data
                        };
                    }
                    can.view.Scope.prototype.init.apply(this, arguments);
                }
            });

        // ## Helpers
        // Helpers are functions that can be called from within a template.
        // These helpers differ from the scanner helpers in that they execute
        // at runtime instead of during compilation.
        // Custom helpers can be added via `can.Mustache.registerHelper`,
        // but there are also some built-in helpers included by default.
        // Most of the built-in helpers are little more than aliases to actions 
        // that the base version of Mustache simply implies based on the 
        // passed in object.
        // Built-in helpers:
        // * `data` - `data` is a special helper that is implemented via scanning helpers. 
        //		It hooks up the active element to the active data object: `<div {{data "key"}} />`
        // * `if` - Renders a truthy section: `{{#if var}} render {{/if}}`
        // * `unless` - Renders a falsey section: `{{#unless var}} render {{/unless}}`
        // * `each` - Renders an array: `{{#each array}} render {{this}} {{/each}}`
        // * `with` - Opens a context section: `{{#with var}} render {{/with}}`
        Mustache._helpers = {};

        Mustache.registerHelper = function(name, fn) {
            this._helpers[name] = {
                name: name,
                fn: fn
            };
        };


        Mustache.getHelper = function(name, options) {
            var helper = options.attr("helpers." + name);
            return helper ? {
                fn: helper
            } : this._helpers[name];
        };


        Mustache.render = function(partial, scope, options) {
            // TOOD: clean up the following
            // If there is a "partial" property and there is not
            // an already-cached partial, we use the value of the 
            // property to look up the partial

            // if this partial is not cached ...
            if (!can.view.cached[partial]) {
                // we don't want to bind to changes so clear and restore reading
                var reads = can.__clearReading && can.__clearReading();
                if (scope.attr('partial')) {
                    partial = scope.attr('partial');
                }
                if (can.__setReading) {
                    can.__setReading(reads);
                }
            }

            // Call into `can.view.render` passing the
            // partial and scope.
            return can.view.render(partial, scope);
        };


        Mustache.safeString = function(str) {
            return {
                toString: function() {
                    return str;
                }
            };
        };

        Mustache.renderPartial = function(partialName, scope, options) {
            var partial = options.attr("partials." + partialName);
            if (partial) {
                return partial.render ? partial.render(scope, options) :
                    partial(scope, options);
            } else {
                return can.Mustache.render(partialName, scope, options);
            }
        };

        // The built-in Mustache helpers.
        can.each({
                // Implements the `if` built-in helper.

                'if': function(expr, options) {
                    var value;
                    // if it's a function, wrap its value in a compute
                    // that will only change values from true to false
                    if (can.isFunction(expr)) {
                        value = can.compute.truthy(expr)();
                    } else {
                        value = !! Mustache.resolve(expr);
                    }

                    if (value) {
                        return options.fn(options.contexts || this);
                    } else {
                        return options.inverse(options.contexts || this);
                    }
                },
                // Implements the `unless` built-in helper.

                'unless': function(expr, options) {
                    if (!Mustache.resolve(expr)) {
                        return options.fn(options.contexts || this);
                    }
                },

                // Implements the `each` built-in helper.

                'each': function(expr, options) {
                    var result = [];
                    var keys, key, i;
                    // Check if this is a list or a compute that resolves to a list, and setup
                    // the incremental live-binding 

                    // First, see what we are dealing with.  It's ok to read the compute
                    // because can.view.text is only temporarily binding to what is going on here.
                    // Calling can.view.lists prevents anything from listening on that compute.
                    var resolved = Mustache.resolve(expr);

                    // When resolved === undefined, the property hasn't been defined yet
                    // Assume it is intended to be a list
                    if (can.view.lists && (resolved instanceof can.List || (expr && expr.isComputed && resolved === undefined))) {
                        return can.view.lists(expr, function(item, index) {
                            return options.fn(options.scope.add({
                                        "@index": index
                                    })
                                .add(item));
                        });
                    }
                    expr = resolved;

                    if ( !! expr && isArrayLike(expr)) {
                        for (i = 0; i < expr.length; i++) {
                            var index = function() {
                                return i;
                            };

                            result.push(options.fn(options.scope.add({
                                            "@index": index
                                        })
                                    .add(expr[i])));
                        }
                        return result.join('');
                    } else if (isObserveLike(expr)) {
                        keys = can.Map.keys(expr);
                        for (i = 0; i < keys.length; i++) {
                            key = keys[i];
                            result.push(options.fn(options.scope.add({
                                            "@key": key
                                        })
                                    .add(expr[key])));
                        }
                        return result.join('');
                    } else if (expr instanceof Object) {
                        for (key in expr) {
                            result.push(options.fn(options.scope.add({
                                            "@key": key
                                        })
                                    .add(expr[key])));
                        }
                        return result.join('');

                    }
                },
                // Implements the `with` built-in helper.

                'with': function(expr, options) {
                    var ctx = expr;
                    expr = Mustache.resolve(expr);
                    if ( !! expr) {
                        return options.fn(ctx);
                    }
                },

                'log': function(expr, options) {
                    if (console !== undefined) {
                        if (!options) {
                            console.log(expr.context);
                        } else {
                            console.log(expr, options.context);
                        }
                    }
                }

            }, function(fn, name) {
                Mustache.registerHelper(name, fn);
            });

        // ## Registration
        // Registers Mustache with can.view.
        can.view.register({
                suffix: "mustache",

                contentType: "x-mustache-template",

                // Returns a `function` that renders the view.
                script: function(id, src) {
                    return "can.Mustache(function(" + ARG_NAMES + ") { " + new Mustache({
                            text: src,
                            name: id
                        })
                        .template.out + " })";
                },

                renderer: function(id, text) {
                    return Mustache({
                            text: text,
                            name: id
                        });
                }
            });

        return can;
    })(__m2, __m18, __m19, __m20, __m16, __m22);

    // ## view/bindings/bindings.js
    var __m25 = (function(can) {

        // IE < 8 doesn't support .hasAttribute, so feature detect it.
        var hasAttribute = function(el, name) {
            return el.hasAttribute ? el.hasAttribute(name) : el.getAttribute(name) !== null;
        };


        can.view.Scanner.attribute("can-value", function(data, el) {

            var attr = el.getAttribute("can-value"),
                value = data.scope.computeData(attr, {
                        args: []
                    })
                    .compute;

            if (el.nodeName.toLowerCase() === "input") {
                var trueValue, falseValue;
                if (el.type === "checkbox") {
                    if (hasAttribute(el, "can-true-value")) {
                        trueValue = data.scope.compute(el.getAttribute("can-true-value"));
                    } else {
                        trueValue = can.compute(true);
                    }
                    if (hasAttribute(el, "can-false-value")) {
                        falseValue = data.scope.compute(el.getAttribute("can-false-value"));
                    } else {
                        falseValue = can.compute(false);
                    }
                }

                if (el.type === "checkbox" || el.type === "radio") {
                    new Checked(el, {
                            value: value,
                            trueValue: trueValue,
                            falseValue: falseValue
                        });
                    return;
                }
            }

            new Value(el, {
                    value: value
                });
        });

        var special = {
            enter: function(data, el, original) {
                return {
                    event: "keyup",
                    handler: function(ev) {
                        if (ev.keyCode === 13) {
                            return original.call(this, ev);
                        }
                    }
                };
            }
        };


        can.view.Scanner.attribute(/can-[\w\.]+/, function(data, el) {

            var attributeName = data.attr,
                event = data.attr.substr("can-".length),
                handler = function(ev) {
                    var attr = el.getAttribute(attributeName),
                        scopeData = data.scope.read(attr, {
                                returnObserveMethods: true,
                                isArgument: true
                            });
                    return scopeData.value.call(scopeData.parent, data.scope._context, can.$(this), ev);
                };

            if (special[event]) {
                var specialData = special[event](data, el, handler);
                handler = specialData.handler;
                event = specialData.event;
            }

            can.bind.call(el, event, handler);
        });

        var Value = can.Control.extend({
                init: function() {
                    if (this.element[0].nodeName.toUpperCase() === "SELECT") {
                        // need to wait until end of turn ...
                        setTimeout(can.proxy(this.set, this), 1);
                    } else {
                        this.set();
                    }

                },
                "{value} change": "set",
                set: function() {
                    //this may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired
                    if (!this.element) {
                        return;
                    }

                    var val = this.options.value();
                    this.element[0].value = (typeof val === 'undefined' ? '' : val);
                },
                "change": function() {
                    //this may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired
                    if (!this.element) {
                        return;
                    }

                    this.options.value(this.element[0].value);
                }
            });

        var Checked = can.Control.extend({
                init: function() {
                    this.isCheckebox = (this.element[0].type.toLowerCase() === "checkbox");
                    this.check();
                },
                "{value} change": "check",
                "{trueValue} change": "check",
                "{falseValue} change": "check",
                check: function() {
                    if (this.isCheckebox) {
                        var value = this.options.value(),
                            trueValue = this.options.trueValue() || true;

                        this.element[0].checked = (value === trueValue);
                    } else {
                        var method = this.options.value() === this.element[0].value ? "setAttr" : "removeAttr";
                        can.view.elements[method](this.element[0], 'checked', true);
                    }

                },
                "change": function() {

                    if (this.isCheckebox) {
                        this.options.value(this.element[0].checked ? this.options.trueValue() : this.options.falseValue());
                    } else {
                        if (this.element[0].checked) {
                            this.options.value(this.element[0].value);
                        }
                    }

                }
            });

    })(__m2, __m17, __m8);

    // ## component/component.js
    var __m1 = (function(can) {
        // ## Helpers
        // Attribute names to ignore for setting scope values.
        var ignoreAttributesRegExp = /^(dataViewId|class|id)$/i;

        var Component = can.Component = can.Construct.extend(

            // ## Static


            {
                // ### setup
                // When a component is extended, this sets up the component's internal constructor
                // functions and templates for later fast initialization.
                setup: function() {
                    can.Construct.setup.apply(this, arguments);

                    // Run the following only in constructors that extend can.Component.
                    if (can.Component) {
                        var self = this;

                        // Define a control using the `events` prototype property.
                        this.Control = can.Control.extend({
                                // Change lookup to first look in the scope.
                                _lookup: function(options) {
                                    return [options.scope, options, window];
                                }
                            },
                            // Extend `events` with a setup method that listens to changes in `scope` and
                            // rebinds all templated event handlers.
                            can.extend({
                                    setup: function(el, options) {
                                        var res = can.Control.prototype.setup.call(this, el, options);
                                        this.scope = options.scope;
                                        var self = this;
                                        this.on(this.scope, "change", function handler() {
                                            self.on();
                                            self.on(self.scope, "change", handler);
                                        });
                                        return res;
                                    }
                                }, this.prototype.events));

                        // Look to convert `scope` to a Map constructor function.
                        if (!this.prototype.scope || typeof this.prototype.scope === "object") {
                            // If scope is an object, use that object as the prototype of an extended 
                            // Map constructor function.
                            // A new instance of that Map constructor function will be created and
                            // set a the constructor instance's scope.
                            this.Map = can.Map.extend(this.prototype.scope || {});
                        } else if (this.prototype.scope.prototype instanceof can.Map) {
                            // If scope is a can.Map constructor function, just use that.
                            this.Map = this.prototype.scope;
                        }

                        // Look for default `@` values. If a `@` is found, these
                        // attributes string values will be set and 2-way bound on the
                        // component instance's scope.
                        this.attributeScopeMappings = {};
                        can.each(this.Map ? this.Map.defaults : {}, function(val, prop) {
                            if (val === "@") {
                                self.attributeScopeMappings[prop] = prop;
                            }
                        });

                        // Convert the template into a renderer function.
                        if (this.prototype.template) {
                            if (typeof this.prototype.template === "function") {
                                var temp = this.prototype.template;
                                this.renderer = function() {
                                    return can.view.frag(temp.apply(null, arguments));
                                };
                            } else {
                                this.renderer = can.view.mustache(this.prototype.template);
                            }
                        }

                        // Register this component to be created when its `tag` is found.
                        can.view.Scanner.tag(this.prototype.tag, function(el, options) {
                            new self(el, options);
                        });
                    }

                }
            }, {
                // ## Prototype

                // ### setup
                // When a new component instance is created, setup bindings, render the template, etc.
                setup: function(el, hookupOptions) {
                    // Setup values passed to component
                    var initalScopeData = {},
                        component = this,
                        twoWayBindings = {},
                        // what scope property is currently updating
                        scopePropertyUpdating,
                        // the object added to the scope
                        componentScope,
                        frag;

                    // scope prototype properties marked with an "@" are added here
                    can.each(this.constructor.attributeScopeMappings, function(val, prop) {
                        initalScopeData[prop] = el.getAttribute(can.hyphenate(val));
                    });

                    // get the value in the scope for each attribute
                    // the hookup should probably happen after?
                    can.each(can.makeArray(el.attributes), function(node, index) {

                        var name = can.camelize(node.nodeName.toLowerCase()),
                            value = node.value;
                        // ignore attributes already in ScopeMappings
                        if (component.constructor.attributeScopeMappings[name] || ignoreAttributesRegExp.test(name) || can.view.Scanner.attributes[node.nodeName]) {
                            return;
                        }
                        // ignore attr regexps
                        for (var regAttr in can.view.Scanner.regExpAttributes) {
                            if (can.view.Scanner.regExpAttributes[regAttr].match.test(node.nodeName)) {
                                return;
                            }
                        }

                        // Cross-bind the value in the scope to this 
                        // component's scope
                        var computeData = hookupOptions.scope.computeData(value, {
                                args: []
                            }),
                            compute = computeData.compute;

                        // bind on this, check it's value, if it has dependencies
                        var handler = function(ev, newVal) {
                            scopePropertyUpdating = name;
                            componentScope.attr(name, newVal);
                            scopePropertyUpdating = null;
                        };
                        // compute only returned if bindable

                        compute.bind("change", handler);

                        // set the value to be added to the scope
                        initalScopeData[name] = compute();

                        if (!compute.hasDependencies) {
                            compute.unbind("change", handler);
                        } else {
                            // make sure we unbind (there's faster ways of doing this)
                            can.bind.call(el, "removed", function() {
                                compute.unbind("change", handler);
                            });
                            // setup two-way binding
                            twoWayBindings[name] = computeData;
                        }

                    });

                    if (this.constructor.Map) {
                        componentScope = new this.constructor.Map(initalScopeData);
                    } else if (this.scope instanceof can.Map) {
                        componentScope = this.scope;
                    } else if (can.isFunction(this.scope)) {

                        var scopeResult = this.scope(initalScopeData, hookupOptions.scope, el);
                        // if the function returns a can.Map, use that as the scope
                        if (scopeResult instanceof can.Map) {
                            componentScope = scopeResult;
                        } else if (scopeResult.prototype instanceof can.Map) {
                            componentScope = new scopeResult(initalScopeData);
                        } else {
                            componentScope = new(can.Map.extend(scopeResult))(initalScopeData);
                        }

                    }
                    var handlers = {};
                    // setup reverse bindings
                    can.each(twoWayBindings, function(computeData, prop) {
                        handlers[prop] = function(ev, newVal) {
                            // check that this property is not being changed because
                            // it's source value just changed
                            if (scopePropertyUpdating !== prop) {
                                computeData.compute(newVal);
                            }
                        };
                        componentScope.bind(prop, handlers[prop]);
                    });
                    // teardown reverse bindings when element is removed
                    can.bind.call(el, "removed", function() {
                        can.each(handlers, function(handler, prop) {
                            componentScope.unbind(prop, handlers[prop]);
                        });
                    });

                    this.scope = componentScope;
                    can.data(can.$(el), "scope", this.scope);

                    // create a real Scope object out of the scope property
                    var renderedScope = hookupOptions.scope.add(this.scope),

                        // setup helpers to callback with `this` as the component
                        helpers = {};

                    can.each(this.helpers || {}, function(val, prop) {
                        if (can.isFunction(val)) {
                            helpers[prop] = function() {
                                return val.apply(componentScope, arguments);
                            };
                        }
                    });

                    // create a control to listen to events
                    this._control = new this.constructor.Control(el, {
                            scope: this.scope
                        });

                    // if this component has a template (that we've already converted to a renderer)
                    if (this.constructor.renderer) {
                        // add content to tags
                        if (!helpers._tags) {
                            helpers._tags = {};
                        }

                        // we need be alerted to when a <content> element is rendered so we can put the original contents of the widget in its place
                        helpers._tags.content = function render(el, rendererOptions) {
                            // first check if there was content within the custom tag
                            // otherwise, render what was within <content>, the default code
                            var subtemplate = hookupOptions.subtemplate || rendererOptions.subtemplate;

                            if (subtemplate) {

                                // rendererOptions.options is a scope of helpers where `<content>` was found, so
                                // the right helpers should already be available.
                                // However, _tags.content is going to point to this current content callback.  We need to 
                                // remove that so it will walk up the chain

                                delete helpers._tags.content;

                                can.view.live.replace([el], subtemplate(
                                        // This is the context of where `<content>` was found
                                        // which will have the the component's context
                                        rendererOptions.scope,

                                        rendererOptions.options));

                                // restore the content tag so it could potentially be used again (as in lists)
                                helpers._tags.content = render;
                            }
                        };
                        // render the component's template
                        frag = this.constructor.renderer(renderedScope, hookupOptions.options.add(helpers));
                    } else {
                        // otherwise render the contents between the 
                        frag = can.view.frag(hookupOptions.subtemplate ? hookupOptions.subtemplate(renderedScope, hookupOptions.options.add(helpers)) : "");
                    }
                    can.appendChild(el, frag);
                }
            });

        if (window.$ && $.fn) {
            $.fn.scope = function(attr) {
                if (attr) {
                    return this.data("scope")
                        .attr(attr);
                } else {
                    return this.data("scope");
                }
            };
        }

        can.scope = function(el, attr) {
            el = can.$(el);
            if (attr) {
                return can.data(el, "scope")
                    .attr(attr);
            } else {
                return can.data(el, "scope");
            }
        };

        return Component;
    })(__m2, __m8, __m11, __m17, __m25);

    // ## model/model.js
    var __m26 = (function(can) {

        // ## model.js  
        // `can.Model`  
        // _A `can.Map` that connects to a RESTful interface._
        // Generic deferred piping function

        var pipe = function(def, model, func) {
            var d = new can.Deferred();
            def.then(function() {
                var args = can.makeArray(arguments),
                    success = true;
                try {
                    args[0] = model[func](args[0]);
                } catch (e) {
                    success = false;
                    d.rejectWith(d, [e].concat(args));
                }
                if (success) {
                    d.resolveWith(d, args);
                }
            }, function() {
                d.rejectWith(this, arguments);
            });

            if (typeof def.abort === 'function') {
                d.abort = function() {
                    return def.abort();
                };
            }

            return d;
        },
            modelNum = 0,
            getId = function(inst) {
                // Instead of using attr, use __get for performance.
                // Need to set reading
                if (can.__reading) {
                    can.__reading(inst, inst.constructor.id);
                }
                return inst.__get(inst.constructor.id);
            },
            // Ajax `options` generator function
            ajax = function(ajaxOb, data, type, dataType, success, error) {

                var params = {};

                // If we get a string, handle it.
                if (typeof ajaxOb === 'string') {
                    // If there's a space, it's probably the type.
                    var parts = ajaxOb.split(/\s+/);
                    params.url = parts.pop();
                    if (parts.length) {
                        params.type = parts.pop();
                    }
                } else {
                    can.extend(params, ajaxOb);
                }

                // If we are a non-array object, copy to a new attrs.
                params.data = typeof data === "object" && !can.isArray(data) ?
                    can.extend(params.data || {}, data) : data;

                // Get the url with any templated values filled out.
                params.url = can.sub(params.url, params.data, true);

                return can.ajax(can.extend({
                            type: type || 'post',
                            dataType: dataType || 'json',
                            success: success,
                            error: error
                        }, params));
            },
            makeRequest = function(self, type, success, error, method) {
                var args;
                // if we pass an array as `self` it it means we are coming from
                // the queued request, and we're passing already serialized data
                // self's signature will be: [self, serializedData]
                if (can.isArray(self)) {
                    args = self[1];
                    self = self[0];
                } else {
                    args = self.serialize();
                }
                args = [args];
                var deferred,
                    // The model.
                    model = self.constructor,
                    jqXHR;

                // `update` and `destroy` need the `id`.
                if (type !== 'create') {
                    args.unshift(getId(self));
                }

                jqXHR = model[type].apply(model, args);

                deferred = jqXHR.pipe(function(data) {
                    self[method || type + "d"](data, jqXHR);
                    return self;
                });

                // Hook up `abort`
                if (jqXHR.abort) {
                    deferred.abort = function() {
                        jqXHR.abort();
                    };
                }

                deferred.then(success, error);
                return deferred;
            }, initializers = {
                // makes a models function that looks up the data in a particular property
                models: function(prop) {
                    return function(instancesRawData, oldList) {
                        // until "end of turn", increment reqs counter so instances will be added to the store
                        can.Model._reqs++;
                        if (!instancesRawData) {
                            return;
                        }

                        if (instancesRawData instanceof this.List) {
                            return instancesRawData;
                        }

                        // Get the list type.
                        var self = this,
                            tmp = [],
                            Cls = self.List || ML,
                            res = oldList instanceof can.List ? oldList : new Cls(),
                            // Did we get an `array`?
                            arr = can.isArray(instancesRawData),

                            // Did we get a model list?
                            ml = instancesRawData instanceof ML,
                            // Get the raw `array` of objects.
                            raw = arr ?

                            // If an `array`, return the `array`.
                            instancesRawData :

                            // Otherwise if a model list.
                            (ml ?

                                // Get the raw objects from the list.
                                instancesRawData.serialize() :

                                // Get the object's data.
                                can.getObject(prop || "data", instancesRawData));

                        if (typeof raw === 'undefined') {
                            throw new Error('Could not get any raw data while converting using .models');
                        }



                        if (res.length) {
                            res.splice(0);
                        }

                        can.each(raw, function(rawPart) {
                            tmp.push(self.model(rawPart));
                        });

                        // We only want one change event so push everything at once
                        res.push.apply(res, tmp);

                        if (!arr) { // Push other stuff onto `array`.
                            can.each(instancesRawData, function(val, prop) {
                                if (prop !== 'data') {
                                    res.attr(prop, val);
                                }
                            });
                        }
                        // at "end of turn", clean up the store
                        setTimeout(can.proxy(this._clean, this), 1);
                        return res;
                    };
                },
                model: function(prop) {
                    return function(attributes) {
                        if (!attributes) {
                            return;
                        }
                        if (typeof attributes.serialize === 'function') {
                            attributes = attributes.serialize();
                        }
                        if (prop) {
                            attributes = can.getObject(prop || 'data', attributes);
                        }

                        var id = attributes[this.id],
                            model = (id || id === 0) && this.store[id] ?
                                this.store[id].attr(attributes, this.removeAttr || false) : new this(attributes);

                        return model;
                    };
                }
            },

            // This object describes how to make an ajax request for each ajax method.  
            // The available properties are:
            //		`url` - The default url to use as indicated as a property on the model.
            //		`type` - The default http request type
            //		`data` - A method that takes the `arguments` and returns `data` used for ajax.

            ajaxMethods = {

                create: {
                    url: "_shortName",
                    type: "post"
                },

                update: {
                    data: function(id, attrs) {
                        attrs = attrs || {};
                        var identity = this.id;
                        if (attrs[identity] && attrs[identity] !== id) {
                            attrs["new" + can.capitalize(id)] = attrs[identity];
                            delete attrs[identity];
                        }
                        attrs[identity] = id;
                        return attrs;
                    },
                    type: "put"
                },

                destroy: {
                    type: 'delete',
                    data: function(id, attrs) {
                        attrs = attrs || {};
                        attrs.id = attrs[this.id] = id;
                        return attrs;
                    }
                },

                findAll: {
                    url: "_shortName"
                },

                findOne: {}
            },
            // Makes an ajax request `function` from a string.
            //		`ajaxMethod` - The `ajaxMethod` object defined above.
            //		`str` - The string the user provided. Ex: `findAll: "/recipes.json"`.
            ajaxMaker = function(ajaxMethod, str) {
                // Return a `function` that serves as the ajax method.
                return function(data) {
                    // If the ajax method has it's own way of getting `data`, use that.
                    data = ajaxMethod.data ?
                        ajaxMethod.data.apply(this, arguments) :
                    // Otherwise use the data passed in.
                    data;
                    // Return the ajax method with `data` and the `type` provided.
                    return ajax(str || this[ajaxMethod.url || "_url"], data, ajaxMethod.type || "get");
                };
            };

        can.Model = can.Map({
                fullName: 'can.Model',
                _reqs: 0,

                setup: function(base) {
                    // create store here if someone wants to use model without inheriting from it
                    this.store = {};
                    can.Map.setup.apply(this, arguments);
                    // Set default list as model list
                    if (!can.Model) {
                        return;
                    }

                    this.List = ML({
                            Map: this
                        }, {});
                    var self = this,
                        clean = can.proxy(this._clean, self);

                    // go through ajax methods and set them up
                    can.each(ajaxMethods, function(method, name) {
                        // if an ajax method is not a function, it's either
                        // a string url like findAll: "/recipes" or an
                        // ajax options object like {url: "/recipes"}
                        if (!can.isFunction(self[name])) {
                            // use ajaxMaker to convert that into a function
                            // that returns a deferred with the data
                            self[name] = ajaxMaker(method, self[name]);
                        }
                        // check if there's a make function like makeFindAll
                        // these take deferred function and can do special
                        // behavior with it (like look up data in a store)
                        if (self['make' + can.capitalize(name)]) {
                            // pass the deferred method to the make method to get back
                            // the "findAll" method.
                            var newMethod = self['make' + can.capitalize(name)](self[name]);
                            can.Construct._overwrite(self, base, name, function() {
                                // increment the numer of requests
                                can.Model._reqs++;
                                var def = newMethod.apply(this, arguments);
                                var then = def.then(clean, clean);
                                then.abort = def.abort;

                                // attach abort to our then and return it
                                return then;
                            });
                        }
                    });
                    can.each(initializers, function(makeInitializer, name) {
                        if (typeof self[name] === 'string') {
                            can.Construct._overwrite(self, base, name, makeInitializer(self[name]));
                        }
                    });
                    if (self.fullName === 'can.Model' || !self.fullName) {
                        modelNum++;
                        self.fullName = 'Model' + modelNum;
                    }
                    // Add ajax converters.
                    can.Model._reqs = 0;
                    this._url = this._shortName + '/{' + this.id + '}';
                },
                _ajax: ajaxMaker,
                _makeRequest: makeRequest,
                _clean: function() {
                    can.Model._reqs--;
                    if (!can.Model._reqs) {
                        for (var id in this.store) {
                            if (!this.store[id]._bindings) {
                                delete this.store[id];
                            }
                        }
                    }
                    return arguments[0];
                },

                models: initializers.models("data"),

                model: initializers.model()
            },


            {
                setup: function(attrs) {
                    // try to add things as early as possible to the store (#457)
                    // we add things to the store before any properties are even set
                    var id = attrs && attrs[this.constructor.id];
                    if (can.Model._reqs && id !== null) {
                        this.constructor.store[id] = this;
                    }
                    can.Map.prototype.setup.apply(this, arguments);
                },

                isNew: function() {
                    var id = getId(this);
                    return !(id || id === 0); // If `null` or `undefined`
                },

                save: function(success, error) {
                    return makeRequest(this, this.isNew() ? 'create' : 'update', success, error);
                },

                destroy: function(success, error) {
                    if (this.isNew()) {
                        var self = this;
                        var def = can.Deferred();
                        def.then(success, error);
                        return def.done(function(data) {
                            self.destroyed(data);
                        })
                            .resolve(self);
                    }
                    return makeRequest(this, 'destroy', success, error, 'destroyed');
                },

                _bindsetup: function() {
                    this.constructor.store[this.__get(this.constructor.id)] = this;
                    return can.Map.prototype._bindsetup.apply(this, arguments);
                },

                _bindteardown: function() {
                    delete this.constructor.store[getId(this)];
                    return can.Map.prototype._bindteardown.apply(this, arguments);
                },
                // Change `id`.
                ___set: function(prop, val) {
                    can.Map.prototype.___set.call(this, prop, val);
                    // If we add an `id`, move it to the store.
                    if (prop === this.constructor.id && this._bindings) {
                        this.constructor.store[getId(this)] = this;
                    }
                }
            });

        can.each({

                makeFindAll: "models",

                makeFindOne: "model",
                makeCreate: "model",
                makeUpdate: "model"
            }, function(method, name) {
                can.Model[name] = function(oldMethod) {
                    return function() {
                        var args = can.makeArray(arguments),
                            oldArgs = can.isFunction(args[1]) ? args.splice(0, 1) : args.splice(0, 2),
                            def = pipe(oldMethod.apply(this, oldArgs), this, method);
                        def.then(args[0], args[1]);
                        // return the original promise
                        return def;
                    };
                };
            });

        can.each([

                "created",

                "updated",

                "destroyed"
            ], function(funcName) {
                can.Model.prototype[funcName] = function(attrs) {
                    var stub,
                        constructor = this.constructor;

                    // Update attributes if attributes have been passed
                    stub = attrs && typeof attrs === 'object' && this.attr(attrs.attr ? attrs.attr() : attrs);

                    // triggers change event that bubble's like
                    // handler( 'change','1.destroyed' ). This is used
                    // to remove items on destroyed from Model Lists.
                    // but there should be a better way.
                    can.trigger(this, "change", funcName);



                    // Call event on the instance's Class
                    can.trigger(constructor, funcName, this);
                };
            });

        // Model lists are just like `Map.List` except that when their items are 
        // destroyed, it automatically gets removed from the list.
        var ML = can.Model.List = can.List({
                setup: function(params) {
                    if (can.isPlainObject(params) && !can.isArray(params)) {
                        can.List.prototype.setup.apply(this);
                        this.replace(this.constructor.Map.findAll(params));
                    } else {
                        can.List.prototype.setup.apply(this, arguments);
                    }
                },
                _changes: function(ev, attr) {
                    can.List.prototype._changes.apply(this, arguments);
                    if (/\w+\.destroyed/.test(attr)) {
                        var index = this.indexOf(ev.target);
                        if (index !== -1) {
                            this.splice(index, 1);
                        }
                    }
                }
            });

        return can.Model;
    })(__m2, __m12, __m15);

    // ## util/string/deparam/deparam.js
    var __m28 = (function(can) {
        // ## deparam.js  
        // `can.deparam`  
        // _Takes a string of name value pairs and returns a Object literal that represents those params._
        var digitTest = /^\d+$/,
            keyBreaker = /([^\[\]]+)|(\[\])/g,
            paramTest = /([^?#]*)(#.*)?$/,
            prep = function(str) {
                return decodeURIComponent(str.replace(/\+/g, ' '));
            };
        can.extend(can, {
                deparam: function(params) {
                    var data = {}, pairs, lastPart;
                    if (params && paramTest.test(params)) {
                        pairs = params.split('&');
                        can.each(pairs, function(pair) {
                            var parts = pair.split('='),
                                key = prep(parts.shift()),
                                value = prep(parts.join('=')),
                                current = data;
                            if (key) {
                                parts = key.match(keyBreaker);
                                for (var j = 0, l = parts.length - 1; j < l; j++) {
                                    if (!current[parts[j]]) {
                                        // If what we are pointing to looks like an `array`
                                        current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                                    }
                                    current = current[parts[j]];
                                }
                                lastPart = parts.pop();
                                if (lastPart === '[]') {
                                    current.push(value);
                                } else {
                                    current[lastPart] = value;
                                }
                            }
                        });
                    }
                    return data;
                }
            });
        return can;
    })(__m2, __m10);

    // ## route/route.js
    var __m27 = (function(can) {

        // ## route.js
        // `can.route`
        // _Helps manage browser history (and client state) by synchronizing the
        // `window.location.hash` with a `can.Map`._
        // Helper methods used for matching routes.
        var
        // `RegExp` used to match route variables of the type ':name'.
        // Any word character or a period is matched.
        matcher = /\:([\w\.]+)/g,
            // Regular expression for identifying &amp;key=value lists.
            paramsMatcher = /^(?:&[^=]+=[^&]*)+/,
            // Converts a JS Object into a list of parameters that can be
            // inserted into an html element tag.
            makeProps = function(props) {
                var tags = [];
                can.each(props, function(val, name) {
                    tags.push((name === 'className' ? 'class' : name) + '="' +
                        (name === "href" ? val : can.esc(val)) + '"');
                });
                return tags.join(" ");
            },
            // Checks if a route matches the data provided. If any route variable
            // is not present in the data, the route does not match. If all route
            // variables are present in the data, the number of matches is returned
            // to allow discerning between general and more specific routes.
            matchesData = function(route, data) {
                var count = 0,
                    i = 0,
                    defaults = {};
                // look at default values, if they match ...
                for (var name in route.defaults) {
                    if (route.defaults[name] === data[name]) {
                        // mark as matched
                        defaults[name] = 1;
                        count++;
                    }
                }
                for (; i < route.names.length; i++) {
                    if (!data.hasOwnProperty(route.names[i])) {
                        return -1;
                    }
                    if (!defaults[route.names[i]]) {
                        count++;
                    }

                }

                return count;
            },
            location = window.location,
            wrapQuote = function(str) {
                return (str + '')
                    .replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
            },
            each = can.each,
            extend = can.extend,
            // Helper for convert any object (or value) to stringified object (or value)
            stringify = function(obj) {
                // Object is array, plain object, Map or List
                if (obj && typeof obj === "object") {
                    // Get native object or array from Map or List
                    if (obj instanceof can.Map) {
                        obj = obj.attr();
                        // Clone object to prevent change original values
                    } else {
                        obj = can.isFunction(obj.slice) ? obj.slice() : can.extend({}, obj);
                    }
                    // Convert each object property or array item into stringified new
                    can.each(obj, function(val, prop) {
                        obj[prop] = stringify(val);
                    });
                    // Object supports toString function
                } else if (obj !== undefined && obj !== null && can.isFunction(obj.toString)) {
                    obj = obj.toString();
                }

                return obj;
            },
            removeBackslash = function(str) {
                return str.replace(/\\/g, "");
            },
            // A ~~throttled~~ debounced function called multiple times will only fire once the
            // timer runs down. Each call resets the timer.
            timer,
            // Intermediate storage for `can.route.data`.
            curParams,
            // The last hash caused by a data change
            lastHash,
            // Are data changes pending that haven't yet updated the hash
            changingData,
            // If the `can.route.data` changes, update the hash.
            // Using `.serialize()` retrieves the raw data contained in the `observable`.
            // This function is ~~throttled~~ debounced so it only updates once even if multiple values changed.
            // This might be able to use batchNum and avoid this.
            onRouteDataChange = function(ev, attr, how, newval) {
                // indicate that data is changing
                changingData = 1;
                clearTimeout(timer);
                timer = setTimeout(function() {
                    // indicate that the hash is set to look like the data
                    changingData = 0;
                    var serialized = can.route.data.serialize(),
                        path = can.route.param(serialized, true);
                    can.route._call("setURL", path);

                    lastHash = path;
                }, 10);
            };

        can.route = function(url, defaults) {
            // if route ends with a / and url starts with a /, remove the leading / of the url
            var root = can.route._call("root");

            if (root.lastIndexOf("/") === root.length - 1 &&
                url.indexOf("/") === 0) {
                url = url.substr(1);
            }

            defaults = defaults || {};
            // Extract the variable names and replace with `RegExp` that will match
            // an atual URL with values.
            var names = [],
                res,
                test = "",
                lastIndex = matcher.lastIndex = 0,
                next,
                querySeparator = can.route._call("querySeparator");

            // res will be something like [":foo","foo"]
            while (res = matcher.exec(url)) {
                names.push(res[1]);
                test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
                next = "\\" + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator);
                // a name without a default value HAS to have a value
                // a name that has a default value can be empty
                // The `\\` is for string-escaping giving single `\` for `RegExp` escaping.
                test += "([^" + next + "]" + (defaults[res[1]] ? "*" : "+") + ")";
                lastIndex = matcher.lastIndex;
            }
            test += url.substr(lastIndex)
                .replace("\\", "");
            // Add route in a form that can be easily figured out.
            can.route.routes[url] = {
                // A regular expression that will match the route when variable values
                // are present; i.e. for `:page/:type` the `RegExp` is `/([\w\.]*)/([\w\.]*)/` which
                // will match for any value of `:page` and `:type` (word chars or period).
                test: new RegExp("^" + test + "($|" + wrapQuote(querySeparator) + ")"),
                // The original URL, same as the index for this entry in routes.
                route: url,
                // An `array` of all the variable names in this route.
                names: names,
                // Default values provided for the variables.
                defaults: defaults,
                // The number of parts in the URL separated by `/`.
                length: url.split('/')
                    .length
            };
            return can.route;
        };


        extend(can.route, {


                param: function(data, _setRoute) {
                    // Check if the provided data keys match the names in any routes;
                    // Get the one with the most matches.
                    var route,
                        // Need to have at least 1 match.
                        matches = 0,
                        matchCount,
                        routeName = data.route,
                        propCount = 0;

                    delete data.route;

                    each(data, function() {
                        propCount++;
                    });
                    // Otherwise find route.
                    each(can.route.routes, function(temp, name) {
                        // best route is the first with all defaults matching

                        matchCount = matchesData(temp, data);
                        if (matchCount > matches) {
                            route = temp;
                            matches = matchCount;
                        }
                        if (matchCount >= propCount) {
                            return false;
                        }
                    });
                    // If we have a route name in our `can.route` data, and it's
                    // just as good as what currently matches, use that
                    if (can.route.routes[routeName] && matchesData(can.route.routes[routeName], data) === matches) {
                        route = can.route.routes[routeName];
                    }
                    // If this is match...
                    if (route) {
                        var cpy = extend({}, data),
                            // Create the url by replacing the var names with the provided data.
                            // If the default value is found an empty string is inserted.
                            res = route.route.replace(matcher, function(whole, name) {
                                delete cpy[name];
                                return data[name] === route.defaults[name] ? "" : encodeURIComponent(data[name]);
                            })
                                .replace("\\", ""),
                            after;
                        // Remove matching default values
                        each(route.defaults, function(val, name) {
                            if (cpy[name] === val) {
                                delete cpy[name];
                            }
                        });

                        // The remaining elements of data are added as
                        // `&amp;` separated parameters to the url.
                        after = can.param(cpy);
                        // if we are paraming for setting the hash
                        // we also want to make sure the route value is updated
                        if (_setRoute) {
                            can.route.attr('route', route.route);
                        }
                        return res + (after ? can.route._call("querySeparator") + after : "");
                    }
                    // If no route was found, there is no hash URL, only paramters.
                    return can.isEmptyObject(data) ? "" : can.route._call("querySeparator") + can.param(data);
                },

                deparam: function(url) {

                    // remove the url
                    var root = can.route._call("root");
                    if (root.lastIndexOf("/") === root.length - 1 &&
                        url.indexOf("/") === 0) {
                        url = url.substr(1);
                    }

                    // See if the url matches any routes by testing it against the `route.test` `RegExp`.
                    // By comparing the URL length the most specialized route that matches is used.
                    var route = {
                        length: -1
                    },
                        querySeparator = can.route._call("querySeparator"),
                        paramsMatcher = can.route._call("paramsMatcher");

                    each(can.route.routes, function(temp, name) {
                        if (temp.test.test(url) && temp.length > route.length) {
                            route = temp;
                        }
                    });
                    // If a route was matched.
                    if (route.length > -1) {

                        var // Since `RegExp` backreferences are used in `route.test` (parens)
                        // the parts will contain the full matched string and each variable (back-referenced) value.
                        parts = url.match(route.test),
                            // Start will contain the full matched string; parts contain the variable values.
                            start = parts.shift(),
                            // The remainder will be the `&amp;key=value` list at the end of the URL.
                            remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)),
                            // If there is a remainder and it contains a `&amp;key=value` list deparam it.
                            obj = (remainder && paramsMatcher.test(remainder)) ? can.deparam(remainder.slice(1)) : {};

                        // Add the default values for this route.
                        obj = extend(true, {}, route.defaults, obj);
                        // Overwrite each of the default values in `obj` with those in
                        // parts if that part is not empty.
                        each(parts, function(part, i) {
                            if (part && part !== querySeparator) {
                                obj[route.names[i]] = decodeURIComponent(part);
                            }
                        });
                        obj.route = route.route;
                        return obj;
                    }
                    // If no route was matched, it is parsed as a `&amp;key=value` list.
                    if (url.charAt(0) !== querySeparator) {
                        url = querySeparator + url;
                    }
                    return paramsMatcher.test(url) ? can.deparam(url.slice(1)) : {};
                },

                data: new can.Map({}),

                routes: {},

                ready: function(val) {
                    if (val !== true) {
                        can.route._setup();
                        can.route.setState();
                    }
                    return can.route;
                },

                url: function(options, merge) {

                    if (merge) {
                        options = can.extend({}, can.route.deparam(can.route._call("matchingPartOfURL")), options);
                    }
                    return can.route._call("root") + can.route.param(options);
                },

                link: function(name, options, props, merge) {
                    return "<a " + makeProps(
                        extend({
                                href: can.route.url(options, merge)
                            }, props)) + ">" + name + "</a>";
                },

                current: function(options) {
                    return this._call("matchingPartOfURL") === can.route.param(options);
                },
                bindings: {
                    hashchange: {
                        paramsMatcher: paramsMatcher,
                        querySeparator: "&",
                        bind: function() {
                            can.bind.call(window, 'hashchange', setState);
                        },
                        unbind: function() {
                            can.unbind.call(window, 'hashchange', setState);
                        },
                        // Gets the part of the url we are determinging the route from.
                        // For hashbased routing, it's everything after the #, for
                        // pushState it's configurable
                        matchingPartOfURL: function() {
                            return location.href.split(/#!?/)[1] || "";
                        },
                        // gets called with the serialized can.route data after a route has changed
                        // returns what the url has been updated to (for matching purposes)
                        setURL: function(path) {
                            location.hash = "#!" + path;
                            return path;
                        },
                        root: "#!"
                    }
                },
                defaultBinding: "hashchange",
                currentBinding: null,
                // ready calls setup
                // setup binds and listens to data changes
                // bind listens to whatever you should be listening to
                // data changes tries to set the path

                // we need to be able to
                // easily kick off calling setState
                // 	teardown whatever is there
                //  turn on a particular binding

                // called when the route is ready
                _setup: function() {
                    if (!can.route.currentBinding) {
                        can.route._call("bind");
                        can.route.bind("change", onRouteDataChange);
                        can.route.currentBinding = can.route.defaultBinding;
                    }
                },
                _teardown: function() {
                    if (can.route.currentBinding) {
                        can.route._call("unbind");
                        can.route.unbind("change", onRouteDataChange);
                        can.route.currentBinding = null;
                    }
                    clearTimeout(timer);
                    changingData = 0;
                },
                // a helper to get stuff from the current or default bindings
                _call: function() {
                    var args = can.makeArray(arguments),
                        prop = args.shift(),
                        binding = can.route.bindings[can.route.currentBinding || can.route.defaultBinding],
                        method = binding[prop];
                    if (method.apply) {
                        return method.apply(binding, args);
                    } else {
                        return method;
                    }
                }
            });

        // The functions in the following list applied to `can.route` (e.g. `can.route.attr('...')`) will
        // instead act on the `can.route.data` observe.
        each(['bind', 'unbind', 'on', 'off', 'delegate', 'undelegate', 'removeAttr', 'compute', '_get', '__get'], function(name) {
            can.route[name] = function() {
                // `delegate` and `undelegate` require
                // the `can/map/delegate` plugin
                if (!can.route.data[name]) {
                    return;
                }

                return can.route.data[name].apply(can.route.data, arguments);
            };
        });

        // Because everything in hashbang is in fact a string this will automaticaly convert new values to string. Works with single value, or deep hashes.
        // Main motivation for this is to prevent double route event call for same value.
        // Example (the problem):
        // When you load page with hashbang like #!&some_number=2 and bind 'some_number' on routes.
        // It will fire event with adding of "2" (string) to 'some_number' property
        // But when you after this set can.route.attr({some_number: 2}) or can.route.attr('some_number', 2). it fires another event with change of 'some_number' from "2" (string) to 2 (integer)
        // This wont happen again with this normalization
        can.route.attr = function(attr, val) {
            var type = typeof attr,
                newArguments;

            // Reading
            if (val === undefined) {
                newArguments = arguments;
                // Sets object
            } else if (type !== "string" && type !== "number") {
                newArguments = [stringify(attr), val];
                // Sets key - value
            } else {
                newArguments = [attr, stringify(val)];
            }

            return can.route.data.attr.apply(can.route.data, newArguments);
        };

        var // Deparameterizes the portion of the hash of interest and assign the
        // values to the `can.route.data` removing existing values no longer in the hash.
        // setState is called typically by hashchange which fires asynchronously
        // So it's possible that someone started changing the data before the
        // hashchange event fired.  For this reason, it will not set the route data
        // if the data is changing or the hash already matches the hash that was set.
        setState = can.route.setState = function() {
            var hash = can.route._call("matchingPartOfURL");
            curParams = can.route.deparam(hash);

            // if the hash data is currently changing, or
            // the hash is what we set it to anyway, do NOT change the hash
            if (!changingData || hash !== lastHash) {
                can.route.attr(curParams, true);
            }
        };

        return can.route;
    })(__m2, __m12, __m15, __m28);

    // ## control/route/route.js
    var __m29 = (function(can) {

        // ## control/route.js
        // _Controller route integration._

        can.Control.processors.route = function(el, event, selector, funcName, controller) {
            selector = selector || "";
            if (!can.route.routes[selector]) {
                if (selector[0] === '/') {
                    selector = selector.substring(1);
                }
                can.route(selector);
            }
            var batchNum,
                check = function(ev, attr, how) {
                    if (can.route.attr('route') === (selector) &&
                        (ev.batchNum === undefined || ev.batchNum !== batchNum)) {

                        batchNum = ev.batchNum;

                        var d = can.route.attr();
                        delete d.route;
                        if (can.isFunction(controller[funcName])) {
                            controller[funcName](d);
                        } else {
                            controller[controller[funcName]](d);
                        }

                    }
                };
            can.route.bind('change', check);
            return function() {
                can.route.unbind('change', check);
            };
        };

        return can;
    })(__m2, __m27, __m8);

    window['can'] = __m4;
})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/construct/super
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## construct/super/super.js
    var __m1 = (function(can, Construct) {
        // tests if we can get super in .toString()
        var isFunction = can.isFunction,
            fnTest = /xyz/.test(function() {
                return this.xyz;
            }) ? /\b_super\b/ : /.*/;
        // overwrites a single property so it can still call super
        can.Construct._overwrite = function(addTo, base, name, val) {
            // Check if we're overwriting an existing function
            addTo[name] = isFunction(val) && isFunction(base[name]) && fnTest.test(val) ? function(name, fn) {
                return function() {
                    var tmp = this._super,
                        ret;
                    // Add a new ._super() method that is the same method
                    // but on the super-class
                    this._super = base[name];
                    // The method only need to be bound temporarily, so we
                    // remove it when we're done executing
                    ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            }(name, val) : val;
        };
        // overwrites an object with methods, sets up _super
        //   newProps - new properties
        //   oldProps - where the old properties might be
        //   addTo - what we are adding to
        can.Construct._inherit = function(newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                can.Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        };
        return can;
    })(window.can, undefined);

})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/map/sort
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## map/sort/sort.js
    var __m1 = (function(can) {
        var proto = can.List.prototype,
            _changes = proto._changes,
            setup = proto.setup;
        // extend the list for sorting support
        can.extend(proto, {
                comparator: undefined,
                sortIndexes: [],


                sortedIndex: function(item) {
                    var itemCompare = item.attr(this.comparator),
                        equaled = 0;
                    for (var i = 0, length = this.length; i < length; i++) {
                        if (item === this[i]) {
                            equaled = -1;
                            continue;
                        }
                        if (itemCompare <= this[i].attr(this.comparator)) {
                            return i + equaled;
                        }
                    }
                    return i + equaled;
                },


                sort: function(method, silent) {
                    var comparator = this.comparator,
                        args = comparator ? [

                            function(a, b) {
                                a = typeof a[comparator] === 'function' ? a[comparator]() : a[comparator];
                                b = typeof b[comparator] === 'function' ? b[comparator]() : b[comparator];
                                return a === b ? 0 : a < b ? -1 : 1;
                            }
                        ] : [method];
                    if (!silent) {
                        can.trigger(this, 'reset');
                    }
                    return Array.prototype.sort.apply(this, args);
                }
            });
        // create push, pop, shift, and unshift
        // converts to an array of arguments
        var getArgs = function(args) {
            return args[0] && can.isArray(args[0]) ? args[0] : can.makeArray(args);
        };
        can.each({

                push: "length",

                unshift: 0
            },

            function(where, name) {
                var proto = can.List.prototype,
                    old = proto[name];
                proto[name] = function() {
                    // get the items being added
                    var args = getArgs(arguments),
                        // where we are going to add items
                        len = where ? this.length : 0;
                    // call the original method
                    var res = old.apply(this, arguments);
                    // cause the change where the args are:
                    // len - where the additions happened
                    // add - items added
                    // args - the items added
                    // undefined - the old value
                    if (this.comparator && args.length) {
                        this.sort(null, true);
                        can.batch.trigger(this, 'reset', [args]);
                        this._triggerChange('' + len, 'add', args, undefined);
                    }
                    return res;
                };
            });
        //- override changes for sorting
        proto._changes = function(ev, attr, how, newVal, oldVal) {
            if (this.comparator && /^\d+./.test(attr)) {
                // get the index
                var index = +/^\d+/.exec(attr)[0],
                    // and item
                    item = this[index];
                if (typeof item !== 'undefined') {
                    // and the new item
                    var newIndex = this.sortedIndex(item);
                    if (newIndex !== index) {
                        // move ...
                        [].splice.call(this, index, 1);
                        [].splice.call(this, newIndex, 0, item);
                        can.trigger(this, 'move', [
                                item,
                                newIndex,
                                index
                            ]);
                        can.trigger(this, 'change', [
                                attr.replace(/^\d+/, newIndex),
                                how,
                                newVal,
                                oldVal
                            ]);
                        return;
                    }
                }
            }
            _changes.apply(this, arguments);
        };
        //- override setup for sorting
        proto.setup = function(instances, options) {
            setup.apply(this, arguments);
            if (this.comparator) {
                this.sort();
            }
        };
        return can.Map;
    })(window.can, undefined);

})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/map/validations
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## map/attributes/attributes.js
    var __m8 = (function(can, Map) {
        can.each([
                can.Map,
                can.Model
            ], function(clss) {
                // in some cases model might not be defined quite yet.
                if (clss === undefined) {
                    return;
                }
                var isObject = function(obj) {
                    return typeof obj === 'object' && obj !== null && obj;
                };
                can.extend(clss, {

                        attributes: {},


                        convert: {
                            'date': function(str) {
                                var type = typeof str;
                                if (type === 'string') {
                                    str = Date.parse(str);
                                    return isNaN(str) ? null : new Date(str);
                                } else if (type === 'number') {
                                    return new Date(str);
                                } else {
                                    return str;
                                }
                            },
                            'number': function(val) {
                                return parseFloat(val);
                            },
                            'boolean': function(val) {
                                if (val === 'false' || val === '0' || !val) {
                                    return false;
                                }
                                return true;
                            },
                            'default': function(val, oldVal, error, type) {
                                // Convert can.Model types using .model and .models
                                if (can.Map.prototype.isPrototypeOf(type.prototype) && typeof type.model === 'function' && typeof type.models === 'function') {
                                    return type[can.isArray(val) ? 'models' : 'model'](val);
                                }
                                if (can.Map.prototype.isPrototypeOf(type.prototype)) {
                                    if (can.isArray(val) && typeof type.List === 'function') {
                                        return new type.List(val);
                                    }
                                    return new type(val);
                                }
                                if (typeof type === 'function') {
                                    return type(val, oldVal);
                                }
                                var construct = can.getObject(type),
                                    context = window,
                                    realType;
                                // if type has a . we need to look it up
                                if (type.indexOf('.') >= 0) {
                                    // get everything before the last .
                                    realType = type.substring(0, type.lastIndexOf('.'));
                                    // get the object before the last .
                                    context = can.getObject(realType);
                                }
                                return typeof construct === 'function' ? construct.call(context, val, oldVal) : val;
                            }
                        },

                        serialize: {
                            'default': function(val, type) {
                                return isObject(val) && val.serialize ? val.serialize() : val;
                            },
                            'date': function(val) {
                                return val && val.getTime();
                            }
                        }
                    });
                // overwrite setup to do this stuff
                var oldSetup = clss.setup;

                clss.setup = function(superClass, stat, proto) {
                    var self = this;
                    oldSetup.call(self, superClass, stat, proto);
                    can.each(['attributes'], function(name) {
                        if (!self[name] || superClass[name] === self[name]) {
                            self[name] = {};
                        }
                    });
                    can.each([
                            'convert',
                            'serialize'
                        ], function(name) {
                            if (superClass[name] !== self[name]) {
                                self[name] = can.extend({}, superClass[name], self[name]);
                            }
                        });
                };
            });

        can.Map.prototype.__convert = function(prop, value) {
            // check if there is a
            var Class = this.constructor,
                oldVal = this.attr(prop),
                type, converter;
            if (Class.attributes) {
                // the type of the attribute
                type = Class.attributes[prop];
                converter = Class.convert[type] || Class.convert['default'];
            }
            return value === null || !type ? value : converter.call(Class, value, oldVal, function() {}, type);
        };

        can.List.prototype.serialize = function(attrName, stack) {
            return can.makeArray(can.Map.prototype.serialize.apply(this, arguments));
        };
        can.Map.prototype.serialize = function(attrName, stack) {
            var where = {}, Class = this.constructor,
                attrs = {};
            stack = can.isArray(stack) ? stack : [];
            stack.push(this._cid);
            if (attrName !== undefined) {
                attrs[attrName] = this[attrName];
            } else {
                attrs = this.__get();
            }
            can.each(attrs, function(val, name) {
                var type, converter;
                // If this is an observe, check that it wasn't serialized earlier in the stack.
                if (val instanceof can.Map && can.inArray(val._cid, stack) > -1) {
                    // Since this object has already been serialized once,
                    // just reference the id (or undefined if it doesn't exist).
                    where[name] = val.attr('id');
                } else {
                    type = Class.attributes ? Class.attributes[name] : 0;
                    converter = Class.serialize ? Class.serialize[type] : 0;
                    // if the value is an object, and has a attrs or serialize function
                    where[name] = val && typeof val.serialize === 'function' ?
                    // call attrs or serialize to get the original data back
                    val.serialize(undefined, stack) :
                    // otherwise if we have  a converter
                    converter ?
                    // use the converter
                    converter(val, type) :
                    // or return the val
                    val;
                }
            });
            if (typeof attrs.length !== 'undefined') {
                where.length = attrs.length;
            }
            return attrName !== undefined ? where[attrName] : where;
        };
        return can.Map;
    })(window.can, undefined, undefined);

    // ## map/validations/validations.js
    var __m1 = (function(can) {
        //validations object is by property.  You can have validations that
        //span properties, but this way we know which ones to run.
        //  proc should return true if there's an error or the error message
        var validate = function(attrNames, options, proc) {
            // normalize argumetns
            if (!proc) {
                proc = options;
                options = {};
            }
            options = options || {};
            attrNames = typeof attrNames === 'string' ? [attrNames] : can.makeArray(attrNames);
            // run testIf if it exists
            if (options.testIf && !options.testIf.call(this)) {
                return;
            }
            var self = this;
            can.each(attrNames, function(attrName) {
                // Add a test function for each attribute
                if (!self.validations[attrName]) {
                    self.validations[attrName] = [];
                }
                self.validations[attrName].push(function(newVal) {
                    // if options has a message return that, otherwise, return the error
                    var res = proc.call(this, newVal, attrName);
                    return res === undefined ? undefined : options.message || res;
                });
            });
        };
        var old = can.Map.prototype.__set;
        can.Map.prototype.__set = function(prop, value, current, success, error) {
            var self = this,
                validations = self.constructor.validations,
                errorCallback = function(errors) {
                    var stub = error && error.call(self, errors);
                    // if 'setter' is on the page it will trigger
                    // the error itself and we dont want to trigger
                    // the event twice. :)
                    if (stub !== false) {
                        can.trigger(self, 'error', [
                                prop,
                                errors
                            ], true);
                    }
                    return false;
                };
            old.call(self, prop, value, current, success, errorCallback);
            if (validations && validations[prop]) {
                var errors = self.errors(prop);
                if (errors) {
                    errorCallback(errors);
                }
            }
            return this;
        };
        can.each([
                can.Map,
                can.Model
            ], function(clss) {
                // in some cases model might not be defined quite yet.
                if (clss === undefined) {
                    return;
                }
                var oldSetup = clss.setup;

                can.extend(clss, {
                        setup: function(superClass) {
                            oldSetup.apply(this, arguments);
                            if (!this.validations || superClass.validations === this.validations) {
                                this.validations = {};
                            }
                        },

                        validate: validate,


                        validationMessages: {
                            format: 'is invalid',
                            inclusion: 'is not a valid option (perhaps out of range)',
                            lengthShort: 'is too short',
                            lengthLong: 'is too long',
                            presence: 'can\'t be empty',
                            range: 'is out of range',
                            numericality: 'must be a number'
                        },


                        validateFormatOf: function(attrNames, regexp, options) {
                            validate.call(this, attrNames, options, function(value) {
                                if (typeof value !== 'undefined' && value !== null && value !== '' && String(value)
                                    .match(regexp) === null) {
                                    return this.constructor.validationMessages.format;
                                }
                            });
                        },


                        validateInclusionOf: function(attrNames, inArray, options) {
                            validate.call(this, attrNames, options, function(value) {
                                if (typeof value === 'undefined') {
                                    return;
                                }
                                for (var i = 0; i < inArray.length; i++) {
                                    if (inArray[i] === value) {
                                        return;
                                    }
                                }
                                return this.constructor.validationMessages.inclusion;
                            });
                        },


                        validateLengthOf: function(attrNames, min, max, options) {
                            validate.call(this, attrNames, options, function(value) {
                                if ((typeof value === 'undefined' || value === null) && min > 0 || typeof value !== 'undefined' && value !== null && value.length < min) {
                                    return this.constructor.validationMessages.lengthShort + ' (min=' + min + ')';
                                } else if (typeof value !== 'undefined' && value !== null && value.length > max) {
                                    return this.constructor.validationMessages.lengthLong + ' (max=' + max + ')';
                                }
                            });
                        },


                        validatePresenceOf: function(attrNames, options) {
                            validate.call(this, attrNames, options, function(value) {
                                if (typeof value === 'undefined' || value === '' || value === null) {
                                    return this.constructor.validationMessages.presence;
                                }
                            });
                        },


                        validateRangeOf: function(attrNames, low, hi, options) {
                            validate.call(this, attrNames, options, function(value) {
                                if ((typeof value === 'undefined' || value === null) && low > 0 || typeof value !== 'undefined' && value !== null && (value < low || value > hi)) {
                                    return this.constructor.validationMessages.range + ' [' + low + ',' + hi + ']';
                                }
                            });
                        },


                        validatesNumericalityOf: function(attrNames) {
                            validate.call(this, attrNames, function(value) {
                                var res = !isNaN(parseFloat(value)) && isFinite(value);
                                if (!res) {
                                    return this.constructor.validationMessages.numericality;
                                }
                            });
                        }
                    });
            });

        can.extend(can.Map.prototype, {

                errors: function(attrs, newVal) {
                    // convert attrs to an array
                    if (attrs) {
                        attrs = can.isArray(attrs) ? attrs : [attrs];
                    }
                    var errors = {}, self = this,
                        // helper function that adds error messages to errors object
                        // attr - the name of the attribute
                        // funcs - the validation functions
                        addErrors = function(attr, funcs) {
                            can.each(funcs, function(func) {
                                var res = func.call(self, isTest ? self.__convert ? self.__convert(attr, newVal) : newVal : self.attr(attr));
                                if (res) {
                                    if (!errors[attr]) {
                                        errors[attr] = [];
                                    }
                                    errors[attr].push(res);
                                }
                            });
                        }, validations = this.constructor.validations,
                        isTest = attrs && attrs.length === 1 && arguments.length === 2;
                    // go through each attribute or validation and
                    // add any errors
                    can.each(attrs || validations || {}, function(funcs, attr) {
                        // if we are iterating through an array, use funcs
                        // as the attr name
                        if (typeof attr === 'number') {
                            attr = funcs;
                            funcs = validations[attr];
                        }
                        // add errors to the
                        addErrors(attr, funcs || []);
                    });
                    // return errors as long as we have one
                    return can.isEmptyObject(errors) ? null : isTest ? errors[attrs[0]] : errors;
                }
            });
        return can.Map;
    })(window.can, __m8);

})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/control/plugin
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## control/plugin/plugin.js
    var __m1 = (function($, can) {
        //used to determine if a control instance is one of controllers
        //controllers can be strings or classes
        var i, isAControllerOf = function(instance, controllers) {
                var name = instance.constructor.pluginName || instance.constructor._shortName;
                for (i = 0; i < controllers.length; i++) {
                    if (typeof controllers[i] === 'string' ? name === controllers[i] : instance instanceof controllers[i]) {
                        return true;
                    }
                }
                return false;
            }, makeArray = can.makeArray,
            old = can.Control.setup;

        can.Control.setup = function() {
            // if you didn't provide a name, or are control, don't do anything
            if (this !== can.Control) {

                var pluginName = this.pluginName || this._fullName;
                // create jQuery plugin
                if (pluginName !== 'can_control') {
                    this.plugin(pluginName);
                }
                old.apply(this, arguments);
            }
        };

        $.fn.extend({


                controls: function() {
                    var controllerNames = makeArray(arguments),
                        instances = [],
                        controls, c;
                    //check if arguments
                    this.each(function() {
                        controls = can.$(this)
                            .data('controls');
                        if (!controls) {
                            return;
                        }
                        for (var i = 0; i < controls.length; i++) {
                            c = controls[i];
                            if (!controllerNames.length || isAControllerOf(c, controllerNames)) {
                                instances.push(c);
                            }
                        }
                    });
                    return instances;
                },


                control: function(control) {
                    return this.controls.apply(this, arguments)[0];
                }
            });
        can.Control.plugin = function(pluginname) {
            var control = this;
            if (!$.fn[pluginname]) {
                $.fn[pluginname] = function(options) {
                    var args = makeArray(arguments),
                        //if the arg is a method on this control
                        isMethod = typeof options === 'string' && $.isFunction(control.prototype[options]),
                        meth = args[0],
                        returns;
                    this.each(function() {
                        //check if created
                        var plugin = can.$(this)
                            .control(control);
                        if (plugin) {
                            if (isMethod) {
                                // call a method on the control with the remaining args
                                returns = plugin[meth].apply(plugin, args.slice(1));
                            } else {
                                // call the plugin's update method
                                plugin.update.apply(plugin, args);
                            }
                        } else {
                            //create a new control instance
                            control.newInstance.apply(control, [this].concat(args));
                        }
                    });
                    return returns !== undefined ? returns : this;
                };
            }
        };

        can.Control.prototype.update = function(options) {
            can.extend(this.options, options);
            this.on();
        };
        return can;
    })(jQuery, window.can, undefined);

})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/construct/proxy
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## construct/proxy/proxy.js
    var __m1 = (function(can, Construct) {
        var isFunction = can.isFunction,
            isArray = can.isArray,
            makeArray = can.makeArray,
            proxy = function(funcs) {
                //args that should be curried
                var args = makeArray(arguments),
                    self;
                // get the functions to callback
                funcs = args.shift();
                // if there is only one function, make funcs into an array
                if (!isArray(funcs)) {
                    funcs = [funcs];
                }
                // keep a reference to us in self
                self = this;



                return function class_cb() {
                    // add the arguments after the curried args
                    var cur = args.concat(makeArray(arguments)),
                        isString, length = funcs.length,
                        f = 0,
                        func;
                    // go through each function to call back
                    for (; f < length; f++) {
                        func = funcs[f];
                        if (!func) {
                            continue;
                        }
                        // set called with the name of the function on self (this is how this.view works)
                        isString = typeof func === 'string';
                        // call the function
                        cur = (isString ? self[func] : func)
                            .apply(self, cur || []);
                        // pass the result to the next function (if there is a next function)
                        if (f < length - 1) {
                            cur = !isArray(cur) || cur._use_call ? [cur] : cur;
                        }
                    }
                    return cur;
                };
            };
        can.Construct.proxy = can.Construct.prototype.proxy = proxy;
        // this corrects the case where can/control loads after can/construct/proxy, so static props don't have proxy
        var correctedClasses = [
            can.Map,
            can.Control,
            can.Model
        ],
            i = 0;
        for (; i < correctedClasses.length; i++) {
            if (correctedClasses[i]) {
                correctedClasses[i].proxy = proxy;
            }
        }
        return can;
    })(window.can, undefined);

})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/map/attributes
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## map/attributes/attributes.js
    var __m1 = (function(can, Map) {
        can.each([
                can.Map,
                can.Model
            ], function(clss) {
                // in some cases model might not be defined quite yet.
                if (clss === undefined) {
                    return;
                }
                var isObject = function(obj) {
                    return typeof obj === 'object' && obj !== null && obj;
                };
                can.extend(clss, {

                        attributes: {},


                        convert: {
                            'date': function(str) {
                                var type = typeof str;
                                if (type === 'string') {
                                    str = Date.parse(str);
                                    return isNaN(str) ? null : new Date(str);
                                } else if (type === 'number') {
                                    return new Date(str);
                                } else {
                                    return str;
                                }
                            },
                            'number': function(val) {
                                return parseFloat(val);
                            },
                            'boolean': function(val) {
                                if (val === 'false' || val === '0' || !val) {
                                    return false;
                                }
                                return true;
                            },
                            'default': function(val, oldVal, error, type) {
                                // Convert can.Model types using .model and .models
                                if (can.Map.prototype.isPrototypeOf(type.prototype) && typeof type.model === 'function' && typeof type.models === 'function') {
                                    return type[can.isArray(val) ? 'models' : 'model'](val);
                                }
                                if (can.Map.prototype.isPrototypeOf(type.prototype)) {
                                    if (can.isArray(val) && typeof type.List === 'function') {
                                        return new type.List(val);
                                    }
                                    return new type(val);
                                }
                                if (typeof type === 'function') {
                                    return type(val, oldVal);
                                }
                                var construct = can.getObject(type),
                                    context = window,
                                    realType;
                                // if type has a . we need to look it up
                                if (type.indexOf('.') >= 0) {
                                    // get everything before the last .
                                    realType = type.substring(0, type.lastIndexOf('.'));
                                    // get the object before the last .
                                    context = can.getObject(realType);
                                }
                                return typeof construct === 'function' ? construct.call(context, val, oldVal) : val;
                            }
                        },

                        serialize: {
                            'default': function(val, type) {
                                return isObject(val) && val.serialize ? val.serialize() : val;
                            },
                            'date': function(val) {
                                return val && val.getTime();
                            }
                        }
                    });
                // overwrite setup to do this stuff
                var oldSetup = clss.setup;

                clss.setup = function(superClass, stat, proto) {
                    var self = this;
                    oldSetup.call(self, superClass, stat, proto);
                    can.each(['attributes'], function(name) {
                        if (!self[name] || superClass[name] === self[name]) {
                            self[name] = {};
                        }
                    });
                    can.each([
                            'convert',
                            'serialize'
                        ], function(name) {
                            if (superClass[name] !== self[name]) {
                                self[name] = can.extend({}, superClass[name], self[name]);
                            }
                        });
                };
            });

        can.Map.prototype.__convert = function(prop, value) {
            // check if there is a
            var Class = this.constructor,
                oldVal = this.attr(prop),
                type, converter;
            if (Class.attributes) {
                // the type of the attribute
                type = Class.attributes[prop];
                converter = Class.convert[type] || Class.convert['default'];
            }
            return value === null || !type ? value : converter.call(Class, value, oldVal, function() {}, type);
        };

        can.List.prototype.serialize = function(attrName, stack) {
            return can.makeArray(can.Map.prototype.serialize.apply(this, arguments));
        };
        can.Map.prototype.serialize = function(attrName, stack) {
            var where = {}, Class = this.constructor,
                attrs = {};
            stack = can.isArray(stack) ? stack : [];
            stack.push(this._cid);
            if (attrName !== undefined) {
                attrs[attrName] = this[attrName];
            } else {
                attrs = this.__get();
            }
            can.each(attrs, function(val, name) {
                var type, converter;
                // If this is an observe, check that it wasn't serialized earlier in the stack.
                if (val instanceof can.Map && can.inArray(val._cid, stack) > -1) {
                    // Since this object has already been serialized once,
                    // just reference the id (or undefined if it doesn't exist).
                    where[name] = val.attr('id');
                } else {
                    type = Class.attributes ? Class.attributes[name] : 0;
                    converter = Class.serialize ? Class.serialize[type] : 0;
                    // if the value is an object, and has a attrs or serialize function
                    where[name] = val && typeof val.serialize === 'function' ?
                    // call attrs or serialize to get the original data back
                    val.serialize(undefined, stack) :
                    // otherwise if we have  a converter
                    converter ?
                    // use the converter
                    converter(val, type) :
                    // or return the val
                    val;
                }
            });
            if (typeof attrs.length !== 'undefined') {
                where.length = attrs.length;
            }
            return attrName !== undefined ? where[attrName] : where;
        };
        return can.Map;
    })(window.can, undefined, undefined);

})();
/*!
 * CanJS - 2.0.7
 * http://canjs.us/
 * Copyright (c) 2014 Bitovi
 * Wed, 26 Mar 2014 16:12:33 GMT
 * Licensed MIT
 * Includes: can/map/backup
 * Download from: http://canjs.com
 */
(function(undefined) {

    // ## util/object/object.js
    var __m13 = (function(can) {
        var isArray = can.isArray;

        can.Object = {};

        var same = can.Object.same = function(a, b, compares, aParent, bParent, deep) {
            var aType = typeof a,
                aArray = isArray(a),
                comparesType = typeof compares,
                compare;
            if (comparesType === 'string' || compares === null) {
                compares = compareMethods[compares];
                comparesType = 'function';
            }
            if (comparesType === 'function') {
                return compares(a, b, aParent, bParent);
            }
            compares = compares || {};
            if (a === null || b === null) {
                return a === b;
            }
            if (a instanceof Date || b instanceof Date) {
                return a === b;
            }
            if (deep === -1) {
                return aType === 'object' || a === b;
            }
            if (aType !== typeof b || aArray !== isArray(b)) {
                return false;
            }
            if (a === b) {
                return true;
            }
            if (aArray) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    compare = compares[i] === undefined ? compares['*'] : compares[i];
                    if (!same(a[i], b[i], a, b, compare)) {
                        return false;
                    }
                }
                return true;
            } else if (aType === 'object' || aType === 'function') {
                var bCopy = can.extend({}, b);
                for (var prop in a) {
                    compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!same(a[prop], b[prop], compare, a, b, deep === false ? -1 : undefined)) {
                        return false;
                    }
                    delete bCopy[prop];
                }
                // go through bCopy props ... if there is no compare .. return false
                for (prop in bCopy) {
                    if (compares[prop] === undefined || !same(undefined, b[prop], compares[prop], a, b, deep === false ? -1 : undefined)) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };

        can.Object.subsets = function(checkSet, sets, compares) {
            var len = sets.length,
                subsets = [];
            for (var i = 0; i < len; i++) {
                //check this subset
                var set = sets[i];
                if (can.Object.subset(checkSet, set, compares)) {
                    subsets.push(set);
                }
            }
            return subsets;
        };

        can.Object.subset = function(subset, set, compares) {
            // go through set {type: 'folder'} and make sure every property
            // is in subset {type: 'folder', parentId :5}
            // then make sure that set has fewer properties
            // make sure we are only checking 'important' properties
            // in subset (ones that have to have a value)
            compares = compares || {};
            for (var prop in set) {
                if (!same(subset[prop], set[prop], compares[prop], subset, set)) {
                    return false;
                }
            }
            return true;
        };
        var compareMethods = {
            'null': function() {
                return true;
            },
            i: function(a, b) {
                return ('' + a)
                    .toLowerCase() === ('' + b)
                    .toLowerCase();
            }
        };
        return can.Object;
    })(window.can);

    // ## map/backup/backup.js
    var __m1 = (function(can) {
        var flatProps = function(a, cur) {
            var obj = {};
            for (var prop in a) {
                if (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {
                    obj[prop] = a[prop];
                } else {
                    obj[prop] = cur.attr(prop);
                }
            }
            return obj;
        };
        can.extend(can.Map.prototype, {


                backup: function() {
                    this._backupStore = this._attrs();
                    return this;
                },


                isDirty: function(checkAssociations) {
                    return this._backupStore && !can.Object.same(this._attrs(), this._backupStore, undefined, undefined, undefined, !! checkAssociations);
                },


                restore: function(restoreAssociations) {
                    var props = restoreAssociations ? this._backupStore : flatProps(this._backupStore, this);
                    if (this.isDirty(restoreAssociations)) {
                        this._attrs(props, true);
                    }
                    return this;
                }
            });
        return can.Map;
    })(window.can, undefined, __m13);

})();
/**
 * Full HTML5 compatibility rule set
 * These rules define which tags and CSS classes are supported and which tags should be specially treated.
 *
 * Examples based on this rule set:
 *
 *    <a href="http://foobar.com">foo</a>
 *    ... becomes ...
 *    <a href="http://foobar.com" target="_blank" rel="nofollow">foo</a>
 *
 *    <img align="left" src="http://foobar.com/image.png">
 *    ... becomes ...
 *    <img class="wysiwyg-float-left" src="http://foobar.com/image.png" alt="">
 *
 *    <div>foo<script>alert(document.cookie)</script></div>
 *    ... becomes ...
 *    <div>foo</div>
 *
 *    <marquee>foo</marquee>
 *    ... becomes ...
 *    <span>foo</span>
 *
 *    foo <br clear="both"> bar
 *    ... becomes ...
 *    foo <br class="wysiwyg-clear-both"> bar
 *
 *    <div>hello <iframe src="http://google.com"></iframe></div>
 *    ... becomes ...
 *    <div>hello </div>
 *
 *    <center>hello</center>
 *    ... becomes ...
 *    <div class="wysiwyg-text-align-center">hello</div>
 */
var wysihtml5ParserRules = {
    /**
     * CSS Class white-list
     * Following CSS classes won't be removed when parsed by the wysihtml5 HTML parser
     */
    "classes": {
        "wysiwyg-clear-both": 1,
        "wysiwyg-clear-left": 1,
        "wysiwyg-clear-right": 1,
        "wysiwyg-color-aqua": 1,
        "wysiwyg-color-black": 1,
        "wysiwyg-color-blue": 1,
        "wysiwyg-color-fuchsia": 1,
        "wysiwyg-color-gray": 1,
        "wysiwyg-color-green": 1,
        "wysiwyg-color-lime": 1,
        "wysiwyg-color-maroon": 1,
        "wysiwyg-color-navy": 1,
        "wysiwyg-color-olive": 1,
        "wysiwyg-color-purple": 1,
        "wysiwyg-color-red": 1,
        "wysiwyg-color-silver": 1,
        "wysiwyg-color-teal": 1,
        "wysiwyg-color-white": 1,
        "wysiwyg-color-yellow": 1,
        "wysiwyg-float-left": 1,
        "wysiwyg-float-right": 1,
        "wysiwyg-font-size-large": 1,
        "wysiwyg-font-size-larger": 1,
        "wysiwyg-font-size-medium": 1,
        "wysiwyg-font-size-small": 1,
        "wysiwyg-font-size-smaller": 1,
        "wysiwyg-font-size-x-large": 1,
        "wysiwyg-font-size-x-small": 1,
        "wysiwyg-font-size-xx-large": 1,
        "wysiwyg-font-size-xx-small": 1,
        "wysiwyg-text-align-center": 1,
        "wysiwyg-text-align-justify": 1,
        "wysiwyg-text-align-left": 1,
        "wysiwyg-text-align-right": 1
    },
    /**
     * Tag list
     *
     * The following options are available:
     *
     *    - add_class:        converts and deletes the given HTML4 attribute (align, clear, ...) via the given method to a css class
     *                        The following methods are implemented in wysihtml5.dom.parse:
     *                          - align_text:  converts align attribute values (right/left/center/justify) to their corresponding css class "wysiwyg-text-align-*")
     *                            <p align="center">foo</p> ... becomes ... <p> class="wysiwyg-text-align-center">foo</p>
     *                          - clear_br:    converts clear attribute values left/right/all/both to their corresponding css class "wysiwyg-clear-*"
     *                            <br clear="all"> ... becomes ... <br class="wysiwyg-clear-both">
     *                          - align_img:    converts align attribute values (right/left) on <img> to their corresponding css class "wysiwyg-float-*"
     *                          
     *    - remove:             removes the element and its content
     *
     *    - rename_tag:         renames the element to the given tag
     *
     *    - set_class:          adds the given class to the element (note: make sure that the class is in the "classes" white list above)
     *
     *    - set_attributes:     sets/overrides the given attributes
     *
     *    - check_attributes:   checks the given HTML attribute via the given method
     *                            - url:            allows only valid urls (starting with http:// or https://)
     *                            - src:            allows something like "/foobar.jpg", "http://google.com", ...
     *                            - href:           allows something like "mailto:bert@foo.com", "http://google.com", "/foobar.jpg"
     *                            - alt:            strips unwanted characters. if the attribute is not set, then it gets set (to ensure valid and compatible HTML)
     *                            - numbers:  ensures that the attribute only contains numeric characters
     */
    "tags": {
        "tr": {
            "add_class": {
                "align": "align_text"
            }
        },
        "strike": {
            "remove": 1
        },
        "form": {
            "rename_tag": "div"
        },
        "rt": {
            "rename_tag": "span"
        },
        "code": {},
        "acronym": {
            "rename_tag": "span"
        },
        "br": {
            "add_class": {
                "clear": "clear_br"
            }
        },
        "details": {
            "rename_tag": "div"
        },
        "h4": {
            "add_class": {
                "align": "align_text"
            }
        },
        "em": {},
        "title": {
            "remove": 1
        },
        "multicol": {
            "rename_tag": "div"
        },
        "figure": {
            "rename_tag": "div"
        },
        "xmp": {
            "rename_tag": "span"
        },
        "small": {
            "rename_tag": "span",
            "set_class": "wysiwyg-font-size-smaller"
        },
        "area": {
            "remove": 1
        },
        "time": {
            "rename_tag": "span"
        },
        "dir": {
            "rename_tag": "ul"
        },
        "bdi": {
            "rename_tag": "span"
        },
        "command": {
            "remove": 1
        },
        "ul": {},
        "progress": {
            "rename_tag": "span"
        },
        "dfn": {
            "rename_tag": "span"
        },
        "iframe": {
            "remove": 1
        },
        "figcaption": {
            "rename_tag": "div"
        },
        "a": {
            "check_attributes": {
                "href": "url" // if you compiled master manually then change this from 'url' to 'href'
            },
            "set_attributes": {
                "rel": "nofollow",
                "target": "_blank"
            }
        },
        "img": {
            "check_attributes": {
                "width": "numbers",
                "alt": "alt",
                "src": "url", // if you compiled master manually then change this from 'url' to 'src'
                "height": "numbers"
            },
            "add_class": {
                "align": "align_img"
            }
        },
        "rb": {
            "rename_tag": "span"
        },
        "footer": {
            "rename_tag": "div"
        },
        "noframes": {
            "remove": 1
        },
        "abbr": {
            "rename_tag": "span"
        },
        "u": {},
        "bgsound": {
            "remove": 1
        },
        "sup": {
            "rename_tag": "span"
        },
        "address": {
            "rename_tag": "div"
        },
        "basefont": {
            "remove": 1
        },
        "nav": {
            "rename_tag": "div"
        },
        "h1": {
            "add_class": {
                "align": "align_text"
            }
        },
        "head": {
            "remove": 1
        },
        "tbody": {
            "add_class": {
                "align": "align_text"
            }
        },
        "dd": {
            "rename_tag": "div"
        },
        "s": {
            "rename_tag": "span"
        },
        "li": {},
        "td": {
            "check_attributes": {
                "rowspan": "numbers",
                "colspan": "numbers"
            },
            "add_class": {
                "align": "align_text"
            }
        },
        "object": {
            "remove": 1
        },
        "div": {
            "add_class": {
                "align": "align_text"
            }
        },
        "option": {
            "rename_tag": "span"
        },
        "select": {
            "rename_tag": "span"
        },
        "i": {},
        "track": {
            "remove": 1
        },
        "wbr": {
            "remove": 1
        },
        "fieldset": {
            "rename_tag": "div"
        },
        "big": {
            "rename_tag": "span",
            "set_class": "wysiwyg-font-size-larger"
        },
        "button": {
            "rename_tag": "span"
        },
        "noscript": {
            "remove": 1
        },
        "svg": {
            "remove": 1
        },
        "input": {
            "remove": 1
        },
        "table": {},
        "keygen": {
            "remove": 1
        },
        "h5": {
            "add_class": {
                "align": "align_text"
            }
        },
        "meta": {
            "remove": 1
        },
        "map": {
            "rename_tag": "div"
        },
        "isindex": {
            "remove": 1
        },
        "mark": {
            "rename_tag": "span"
        },
        "caption": {
            "add_class": {
                "align": "align_text"
            }
        },
        "tfoot": {
            "add_class": {
                "align": "align_text"
            }
        },
        "base": {
            "remove": 1
        },
        "video": {
            "remove": 1
        },
        "strong": {},
        "canvas": {
            "remove": 1
        },
        "output": {
            "rename_tag": "span"
        },
        "marquee": {
            "rename_tag": "span"
        },
        "b": {},
        "q": {
            "check_attributes": {
                "cite": "url"
            }
        },
        "applet": {
            "remove": 1
        },
        "span": {},
        "rp": {
            "rename_tag": "span"
        },
        "spacer": {
            "remove": 1
        },
        "source": {
            "remove": 1
        },
        "aside": {
            "rename_tag": "div"
        },
        "frame": {
            "remove": 1
        },
        "section": {
            "rename_tag": "div"
        },
        "body": {
            "rename_tag": "div"
        },
        "ol": {},
        "nobr": {
            "rename_tag": "span"
        },
        "html": {
            "rename_tag": "div"
        },
        "summary": {
            "rename_tag": "span"
        },
        "var": {
            "rename_tag": "span"
        },
        "del": {
            "remove": 1
        },
        "blockquote": {
            "check_attributes": {
                "cite": "url"
            }
        },
        "style": {
            "remove": 1
        },
        "device": {
            "remove": 1
        },
        "meter": {
            "rename_tag": "span"
        },
        "h3": {
            "add_class": {
                "align": "align_text"
            }
        },
        "textarea": {
            "rename_tag": "span"
        },
        "embed": {
            "remove": 1
        },
        "hgroup": {
            "rename_tag": "div"
        },
        "font": {
            "rename_tag": "span",
            "add_class": {
                "size": "size_font"
            }
        },
        "tt": {
            "rename_tag": "span"
        },
        "noembed": {
            "remove": 1
        },
        "thead": {
            "add_class": {
                "align": "align_text"
            }
        },
        "blink": {
            "rename_tag": "span"
        },
        "plaintext": {
            "rename_tag": "span"
        },
        "xml": {
            "remove": 1
        },
        "h6": {
            "add_class": {
                "align": "align_text"
            }
        },
        "param": {
            "remove": 1
        },
        "th": {
            "check_attributes": {
                "rowspan": "numbers",
                "colspan": "numbers"
            },
            "add_class": {
                "align": "align_text"
            }
        },
        "legend": {
            "rename_tag": "span"
        },
        "hr": {},
        "label": {
            "rename_tag": "span"
        },
        "dl": {
            "rename_tag": "div"
        },
        "kbd": {
            "rename_tag": "span"
        },
        "listing": {
            "rename_tag": "div"
        },
        "dt": {
            "rename_tag": "span"
        },
        "nextid": {
            "remove": 1
        },
        "pre": {},
        "center": {
            "rename_tag": "div",
            "set_class": "wysiwyg-text-align-center"
        },
        "audio": {
            "remove": 1
        },
        "datalist": {
            "rename_tag": "span"
        },
        "samp": {
            "rename_tag": "span"
        },
        "col": {
            "remove": 1
        },
        "article": {
            "rename_tag": "div"
        },
        "cite": {},
        "link": {
            "remove": 1
        },
        "script": {
            "remove": 1
        },
        "bdo": {
            "rename_tag": "span"
        },
        "menu": {
            "rename_tag": "ul"
        },
        "colgroup": {
            "remove": 1
        },
        "ruby": {
            "rename_tag": "span"
        },
        "h2": {
            "add_class": {
                "align": "align_text"
            }
        },
        "ins": {
            "rename_tag": "span"
        },
        "p": {
            "add_class": {
                "align": "align_text"
            }
        },
        "sub": {
            "rename_tag": "span"
        },
        "comment": {
            "remove": 1
        },
        "frameset": {
            "remove": 1
        },
        "optgroup": {
            "rename_tag": "span"
        },
        "header": {
            "rename_tag": "div"
        }
    }
};

/**
 * @license wysihtml5 v0.4.0pre
 * https://github.com/xing/wysihtml5
 *
 * Author: Christopher Blum (https://github.com/tiff)
 *
 * Copyright (C) 2012 XING AG
 * Licensed under the MIT license (MIT)
 *
 */
var wysihtml5 = {
  version: "0.4.0pre",
  
  // namespaces
  commands:   {},
  dom:        {},
  quirks:     {},
  toolbar:    {},
  lang:       {},
  selection:  {},
  views:      {},
  
  INVISIBLE_SPACE: "\uFEFF",
  
  EMPTY_FUNCTION: function() {},
  
  ELEMENT_NODE: 1,
  TEXT_NODE:    3,
  
  BACKSPACE_KEY:  8,
  ENTER_KEY:      13,
  ESCAPE_KEY:     27,
  SPACE_KEY:      32,
  DELETE_KEY:     46
};/**
 * @license Rangy, a cross-browser JavaScript range and selection library
 * http://code.google.com/p/rangy/
 *
 * Copyright 2011, Tim Down
 * Licensed under the MIT license.
 * Version: 1.2.2
 * Build date: 13 November 2011
 */
window['rangy'] = (function() {


    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";

    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
        "commonAncestorContainer", "START_TO_START", "START_TO_END", "END_TO_START", "END_TO_END"];

    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",
        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",
        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];

    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];

    // Subset of TextRange's full set of methods that we're interested in
    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "getBookmark", "moveToBookmark",
        "moveToElementText", "parentElement", "pasteHTML", "select", "setEndPoint", "getBoundingClientRect"];

    /*----------------------------------------------------------------------------------------------------------------*/

    // Trio of functions taken from Peter Michaux's article:
    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
    function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";
    }

    function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
    }

    function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
    }

    // Creates a convenience function to save verbose repeated calls to tests functions
    function createMultiplePropertyTest(testFunc) {
        return function(o, props) {
            var i = props.length;
            while (i--) {
                if (!testFunc(o, props[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions
    var areHostMethods = createMultiplePropertyTest(isHostMethod);
    var areHostObjects = createMultiplePropertyTest(isHostObject);
    var areHostProperties = createMultiplePropertyTest(isHostProperty);

    function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
    }

    var api = {
        version: "1.2.2",
        initialized: false,
        supported: true,

        util: {
            isHostMethod: isHostMethod,
            isHostObject: isHostObject,
            isHostProperty: isHostProperty,
            areHostMethods: areHostMethods,
            areHostObjects: areHostObjects,
            areHostProperties: areHostProperties,
            isTextRange: isTextRange
        },

        features: {},

        modules: {},
        config: {
            alertOnWarn: false,
            preferTextRange: false
        }
    };

    function fail(reason) {
        window.alert("Rangy not supported in your browser. Reason: " + reason);
        api.initialized = true;
        api.supported = false;
    }

    api.fail = fail;

    function warn(msg) {
        var warningMessage = "Rangy warning: " + msg;
        if (api.config.alertOnWarn) {
            window.alert(warningMessage);
        } else if (typeof window.console != UNDEFINED && typeof window.console.log != UNDEFINED) {
            window.console.log(warningMessage);
        }
    }

    api.warn = warn;

    if ({}.hasOwnProperty) {
        api.util.extend = function(o, props) {
            for (var i in props) {
                if (props.hasOwnProperty(i)) {
                    o[i] = props[i];
                }
            }
        };
    } else {
        fail("hasOwnProperty not supported");
    }

    var initListeners = [];
    var moduleInitializers = [];

    // Initialization
    function init() {
        if (api.initialized) {
            return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;

        // First, perform basic feature tests

        if (isHostMethod(document, "createRange")) {
            testRange = document.createRange();
            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
                implementsDomRange = true;
            }
            testRange.detach();
        }

        var body = isHostObject(document, "body") ? document.body : document.getElementsByTagName("body")[0];

        if (body && isHostMethod(body, "createTextRange")) {
            testRange = body.createTextRange();
            if (isTextRange(testRange)) {
                implementsTextRange = true;
            }
        }

        if (!implementsDomRange && !implementsTextRange) {
            fail("Neither Range nor TextRange are implemented");
        }

        api.initialized = true;
        api.features = {
            implementsDomRange: implementsDomRange,
            implementsTextRange: implementsTextRange
        };

        // Initialize modules and call init listeners
        var allListeners = moduleInitializers.concat(initListeners);
        for (var i = 0, len = allListeners.length; i < len; ++i) {
            try {
                allListeners[i](api);
            } catch (ex) {
                if (isHostObject(window, "console") && isHostMethod(window.console, "log")) {
                    window.console.log("Init listener threw an exception. Continuing.", ex);
                }

            }
        }
    }

    // Allow external scripts to initialize this library in case it's loaded after the document has loaded
    api.init = init;

    // Execute listener immediately if already initialized
    api.addInitListener = function(listener) {
        if (api.initialized) {
            listener(api);
        } else {
            initListeners.push(listener);
        }
    };

    var createMissingNativeApiListeners = [];

    api.addCreateMissingNativeApiListener = function(listener) {
        createMissingNativeApiListeners.push(listener);
    };

    function createMissingNativeApi(win) {
        win = win || window;
        init();

        // Notify listeners
        for (var i = 0, len = createMissingNativeApiListeners.length; i < len; ++i) {
            createMissingNativeApiListeners[i](win);
        }
    }

    api.createMissingNativeApi = createMissingNativeApi;

    /**
     * @constructor
     */
    function Module(name) {
        this.name = name;
        this.initialized = false;
        this.supported = false;
    }

    Module.prototype.fail = function(reason) {
        this.initialized = true;
        this.supported = false;

        throw new Error("Module '" + this.name + "' failed to load: " + reason);
    };

    Module.prototype.warn = function(msg) {
        api.warn("Module " + this.name + ": " + msg);
    };

    Module.prototype.createError = function(msg) {
        return new Error("Error in Rangy " + this.name + " module: " + msg);
    };

    api.createModule = function(name, initFunc) {
        var module = new Module(name);
        api.modules[name] = module;

        moduleInitializers.push(function(api) {
            initFunc(api, module);
            module.initialized = true;
            module.supported = true;
        });
    };

    api.requireModules = function(modules) {
        for (var i = 0, len = modules.length, module, moduleName; i < len; ++i) {
            moduleName = modules[i];
            module = api.modules[moduleName];
            if (!module || !(module instanceof Module)) {
                throw new Error("Module '" + moduleName + "' not found");
            }
            if (!module.supported) {
                throw new Error("Module '" + moduleName + "' not supported");
            }
        }
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Wait for document to load before running tests

    var docReady = false;

    var loadHandler = function(e) {

        if (!docReady) {
            docReady = true;
            if (!api.initialized) {
                init();
            }
        }
    };

    // Test whether we have window and document objects that we will need
    if (typeof window == UNDEFINED) {
        fail("No window found");
        return;
    }
    if (typeof document == UNDEFINED) {
        fail("No document found");
        return;
    }

    if (isHostMethod(document, "addEventListener")) {
        document.addEventListener("DOMContentLoaded", loadHandler, false);
    }

    // Add a fallback in case the DOMContentLoaded event isn't supported
    if (isHostMethod(window, "addEventListener")) {
        window.addEventListener("load", loadHandler, false);
    } else if (isHostMethod(window, "attachEvent")) {
        window.attachEvent("onload", loadHandler);
    } else {
        fail("Window does not have required addEventListener or attachEvent method");
    }

    return api;
})();
rangy.createModule("DomUtil", function(api, module) {

    var UNDEF = "undefined";
    var util = api.util;

    // Perform feature tests
    if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
        module.fail("document missing a Node creation method");
    }

    if (!util.isHostMethod(document, "getElementsByTagName")) {
        module.fail("document missing getElementsByTagName method");
    }

    var el = document.createElement("div");
    if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||
            !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {
        module.fail("Incomplete Element implementation");
    }

    // innerHTML is required for Range's createContextualFragment method
    if (!util.isHostProperty(el, "innerHTML")) {
        module.fail("Element is missing innerHTML property");
    }

    var textNode = document.createTextNode("test");
    if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||
            !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) ||
            !util.areHostProperties(textNode, ["data"]))) {
        module.fail("Incomplete Text Node implementation");
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been
    // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that
    // contains just the document as a single element and the value searched for is the document.
    var arrayContains = /*Array.prototype.indexOf ?
        function(arr, val) {
            return arr.indexOf(val) > -1;
        }:*/

        function(arr, val) {
            var i = arr.length;
            while (i--) {
                if (arr[i] === val) {
                    return true;
                }
            }
            return false;
        };

    // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI
    function isHtmlNamespace(node) {
        var ns;
        return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
    }

    function parentElement(node) {
        var parent = node.parentNode;
        return (parent.nodeType == 1) ? parent : null;
    }

    function getNodeIndex(node) {
        var i = 0;
        while( (node = node.previousSibling) ) {
            i++;
        }
        return i;
    }

    function getNodeLength(node) {
        var childNodes;
        return isCharacterDataNode(node) ? node.length : ((childNodes = node.childNodes) ? childNodes.length : 0);
    }

    function getCommonAncestor(node1, node2) {
        var ancestors = [], n;
        for (n = node1; n; n = n.parentNode) {
            ancestors.push(n);
        }

        for (n = node2; n; n = n.parentNode) {
            if (arrayContains(ancestors, n)) {
                return n;
            }
        }

        return null;
    }

    function isAncestorOf(ancestor, descendant, selfIsAncestor) {
        var n = selfIsAncestor ? descendant : descendant.parentNode;
        while (n) {
            if (n === ancestor) {
                return true;
            } else {
                n = n.parentNode;
            }
        }
        return false;
    }

    function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
        var p, n = selfIsAncestor ? node : node.parentNode;
        while (n) {
            p = n.parentNode;
            if (p === ancestor) {
                return n;
            }
            n = p;
        }
        return null;
    }

    function isCharacterDataNode(node) {
        var t = node.nodeType;
        return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment
    }

    function insertAfter(node, precedingNode) {
        var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
        if (nextNode) {
            parent.insertBefore(node, nextNode);
        } else {
            parent.appendChild(node);
        }
        return node;
    }

    // Note that we cannot use splitText() because it is bugridden in IE 9.
    function splitDataNode(node, index) {
        var newNode = node.cloneNode(false);
        newNode.deleteData(0, index);
        node.deleteData(index, node.length - index);
        insertAfter(newNode, node);
        return newNode;
    }

    function getDocument(node) {
        if (node.nodeType == 9) {
            return node;
        } else if (typeof node.ownerDocument != UNDEF) {
            return node.ownerDocument;
        } else if (typeof node.document != UNDEF) {
            return node.document;
        } else if (node.parentNode) {
            return getDocument(node.parentNode);
        } else {
            throw new Error("getDocument: no document found for node");
        }
    }

    function getWindow(node) {
        var doc = getDocument(node);
        if (typeof doc.defaultView != UNDEF) {
            return doc.defaultView;
        } else if (typeof doc.parentWindow != UNDEF) {
            return doc.parentWindow;
        } else {
            throw new Error("Cannot get a window object for node");
        }
    }

    function getIframeDocument(iframeEl) {
        if (typeof iframeEl.contentDocument != UNDEF) {
            return iframeEl.contentDocument;
        } else if (typeof iframeEl.contentWindow != UNDEF) {
            return iframeEl.contentWindow.document;
        } else {
            throw new Error("getIframeWindow: No Document object found for iframe element");
        }
    }

    function getIframeWindow(iframeEl) {
        if (typeof iframeEl.contentWindow != UNDEF) {
            return iframeEl.contentWindow;
        } else if (typeof iframeEl.contentDocument != UNDEF) {
            return iframeEl.contentDocument.defaultView;
        } else {
            throw new Error("getIframeWindow: No Window object found for iframe element");
        }
    }

    function getBody(doc) {
        return util.isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
    }

    function getRootContainer(node) {
        var parent;
        while ( (parent = node.parentNode) ) {
            node = parent;
        }
        return node;
    }

    function comparePoints(nodeA, offsetA, nodeB, offsetB) {
        // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing
        var nodeC, root, childA, childB, n;
        if (nodeA == nodeB) {

            // Case 1: nodes are the same
            return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;
        } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {

            // Case 2: node C (container B or an ancestor) is a child node of A
            return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
        } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {

            // Case 3: node C (container A or an ancestor) is a child node of B
            return getNodeIndex(nodeC) < offsetB  ? -1 : 1;
        } else {

            // Case 4: containers are siblings or descendants of siblings
            root = getCommonAncestor(nodeA, nodeB);
            childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);
            childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);

            if (childA === childB) {
                // This shouldn't be possible

                throw new Error("comparePoints got to case 4 and childA and childB are the same!");
            } else {
                n = root.firstChild;
                while (n) {
                    if (n === childA) {
                        return -1;
                    } else if (n === childB) {
                        return 1;
                    }
                    n = n.nextSibling;
                }
                throw new Error("Should not be here!");
            }
        }
    }

    function fragmentFromNodeChildren(node) {
        var fragment = getDocument(node).createDocumentFragment(), child;
        while ( (child = node.firstChild) ) {
            fragment.appendChild(child);
        }
        return fragment;
    }

    function inspectNode(node) {
        if (!node) {
            return "[No node]";
        }
        if (isCharacterDataNode(node)) {
            return '"' + node.data + '"';
        } else if (node.nodeType == 1) {
            var idAttr = node.id ? ' id="' + node.id + '"' : "";
            return "<" + node.nodeName + idAttr + ">[" + node.childNodes.length + "]";
        } else {
            return node.nodeName;
        }
    }

    /**
     * @constructor
     */
    function NodeIterator(root) {
        this.root = root;
        this._next = root;
    }

    NodeIterator.prototype = {
        _current: null,

        hasNext: function() {
            return !!this._next;
        },

        next: function() {
            var n = this._current = this._next;
            var child, next;
            if (this._current) {
                child = n.firstChild;
                if (child) {
                    this._next = child;
                } else {
                    next = null;
                    while ((n !== this.root) && !(next = n.nextSibling)) {
                        n = n.parentNode;
                    }
                    this._next = next;
                }
            }
            return this._current;
        },

        detach: function() {
            this._current = this._next = this.root = null;
        }
    };

    function createIterator(root) {
        return new NodeIterator(root);
    }

    /**
     * @constructor
     */
    function DomPosition(node, offset) {
        this.node = node;
        this.offset = offset;
    }

    DomPosition.prototype = {
        equals: function(pos) {
            return this.node === pos.node & this.offset == pos.offset;
        },

        inspect: function() {
            return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
        }
    };

    /**
     * @constructor
     */
    function DOMException(codeName) {
        this.code = this[codeName];
        this.codeName = codeName;
        this.message = "DOMException: " + this.codeName;
    }

    DOMException.prototype = {
        INDEX_SIZE_ERR: 1,
        HIERARCHY_REQUEST_ERR: 3,
        WRONG_DOCUMENT_ERR: 4,
        NO_MODIFICATION_ALLOWED_ERR: 7,
        NOT_FOUND_ERR: 8,
        NOT_SUPPORTED_ERR: 9,
        INVALID_STATE_ERR: 11
    };

    DOMException.prototype.toString = function() {
        return this.message;
    };

    api.dom = {
        arrayContains: arrayContains,
        isHtmlNamespace: isHtmlNamespace,
        parentElement: parentElement,
        getNodeIndex: getNodeIndex,
        getNodeLength: getNodeLength,
        getCommonAncestor: getCommonAncestor,
        isAncestorOf: isAncestorOf,
        getClosestAncestorIn: getClosestAncestorIn,
        isCharacterDataNode: isCharacterDataNode,
        insertAfter: insertAfter,
        splitDataNode: splitDataNode,
        getDocument: getDocument,
        getWindow: getWindow,
        getIframeWindow: getIframeWindow,
        getIframeDocument: getIframeDocument,
        getBody: getBody,
        getRootContainer: getRootContainer,
        comparePoints: comparePoints,
        inspectNode: inspectNode,
        fragmentFromNodeChildren: fragmentFromNodeChildren,
        createIterator: createIterator,
        DomPosition: DomPosition
    };

    api.DOMException = DOMException;
});rangy.createModule("DomRange", function(api, module) {
    api.requireModules( ["DomUtil"] );


    var dom = api.dom;
    var DomPosition = dom.DomPosition;
    var DOMException = api.DOMException;
    
    /*----------------------------------------------------------------------------------------------------------------*/

    // Utility functions

    function isNonTextPartiallySelected(node, range) {
        return (node.nodeType != 3) &&
               (dom.isAncestorOf(node, range.startContainer, true) || dom.isAncestorOf(node, range.endContainer, true));
    }

    function getRangeDocument(range) {
        return dom.getDocument(range.startContainer);
    }

    function dispatchEvent(range, type, args) {
        var listeners = range._listeners[type];
        if (listeners) {
            for (var i = 0, len = listeners.length; i < len; ++i) {
                listeners[i].call(range, {target: range, args: args});
            }
        }
    }

    function getBoundaryBeforeNode(node) {
        return new DomPosition(node.parentNode, dom.getNodeIndex(node));
    }

    function getBoundaryAfterNode(node) {
        return new DomPosition(node.parentNode, dom.getNodeIndex(node) + 1);
    }

    function insertNodeAtPosition(node, n, o) {
        var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
        if (dom.isCharacterDataNode(n)) {
            if (o == n.length) {
                dom.insertAfter(node, n);
            } else {
                n.parentNode.insertBefore(node, o == 0 ? n : dom.splitDataNode(n, o));
            }
        } else if (o >= n.childNodes.length) {
            n.appendChild(node);
        } else {
            n.insertBefore(node, n.childNodes[o]);
        }
        return firstNodeInserted;
    }

    function cloneSubtree(iterator) {
        var partiallySelected;
        for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
            partiallySelected = iterator.isPartiallySelectedSubtree();

            node = node.cloneNode(!partiallySelected);
            if (partiallySelected) {
                subIterator = iterator.getSubtreeIterator();
                node.appendChild(cloneSubtree(subIterator));
                subIterator.detach(true);
            }

            if (node.nodeType == 10) { // DocumentType
                throw new DOMException("HIERARCHY_REQUEST_ERR");
            }
            frag.appendChild(node);
        }
        return frag;
    }

    function iterateSubtree(rangeIterator, func, iteratorState) {
        var it, n;
        iteratorState = iteratorState || { stop: false };
        for (var node, subRangeIterator; node = rangeIterator.next(); ) {
            //log.debug("iterateSubtree, partially selected: " + rangeIterator.isPartiallySelectedSubtree(), nodeToString(node));
            if (rangeIterator.isPartiallySelectedSubtree()) {
                // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of the
                // node selected by the Range.
                if (func(node) === false) {
                    iteratorState.stop = true;
                    return;
                } else {
                    subRangeIterator = rangeIterator.getSubtreeIterator();
                    iterateSubtree(subRangeIterator, func, iteratorState);
                    subRangeIterator.detach(true);
                    if (iteratorState.stop) {
                        return;
                    }
                }
            } else {
                // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its
                // descendant
                it = dom.createIterator(node);
                while ( (n = it.next()) ) {
                    if (func(n) === false) {
                        iteratorState.stop = true;
                        return;
                    }
                }
            }
        }
    }

    function deleteSubtree(iterator) {
        var subIterator;
        while (iterator.next()) {
            if (iterator.isPartiallySelectedSubtree()) {
                subIterator = iterator.getSubtreeIterator();
                deleteSubtree(subIterator);
                subIterator.detach(true);
            } else {
                iterator.remove();
            }
        }
    }

    function extractSubtree(iterator) {

        for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {


            if (iterator.isPartiallySelectedSubtree()) {
                node = node.cloneNode(false);
                subIterator = iterator.getSubtreeIterator();
                node.appendChild(extractSubtree(subIterator));
                subIterator.detach(true);
            } else {
                iterator.remove();
            }
            if (node.nodeType == 10) { // DocumentType
                throw new DOMException("HIERARCHY_REQUEST_ERR");
            }
            frag.appendChild(node);
        }
        return frag;
    }

    function getNodesInRange(range, nodeTypes, filter) {
        //log.info("getNodesInRange, " + nodeTypes.join(","));
        var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
        var filterExists = !!filter;
        if (filterNodeTypes) {
            regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
        }

        var nodes = [];
        iterateSubtree(new RangeIterator(range, false), function(node) {
            if ((!filterNodeTypes || regex.test(node.nodeType)) && (!filterExists || filter(node))) {
                nodes.push(node);
            }
        });
        return nodes;
    }

    function inspect(range) {
        var name = (typeof range.getName == "undefined") ? "Range" : range.getName();
        return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +
                dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)

    /**
     * @constructor
     */
    function RangeIterator(range, clonePartiallySelectedTextNodes) {
        this.range = range;
        this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;



        if (!range.collapsed) {
            this.sc = range.startContainer;
            this.so = range.startOffset;
            this.ec = range.endContainer;
            this.eo = range.endOffset;
            var root = range.commonAncestorContainer;

            if (this.sc === this.ec && dom.isCharacterDataNode(this.sc)) {
                this.isSingleCharacterDataNode = true;
                this._first = this._last = this._next = this.sc;
            } else {
                this._first = this._next = (this.sc === root && !dom.isCharacterDataNode(this.sc)) ?
                    this.sc.childNodes[this.so] : dom.getClosestAncestorIn(this.sc, root, true);
                this._last = (this.ec === root && !dom.isCharacterDataNode(this.ec)) ?
                    this.ec.childNodes[this.eo - 1] : dom.getClosestAncestorIn(this.ec, root, true);
            }

        }
    }

    RangeIterator.prototype = {
        _current: null,
        _next: null,
        _first: null,
        _last: null,
        isSingleCharacterDataNode: false,

        reset: function() {
            this._current = null;
            this._next = this._first;
        },

        hasNext: function() {
            return !!this._next;
        },

        next: function() {
            // Move to next node
            var current = this._current = this._next;
            if (current) {
                this._next = (current !== this._last) ? current.nextSibling : null;

                // Check for partially selected text nodes
                if (dom.isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                    if (current === this.ec) {

                        (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                    }
                    if (this._current === this.sc) {

                        (current = current.cloneNode(true)).deleteData(0, this.so);
                    }
                }
            }

            return current;
        },

        remove: function() {
            var current = this._current, start, end;

            if (dom.isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
                start = (current === this.sc) ? this.so : 0;
                end = (current === this.ec) ? this.eo : current.length;
                if (start != end) {
                    current.deleteData(start, end - start);
                }
            } else {
                if (current.parentNode) {
                    current.parentNode.removeChild(current);
                } else {

                }
            }
        },

        // Checks if the current node is partially selected
        isPartiallySelectedSubtree: function() {
            var current = this._current;
            return isNonTextPartiallySelected(current, this.range);
        },

        getSubtreeIterator: function() {
            var subRange;
            if (this.isSingleCharacterDataNode) {
                subRange = this.range.cloneRange();
                subRange.collapse();
            } else {
                subRange = new Range(getRangeDocument(this.range));
                var current = this._current;
                var startContainer = current, startOffset = 0, endContainer = current, endOffset = dom.getNodeLength(current);

                if (dom.isAncestorOf(current, this.sc, true)) {
                    startContainer = this.sc;
                    startOffset = this.so;
                }
                if (dom.isAncestorOf(current, this.ec, true)) {
                    endContainer = this.ec;
                    endOffset = this.eo;
                }

                updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
            }
            return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
        },

        detach: function(detachRange) {
            if (detachRange) {
                this.range.detach();
            }
            this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
        }
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Exceptions

    /**
     * @constructor
     */
    function RangeException(codeName) {
        this.code = this[codeName];
        this.codeName = codeName;
        this.message = "RangeException: " + this.codeName;
    }

    RangeException.prototype = {
        BAD_BOUNDARYPOINTS_ERR: 1,
        INVALID_NODE_TYPE_ERR: 2
    };

    RangeException.prototype.toString = function() {
        return this.message;
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    /**
     * Currently iterates through all nodes in the range on creation until I think of a decent way to do it
     * TODO: Look into making this a proper iterator, not requiring preloading everything first
     * @constructor
     */
    function RangeNodeIterator(range, nodeTypes, filter) {
        this.nodes = getNodesInRange(range, nodeTypes, filter);
        this._next = this.nodes[0];
        this._position = 0;
    }

    RangeNodeIterator.prototype = {
        _current: null,

        hasNext: function() {
            return !!this._next;
        },

        next: function() {
            this._current = this._next;
            this._next = this.nodes[ ++this._position ];
            return this._current;
        },

        detach: function() {
            this._current = this._next = this.nodes = null;
        }
    };

    var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
    var rootContainerNodeTypes = [2, 9, 11];
    var readonlyNodeTypes = [5, 6, 10, 12];
    var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
    var surroundNodeTypes = [1, 3, 4, 5, 7, 8];

    function createAncestorFinder(nodeTypes) {
        return function(node, selfIsAncestor) {
            var t, n = selfIsAncestor ? node : node.parentNode;
            while (n) {
                t = n.nodeType;
                if (dom.arrayContains(nodeTypes, t)) {
                    return n;
                }
                n = n.parentNode;
            }
            return null;
        };
    }

    var getRootContainer = dom.getRootContainer;
    var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );
    var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
    var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );

    function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
        if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
            throw new RangeException("INVALID_NODE_TYPE_ERR");
        }
    }

    function assertNotDetached(range) {
        if (!range.startContainer) {
            throw new DOMException("INVALID_STATE_ERR");
        }
    }

    function assertValidNodeType(node, invalidTypes) {
        if (!dom.arrayContains(invalidTypes, node.nodeType)) {
            throw new RangeException("INVALID_NODE_TYPE_ERR");
        }
    }

    function assertValidOffset(node, offset) {
        if (offset < 0 || offset > (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
            throw new DOMException("INDEX_SIZE_ERR");
        }
    }

    function assertSameDocumentOrFragment(node1, node2) {
        if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
            throw new DOMException("WRONG_DOCUMENT_ERR");
        }
    }

    function assertNodeNotReadOnly(node) {
        if (getReadonlyAncestor(node, true)) {
            throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");
        }
    }

    function assertNode(node, codeName) {
        if (!node) {
            throw new DOMException(codeName);
        }
    }

    function isOrphan(node) {
        return !dom.arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);
    }

    function isValidOffset(node, offset) {
        return offset <= (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length);
    }

    function assertRangeValid(range) {
        assertNotDetached(range);
        if (isOrphan(range.startContainer) || isOrphan(range.endContainer) ||
                !isValidOffset(range.startContainer, range.startOffset) ||
                !isValidOffset(range.endContainer, range.endOffset)) {
            throw new Error("Range error: Range is no longer valid after DOM mutation (" + range.inspect() + ")");
        }
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    // Test the browser's innerHTML support to decide how to implement createContextualFragment
    var styleEl = document.createElement("style");
    var htmlParsingConforms = false;
    try {
        styleEl.innerHTML = "<b>x</b>";
        htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node
    } catch (e) {
        // IE 6 and 7 throw
    }

    api.features.htmlParsingConforms = htmlParsingConforms;

    var createContextualFragment = htmlParsingConforms ?

        // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
        // discussion and base code for this implementation at issue 67.
        // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
        // Thanks to Aleks Williams.
        function(fragmentStr) {
            // "Let node the context object's start's node."
            var node = this.startContainer;
            var doc = dom.getDocument(node);

            // "If the context object's start's node is null, raise an INVALID_STATE_ERR
            // exception and abort these steps."
            if (!node) {
                throw new DOMException("INVALID_STATE_ERR");
            }

            // "Let element be as follows, depending on node's interface:"
            // Document, Document Fragment: null
            var el = null;

            // "Element: node"
            if (node.nodeType == 1) {
                el = node;

            // "Text, Comment: node's parentElement"
            } else if (dom.isCharacterDataNode(node)) {
                el = dom.parentElement(node);
            }

            // "If either element is null or element's ownerDocument is an HTML document
            // and element's local name is "html" and element's namespace is the HTML
            // namespace"
            if (el === null || (
                el.nodeName == "HTML"
                && dom.isHtmlNamespace(dom.getDocument(el).documentElement)
                && dom.isHtmlNamespace(el)
            )) {

            // "let element be a new Element with "body" as its local name and the HTML
            // namespace as its namespace.""
                el = doc.createElement("body");
            } else {
                el = el.cloneNode(false);
            }

            // "If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm."
            // "If the node's document is an XML document: Invoke the XML fragment parsing algorithm."
            // "In either case, the algorithm must be invoked with fragment as the input
            // and element as the context element."
            el.innerHTML = fragmentStr;

            // "If this raises an exception, then abort these steps. Otherwise, let new
            // children be the nodes returned."

            // "Let fragment be a new DocumentFragment."
            // "Append all new children to fragment."
            // "Return fragment."
            return dom.fragmentFromNodeChildren(el);
        } :

        // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
        // previous versions of Rangy used (with the exception of using a body element rather than a div)
        function(fragmentStr) {
            assertNotDetached(this);
            var doc = getRangeDocument(this);
            var el = doc.createElement("body");
            el.innerHTML = fragmentStr;

            return dom.fragmentFromNodeChildren(el);
        };

    /*----------------------------------------------------------------------------------------------------------------*/

    var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",
        "commonAncestorContainer"];

    var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
    var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;

    function RangePrototype() {}

    RangePrototype.prototype = {
        attachListener: function(type, listener) {
            this._listeners[type].push(listener);
        },

        compareBoundaryPoints: function(how, range) {
            assertRangeValid(this);
            assertSameDocumentOrFragment(this.startContainer, range.startContainer);

            var nodeA, offsetA, nodeB, offsetB;
            var prefixA = (how == e2s || how == s2s) ? "start" : "end";
            var prefixB = (how == s2e || how == s2s) ? "start" : "end";
            nodeA = this[prefixA + "Container"];
            offsetA = this[prefixA + "Offset"];
            nodeB = range[prefixB + "Container"];
            offsetB = range[prefixB + "Offset"];
            return dom.comparePoints(nodeA, offsetA, nodeB, offsetB);
        },

        insertNode: function(node) {
            assertRangeValid(this);
            assertValidNodeType(node, insertableNodeTypes);
            assertNodeNotReadOnly(this.startContainer);

            if (dom.isAncestorOf(node, this.startContainer, true)) {
                throw new DOMException("HIERARCHY_REQUEST_ERR");
            }

            // No check for whether the container of the start of the Range is of a type that does not allow
            // children of the type of node: the browser's DOM implementation should do this for us when we attempt
            // to add the node

            var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
            this.setStartBefore(firstNodeInserted);
        },

        cloneContents: function() {
            assertRangeValid(this);

            var clone, frag;
            if (this.collapsed) {
                return getRangeDocument(this).createDocumentFragment();
            } else {
                if (this.startContainer === this.endContainer && dom.isCharacterDataNode(this.startContainer)) {
                    clone = this.startContainer.cloneNode(true);
                    clone.data = clone.data.slice(this.startOffset, this.endOffset);
                    frag = getRangeDocument(this).createDocumentFragment();
                    frag.appendChild(clone);
                    return frag;
                } else {
                    var iterator = new RangeIterator(this, true);
                    clone = cloneSubtree(iterator);
                    iterator.detach();
                }
                return clone;
            }
        },

        canSurroundContents: function() {
            assertRangeValid(this);
            assertNodeNotReadOnly(this.startContainer);
            assertNodeNotReadOnly(this.endContainer);

            // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
            // no non-text nodes.
            var iterator = new RangeIterator(this, true);
            var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
                    (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
            iterator.detach();
            return !boundariesInvalid;
        },

        surroundContents: function(node) {
            assertValidNodeType(node, surroundNodeTypes);

            if (!this.canSurroundContents()) {
                throw new RangeException("BAD_BOUNDARYPOINTS_ERR");
            }

            // Extract the contents
            var content = this.extractContents();

            // Clear the children of the node
            if (node.hasChildNodes()) {
                while (node.lastChild) {
                    node.removeChild(node.lastChild);
                }
            }

            // Insert the new node and add the extracted contents
            insertNodeAtPosition(node, this.startContainer, this.startOffset);
            node.appendChild(content);

            this.selectNode(node);
        },

        cloneRange: function() {
            assertRangeValid(this);
            var range = new Range(getRangeDocument(this));
            var i = rangeProperties.length, prop;
            while (i--) {
                prop = rangeProperties[i];
                range[prop] = this[prop];
            }
            return range;
        },

        toString: function() {
            assertRangeValid(this);
            var sc = this.startContainer;
            if (sc === this.endContainer && dom.isCharacterDataNode(sc)) {
                return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";
            } else {
                var textBits = [], iterator = new RangeIterator(this, true);

                iterateSubtree(iterator, function(node) {
                    // Accept only text or CDATA nodes, not comments

                    if (node.nodeType == 3 || node.nodeType == 4) {
                        textBits.push(node.data);
                    }
                });
                iterator.detach();
                return textBits.join("");
            }
        },

        // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
        // been removed from Mozilla.

        compareNode: function(node) {
            assertRangeValid(this);

            var parent = node.parentNode;
            var nodeIndex = dom.getNodeIndex(node);

            if (!parent) {
                throw new DOMException("NOT_FOUND_ERR");
            }

            var startComparison = this.comparePoint(parent, nodeIndex),
                endComparison = this.comparePoint(parent, nodeIndex + 1);

            if (startComparison < 0) { // Node starts before
                return (endComparison > 0) ? n_b_a : n_b;
            } else {
                return (endComparison > 0) ? n_a : n_i;
            }
        },

        comparePoint: function(node, offset) {
            assertRangeValid(this);
            assertNode(node, "HIERARCHY_REQUEST_ERR");
            assertSameDocumentOrFragment(node, this.startContainer);

            if (dom.comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
                return -1;
            } else if (dom.comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
                return 1;
            }
            return 0;
        },

        createContextualFragment: createContextualFragment,

        toHtml: function() {
            assertRangeValid(this);
            var container = getRangeDocument(this).createElement("div");
            container.appendChild(this.cloneContents());
            return container.innerHTML;
        },

        // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
        // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
        intersectsNode: function(node, touchingIsIntersecting) {
            assertRangeValid(this);
            assertNode(node, "NOT_FOUND_ERR");
            if (dom.getDocument(node) !== getRangeDocument(this)) {
                return false;
            }

            var parent = node.parentNode, offset = dom.getNodeIndex(node);
            assertNode(parent, "NOT_FOUND_ERR");

            var startComparison = dom.comparePoints(parent, offset, this.endContainer, this.endOffset),
                endComparison = dom.comparePoints(parent, offset + 1, this.startContainer, this.startOffset);

            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        },


        isPointInRange: function(node, offset) {
            assertRangeValid(this);
            assertNode(node, "HIERARCHY_REQUEST_ERR");
            assertSameDocumentOrFragment(node, this.startContainer);

            return (dom.comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&
                   (dom.comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);
        },

        // The methods below are non-standard and invented by me.

        // Sharing a boundary start-to-end or end-to-start does not count as intersection.
        intersectsRange: function(range, touchingIsIntersecting) {
            assertRangeValid(this);

            if (getRangeDocument(range) != getRangeDocument(this)) {
                throw new DOMException("WRONG_DOCUMENT_ERR");
            }

            var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.endContainer, range.endOffset),
                endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.startContainer, range.startOffset);

            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        },

        intersection: function(range) {
            if (this.intersectsRange(range)) {
                var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),
                    endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);

                var intersectionRange = this.cloneRange();

                if (startComparison == -1) {
                    intersectionRange.setStart(range.startContainer, range.startOffset);
                }
                if (endComparison == 1) {
                    intersectionRange.setEnd(range.endContainer, range.endOffset);
                }
                return intersectionRange;
            }
            return null;
        },

        union: function(range) {
            if (this.intersectsRange(range, true)) {
                var unionRange = this.cloneRange();
                if (dom.comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                    unionRange.setStart(range.startContainer, range.startOffset);
                }
                if (dom.comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                    unionRange.setEnd(range.endContainer, range.endOffset);
                }
                return unionRange;
            } else {
                throw new RangeException("Ranges do not intersect");
            }
        },

        containsNode: function(node, allowPartial) {
            if (allowPartial) {
                return this.intersectsNode(node, false);
            } else {
                return this.compareNode(node) == n_i;
            }
        },

        containsNodeContents: function(node) {
            return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, dom.getNodeLength(node)) <= 0;
        },

        containsRange: function(range) {
            return this.intersection(range).equals(range);
        },

        containsNodeText: function(node) {
            var nodeRange = this.cloneRange();
            nodeRange.selectNode(node);
            var textNodes = nodeRange.getNodes([3]);
            if (textNodes.length > 0) {
                nodeRange.setStart(textNodes[0], 0);
                var lastTextNode = textNodes.pop();
                nodeRange.setEnd(lastTextNode, lastTextNode.length);
                var contains = this.containsRange(nodeRange);
                nodeRange.detach();
                return contains;
            } else {
                return this.containsNodeContents(node);
            }
        },

        createNodeIterator: function(nodeTypes, filter) {
            assertRangeValid(this);
            return new RangeNodeIterator(this, nodeTypes, filter);
        },

        getNodes: function(nodeTypes, filter) {
            assertRangeValid(this);
            return getNodesInRange(this, nodeTypes, filter);
        },

        getDocument: function() {
            return getRangeDocument(this);
        },

        collapseBefore: function(node) {
            assertNotDetached(this);

            this.setEndBefore(node);
            this.collapse(false);
        },

        collapseAfter: function(node) {
            assertNotDetached(this);

            this.setStartAfter(node);
            this.collapse(true);
        },

        getName: function() {
            return "DomRange";
        },

        equals: function(range) {
            return Range.rangesEqual(this, range);
        },

        inspect: function() {
            return inspect(this);
        }
    };

    function copyComparisonConstantsToObject(obj) {
        obj.START_TO_START = s2s;
        obj.START_TO_END = s2e;
        obj.END_TO_END = e2e;
        obj.END_TO_START = e2s;

        obj.NODE_BEFORE = n_b;
        obj.NODE_AFTER = n_a;
        obj.NODE_BEFORE_AND_AFTER = n_b_a;
        obj.NODE_INSIDE = n_i;
    }

    function copyComparisonConstants(constructor) {
        copyComparisonConstantsToObject(constructor);
        copyComparisonConstantsToObject(constructor.prototype);
    }

    function createRangeContentRemover(remover, boundaryUpdater) {
        return function() {
            assertRangeValid(this);

            var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;

            var iterator = new RangeIterator(this, true);

            // Work out where to position the range after content removal
            var node, boundary;
            if (sc !== root) {
                node = dom.getClosestAncestorIn(sc, root, true);
                boundary = getBoundaryAfterNode(node);
                sc = boundary.node;
                so = boundary.offset;
            }

            // Check none of the range is read-only
            iterateSubtree(iterator, assertNodeNotReadOnly);

            iterator.reset();

            // Remove the content
            var returnValue = remover(iterator);
            iterator.detach();

            // Move to the new position
            boundaryUpdater(this, sc, so, sc, so);

            return returnValue;
        };
    }

    function createPrototypeRange(constructor, boundaryUpdater, detacher) {
        function createBeforeAfterNodeSetter(isBefore, isStart) {
            return function(node) {
                assertNotDetached(this);
                assertValidNodeType(node, beforeAfterNodeTypes);
                assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);

                var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
                (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
            };
        }

        function setRangeStart(range, node, offset) {
            var ec = range.endContainer, eo = range.endOffset;
            if (node !== range.startContainer || offset !== range.startOffset) {
                // Check the root containers of the range and the new boundary, and also check whether the new boundary
                // is after the current end. In either case, collapse the range to the new position
                if (getRootContainer(node) != getRootContainer(ec) || dom.comparePoints(node, offset, ec, eo) == 1) {
                    ec = node;
                    eo = offset;
                }
                boundaryUpdater(range, node, offset, ec, eo);
            }
        }

        function setRangeEnd(range, node, offset) {
            var sc = range.startContainer, so = range.startOffset;
            if (node !== range.endContainer || offset !== range.endOffset) {
                // Check the root containers of the range and the new boundary, and also check whether the new boundary
                // is after the current end. In either case, collapse the range to the new position
                if (getRootContainer(node) != getRootContainer(sc) || dom.comparePoints(node, offset, sc, so) == -1) {
                    sc = node;
                    so = offset;
                }
                boundaryUpdater(range, sc, so, node, offset);
            }
        }

        function setRangeStartAndEnd(range, node, offset) {
            if (node !== range.startContainer || offset !== range.startOffset || node !== range.endContainer || offset !== range.endOffset) {
                boundaryUpdater(range, node, offset, node, offset);
            }
        }

        constructor.prototype = new RangePrototype();

        api.util.extend(constructor.prototype, {
            setStart: function(node, offset) {
                assertNotDetached(this);
                assertNoDocTypeNotationEntityAncestor(node, true);
                assertValidOffset(node, offset);

                setRangeStart(this, node, offset);
            },

            setEnd: function(node, offset) {
                assertNotDetached(this);
                assertNoDocTypeNotationEntityAncestor(node, true);
                assertValidOffset(node, offset);

                setRangeEnd(this, node, offset);
            },

            setStartBefore: createBeforeAfterNodeSetter(true, true),
            setStartAfter: createBeforeAfterNodeSetter(false, true),
            setEndBefore: createBeforeAfterNodeSetter(true, false),
            setEndAfter: createBeforeAfterNodeSetter(false, false),

            collapse: function(isStart) {
                assertRangeValid(this);
                if (isStart) {
                    boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
                } else {
                    boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
                }
            },

            selectNodeContents: function(node) {
                // This doesn't seem well specified: the spec talks only about selecting the node's contents, which
                // could be taken to mean only its children. However, browsers implement this the same as selectNode for
                // text nodes, so I shall do likewise
                assertNotDetached(this);
                assertNoDocTypeNotationEntityAncestor(node, true);

                boundaryUpdater(this, node, 0, node, dom.getNodeLength(node));
            },

            selectNode: function(node) {
                assertNotDetached(this);
                assertNoDocTypeNotationEntityAncestor(node, false);
                assertValidNodeType(node, beforeAfterNodeTypes);

                var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
                boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
            },

            extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),

            deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),

            canSurroundContents: function() {
                assertRangeValid(this);
                assertNodeNotReadOnly(this.startContainer);
                assertNodeNotReadOnly(this.endContainer);

                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
                // no non-text nodes.
                var iterator = new RangeIterator(this, true);
                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||
                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));
                iterator.detach();
                return !boundariesInvalid;
            },

            detach: function() {
                detacher(this);
            },

            splitBoundaries: function() {
                assertRangeValid(this);


                var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;
                var startEndSame = (sc === ec);

                if (dom.isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
                    dom.splitDataNode(ec, eo);

                }

                if (dom.isCharacterDataNode(sc) && so > 0 && so < sc.length) {

                    sc = dom.splitDataNode(sc, so);
                    if (startEndSame) {
                        eo -= so;
                        ec = sc;
                    } else if (ec == sc.parentNode && eo >= dom.getNodeIndex(sc)) {
                        eo++;
                    }
                    so = 0;

                }
                boundaryUpdater(this, sc, so, ec, eo);
            },

            normalizeBoundaries: function() {
                assertRangeValid(this);

                var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;

                var mergeForward = function(node) {
                    var sibling = node.nextSibling;
                    if (sibling && sibling.nodeType == node.nodeType) {
                        ec = node;
                        eo = node.length;
                        node.appendData(sibling.data);
                        sibling.parentNode.removeChild(sibling);
                    }
                };

                var mergeBackward = function(node) {
                    var sibling = node.previousSibling;
                    if (sibling && sibling.nodeType == node.nodeType) {
                        sc = node;
                        var nodeLength = node.length;
                        so = sibling.length;
                        node.insertData(0, sibling.data);
                        sibling.parentNode.removeChild(sibling);
                        if (sc == ec) {
                            eo += so;
                            ec = sc;
                        } else if (ec == node.parentNode) {
                            var nodeIndex = dom.getNodeIndex(node);
                            if (eo == nodeIndex) {
                                ec = node;
                                eo = nodeLength;
                            } else if (eo > nodeIndex) {
                                eo--;
                            }
                        }
                    }
                };

                var normalizeStart = true;

                if (dom.isCharacterDataNode(ec)) {
                    if (ec.length == eo) {
                        mergeForward(ec);
                    }
                } else {
                    if (eo > 0) {
                        var endNode = ec.childNodes[eo - 1];
                        if (endNode && dom.isCharacterDataNode(endNode)) {
                            mergeForward(endNode);
                        }
                    }
                    normalizeStart = !this.collapsed;
                }

                if (normalizeStart) {
                    if (dom.isCharacterDataNode(sc)) {
                        if (so == 0) {
                            mergeBackward(sc);
                        }
                    } else {
                        if (so < sc.childNodes.length) {
                            var startNode = sc.childNodes[so];
                            if (startNode && dom.isCharacterDataNode(startNode)) {
                                mergeBackward(startNode);
                            }
                        }
                    }
                } else {
                    sc = ec;
                    so = eo;
                }

                boundaryUpdater(this, sc, so, ec, eo);
            },

            collapseToPoint: function(node, offset) {
                assertNotDetached(this);

                assertNoDocTypeNotationEntityAncestor(node, true);
                assertValidOffset(node, offset);

                setRangeStartAndEnd(this, node, offset);
            }
        });

        copyComparisonConstants(constructor);
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    // Updates commonAncestorContainer and collapsed after boundary change
    function updateCollapsedAndCommonAncestor(range) {
        range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);
        range.commonAncestorContainer = range.collapsed ?
            range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
    }

    function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
        var startMoved = (range.startContainer !== startContainer || range.startOffset !== startOffset);
        var endMoved = (range.endContainer !== endContainer || range.endOffset !== endOffset);

        range.startContainer = startContainer;
        range.startOffset = startOffset;
        range.endContainer = endContainer;
        range.endOffset = endOffset;

        updateCollapsedAndCommonAncestor(range);
        dispatchEvent(range, "boundarychange", {startMoved: startMoved, endMoved: endMoved});
    }

    function detach(range) {
        assertNotDetached(range);
        range.startContainer = range.startOffset = range.endContainer = range.endOffset = null;
        range.collapsed = range.commonAncestorContainer = null;
        dispatchEvent(range, "detach", null);
        range._listeners = null;
    }

    /**
     * @constructor
     */
    function Range(doc) {
        this.startContainer = doc;
        this.startOffset = 0;
        this.endContainer = doc;
        this.endOffset = 0;
        this._listeners = {
            boundarychange: [],
            detach: []
        };
        updateCollapsedAndCommonAncestor(this);
    }

    createPrototypeRange(Range, updateBoundaries, detach);

    api.rangePrototype = RangePrototype.prototype;

    Range.rangeProperties = rangeProperties;
    Range.RangeIterator = RangeIterator;
    Range.copyComparisonConstants = copyComparisonConstants;
    Range.createPrototypeRange = createPrototypeRange;
    Range.inspect = inspect;
    Range.getRangeDocument = getRangeDocument;
    Range.rangesEqual = function(r1, r2) {
        return r1.startContainer === r2.startContainer &&
               r1.startOffset === r2.startOffset &&
               r1.endContainer === r2.endContainer &&
               r1.endOffset === r2.endOffset;
    };

    api.DomRange = Range;
    api.RangeException = RangeException;
});rangy.createModule("WrappedRange", function(api, module) {
    api.requireModules( ["DomUtil", "DomRange"] );

    /**
     * @constructor
     */
    var WrappedRange;
    var dom = api.dom;
    var DomPosition = dom.DomPosition;
    var DomRange = api.DomRange;



    /*----------------------------------------------------------------------------------------------------------------*/

    /*
    This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
    method. For example, in the following (where pipes denote the selection boundaries):

    <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>

    var range = document.selection.createRange();
    alert(range.parentElement().id); // Should alert "ul" but alerts "b"

    This method returns the common ancestor node of the following:
    - the parentElement() of the textRange
    - the parentElement() of the textRange after calling collapse(true)
    - the parentElement() of the textRange after calling collapse(false)
     */
    function getTextRangeContainerElement(textRange) {
        var parentEl = textRange.parentElement();

        var range = textRange.duplicate();
        range.collapse(true);
        var startEl = range.parentElement();
        range = textRange.duplicate();
        range.collapse(false);
        var endEl = range.parentElement();
        var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);

        return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
    }

    function textRangeIsCollapsed(textRange) {
        return textRange.compareEndPoints("StartToEnd", textRange) == 0;
    }

    // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started out as
    // an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/) but has
    // grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange bugs, handling
    // for inputs and images, plus optimizations.
    function getTextRangeBoundaryPosition(textRange, wholeRangeContainerElement, isStart, isCollapsed) {
        var workingRange = textRange.duplicate();

        workingRange.collapse(isStart);
        var containerElement = workingRange.parentElement();

        // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so
        // check for that
        // TODO: Find out when. Workaround for wholeRangeContainerElement may break this
        if (!dom.isAncestorOf(wholeRangeContainerElement, containerElement, true)) {
            containerElement = wholeRangeContainerElement;

        }



        // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and
        // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx
        if (!containerElement.canHaveHTML) {
            return new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
        }

        var workingNode = dom.getDocument(containerElement).createElement("span");
        var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
        var previousNode, nextNode, boundaryPosition, boundaryNode;

        // Move the working range through the container's children, starting at the end and working backwards, until the
        // working range reaches or goes past the boundary we're interested in
        do {
            containerElement.insertBefore(workingNode, workingNode.previousSibling);
            workingRange.moveToElementText(workingNode);
        } while ( (comparison = workingRange.compareEndPoints(workingComparisonType, textRange)) > 0 &&
                workingNode.previousSibling);

        // We've now reached or gone past the boundary of the text range we're interested in
        // so have identified the node we want
        boundaryNode = workingNode.nextSibling;

        if (comparison == -1 && boundaryNode && dom.isCharacterDataNode(boundaryNode)) {
            // This is a character data node (text, comment, cdata). The working range is collapsed at the start of the
            // node containing the text range's boundary, so we move the end of the working range to the boundary point
            // and measure the length of its text to get the boundary's offset within the node.
            workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);


            var offset;

            if (/[\r\n]/.test(boundaryNode.data)) {
                /*
                For the particular case of a boundary within a text node containing line breaks (within a <pre> element,
                for example), we need a slightly complicated approach to get the boundary's offset in IE. The facts:

                - Each line break is represented as \r in the text node's data/nodeValue properties
                - Each line break is represented as \r\n in the TextRange's 'text' property
                - The 'text' property of the TextRange does not contain trailing line breaks

                To get round the problem presented by the final fact above, we can use the fact that TextRange's
                moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily
                the same as the number of characters it was instructed to move. The simplest approach is to use this to
                store the characters moved when moving both the start and end of the range to the start of the document
                body and subtracting the start offset from the end offset (the "move-negative-gazillion" method).
                However, this is extremely slow when the document is large and the range is near the end of it. Clearly
                doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same
                problem.

                Another approach that works is to use moveStart() to move the start boundary of the range up to the end
                boundary one character at a time and incrementing a counter with the value returned by the moveStart()
                call. However, the check for whether the start boundary has reached the end boundary is expensive, so
                this method is slow (although unlike "move-negative-gazillion" is largely unaffected by the location of
                the range within the document).

                The method below is a hybrid of the two methods above. It uses the fact that a string containing the
                TextRange's 'text' property with each \r\n converted to a single \r character cannot be longer than the
                text of the TextRange, so the start of the range is moved that length initially and then a character at
                a time to make up for any trailing line breaks not contained in the 'text' property. This has good
                performance in most situations compared to the previous two methods.
                */
                var tempRange = workingRange.duplicate();
                var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;

                offset = tempRange.moveStart("character", rangeLength);
                while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                    offset++;
                    tempRange.moveStart("character", 1);
                }
            } else {
                offset = workingRange.text.length;
            }
            boundaryPosition = new DomPosition(boundaryNode, offset);
        } else {


            // If the boundary immediately follows a character data node and this is the end boundary, we should favour
            // a position within that, and likewise for a start boundary preceding a character data node
            previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
            nextNode = (isCollapsed || isStart) && workingNode.nextSibling;



            if (nextNode && dom.isCharacterDataNode(nextNode)) {
                boundaryPosition = new DomPosition(nextNode, 0);
            } else if (previousNode && dom.isCharacterDataNode(previousNode)) {
                boundaryPosition = new DomPosition(previousNode, previousNode.length);
            } else {
                boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
            }
        }

        // Clean up
        workingNode.parentNode.removeChild(workingNode);

        return boundaryPosition;
    }

    // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that node.
    // This function started out as an optimized version of code found in Tim Cameron Ryan's IERange
    // (http://code.google.com/p/ierange/)
    function createBoundaryTextRange(boundaryPosition, isStart) {
        var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
        var doc = dom.getDocument(boundaryPosition.node);
        var workingNode, childNodes, workingRange = doc.body.createTextRange();
        var nodeIsDataNode = dom.isCharacterDataNode(boundaryPosition.node);

        if (nodeIsDataNode) {
            boundaryNode = boundaryPosition.node;
            boundaryParent = boundaryNode.parentNode;
        } else {
            childNodes = boundaryPosition.node.childNodes;
            boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;
            boundaryParent = boundaryPosition.node;
        }

        // Position the range immediately before the node containing the boundary
        workingNode = doc.createElement("span");

        // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within the
        // element rather than immediately before or after it, which is what we want
        workingNode.innerHTML = "&#feff;";

        // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report
        // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12
        if (boundaryNode) {
            boundaryParent.insertBefore(workingNode, boundaryNode);
        } else {
            boundaryParent.appendChild(workingNode);
        }

        workingRange.moveToElementText(workingNode);
        workingRange.collapse(!isStart);

        // Clean up
        boundaryParent.removeChild(workingNode);

        // Move the working range to the text offset, if required
        if (nodeIsDataNode) {
            workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
        }

        return workingRange;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    if (api.features.implementsDomRange && (!api.features.implementsTextRange || !api.config.preferTextRange)) {
        // This is a wrapper around the browser's native DOM Range. It has two aims:
        // - Provide workarounds for specific browser bugs
        // - provide convenient extensions, which are inherited from Rangy's DomRange

        (function() {
            var rangeProto;
            var rangeProperties = DomRange.rangeProperties;
            var canSetRangeStartAfterEnd;

            function updateRangeProperties(range) {
                var i = rangeProperties.length, prop;
                while (i--) {
                    prop = rangeProperties[i];
                    range[prop] = range.nativeRange[prop];
                }
            }

            function updateNativeRange(range, startContainer, startOffset, endContainer,endOffset) {
                var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);
                var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);

                // Always set both boundaries for the benefit of IE9 (see issue 35)
                if (startMoved || endMoved) {
                    range.setEnd(endContainer, endOffset);
                    range.setStart(startContainer, startOffset);
                }
            }

            function detach(range) {
                range.nativeRange.detach();
                range.detached = true;
                var i = rangeProperties.length, prop;
                while (i--) {
                    prop = rangeProperties[i];
                    range[prop] = null;
                }
            }

            var createBeforeAfterNodeSetter;

            WrappedRange = function(range) {
                if (!range) {
                    throw new Error("Range must be specified");
                }
                this.nativeRange = range;
                updateRangeProperties(this);
            };

            DomRange.createPrototypeRange(WrappedRange, updateNativeRange, detach);

            rangeProto = WrappedRange.prototype;

            rangeProto.selectNode = function(node) {
                this.nativeRange.selectNode(node);
                updateRangeProperties(this);
            };

            rangeProto.deleteContents = function() {
                this.nativeRange.deleteContents();
                updateRangeProperties(this);
            };

            rangeProto.extractContents = function() {
                var frag = this.nativeRange.extractContents();
                updateRangeProperties(this);
                return frag;
            };

            rangeProto.cloneContents = function() {
                return this.nativeRange.cloneContents();
            };

            // TODO: Until I can find a way to programmatically trigger the Firefox bug (apparently long-standing, still
            // present in 3.6.8) that throws "Index or size is negative or greater than the allowed amount" for
            // insertNode in some circumstances, all browsers will have to use the Rangy's own implementation of
            // insertNode, which works but is almost certainly slower than the native implementation.
/*
            rangeProto.insertNode = function(node) {
                this.nativeRange.insertNode(node);
                updateRangeProperties(this);
            };
*/

            rangeProto.surroundContents = function(node) {
                this.nativeRange.surroundContents(node);
                updateRangeProperties(this);
            };

            rangeProto.collapse = function(isStart) {
                this.nativeRange.collapse(isStart);
                updateRangeProperties(this);
            };

            rangeProto.cloneRange = function() {
                return new WrappedRange(this.nativeRange.cloneRange());
            };

            rangeProto.refresh = function() {
                updateRangeProperties(this);
            };

            rangeProto.toString = function() {
                return this.nativeRange.toString();
            };

            // Create test range and node for feature detection

            var testTextNode = document.createTextNode("test");
            dom.getBody(document).appendChild(testTextNode);
            var range = document.createRange();

            /*--------------------------------------------------------------------------------------------------------*/

            // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and
            // correct for it

            range.setStart(testTextNode, 0);
            range.setEnd(testTextNode, 0);

            try {
                range.setStart(testTextNode, 1);
                canSetRangeStartAfterEnd = true;

                rangeProto.setStart = function(node, offset) {
                    this.nativeRange.setStart(node, offset);
                    updateRangeProperties(this);
                };

                rangeProto.setEnd = function(node, offset) {
                    this.nativeRange.setEnd(node, offset);
                    updateRangeProperties(this);
                };

                createBeforeAfterNodeSetter = function(name) {
                    return function(node) {
                        this.nativeRange[name](node);
                        updateRangeProperties(this);
                    };
                };

            } catch(ex) {


                canSetRangeStartAfterEnd = false;

                rangeProto.setStart = function(node, offset) {
                    try {
                        this.nativeRange.setStart(node, offset);
                    } catch (ex) {
                        this.nativeRange.setEnd(node, offset);
                        this.nativeRange.setStart(node, offset);
                    }
                    updateRangeProperties(this);
                };

                rangeProto.setEnd = function(node, offset) {
                    try {
                        this.nativeRange.setEnd(node, offset);
                    } catch (ex) {
                        this.nativeRange.setStart(node, offset);
                        this.nativeRange.setEnd(node, offset);
                    }
                    updateRangeProperties(this);
                };

                createBeforeAfterNodeSetter = function(name, oppositeName) {
                    return function(node) {
                        try {
                            this.nativeRange[name](node);
                        } catch (ex) {
                            this.nativeRange[oppositeName](node);
                            this.nativeRange[name](node);
                        }
                        updateRangeProperties(this);
                    };
                };
            }

            rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
            rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
            rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
            rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");

            /*--------------------------------------------------------------------------------------------------------*/

            // Test for and correct Firefox 2 behaviour with selectNodeContents on text nodes: it collapses the range to
            // the 0th character of the text node
            range.selectNodeContents(testTextNode);
            if (range.startContainer == testTextNode && range.endContainer == testTextNode &&
                    range.startOffset == 0 && range.endOffset == testTextNode.length) {
                rangeProto.selectNodeContents = function(node) {
                    this.nativeRange.selectNodeContents(node);
                    updateRangeProperties(this);
                };
            } else {
                rangeProto.selectNodeContents = function(node) {
                    this.setStart(node, 0);
                    this.setEnd(node, DomRange.getEndOffset(node));
                };
            }

            /*--------------------------------------------------------------------------------------------------------*/

            // Test for WebKit bug that has the beahviour of compareBoundaryPoints round the wrong way for constants
            // START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738

            range.selectNodeContents(testTextNode);
            range.setEnd(testTextNode, 3);

            var range2 = document.createRange();
            range2.selectNodeContents(testTextNode);
            range2.setEnd(testTextNode, 4);
            range2.setStart(testTextNode, 2);

            if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &
                    range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
                // This is the wrong way round, so correct for it


                rangeProto.compareBoundaryPoints = function(type, range) {
                    range = range.nativeRange || range;
                    if (type == range.START_TO_END) {
                        type = range.END_TO_START;
                    } else if (type == range.END_TO_START) {
                        type = range.START_TO_END;
                    }
                    return this.nativeRange.compareBoundaryPoints(type, range);
                };
            } else {
                rangeProto.compareBoundaryPoints = function(type, range) {
                    return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
                };
            }

            /*--------------------------------------------------------------------------------------------------------*/

            // Test for existence of createContextualFragment and delegate to it if it exists
            if (api.util.isHostMethod(range, "createContextualFragment")) {
                rangeProto.createContextualFragment = function(fragmentStr) {
                    return this.nativeRange.createContextualFragment(fragmentStr);
                };
            }

            /*--------------------------------------------------------------------------------------------------------*/

            // Clean up
            dom.getBody(document).removeChild(testTextNode);
            range.detach();
            range2.detach();
        })();

        api.createNativeRange = function(doc) {
            doc = doc || document;
            return doc.createRange();
        };
    } else if (api.features.implementsTextRange) {
        // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a
        // prototype

        WrappedRange = function(textRange) {
            this.textRange = textRange;
            this.refresh();
        };

        WrappedRange.prototype = new DomRange(document);

        WrappedRange.prototype.refresh = function() {
            var start, end;

            // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.
            var rangeContainerElement = getTextRangeContainerElement(this.textRange);

            if (textRangeIsCollapsed(this.textRange)) {
                end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true);
            } else {

                start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
                end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false);
            }

            this.setStart(start.node, start.offset);
            this.setEnd(end.node, end.offset);
        };

        DomRange.copyComparisonConstants(WrappedRange);

        // Add WrappedRange as the Range property of the global object to allow expression like Range.END_TO_END to work
        var globalObj = (function() { return this; })();
        if (typeof globalObj.Range == "undefined") {
            globalObj.Range = WrappedRange;
        }

        api.createNativeRange = function(doc) {
            doc = doc || document;
            return doc.body.createTextRange();
        };
    }

    if (api.features.implementsTextRange) {
        WrappedRange.rangeToTextRange = function(range) {
            if (range.collapsed) {
                var tr = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);



                return tr;

                //return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
            } else {
                var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
                var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
                var textRange = dom.getDocument(range.startContainer).body.createTextRange();
                textRange.setEndPoint("StartToStart", startRange);
                textRange.setEndPoint("EndToEnd", endRange);
                return textRange;
            }
        };
    }

    WrappedRange.prototype.getName = function() {
        return "WrappedRange";
    };

    api.WrappedRange = WrappedRange;

    api.createRange = function(doc) {
        doc = doc || document;
        return new WrappedRange(api.createNativeRange(doc));
    };

    api.createRangyRange = function(doc) {
        doc = doc || document;
        return new DomRange(doc);
    };

    api.createIframeRange = function(iframeEl) {
        return api.createRange(dom.getIframeDocument(iframeEl));
    };

    api.createIframeRangyRange = function(iframeEl) {
        return api.createRangyRange(dom.getIframeDocument(iframeEl));
    };

    api.addCreateMissingNativeApiListener(function(win) {
        var doc = win.document;
        if (typeof doc.createRange == "undefined") {
            doc.createRange = function() {
                return api.createRange(this);
            };
        }
        doc = win = null;
    });
});rangy.createModule("WrappedSelection", function(api, module) {
    // This will create a selection object wrapper that follows the Selection object found in the WHATWG draft DOM Range
    // spec (http://html5.org/specs/dom-range.html)

    api.requireModules( ["DomUtil", "DomRange", "WrappedRange"] );

    api.config.checkSelectionRanges = true;

    var BOOLEAN = "boolean",
        windowPropertyName = "_rangySelection",
        dom = api.dom,
        util = api.util,
        DomRange = api.DomRange,
        WrappedRange = api.WrappedRange,
        DOMException = api.DOMException,
        DomPosition = dom.DomPosition,
        getSelection,
        selectionIsCollapsed,
        CONTROL = "Control";



    function getWinSelection(winParam) {
        return (winParam || window).getSelection();
    }

    function getDocSelection(winParam) {
        return (winParam || window).document.selection;
    }

    // Test for the Range/TextRange and Selection features required
    // Test for ability to retrieve selection
    var implementsWinGetSelection = api.util.isHostMethod(window, "getSelection"),
        implementsDocSelection = api.util.isHostObject(document, "selection");

    var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);

    if (useDocumentSelection) {
        getSelection = getDocSelection;
        api.isSelectionValid = function(winParam) {
            var doc = (winParam || window).document, nativeSel = doc.selection;

            // Check whether the selection TextRange is actually contained within the correct document
            return (nativeSel.type != "None" || dom.getDocument(nativeSel.createRange().parentElement()) == doc);
        };
    } else if (implementsWinGetSelection) {
        getSelection = getWinSelection;
        api.isSelectionValid = function() {
            return true;
        };
    } else {
        module.fail("Neither document.selection or window.getSelection() detected.");
    }

    api.getNativeSelection = getSelection;

    var testSelection = getSelection();
    var testRange = api.createNativeRange(document);
    var body = dom.getBody(document);

    // Obtaining a range from a selection
    var selectionHasAnchorAndFocus = util.areHostObjects(testSelection, ["anchorNode", "focusNode"] &&
                                     util.areHostProperties(testSelection, ["anchorOffset", "focusOffset"]));
    api.features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;

    // Test for existence of native selection extend() method
    var selectionHasExtend = util.isHostMethod(testSelection, "extend");
    api.features.selectionHasExtend = selectionHasExtend;

    // Test if rangeCount exists
    var selectionHasRangeCount = (typeof testSelection.rangeCount == "number");
    api.features.selectionHasRangeCount = selectionHasRangeCount;

    var selectionSupportsMultipleRanges = false;
    var collapsedNonEditableSelectionsSupported = true;

    if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&
            typeof testSelection.rangeCount == "number" && api.features.implementsDomRange) {

        (function() {
            var iframe = document.createElement("iframe");
            body.appendChild(iframe);

            var iframeDoc = dom.getIframeDocument(iframe);
            iframeDoc.open();
            iframeDoc.write("<html><head></head><body>12</body></html>");
            iframeDoc.close();

            var sel = dom.getIframeWindow(iframe).getSelection();
            var docEl = iframeDoc.documentElement;
            var iframeBody = docEl.lastChild, textNode = iframeBody.firstChild;

            // Test whether the native selection will allow a collapsed selection within a non-editable element
            var r1 = iframeDoc.createRange();
            r1.setStart(textNode, 1);
            r1.collapse(true);
            sel.addRange(r1);
            collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);
            sel.removeAllRanges();

            // Test whether the native selection is capable of supporting multiple ranges
            var r2 = r1.cloneRange();
            r1.setStart(textNode, 0);
            r2.setEnd(textNode, 2);
            sel.addRange(r1);
            sel.addRange(r2);

            selectionSupportsMultipleRanges = (sel.rangeCount == 2);

            // Clean up
            r1.detach();
            r2.detach();

            body.removeChild(iframe);
        })();
    }

    api.features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
    api.features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;

    // ControlRanges
    var implementsControlRange = false, testControlRange;

    if (body && util.isHostMethod(body, "createControlRange")) {
        testControlRange = body.createControlRange();
        if (util.areHostProperties(testControlRange, ["item", "add"])) {
            implementsControlRange = true;
        }
    }
    api.features.implementsControlRange = implementsControlRange;

    // Selection collapsedness
    if (selectionHasAnchorAndFocus) {
        selectionIsCollapsed = function(sel) {
            return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
        };
    } else {
        selectionIsCollapsed = function(sel) {
            return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
        };
    }

    function updateAnchorAndFocusFromRange(sel, range, backwards) {
        var anchorPrefix = backwards ? "end" : "start", focusPrefix = backwards ? "start" : "end";
        sel.anchorNode = range[anchorPrefix + "Container"];
        sel.anchorOffset = range[anchorPrefix + "Offset"];
        sel.focusNode = range[focusPrefix + "Container"];
        sel.focusOffset = range[focusPrefix + "Offset"];
    }

    function updateAnchorAndFocusFromNativeSelection(sel) {
        var nativeSel = sel.nativeSelection;
        sel.anchorNode = nativeSel.anchorNode;
        sel.anchorOffset = nativeSel.anchorOffset;
        sel.focusNode = nativeSel.focusNode;
        sel.focusOffset = nativeSel.focusOffset;
    }

    function updateEmptySelection(sel) {
        sel.anchorNode = sel.focusNode = null;
        sel.anchorOffset = sel.focusOffset = 0;
        sel.rangeCount = 0;
        sel.isCollapsed = true;
        sel._ranges.length = 0;
    }

    function getNativeRange(range) {
        var nativeRange;
        if (range instanceof DomRange) {
            nativeRange = range._selectionNativeRange;
            if (!nativeRange) {
                nativeRange = api.createNativeRange(dom.getDocument(range.startContainer));
                nativeRange.setEnd(range.endContainer, range.endOffset);
                nativeRange.setStart(range.startContainer, range.startOffset);
                range._selectionNativeRange = nativeRange;
                range.attachListener("detach", function() {

                    this._selectionNativeRange = null;
                });
            }
        } else if (range instanceof WrappedRange) {
            nativeRange = range.nativeRange;
        } else if (api.features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {
            nativeRange = range;
        }
        return nativeRange;
    }

    function rangeContainsSingleElement(rangeNodes) {
        if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
            return false;
        }
        for (var i = 1, len = rangeNodes.length; i < len; ++i) {
            if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
                return false;
            }
        }
        return true;
    }

    function getSingleElementFromRange(range) {
        var nodes = range.getNodes();
        if (!rangeContainsSingleElement(nodes)) {
            throw new Error("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");
        }
        return nodes[0];
    }

    function isTextRange(range) {
        return !!range && typeof range.text != "undefined";
    }

    function updateFromTextRange(sel, range) {
        // Create a Range from the selected TextRange
        var wrappedRange = new WrappedRange(range);
        sel._ranges = [wrappedRange];

        updateAnchorAndFocusFromRange(sel, wrappedRange, false);
        sel.rangeCount = 1;
        sel.isCollapsed = wrappedRange.collapsed;
    }

    function updateControlSelection(sel) {
        // Update the wrapped selection based on what's now in the native selection
        sel._ranges.length = 0;
        if (sel.docSelection.type == "None") {
            updateEmptySelection(sel);
        } else {
            var controlRange = sel.docSelection.createRange();
            if (isTextRange(controlRange)) {
                // This case (where the selection type is "Control" and calling createRange() on the selection returns
                // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected
                // ControlRange have been removed from the ControlRange and removed from the document.
                updateFromTextRange(sel, controlRange);
            } else {
                sel.rangeCount = controlRange.length;
                var range, doc = dom.getDocument(controlRange.item(0));
                for (var i = 0; i < sel.rangeCount; ++i) {
                    range = api.createRange(doc);
                    range.selectNode(controlRange.item(i));
                    sel._ranges.push(range);
                }
                sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
                updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
            }
        }
    }

    function addRangeToControlSelection(sel, range) {
        var controlRange = sel.docSelection.createRange();
        var rangeElement = getSingleElementFromRange(range);

        // Create a new ControlRange containing all the elements in the selected ControlRange plus the element
        // contained by the supplied range
        var doc = dom.getDocument(controlRange.item(0));
        var newControlRange = dom.getBody(doc).createControlRange();
        for (var i = 0, len = controlRange.length; i < len; ++i) {
            newControlRange.add(controlRange.item(i));
        }
        try {
            newControlRange.add(rangeElement);
        } catch (ex) {
            throw new Error("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
        }
        newControlRange.select();

        // Update the wrapped selection based on what's now in the native selection
        updateControlSelection(sel);
    }

    var getSelectionRangeAt;

    if (util.isHostMethod(testSelection,  "getRangeAt")) {
        getSelectionRangeAt = function(sel, index) {
            try {
                return sel.getRangeAt(index);
            } catch(ex) {
                return null;
            }
        };
    } else if (selectionHasAnchorAndFocus) {
        getSelectionRangeAt = function(sel) {
            var doc = dom.getDocument(sel.anchorNode);
            var range = api.createRange(doc);
            range.setStart(sel.anchorNode, sel.anchorOffset);
            range.setEnd(sel.focusNode, sel.focusOffset);

            // Handle the case when the selection was selected backwards (from the end to the start in the
            // document)
            if (range.collapsed !== this.isCollapsed) {
                range.setStart(sel.focusNode, sel.focusOffset);
                range.setEnd(sel.anchorNode, sel.anchorOffset);
            }

            return range;
        };
    }

    /**
     * @constructor
     */
    function WrappedSelection(selection, docSelection, win) {
        this.nativeSelection = selection;
        this.docSelection = docSelection;
        this._ranges = [];
        this.win = win;
        this.refresh();
    }

    api.getSelection = function(win) {
        win = win || window;
        var sel = win[windowPropertyName];
        var nativeSel = getSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
        if (sel) {
            sel.nativeSelection = nativeSel;
            sel.docSelection = docSel;
            sel.refresh(win);
        } else {
            sel = new WrappedSelection(nativeSel, docSel, win);
            win[windowPropertyName] = sel;
        }
        return sel;
    };

    api.getIframeSelection = function(iframeEl) {
        return api.getSelection(dom.getIframeWindow(iframeEl));
    };

    var selProto = WrappedSelection.prototype;

    function createControlSelection(sel, ranges) {
        // Ensure that the selection becomes of type "Control"
        var doc = dom.getDocument(ranges[0].startContainer);
        var controlRange = dom.getBody(doc).createControlRange();
        for (var i = 0, el; i < rangeCount; ++i) {
            el = getSingleElementFromRange(ranges[i]);
            try {
                controlRange.add(el);
            } catch (ex) {
                throw new Error("setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)");
            }
        }
        controlRange.select();

        // Update the wrapped selection based on what's now in the native selection
        updateControlSelection(sel);
    }

    // Selecting a range
    if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
        selProto.removeAllRanges = function() {
            this.nativeSelection.removeAllRanges();
            updateEmptySelection(this);
        };

        var addRangeBackwards = function(sel, range) {
            var doc = DomRange.getRangeDocument(range);
            var endRange = api.createRange(doc);
            endRange.collapseToPoint(range.endContainer, range.endOffset);
            sel.nativeSelection.addRange(getNativeRange(endRange));
            sel.nativeSelection.extend(range.startContainer, range.startOffset);
            sel.refresh();
        };

        if (selectionHasRangeCount) {
            selProto.addRange = function(range, backwards) {
                if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                    addRangeToControlSelection(this, range);
                } else {
                    if (backwards && selectionHasExtend) {
                        addRangeBackwards(this, range);
                    } else {
                        var previousRangeCount;
                        if (selectionSupportsMultipleRanges) {
                            previousRangeCount = this.rangeCount;
                        } else {
                            this.removeAllRanges();
                            previousRangeCount = 0;
                        }
                        this.nativeSelection.addRange(getNativeRange(range));

                        // Check whether adding the range was successful
                        this.rangeCount = this.nativeSelection.rangeCount;

                        if (this.rangeCount == previousRangeCount + 1) {
                            // The range was added successfully

                            // Check whether the range that we added to the selection is reflected in the last range extracted from
                            // the selection
                            if (api.config.checkSelectionRanges) {
                                var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                                if (nativeRange && !DomRange.rangesEqual(nativeRange, range)) {
                                    // Happens in WebKit with, for example, a selection placed at the start of a text node
                                    range = new WrappedRange(nativeRange);
                                }
                            }
                            this._ranges[this.rangeCount - 1] = range;
                            updateAnchorAndFocusFromRange(this, range, selectionIsBackwards(this.nativeSelection));
                            this.isCollapsed = selectionIsCollapsed(this);
                        } else {
                            // The range was not added successfully. The simplest thing is to refresh
                            this.refresh();
                        }
                    }
                }
            };
        } else {
            selProto.addRange = function(range, backwards) {
                if (backwards && selectionHasExtend) {
                    addRangeBackwards(this, range);
                } else {
                    this.nativeSelection.addRange(getNativeRange(range));
                    this.refresh();
                }
            };
        }

        selProto.setRanges = function(ranges) {
            if (implementsControlRange && ranges.length > 1) {
                createControlSelection(this, ranges);
            } else {
                this.removeAllRanges();
                for (var i = 0, len = ranges.length; i < len; ++i) {
                    this.addRange(ranges[i]);
                }
            }
        };
    } else if (util.isHostMethod(testSelection, "empty") && util.isHostMethod(testRange, "select") &&
               implementsControlRange && useDocumentSelection) {

        selProto.removeAllRanges = function() {
            // Added try/catch as fix for issue #21
            try {
                this.docSelection.empty();

                // Check for empty() not working (issue #24)
                if (this.docSelection.type != "None") {
                    // Work around failure to empty a control selection by instead selecting a TextRange and then
                    // calling empty()
                    var doc;
                    if (this.anchorNode) {
                        doc = dom.getDocument(this.anchorNode);
                    } else if (this.docSelection.type == CONTROL) {
                        var controlRange = this.docSelection.createRange();
                        if (controlRange.length) {
                            doc = dom.getDocument(controlRange.item(0)).body.createTextRange();
                        }
                    }
                    if (doc) {
                        var textRange = doc.body.createTextRange();
                        textRange.select();
                        this.docSelection.empty();
                    }
                }
            } catch(ex) {}
            updateEmptySelection(this);
        };

        selProto.addRange = function(range) {
            if (this.docSelection.type == CONTROL) {
                addRangeToControlSelection(this, range);
            } else {
                WrappedRange.rangeToTextRange(range).select();
                this._ranges[0] = range;
                this.rangeCount = 1;
                this.isCollapsed = this._ranges[0].collapsed;
                updateAnchorAndFocusFromRange(this, range, false);
            }
        };

        selProto.setRanges = function(ranges) {
            this.removeAllRanges();
            var rangeCount = ranges.length;
            if (rangeCount > 1) {
                createControlSelection(this, ranges);
            } else if (rangeCount) {
                this.addRange(ranges[0]);
            }
        };
    } else {
        module.fail("No means of selecting a Range or TextRange was found");
        return false;
    }

    selProto.getRangeAt = function(index) {
        if (index < 0 || index >= this.rangeCount) {
            throw new DOMException("INDEX_SIZE_ERR");
        } else {
            return this._ranges[index];
        }
    };

    var refreshSelection;

    if (useDocumentSelection) {
        refreshSelection = function(sel) {
            var range;
            if (api.isSelectionValid(sel.win)) {
                range = sel.docSelection.createRange();
            } else {
                range = dom.getBody(sel.win.document).createTextRange();
                range.collapse(true);
            }


            if (sel.docSelection.type == CONTROL) {
                updateControlSelection(sel);
            } else if (isTextRange(range)) {
                updateFromTextRange(sel, range);
            } else {
                updateEmptySelection(sel);
            }
        };
    } else if (util.isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == "number") {
        refreshSelection = function(sel) {
            if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
                updateControlSelection(sel);
            } else {
                sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
                if (sel.rangeCount) {
                    for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                        sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
                    }
                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackwards(sel.nativeSelection));
                    sel.isCollapsed = selectionIsCollapsed(sel);
                } else {
                    updateEmptySelection(sel);
                }
            }
        };
    } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && api.features.implementsDomRange) {
        refreshSelection = function(sel) {
            var range, nativeSel = sel.nativeSelection;
            if (nativeSel.anchorNode) {
                range = getSelectionRangeAt(nativeSel, 0);
                sel._ranges = [range];
                sel.rangeCount = 1;
                updateAnchorAndFocusFromNativeSelection(sel);
                sel.isCollapsed = selectionIsCollapsed(sel);
            } else {
                updateEmptySelection(sel);
            }
        };
    } else {
        module.fail("No means of obtaining a Range or TextRange from the user's selection was found");
        return false;
    }

    selProto.refresh = function(checkForChanges) {
        var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
        refreshSelection(this);
        if (checkForChanges) {
            var i = oldRanges.length;
            if (i != this._ranges.length) {
                return false;
            }
            while (i--) {
                if (!DomRange.rangesEqual(oldRanges[i], this._ranges[i])) {
                    return false;
                }
            }
            return true;
        }
    };

    // Removal of a single range
    var removeRangeManually = function(sel, range) {
        var ranges = sel.getAllRanges(), removed = false;
        sel.removeAllRanges();
        for (var i = 0, len = ranges.length; i < len; ++i) {
            if (removed || range !== ranges[i]) {
                sel.addRange(ranges[i]);
            } else {
                // According to the draft WHATWG Range spec, the same range may be added to the selection multiple
                // times. removeRange should only remove the first instance, so the following ensures only the first
                // instance is removed
                removed = true;
            }
        }
        if (!sel.rangeCount) {
            updateEmptySelection(sel);
        }
    };

    if (implementsControlRange) {
        selProto.removeRange = function(range) {
            if (this.docSelection.type == CONTROL) {
                var controlRange = this.docSelection.createRange();
                var rangeElement = getSingleElementFromRange(range);

                // Create a new ControlRange containing all the elements in the selected ControlRange minus the
                // element contained by the supplied range
                var doc = dom.getDocument(controlRange.item(0));
                var newControlRange = dom.getBody(doc).createControlRange();
                var el, removed = false;
                for (var i = 0, len = controlRange.length; i < len; ++i) {
                    el = controlRange.item(i);
                    if (el !== rangeElement || removed) {
                        newControlRange.add(controlRange.item(i));
                    } else {
                        removed = true;
                    }
                }
                newControlRange.select();

                // Update the wrapped selection based on what's now in the native selection
                updateControlSelection(this);
            } else {
                removeRangeManually(this, range);
            }
        };
    } else {
        selProto.removeRange = function(range) {
            removeRangeManually(this, range);
        };
    }

    // Detecting if a selection is backwards
    var selectionIsBackwards;
    if (!useDocumentSelection && selectionHasAnchorAndFocus && api.features.implementsDomRange) {
        selectionIsBackwards = function(sel) {
            var backwards = false;
            if (sel.anchorNode) {
                backwards = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);
            }
            return backwards;
        };

        selProto.isBackwards = function() {
            return selectionIsBackwards(this);
        };
    } else {
        selectionIsBackwards = selProto.isBackwards = function() {
            return false;
        };
    }

    // Selection text
    // This is conformant to the new WHATWG DOM Range draft spec but differs from WebKit and Mozilla's implementation
    selProto.toString = function() {

        var rangeTexts = [];
        for (var i = 0, len = this.rangeCount; i < len; ++i) {
            rangeTexts[i] = "" + this._ranges[i];
        }
        return rangeTexts.join("");
    };

    function assertNodeInSameDocument(sel, node) {
        if (sel.anchorNode && (dom.getDocument(sel.anchorNode) !== dom.getDocument(node))) {
            throw new DOMException("WRONG_DOCUMENT_ERR");
        }
    }

    // No current browsers conform fully to the HTML 5 draft spec for this method, so Rangy's own method is always used
    selProto.collapse = function(node, offset) {
        assertNodeInSameDocument(this, node);
        var range = api.createRange(dom.getDocument(node));
        range.collapseToPoint(node, offset);
        this.removeAllRanges();
        this.addRange(range);
        this.isCollapsed = true;
    };

    selProto.collapseToStart = function() {
        if (this.rangeCount) {
            var range = this._ranges[0];
            this.collapse(range.startContainer, range.startOffset);
        } else {
            throw new DOMException("INVALID_STATE_ERR");
        }
    };

    selProto.collapseToEnd = function() {
        if (this.rangeCount) {
            var range = this._ranges[this.rangeCount - 1];
            this.collapse(range.endContainer, range.endOffset);
        } else {
            throw new DOMException("INVALID_STATE_ERR");
        }
    };

    // The HTML 5 spec is very specific on how selectAllChildren should be implemented so the native implementation is
    // never used by Rangy.
    selProto.selectAllChildren = function(node) {
        assertNodeInSameDocument(this, node);
        var range = api.createRange(dom.getDocument(node));
        range.selectNodeContents(node);
        this.removeAllRanges();
        this.addRange(range);
    };

    selProto.deleteFromDocument = function() {
        // Sepcial behaviour required for Control selections
        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
            var controlRange = this.docSelection.createRange();
            var element;
            while (controlRange.length) {
                element = controlRange.item(0);
                controlRange.remove(element);
                element.parentNode.removeChild(element);
            }
            this.refresh();
        } else if (this.rangeCount) {
            var ranges = this.getAllRanges();
            this.removeAllRanges();
            for (var i = 0, len = ranges.length; i < len; ++i) {
                ranges[i].deleteContents();
            }
            // The HTML5 spec says nothing about what the selection should contain after calling deleteContents on each
            // range. Firefox moves the selection to where the final selected range was, so we emulate that
            this.addRange(ranges[len - 1]);
        }
    };

    // The following are non-standard extensions
    selProto.getAllRanges = function() {
        return this._ranges.slice(0);
    };

    selProto.setSingleRange = function(range) {
        this.setRanges( [range] );
    };

    selProto.containsNode = function(node, allowPartial) {
        for (var i = 0, len = this._ranges.length; i < len; ++i) {
            if (this._ranges[i].containsNode(node, allowPartial)) {
                return true;
            }
        }
        return false;
    };

    selProto.toHtml = function() {
        var html = "";
        if (this.rangeCount) {
            var container = DomRange.getRangeDocument(this._ranges[0]).createElement("div");
            for (var i = 0, len = this._ranges.length; i < len; ++i) {
                container.appendChild(this._ranges[i].cloneContents());
            }
            html = container.innerHTML;
        }
        return html;
    };

    function inspect(sel) {
        var rangeInspects = [];
        var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
        var focus = new DomPosition(sel.focusNode, sel.focusOffset);
        var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";

        if (typeof sel.rangeCount != "undefined") {
            for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
            }
        }
        return "[" + name + "(Ranges: " + rangeInspects.join(", ") +
                ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";

    }

    selProto.getName = function() {
        return "WrappedSelection";
    };

    selProto.inspect = function() {
        return inspect(this);
    };

    selProto.detach = function() {
        this.win[windowPropertyName] = null;
        this.win = this.anchorNode = this.focusNode = null;
    };

    WrappedSelection.inspect = inspect;

    api.Selection = WrappedSelection;

    api.selectionPrototype = selProto;

    api.addCreateMissingNativeApiListener(function(win) {
        if (typeof win.getSelection == "undefined") {
            win.getSelection = function() {
                return api.getSelection(this);
            };
        }
        win = null;
    });
});
/*
    Base.js, version 1.1a
    Copyright 2006-2010, Dean Edwards
    License: http://www.opensource.org/licenses/mit-license.php
*/

var Base = function() {
    // dummy
};

Base.extend = function(_instance, _static) { // subclass
    var extend = Base.prototype.extend;
    
    // build the prototype
    Base._prototyping = true;
    var proto = new this;
    extend.call(proto, _instance);
  proto.base = function() {
    // call this method from any other method to invoke that method's ancestor
  };
    delete Base._prototyping;
    
    // create the wrapper for the constructor function
    //var constructor = proto.constructor.valueOf(); //-dean
    var constructor = proto.constructor;
    var klass = proto.constructor = function() {
        if (!Base._prototyping) {
            if (this._constructing || this.constructor == klass) { // instantiation
                this._constructing = true;
                constructor.apply(this, arguments);
                delete this._constructing;
            } else if (arguments[0] != null) { // casting
                return (arguments[0].extend || extend).call(arguments[0], proto);
            }
        }
    };
    
    // build the class interface
    klass.ancestor = this;
    klass.extend = this.extend;
    klass.forEach = this.forEach;
    klass.implement = this.implement;
    klass.prototype = proto;
    klass.toString = this.toString;
    klass.valueOf = function(type) {
        //return (type == "object") ? klass : constructor; //-dean
        return (type == "object") ? klass : constructor.valueOf();
    };
    extend.call(klass, _static);
    // class initialisation
    if (typeof klass.init == "function") klass.init();
    return klass;
};

Base.prototype = {  
    extend: function(source, value) {
        if (arguments.length > 1) { // extending with a name/value pair
            var ancestor = this[source];
            if (ancestor && (typeof value == "function") && // overriding a method?
                // the valueOf() comparison is to avoid circular references
                (!ancestor.valueOf || ancestor.valueOf() != value.valueOf()) &&
                /\bbase\b/.test(value)) {
                // get the underlying method
                var method = value.valueOf();
                // override
                value = function() {
                    var previous = this.base || Base.prototype.base;
                    this.base = ancestor;
                    var returnValue = method.apply(this, arguments);
                    this.base = previous;
                    return returnValue;
                };
                // point to the underlying method
                value.valueOf = function(type) {
                    return (type == "object") ? value : method;
                };
                value.toString = Base.toString;
            }
            this[source] = value;
        } else if (source) { // extending with an object literal
            var extend = Base.prototype.extend;
            // if this object has a customised extend method then use it
            if (!Base._prototyping && typeof this != "function") {
                extend = this.extend || extend;
            }
            var proto = {toSource: null};
            // do the "toString" and other methods manually
            var hidden = ["constructor", "toString", "valueOf"];
            // if we are prototyping then include the constructor
            var i = Base._prototyping ? 0 : 1;
            while (key = hidden[i++]) {
                if (source[key] != proto[key]) {
                    extend.call(this, key, source[key]);

                }
            }
            // copy each of the source object's properties to this object
            for (var key in source) {
                if (!proto[key]) extend.call(this, key, source[key]);
            }
        }
        return this;
    }
};

// initialise
Base = Base.extend({
    constructor: function() {
        this.extend(arguments[0]);
    }
}, {
    ancestor: Object,
    version: "1.1",
    
    forEach: function(object, block, context) {
        for (var key in object) {
            if (this.prototype[key] === undefined) {
                block.call(context, object[key], key, object);
            }
        }
    },
        
    implement: function() {
        for (var i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] == "function") {
                // if it's a function, call it
                arguments[i](this.prototype);
            } else {
                // add the interface using the extend method
                this.prototype.extend(arguments[i]);
            }
        }
        return this;
    },
    
    toString: function() {
        return String(this.valueOf());
    }
});/**
 * Detect browser support for specific features
 */
wysihtml5.browser = (function() {
  var userAgent   = navigator.userAgent,
      testElement = document.createElement("div"),
      // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect
      isIE        = userAgent.indexOf("MSIE")         !== -1 && userAgent.indexOf("Opera") === -1,
      isGecko     = userAgent.indexOf("Gecko")        !== -1 && userAgent.indexOf("KHTML") === -1,
      isWebKit    = userAgent.indexOf("AppleWebKit/") !== -1,
      isChrome    = userAgent.indexOf("Chrome/")      !== -1,
      isOpera     = userAgent.indexOf("Opera/")       !== -1;
  
  function iosVersion(userAgent) {
    return +((/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\d+).+? like mac os x/)) || [, 0])[1];
  }
  
  function androidVersion(userAgent) {
    return +(userAgent.match(/android (\d+)/) || [, 0])[1];
  }
  
  return {
    // Static variable needed, publicly accessible, to be able override it in unit tests
    USER_AGENT: userAgent,
    
    /**
     * Exclude browsers that are not capable of displaying and handling
     * contentEditable as desired:
     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable
     *    - IE < 8 create invalid markup and crash randomly from time to time
     *
     * @return {Boolean}
     */
    supported: function() {
      var userAgent                   = this.USER_AGENT.toLowerCase(),
          // Essential for making html elements editable
          hasContentEditableSupport   = "contentEditable" in testElement,
          // Following methods are needed in order to interact with the contentEditable area
          hasEditingApiSupport        = document.execCommand && document.queryCommandSupported && document.queryCommandState,
          // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+
          hasQuerySelectorSupport     = document.querySelector && document.querySelectorAll,
          // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)
          isIncompatibleMobileBrowser = (this.isIos() && iosVersion(userAgent) < 5) || (this.isAndroid() && androidVersion(userAgent) < 4) || userAgent.indexOf("opera mobi") !== -1 || userAgent.indexOf("hpwos/") !== -1;
      return hasContentEditableSupport
        && hasEditingApiSupport
        && hasQuerySelectorSupport
        && !isIncompatibleMobileBrowser;
    },
    
    isTouchDevice: function() {
      return this.supportsEvent("touchmove");
    },
    
    isIos: function() {
      return (/ipad|iphone|ipod/i).test(this.USER_AGENT);
    },
    
    isAndroid: function() {
      return this.USER_AGENT.indexOf("Android") !== -1;
    },
    
    /**
     * Whether the browser supports sandboxed iframes
     * Currently only IE 6+ offers such feature <iframe security="restricted">
     *
     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx
     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx
     *
     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)
     */
    supportsSandboxedIframes: function() {
      return isIE;
    },

    /**
     * IE6+7 throw a mixed content warning when the src of an iframe
     * is empty/unset or about:blank
     * window.querySelector is implemented as of IE8
     */
    throwsMixedContentWarningWhenIframeSrcIsEmpty: function() {
      return !("querySelector" in document);
    },

    /**
     * Whether the caret is correctly displayed in contentEditable elements
     * Firefox sometimes shows a huge caret in the beginning after focusing
     */
    displaysCaretInEmptyContentEditableCorrectly: function() {
      return isIE;
    },

    /**
     * Opera and IE are the only browsers who offer the css value
     * in the original unit, thx to the currentStyle object
     * All other browsers provide the computed style in px via window.getComputedStyle
     */
    hasCurrentStyleProperty: function() {
      return "currentStyle" in testElement;
    },
    
    /**
     * Firefox on OSX navigates through history when hitting CMD + Arrow right/left
     */
    hasHistoryIssue: function() {
      return isGecko;
    },

    /**
     * Whether the browser inserts a <br> when pressing enter in a contentEditable element
     */
    insertsLineBreaksOnReturn: function() {
      return isGecko;
    },

    supportsPlaceholderAttributeOn: function(element) {
      return "placeholder" in element;
    },

    supportsEvent: function(eventName) {
      return "on" + eventName in testElement || (function() {
        testElement.setAttribute("on" + eventName, "return;");
        return typeof(testElement["on" + eventName]) === "function";
      })();
    },

    /**
     * Opera doesn't correctly fire focus/blur events when clicking in- and outside of iframe
     */
    supportsEventsInIframeCorrectly: function() {
      return !isOpera;
    },
    
    /**
     * Everything below IE9 doesn't know how to treat HTML5 tags
     *
     * @param {Object} context The document object on which to check HTML5 support
     *
     * @example
     *    wysihtml5.browser.supportsHTML5Tags(document);
     */
    supportsHTML5Tags: function(context) {
      var element = context.createElement("div"),
          html5   = "<article>foo</article>";
      element.innerHTML = html5;
      return element.innerHTML.toLowerCase() === html5;
    },

    /**
     * Checks whether a document supports a certain queryCommand
     * In particular, Opera needs a reference to a document that has a contentEditable in it's dom tree
     * in oder to report correct results
     *
     * @param {Object} doc Document object on which to check for a query command
     * @param {String} command The query command to check for
     * @return {Boolean}
     *
     * @example
     *    wysihtml5.browser.supportsCommand(document, "bold");
     */
    supportsCommand: (function() {
      // Following commands are supported but contain bugs in some browsers
      var buggyCommands = {
        // formatBlock fails with some tags (eg. <blockquote>)
        "formatBlock":          isIE,
         // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets
         // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)
         // IE and Opera act a bit different here as they convert the entire content of the current block element into a list
        "insertUnorderedList":  isIE || isWebKit,
        "insertOrderedList":    isIE || isWebKit
      };
      
      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands
      var supported = {
        "insertHTML": isGecko
      };

      return function(doc, command) {
        var isBuggy = buggyCommands[command];
        if (!isBuggy) {
          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled
          try {
            return doc.queryCommandSupported(command);
          } catch(e1) {}

          try {
            return doc.queryCommandEnabled(command);
          } catch(e2) {
            return !!supported[command];
          }
        }
        return false;
      };
    })(),

    /**
     * IE: URLs starting with:
     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,
     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:
     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the
     * space bar when the caret is directly after such an url.
     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll
     * (related blog post on msdn
     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).
     */
    doesAutoLinkingInContentEditable: function() {
      return isIE;
    },

    /**
     * As stated above, IE auto links urls typed into contentEditable elements
     * Since IE9 it's possible to prevent this behavior
     */
    canDisableAutoLinking: function() {
      return this.supportsCommand(document, "AutoUrlDetect");
    },

    /**
     * IE leaves an empty paragraph in the contentEditable element after clearing it
     * Chrome/Safari sometimes an empty <div>
     */
    clearsContentEditableCorrectly: function() {
      return isGecko || isOpera || isWebKit;
    },

    /**
     * IE gives wrong results for getAttribute
     */
    supportsGetAttributeCorrectly: function() {
      var td = document.createElement("td");
      return td.getAttribute("rowspan") != "1";
    },

    /**
     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.
     * Chrome and Safari both don't support this
     */
    canSelectImagesInContentEditable: function() {
      return isGecko || isIE || isOpera;
    },

    /**
     * All browsers except Safari and Chrome automatically scroll the range/caret position into view
     */
    autoScrollsToCaret: function() {
      return !isWebKit;
    },

    /**
     * Check whether the browser automatically closes tags that don't need to be opened
     */
    autoClosesUnclosedTags: function() {
      var clonedTestElement = testElement.cloneNode(false),
          returnValue,
          innerHTML;

      clonedTestElement.innerHTML = "<p><div></div>";
      innerHTML                   = clonedTestElement.innerHTML.toLowerCase();
      returnValue                 = innerHTML === "<p></p><div></div>" || innerHTML === "<p><div></div></p>";

      // Cache result by overwriting current function
      this.autoClosesUnclosedTags = function() { return returnValue; };

      return returnValue;
    },

    /**
     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists
     */
    supportsNativeGetElementsByClassName: function() {
      return String(document.getElementsByClassName).indexOf("[native code]") !== -1;
    },

    /**
     * As of now (19.04.2011) only supported by Firefox 4 and Chrome
     * See https://developer.mozilla.org/en/DOM/Selection/modify
     */
    supportsSelectionModify: function() {
      return "getSelection" in window && "modify" in window.getSelection();
    },
    
    /**
     * Opera needs a white space after a <br> in order to position the caret correctly
     */
    needsSpaceAfterLineBreak: function() {
      return isOpera;
    },
    
    /**
     * Whether the browser supports the speech api on the given element
     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/
     *
     * @example
     *    var input = document.createElement("input");
     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {
     *      // ...
     *    }
     */
    supportsSpeechApiOn: function(input) {
      var chromeVersion = userAgent.match(/Chrome\/(\d+)/) || [, 0];
      return chromeVersion[1] >= 11 && ("onwebkitspeechchange" in input || "speech" in input);
    },
    
    /**
     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest
     * See https://connect.microsoft.com/ie/feedback/details/650112
     * or try the POC http://tifftiff.de/ie9_crash/
     */
    crashesWhenDefineProperty: function(property) {
      return isIE && (property === "XMLHttpRequest" || property === "XDomainRequest");
    },
    
    /**
     * IE is the only browser who fires the "focus" event not immediately when .focus() is called on an element
     */
    doesAsyncFocus: function() {
      return isIE;
    },
    
    /**
     * In IE it's impssible for the user and for the selection library to set the caret after an <img> when it's the lastChild in the document
     */
    hasProblemsSettingCaretAfterImg: function() {
      return isIE;
    },
    
    hasUndoInContextMenu: function() {
      return isGecko || isChrome || isOpera;
    },
    
    /**
     * Opera sometimes doesn't insert the node at the right position when range.insertNode(someNode)
     * is used (regardless if rangy or native)
     * This especially happens when the caret is positioned right after a <br> because then
     * insertNode() will insert the node right before the <br>
     */
    hasInsertNodeIssue: function() {
      return isOpera;
    },
    
    /**
     * IE 8+9 don't fire the focus event of the <body> when the iframe gets focused (even though the caret gets set into the <body>)
     */
    hasIframeFocusIssue: function() {
      return isIE;
    }
  };
})();wysihtml5.lang.array = function(arr) {
  return {
    /**
     * Check whether a given object exists in an array
     *
     * @example
     *    wysihtml5.lang.array([1, 2]).contains(1);
     *    // => true
     */
    contains: function(needle) {
      if (arr.indexOf) {
        return arr.indexOf(needle) !== -1;
      } else {
        for (var i=0, length=arr.length; i<length; i++) {
          if (arr[i] === needle) { return true; }
        }
        return false;
      }
    },
    
    /**
     * Substract one array from another
     *
     * @example
     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);
     *    // => [1, 2]
     */
    without: function(arrayToSubstract) {
      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);
      var newArr  = [],
          i       = 0,
          length  = arr.length;
      for (; i<length; i++) {
        if (!arrayToSubstract.contains(arr[i])) {
          newArr.push(arr[i]);
        }
      }
      return newArr;
    },
    
    /**
     * Return a clean native array
     * 
     * Following will convert a Live NodeList to a proper Array
     * @example
     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();
     */
    get: function() {
      var i        = 0,
          length   = arr.length,
          newArray = [];
      for (; i<length; i++) {
        newArray.push(arr[i]);
      }
      return newArray;
    }
  };
};wysihtml5.lang.Dispatcher = Base.extend(
  /** @scope wysihtml5.lang.Dialog.prototype */ {
  on: function(eventName, handler) {
    this.events = this.events || {};
    this.events[eventName] = this.events[eventName] || [];
    this.events[eventName].push(handler);
    return this;
  },

  off: function(eventName, handler) {
    this.events = this.events || {};
    var i = 0,
        handlers,
        newHandlers;
    if (eventName) {
      handlers    = this.events[eventName] || [],
      newHandlers = [];
      for (; i<handlers.length; i++) {
        if (handlers[i] !== handler && handler) {
          newHandlers.push(handlers[i]);
        }
      }
      this.events[eventName] = newHandlers;
    } else {
      // Clean up all events
      this.events = {};
    }
    return this;
  },
  
  fire: function(eventName, payload) {
    this.events = this.events || {};
    var handlers = this.events[eventName] || [],
        i        = 0;
    for (; i<handlers.length; i++) {
      handlers[i].call(this, payload);
    }
    return this;
  },
  
  // deprecated, use .on()
  observe: function() {
    return this.on.apply(this, arguments);
  },
  
  // deprecated, use .off()
  stopObserving: function() {
    return this.off.apply(this, arguments);
  }
});wysihtml5.lang.object = function(obj) {
  return {
    /**
     * @example
     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();
     *    // => { foo: 1, bar: 2, baz: 3 }
     */
    merge: function(otherObj) {
      for (var i in otherObj) {
        obj[i] = otherObj[i];
      }
      return this;
    },
    
    get: function() {
      return obj;
    },
    
    /**
     * @example
     *    wysihtml5.lang.object({ foo: 1 }).clone();
     *    // => { foo: 1 }
     */
    clone: function() {
      var newObj = {},
          i;
      for (i in obj) {
        newObj[i] = obj[i];
      }
      return newObj;
    },
    
    /**
     * @example
     *    wysihtml5.lang.object([]).isArray();
     *    // => true
     */
    isArray: function() {
      return Object.prototype.toString.call(obj) === "[object Array]";
    }
  };
};(function() {
  var WHITE_SPACE_START = /^\s+/,
      WHITE_SPACE_END   = /\s+$/;
  wysihtml5.lang.string = function(str) {
    str = String(str);
    return {
      /**
       * @example
       *    wysihtml5.lang.string("   foo   ").trim();
       *    // => "foo"
       */
      trim: function() {
        return str.replace(WHITE_SPACE_START, "").replace(WHITE_SPACE_END, "");
      },
      
      /**
       * @example
       *    wysihtml5.lang.string("Hello #{name}").interpolate({ name: "Christopher" });
       *    // => "Hello Christopher"
       */
      interpolate: function(vars) {
        for (var i in vars) {
          str = this.replace("#{" + i + "}").by(vars[i]);
        }
        return str;
      },
      
      /**
       * @example
       *    wysihtml5.lang.string("Hello Tom").replace("Tom").with("Hans");
       *    // => "Hello Hans"
       */
      replace: function(search) {
        return {
          by: function(replace) {
            return str.split(search).join(replace);
          }
        };
      }
    };
  };
})();/**
 * Find urls in descendant text nodes of an element and auto-links them
 * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/
 *
 * @param {Element} element Container element in which to search for urls
 *
 * @example
 *    <div id="text-container">Please click here: www.google.com</div>
 *    <script>wysihtml5.dom.autoLink(document.getElementById("text-container"));</script>
 */
(function(wysihtml5) {
  var /**
       * Don't auto-link urls that are contained in the following elements:
       */
      IGNORE_URLS_IN        = wysihtml5.lang.array(["CODE", "PRE", "A", "SCRIPT", "HEAD", "TITLE", "STYLE"]),
      /**
       * revision 1:
       *    /(\S+\.{1}[^\s\,\.\!]+)/g
       *
       * revision 2:
       *    /(\b(((https?|ftp):\/\/)|(www\.))[-A-Z0-9+&@#\/%?=~_|!:,.;\[\]]*[-A-Z0-9+&@#\/%=~_|])/gim
       *
       * put this in the beginning if you don't wan't to match within a word
       *    (^|[\>\(\{\[\s\>])
       */
      URL_REG_EXP           = /((https?:\/\/|www\.)[^\s<]{3,})/gi,
      TRAILING_CHAR_REG_EXP = /([^\w\/\-](,?))$/i,
      MAX_DISPLAY_LENGTH    = 100,
      BRACKETS              = { ")": "(", "]": "[", "}": "{" };
  
  function autoLink(element) {
    if (_hasParentThatShouldBeIgnored(element)) {
      return element;
    }

    if (element === element.ownerDocument.documentElement) {
      element = element.ownerDocument.body;
    }

    return _parseNode(element);
  }
  
  /**
   * This is basically a rebuild of
   * the rails auto_link_urls text helper
   */
  function _convertUrlsToLinks(str) {
    return str.replace(URL_REG_EXP, function(match, url) {
      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || "",
          opening     = BRACKETS[punctuation];
      url = url.replace(TRAILING_CHAR_REG_EXP, "");

      if (url.split(opening).length > url.split(punctuation).length) {
        url = url + punctuation;
        punctuation = "";
      }
      var realUrl    = url,
          displayUrl = url;
      if (url.length > MAX_DISPLAY_LENGTH) {
        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + "...";
      }
      // Add http prefix if necessary
      if (realUrl.substr(0, 4) === "www.") {
        realUrl = "http://" + realUrl;
      }
      
      return '<a href="' + realUrl + '">' + displayUrl + '</a>' + punctuation;
    });
  }
  
  /**
   * Creates or (if already cached) returns a temp element
   * for the given document object
   */
  function _getTempElement(context) {
    var tempElement = context._wysihtml5_tempElement;
    if (!tempElement) {
      tempElement = context._wysihtml5_tempElement = context.createElement("div");
    }
    return tempElement;
  }
  
  /**
   * Replaces the original text nodes with the newly auto-linked dom tree
   */
  function _wrapMatchesInNode(textNode) {
    var parentNode  = textNode.parentNode,
        tempElement = _getTempElement(parentNode.ownerDocument);
    
    // We need to insert an empty/temporary <span /> to fix IE quirks
    // Elsewise IE would strip white space in the beginning
    tempElement.innerHTML = "<span></span>" + _convertUrlsToLinks(textNode.data);
    tempElement.removeChild(tempElement.firstChild);
    
    while (tempElement.firstChild) {
      // inserts tempElement.firstChild before textNode
      parentNode.insertBefore(tempElement.firstChild, textNode);
    }
    parentNode.removeChild(textNode);
  }
  
  function _hasParentThatShouldBeIgnored(node) {
    var nodeName;
    while (node.parentNode) {
      node = node.parentNode;
      nodeName = node.nodeName;
      if (IGNORE_URLS_IN.contains(nodeName)) {
        return true;
      } else if (nodeName === "body") {
        return false;
      }
    }
    return false;
  }
  
  function _parseNode(element) {
    if (IGNORE_URLS_IN.contains(element.nodeName)) {
      return;
    }
    
    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {
      _wrapMatchesInNode(element);
      return;
    }
    
    var childNodes        = wysihtml5.lang.array(element.childNodes).get(),
        childNodesLength  = childNodes.length,
        i                 = 0;
    
    for (; i<childNodesLength; i++) {
      _parseNode(childNodes[i]);
    }
    
    return element;
  }
  
  wysihtml5.dom.autoLink = autoLink;
  
  // Reveal url reg exp to the outside
  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;
})(wysihtml5);(function(wysihtml5) {
  var api = wysihtml5.dom;
  
  api.addClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.add(className);
    }
    if (api.hasClass(element, className)) {
      return;
    }
    element.className += " " + className;
  };
  
  api.removeClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.remove(className);
    }
    
    element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ");
  };
  
  api.hasClass = function(element, className) {
    var classList = element.classList;
    if (classList) {
      return classList.contains(className);
    }
    
    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className || new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  };
})(wysihtml5);
wysihtml5.dom.contains = (function() {
  var documentElement = document.documentElement;
  if (documentElement.contains) {
    return function(container, element) {
      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {
        element = element.parentNode;
      }
      return container !== element && container.contains(element);
    };
  } else if (documentElement.compareDocumentPosition) {
    return function(container, element) {
      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition
      return !!(container.compareDocumentPosition(element) & 16);
    };
  }
})();/**
 * Converts an HTML fragment/element into a unordered/ordered list
 *
 * @param {Element} element The element which should be turned into a list
 * @param {String} listType The list type in which to convert the tree (either "ul" or "ol")
 * @return {Element} The created list
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <span id="pseudo-list">
 *      eminem<br>
 *      dr. dre
 *      <div>50 Cent</div>
 *    </span>
 *
 *    <script>
 *      wysihtml5.dom.convertToList(document.getElementById("pseudo-list"), "ul");
 *    </script>
 *
 *    <!-- Will result in: -->
 *    <ul>
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 */
wysihtml5.dom.convertToList = (function() {
  function _createListItem(doc, list) {
    var listItem = doc.createElement("li");
    list.appendChild(listItem);
    return listItem;
  }
  
  function _createList(doc, type) {
    return doc.createElement(type);
  }
  
  function convertToList(element, listType) {
    if (element.nodeName === "UL" || element.nodeName === "OL" || element.nodeName === "MENU") {
      // Already a list
      return element;
    }
    
    var doc               = element.ownerDocument,
        list              = _createList(doc, listType),
        lineBreaks        = element.querySelectorAll("br"),
        lineBreaksLength  = lineBreaks.length,
        childNodes,
        childNodesLength,
        childNode,
        lineBreak,
        parentNode,
        isBlockElement,
        isLineBreak,
        currentListItem,
        i;
    
    // First find <br> at the end of inline elements and move them behind them
    for (i=0; i<lineBreaksLength; i++) {
      lineBreak = lineBreaks[i];
      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {
        if (wysihtml5.dom.getStyle("display").from(parentNode) === "block") {
          parentNode.removeChild(lineBreak);
          break;
        }
        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);
      }
    }
    
    childNodes        = wysihtml5.lang.array(element.childNodes).get();
    childNodesLength  = childNodes.length;
    
    for (i=0; i<childNodesLength; i++) {
      currentListItem   = currentListItem || _createListItem(doc, list);
      childNode         = childNodes[i];
      isBlockElement    = wysihtml5.dom.getStyle("display").from(childNode) === "block";
      isLineBreak       = childNode.nodeName === "BR";
      
      if (isBlockElement) {
        // Append blockElement to current <li> if empty, otherwise create a new one
        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;
        currentListItem.appendChild(childNode);
        currentListItem = null;
        continue;
      }
      
      if (isLineBreak) {
        // Only create a new list item in the next iteration when the current one has already content
        currentListItem = currentListItem.firstChild ? null : currentListItem;
        continue;
      }
      
      currentListItem.appendChild(childNode);
    }
    
    if (childNodes.length === 0) {
      _createListItem(doc, list);
    }
    
    element.parentNode.replaceChild(list, element);
    return list;
  }
  
  return convertToList;
})();/**
 * Copy a set of attributes from one element to another
 *
 * @param {Array} attributesToCopy List of attributes which should be copied
 * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to
 *    copy the attributes from., this again returns an object which provides a method named "to" which can be invoked 
 *    with the element where to copy the attributes to (see example)
 *
 * @example
 *    var textarea    = document.querySelector("textarea"),
 *        div         = document.querySelector("div[contenteditable=true]"),
 *        anotherDiv  = document.querySelector("div.preview");
 *    wysihtml5.dom.copyAttributes(["spellcheck", "value", "placeholder"]).from(textarea).to(div).andTo(anotherDiv);
 *
 */
wysihtml5.dom.copyAttributes = function(attributesToCopy) {
  return {
    from: function(elementToCopyFrom) {
      return {
        to: function(elementToCopyTo) {
          var attribute,
              i         = 0,
              length    = attributesToCopy.length;
          for (; i<length; i++) {
            attribute = attributesToCopy[i];
            if (typeof(elementToCopyFrom[attribute]) !== "undefined" && elementToCopyFrom[attribute] !== "") {
              elementToCopyTo[attribute] = elementToCopyFrom[attribute];
            }
          }
          return { andTo: arguments.callee };
        }
      };
    }
  };
};/**
 * Copy a set of styles from one element to another
 * Please note that this only works properly across browsers when the element from which to copy the styles
 * is in the dom
 *
 * Interesting article on how to copy styles
 *
 * @param {Array} stylesToCopy List of styles which should be copied
 * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to
 *    copy the styles from., this again returns an object which provides a method named "to" which can be invoked 
 *    with the element where to copy the styles to (see example)
 *
 * @example
 *    var textarea    = document.querySelector("textarea"),
 *        div         = document.querySelector("div[contenteditable=true]"),
 *        anotherDiv  = document.querySelector("div.preview");
 *    wysihtml5.dom.copyStyles(["overflow-y", "width", "height"]).from(textarea).to(div).andTo(anotherDiv);
 *
 */
(function(dom) {
  
  /**
   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set
   * So if an element has "width: 200px; -moz-box-sizing: border-box; border: 1px;" then 
   * its computed css width will be 198px
   *
   * See https://bugzilla.mozilla.org/show_bug.cgi?id=520992
   */
  var BOX_SIZING_PROPERTIES = ["-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing"];
  
  var shouldIgnoreBoxSizingBorderBox = function(element) {
    if (hasBoxSizingBorderBox(element)) {
       return parseInt(dom.getStyle("width").from(element), 10) < element.offsetWidth;
    }
    return false;
  };
  
  var hasBoxSizingBorderBox = function(element) {
    var i       = 0,
        length  = BOX_SIZING_PROPERTIES.length;
    for (; i<length; i++) {
      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === "border-box") {
        return BOX_SIZING_PROPERTIES[i];
      }
    }
  };
  
  dom.copyStyles = function(stylesToCopy) {
    return {
      from: function(element) {
        if (shouldIgnoreBoxSizingBorderBox(element)) {
          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);
        }
        
        var cssText = "",
            length  = stylesToCopy.length,
            i       = 0,
            property;
        for (; i<length; i++) {
          property = stylesToCopy[i];
          cssText += property + ":" + dom.getStyle(property).from(element) + ";";
        }
        
        return {
          to: function(element) {
            dom.setStyles(cssText).on(element);
            return { andTo: arguments.callee };
          }
        };
      }
    };
  };
})(wysihtml5.dom);/**
 * Event Delegation
 *
 * @example
 *    wysihtml5.dom.delegate(document.body, "a", "click", function() {
 *      // foo
 *    });
 */
(function(wysihtml5) {
  
  wysihtml5.dom.delegate = function(container, selector, eventName, handler) {
    return wysihtml5.dom.observe(container, eventName, function(event) {
      var target    = event.target,
          match     = wysihtml5.lang.array(container.querySelectorAll(selector));
      
      while (target && target !== container) {
        if (match.contains(target)) {
          handler.call(target, event);
          break;
        }
        target = target.parentNode;
      }
    });
  };
  
})(wysihtml5);/**
 * Returns the given html wrapped in a div element
 *
 * Fixing IE's inability to treat unknown elements (HTML5 section, article, ...) correctly
 * when inserted via innerHTML
 * 
 * @param {String} html The html which should be wrapped in a dom element
 * @param {Obejct} [context] Document object of the context the html belongs to
 *
 * @example
 *    wysihtml5.dom.getAsDom("<article>foo</article>");
 */
wysihtml5.dom.getAsDom = (function() {
  
  var _innerHTMLShiv = function(html, context) {
    var tempElement = context.createElement("div");
    tempElement.style.display = "none";
    context.body.appendChild(tempElement);
    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML
    try { tempElement.innerHTML = html; } catch(e) {}
    context.body.removeChild(tempElement);
    return tempElement;
  };
  
  /**
   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element
   */
  var _ensureHTML5Compatibility = function(context) {
    if (context._wysihtml5_supportsHTML5Tags) {
      return;
    }
    for (var i=0, length=HTML5_ELEMENTS.length; i<length; i++) {
      context.createElement(HTML5_ELEMENTS[i]);
    }
    context._wysihtml5_supportsHTML5Tags = true;
  };
  
  
  /**
   * List of html5 tags
   * taken from http://simon.html5.org/html5-elements
   */
  var HTML5_ELEMENTS = [
    "abbr", "article", "aside", "audio", "bdi", "canvas", "command", "datalist", "details", "figcaption",
    "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav", "output", "progress",
    "rp", "rt", "ruby", "svg", "section", "source", "summary", "time", "track", "video", "wbr"
  ];
  
  return function(html, context) {
    context = context || document;
    var tempElement;
    if (typeof(html) === "object" && html.nodeType) {
      tempElement = context.createElement("div");
      tempElement.appendChild(html);
    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {
      tempElement = context.createElement("div");
      tempElement.innerHTML = html;
    } else {
      _ensureHTML5Compatibility(context);
      tempElement = _innerHTMLShiv(html, context);
    }
    return tempElement;
  };
})();/**
 * Walks the dom tree from the given node up until it finds a match
 * Designed for optimal performance.
 *
 * @param {Element} node The from which to check the parent nodes
 * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)
 * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)
 * @return {null|Element} Returns the first element that matched the desiredNodeName(s)
 * @example
 *    var listElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: ["MENU", "UL", "OL"] });
 *    // ... or ...
 *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: "UL" });
 *    // ... or ...
 *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: "SPAN", className: "wysiwyg-color-red", classRegExp: /wysiwyg-color-[a-z]/g });
 */
wysihtml5.dom.getParentElement = (function() {
  
  function _isSameNodeName(nodeName, desiredNodeNames) {
    if (!desiredNodeNames || !desiredNodeNames.length) {
      return true;
    }
    
    if (typeof(desiredNodeNames) === "string") {
      return nodeName === desiredNodeNames;
    } else {
      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);
    }
  }
  
  function _isElement(node) {
    return node.nodeType === wysihtml5.ELEMENT_NODE;
  }
  
  function _hasClassName(element, className, classRegExp) {
    var classNames = (element.className || "").match(classRegExp) || [];
    if (!className) {
      return !!classNames.length;
    }
    return classNames[classNames.length - 1] === className;
  }
  
  function _getParentElementWithNodeName(node, nodeName, levels) {
    while (levels-- && node && node.nodeName !== "BODY") {
      if (_isSameNodeName(node.nodeName, nodeName)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }
  
  function _getParentElementWithNodeNameAndClassName(node, nodeName, className, classRegExp, levels) {
    while (levels-- && node && node.nodeName !== "BODY") {
      if (_isElement(node) &&
          _isSameNodeName(node.nodeName, nodeName) &&
          _hasClassName(node, className, classRegExp)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }
  
  return function(node, matchingSet, levels) {
    levels = levels || 50; // Go max 50 nodes upwards from current node
    if (matchingSet.className || matchingSet.classRegExp) {
      return _getParentElementWithNodeNameAndClassName(
        node, matchingSet.nodeName, matchingSet.className, matchingSet.classRegExp, levels
      );
    } else {
      return _getParentElementWithNodeName(
        node, matchingSet.nodeName, levels
      );
    }
  };
})();
/**
 * Get element's style for a specific css property
 *
 * @param {Element} element The element on which to retrieve the style
 * @param {String} property The CSS property to retrieve ("float", "display", "text-align", ...)
 *
 * @example
 *    wysihtml5.dom.getStyle("display").from(document.body);
 *    // => "block"
 */
wysihtml5.dom.getStyle = (function() {
  var stylePropertyMapping = {
        "float": ("styleFloat" in document.createElement("div").style) ? "styleFloat" : "cssFloat"
      },
      REG_EXP_CAMELIZE = /\-[a-z]/g;
  
  function camelize(str) {
    return str.replace(REG_EXP_CAMELIZE, function(match) {
      return match.charAt(1).toUpperCase();
    });
  }
  
  return function(property) {
    return {
      from: function(element) {
        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {
          return;
        }
        
        var doc               = element.ownerDocument,
            camelizedProperty = stylePropertyMapping[property] || camelize(property),
            style             = element.style,
            currentStyle      = element.currentStyle,
            styleValue        = style[camelizedProperty];
        if (styleValue) {
          return styleValue;
        }
        
        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant
        // window.getComputedStyle, since it returns css property values in their original unit:
        // If you set an elements width to "50%", window.getComputedStyle will give you it's current width in px while currentStyle
        // gives you the original "50%".
        // Opera supports both, currentStyle and window.getComputedStyle, that's why checking for currentStyle should have higher prio
        if (currentStyle) {
          try {
            return currentStyle[camelizedProperty];
          } catch(e) {
            //ie will occasionally fail for unknown reasons. swallowing exception
          }
        }

        var win                 = doc.defaultView || doc.parentWindow,
            needsOverflowReset  = (property === "height" || property === "width") && element.nodeName === "TEXTAREA",
            originalOverflow,
            returnValue;

        if (win.getComputedStyle) {
          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars
          // therfore we remove and restore the scrollbar and calculate the value in between
          if (needsOverflowReset) {
            originalOverflow = style.overflow;
            style.overflow = "hidden";
          }
          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);
          if (needsOverflowReset) {
            style.overflow = originalOverflow || "";
          }
          return returnValue;
        }
      }
    };
  };
})();/**
 * High performant way to check whether an element with a specific tag name is in the given document
 * Optimized for being heavily executed
 * Unleashes the power of live node lists
 *
 * @param {Object} doc The document object of the context where to check
 * @param {String} tagName Upper cased tag name
 * @example
 *    wysihtml5.dom.hasElementWithTagName(document, "IMG");
 */
wysihtml5.dom.hasElementWithTagName = (function() {
  var LIVE_CACHE          = {},
      DOCUMENT_IDENTIFIER = 1;
  
  function _getDocumentIdentifier(doc) {
    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);
  }
  
  return function(doc, tagName) {
    var key         = _getDocumentIdentifier(doc) + ":" + tagName,
        cacheEntry  = LIVE_CACHE[key];
    if (!cacheEntry) {
      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);
    }
    
    return cacheEntry.length > 0;
  };
})();/**
 * High performant way to check whether an element with a specific class name is in the given document
 * Optimized for being heavily executed
 * Unleashes the power of live node lists
 *
 * @param {Object} doc The document object of the context where to check
 * @param {String} tagName Upper cased tag name
 * @example
 *    wysihtml5.dom.hasElementWithClassName(document, "foobar");
 */
(function(wysihtml5) {
  var LIVE_CACHE          = {},
      DOCUMENT_IDENTIFIER = 1;

  function _getDocumentIdentifier(doc) {
    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);
  }
  
  wysihtml5.dom.hasElementWithClassName = function(doc, className) {
    // getElementsByClassName is not supported by IE<9
    // but is sometimes mocked via library code (which then doesn't return live node lists)
    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {
      return !!doc.querySelector("." + className);
    }

    var key         = _getDocumentIdentifier(doc) + ":" + className,
        cacheEntry  = LIVE_CACHE[key];
    if (!cacheEntry) {
      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);
    }

    return cacheEntry.length > 0;
  };
})(wysihtml5);
wysihtml5.dom.insert = function(elementToInsert) {
  return {
    after: function(element) {
      element.parentNode.insertBefore(elementToInsert, element.nextSibling);
    },
    
    before: function(element) {
      element.parentNode.insertBefore(elementToInsert, element);
    },
    
    into: function(element) {
      element.appendChild(elementToInsert);
    }
  };
};wysihtml5.dom.insertCSS = function(rules) {
  rules = rules.join("\n");
  
  return {
    into: function(doc) {
      var styleElement = doc.createElement("style");
      styleElement.type = "text/css";
      
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = rules;
      } else {
        styleElement.appendChild(doc.createTextNode(rules));
      }
      
      var link = doc.querySelector("head link");
      if (link) {
        link.parentNode.insertBefore(styleElement, link);
        return;
      } else {
        var head = doc.querySelector("head");
        if (head) {
          head.appendChild(styleElement);
        }
      }
    }
  };
};/**
 * Method to set dom events
 *
 * @example
 *    wysihtml5.dom.observe(iframe.contentWindow.document.body, ["focus", "blur"], function() { ... });
 */
wysihtml5.dom.observe = function(element, eventNames, handler) {
  eventNames = typeof(eventNames) === "string" ? [eventNames] : eventNames;
  
  var handlerWrapper,
      eventName,
      i       = 0,
      length  = eventNames.length;
  
  for (; i<length; i++) {
    eventName = eventNames[i];
    if (element.addEventListener) {
      element.addEventListener(eventName, handler, false);
    } else {
      handlerWrapper = function(event) {
        if (!("target" in event)) {
          event.target = event.srcElement;
        }
        event.preventDefault = event.preventDefault || function() {
          this.returnValue = false;
        };
        event.stopPropagation = event.stopPropagation || function() {
          this.cancelBubble = true;
        };
        handler.call(element, event);
      };
      element.attachEvent("on" + eventName, handlerWrapper);
    }
  }
  
  return {
    stop: function() {
      var eventName,
          i       = 0,
          length  = eventNames.length;
      for (; i<length; i++) {
        eventName = eventNames[i];
        if (element.removeEventListener) {
          element.removeEventListener(eventName, handler, false);
        } else {
          element.detachEvent("on" + eventName, handlerWrapper);
        }
      }
    }
  };
};
/**
 * HTML Sanitizer
 * Rewrites the HTML based on given rules
 *
 * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized
 * @param {Object} [rules] List of rules for rewriting the HTML, if there's no rule for an element it will
 *    be converted to a "span". Each rule is a key/value pair where key is the tag to convert, and value the
 *    desired substitution.
 * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing
 *
 * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.
 *
 * @example
 *    var userHTML = '<div id="foo" onclick="alert(1);"><p><font color="red">foo</font><script>alert(1);</script></p></div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      tags {
 *        p:      "div",      // Rename p tags to div tags
 *        font:   "span"      // Rename font tags to span tags
 *        div:    true,       // Keep them, also possible (same result when passing: "div" or true)
 *        script: undefined   // Remove script elements
 *      }
 *    });
 *    // => <div><div><span>foo bar</span></div></div>
 *
 *    var userHTML = '<table><tbody><tr><td>I'm a table!</td></tr></tbody></table>';
 *    wysihtml5.dom.parse(userHTML);
 *    // => '<span><span><span><span>I'm a table!</span></span></span></span>'
 *
 *    var userHTML = '<div>foobar<br>foobar</div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      tags: {
 *        div: undefined,
 *        br:  true
 *      }
 *    });
 *    // => ''
 *
 *    var userHTML = '<div class="red">foo</div><div class="pink">bar</div>';
 *    wysihtml5.dom.parse(userHTML, {
 *      classes: {
 *        red:    1,
 *        green:  1
 *      },
 *      tags: {
 *        div: {
 *          rename_tag:     "p"
 *        }
 *      }
 *    });
 *    // => '<p class="red">foo</p><p>bar</p>'
 */
wysihtml5.dom.parse = (function() {
  
  /**
   * It's not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML
   * new DOMParser().parseFromString('<img src="foo.gif">') will cause a parseError since the
   * node isn't closed
   *
   * Therefore we've to use the browser's ordinary HTML parser invoked by setting innerHTML.
   */
  var NODE_TYPE_MAPPING = {
        "1": _handleElement,
        "3": _handleText
      },
      // Rename unknown tags to this
      DEFAULT_NODE_NAME   = "span",
      WHITE_SPACE_REG_EXP = /\s+/,
      defaultRules        = { tags: {}, classes: {} },
      currentRules        = {};
  
  /**
   * Iterates over all childs of the element, recreates them, appends them into a document fragment
   * which later replaces the entire body content
   */
  function parse(elementOrHtml, rules, context, cleanUp) {
    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(rules).get();
    
    context           = context || elementOrHtml.ownerDocument || document;
    var fragment      = context.createDocumentFragment(),
        isString      = typeof(elementOrHtml) === "string",
        element,
        newNode,
        firstChild;
    
    if (isString) {
      element = wysihtml5.dom.getAsDom(elementOrHtml, context);
    } else {
      element = elementOrHtml;
    }
    
    while (element.firstChild) {
      firstChild  = element.firstChild;
      element.removeChild(firstChild);
      newNode = _convert(firstChild, cleanUp);
      if (newNode) {
        fragment.appendChild(newNode);
      }
    }
    
    // Clear element contents
    element.innerHTML = "";
    
    // Insert new DOM tree
    element.appendChild(fragment);
    
    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;
  }
  
  function _convert(oldNode, cleanUp) {
    var oldNodeType     = oldNode.nodeType,
        oldChilds       = oldNode.childNodes,
        oldChildsLength = oldChilds.length,
        method          = NODE_TYPE_MAPPING[oldNodeType],
        i               = 0,
        newNode,
        newChild;
    
    newNode = method && method(oldNode);
    
    if (!newNode) {
      return null;
    }
    
    for (i=0; i<oldChildsLength; i++) {
      newChild = _convert(oldChilds[i], cleanUp);
      if (newChild) {
        newNode.appendChild(newChild);
      }
    }
    
    // Cleanup senseless <span> elements
    if (cleanUp &&
        newNode.childNodes.length <= 1 &&
        newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME &&
        !newNode.attributes.length) {
      return newNode.firstChild;
    }
    
    return newNode;
  }
  
  function _handleElement(oldNode) {
    var rule,
        newNode,
        tagRules    = currentRules.tags,
        nodeName    = oldNode.nodeName.toLowerCase(),
        scopeName   = oldNode.scopeName;
    
    /**
     * We already parsed that element
     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)
     */
    if (oldNode._wysihtml5) {
      return null;
    }
    oldNode._wysihtml5 = 1;
    
    if (oldNode.className === "wysihtml5-temp") {
      return null;
    }
    
    /**
     * IE is the only browser who doesn't include the namespace in the
     * nodeName, that's why we have to prepend it by ourselves
     * scopeName is a proprietary IE feature
     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx
     */
    if (scopeName && scopeName != "HTML") {
      nodeName = scopeName + ":" + nodeName;
    }
    
    /**
     * Repair node
     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags
     * A <p> doesn't need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout
     */
    if ("outerHTML" in oldNode) {
      if (!wysihtml5.browser.autoClosesUnclosedTags() &&
          oldNode.nodeName === "P" &&
          oldNode.outerHTML.slice(-4).toLowerCase() !== "</p>") {
        nodeName = "div";
      }
    }
    
    if (nodeName in tagRules) {
      rule = tagRules[nodeName];
      if (!rule || rule.remove) {
        return null;
      }
      
      rule = typeof(rule) === "string" ? { rename_tag: rule } : rule;
    } else if (oldNode.firstChild) {
      rule = { rename_tag: DEFAULT_NODE_NAME };
    } else {
      // Remove empty unknown elements
      return null;
    }
    
    newNode = oldNode.ownerDocument.createElement(rule.rename_tag || nodeName);
    _handleAttributes(oldNode, newNode, rule);
    
    oldNode = null;
    return newNode;
  }
  
  function _handleAttributes(oldNode, newNode, rule) {
    var attributes          = {},                         // fresh new set of attributes to set on newNode
        setClass            = rule.set_class,             // classes to set
        addClass            = rule.add_class,             // add classes based on existing attributes
        setAttributes       = rule.set_attributes,        // attributes to set on the current node
        checkAttributes     = rule.check_attributes,      // check/convert values of attributes
        allowedClasses      = currentRules.classes,
        i                   = 0,
        classes             = [],
        newClasses          = [],
        newUniqueClasses    = [],
        oldClasses          = [],
        classesLength,
        newClassesLength,
        currentClass,
        newClass,
        attributeName,
        newAttributeValue,
        method;
    
    if (setAttributes) {
      attributes = wysihtml5.lang.object(setAttributes).clone();
    }
    
    if (checkAttributes) {
      for (attributeName in checkAttributes) {
        method = attributeCheckMethods[checkAttributes[attributeName]];
        if (!method) {
          continue;
        }
        newAttributeValue = method(_getAttribute(oldNode, attributeName));
        if (typeof(newAttributeValue) === "string") {
          attributes[attributeName] = newAttributeValue;
        }
      }
    }
    
    if (setClass) {
      classes.push(setClass);
    }
    
    if (addClass) {
      for (attributeName in addClass) {
        method = addClassMethods[addClass[attributeName]];
        if (!method) {
          continue;
        }
        newClass = method(_getAttribute(oldNode, attributeName));
        if (typeof(newClass) === "string") {
          classes.push(newClass);
        }
      }
    }
    
    // make sure that wysihtml5 temp class doesn't get stripped out
    allowedClasses["_wysihtml5-temp-placeholder"] = 1;
    
    // add old classes last
    oldClasses = oldNode.getAttribute("class");
    if (oldClasses) {
      classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));
    }
    classesLength = classes.length;
    for (; i<classesLength; i++) {
      currentClass = classes[i];
      if (allowedClasses[currentClass]) {
        newClasses.push(currentClass);
      }
    }
    
    // remove duplicate entries and preserve class specificity
    newClassesLength = newClasses.length;
    while (newClassesLength--) {
      currentClass = newClasses[newClassesLength];
      if (!wysihtml5.lang.array(newUniqueClasses).contains(currentClass)) {
        newUniqueClasses.unshift(currentClass);
      }
    }
    
    if (newUniqueClasses.length) {
      attributes["class"] = newUniqueClasses.join(" ");
    }
    
    // set attributes on newNode
    for (attributeName in attributes) {
      // Setting attributes can cause a js error in IE under certain circumstances
      // eg. on a <img> under https when it's new attribute value is non-https
      // TODO: Investigate this further and check for smarter handling
      try {
        newNode.setAttribute(attributeName, attributes[attributeName]);
      } catch(e) {}
    }
    
    // IE8 sometimes loses the width/height attributes when those are set before the "src"
    // so we make sure to set them again
    if (attributes.src) {
      if (typeof(attributes.width) !== "undefined") {
        newNode.setAttribute("width", attributes.width);
      }
      if (typeof(attributes.height) !== "undefined") {
        newNode.setAttribute("height", attributes.height);
      }
    }
  }
  
  /**
   * IE gives wrong results for hasAttribute/getAttribute, for example:
   *    var td = document.createElement("td");
   *    td.getAttribute("rowspan"); // => "1" in IE
   *
   * Therefore we have to check the element's outerHTML for the attribute
   */
  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();
  function _getAttribute(node, attributeName) {
    attributeName = attributeName.toLowerCase();
    var nodeName = node.nodeName;
    if (nodeName == "IMG" && attributeName == "src" && _isLoadedImage(node) === true) {
      // Get 'src' attribute value via object property since this will always contain the
      // full absolute url (http://...)
      // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host
      // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)
      return node.src;
    } else if (HAS_GET_ATTRIBUTE_BUG && "outerHTML" in node) {
      // Don't trust getAttribute/hasAttribute in IE 6-8, instead check the element's outerHTML
      var outerHTML      = node.outerHTML.toLowerCase(),
          // TODO: This might not work for attributes without value: <input disabled>
          hasAttribute   = outerHTML.indexOf(" " + attributeName +  "=") != -1;
      
      return hasAttribute ? node.getAttribute(attributeName) : null;
    } else{
      return node.getAttribute(attributeName);
    }
  }
  
  /**
   * Check whether the given node is a proper loaded image
   * FIXME: Returns undefined when unknown (Chrome, Safari)
   */
  function _isLoadedImage(node) {
    try {
      return node.complete && !node.mozMatchesSelector(":-moz-broken");
    } catch(e) {
      if (node.complete && node.readyState === "complete") {
        return true;
      }
    }
  }
  
  function _handleText(oldNode) {
    return oldNode.ownerDocument.createTextNode(oldNode.data);
  }
  
  
  // ------------ attribute checks ------------ \\
  var attributeCheckMethods = {
    url: (function() {
      var REG_EXP = /^https?:\/\//i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    src: (function() {
      var REG_EXP = /^(\/|https?:\/\/)/i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),

    href: (function() {
      var REG_EXP = /^(\/|https?:\/\/|mailto:)/i;
      return function(attributeValue) {
        if (!attributeValue || !attributeValue.match(REG_EXP)) {
          return null;
        }
        return attributeValue.replace(REG_EXP, function(match) {
          return match.toLowerCase();
        });
      };
    })(),
    
    alt: (function() {
      var REG_EXP = /[^ a-z0-9_\-]/gi;
      return function(attributeValue) {
        if (!attributeValue) {
          return "";
        }
        return attributeValue.replace(REG_EXP, "");
      };
    })(),
    
    numbers: (function() {
      var REG_EXP = /\D/g;
      return function(attributeValue) {
        attributeValue = (attributeValue || "").replace(REG_EXP, "");
        return attributeValue || null;
      };
    })()
  };
  
  // ------------ class converter (converts an html attribute to a class name) ------------ \\
  var addClassMethods = {
    align_img: (function() {
      var mapping = {
        left:   "wysiwyg-float-left",
        right:  "wysiwyg-float-right"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),
    
    align_text: (function() {
      var mapping = {
        left:     "wysiwyg-text-align-left",
        right:    "wysiwyg-text-align-right",
        center:   "wysiwyg-text-align-center",
        justify:  "wysiwyg-text-align-justify"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),
    
    clear_br: (function() {
      var mapping = {
        left:   "wysiwyg-clear-left",
        right:  "wysiwyg-clear-right",
        both:   "wysiwyg-clear-both",
        all:    "wysiwyg-clear-both"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).toLowerCase()];
      };
    })(),
    
    size_font: (function() {
      var mapping = {
        "1": "wysiwyg-font-size-xx-small",
        "2": "wysiwyg-font-size-small",
        "3": "wysiwyg-font-size-medium",
        "4": "wysiwyg-font-size-large",
        "5": "wysiwyg-font-size-x-large",
        "6": "wysiwyg-font-size-xx-large",
        "7": "wysiwyg-font-size-xx-large",
        "-": "wysiwyg-font-size-smaller",
        "+": "wysiwyg-font-size-larger"
      };
      return function(attributeValue) {
        return mapping[String(attributeValue).charAt(0)];
      };
    })()
  };
  
  return parse;
})();
/**
 * Checks for empty text node childs and removes them
 *
 * @param {Element} node The element in which to cleanup
 * @example
 *    wysihtml5.dom.removeEmptyTextNodes(element);
 */
wysihtml5.dom.removeEmptyTextNodes = function(node) {
  var childNode,
      childNodes        = wysihtml5.lang.array(node.childNodes).get(),
      childNodesLength  = childNodes.length,
      i                 = 0;
  for (; i<childNodesLength; i++) {
    childNode = childNodes[i];
    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === "") {
      childNode.parentNode.removeChild(childNode);
    }
  }
};
/**
 * Renames an element (eg. a <div> to a <p>) and keeps its childs
 *
 * @param {Element} element The list element which should be renamed
 * @param {Element} newNodeName The desired tag name
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <ul id="list">
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 *
 *    <script>
 *      wysihtml5.dom.renameElement(document.getElementById("list"), "ol");
 *    </script>
 *
 *    <!-- Will result in: -->
 *    <ol>
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ol>
 */
wysihtml5.dom.renameElement = function(element, newNodeName) {
  var newElement = element.ownerDocument.createElement(newNodeName),
      firstChild;
  while (firstChild = element.firstChild) {
    newElement.appendChild(firstChild);
  }
  wysihtml5.dom.copyAttributes(["align", "className"]).from(element).to(newElement);
  element.parentNode.replaceChild(newElement, element);
  return newElement;
};/**
 * Takes an element, removes it and replaces it with it's childs
 * 
 * @param {Object} node The node which to replace with it's child nodes
 * @example
 *    <div id="foo">
 *      <span>hello</span>
 *    </div>
 *    <script>
 *      // Remove #foo and replace with it's children
 *      wysihtml5.dom.replaceWithChildNodes(document.getElementById("foo"));
 *    </script>
 */
wysihtml5.dom.replaceWithChildNodes = function(node) {
  if (!node.parentNode) {
    return;
  }
  
  if (!node.firstChild) {
    node.parentNode.removeChild(node);
    return;
  }
  
  var fragment = node.ownerDocument.createDocumentFragment();
  while (node.firstChild) {
    fragment.appendChild(node.firstChild);
  }
  node.parentNode.replaceChild(fragment, node);
  node = fragment = null;
};
/**
 * Unwraps an unordered/ordered list
 *
 * @param {Element} element The list element which should be unwrapped
 *
 * @example
 *    <!-- Assume the following dom: -->
 *    <ul id="list">
 *      <li>eminem</li>
 *      <li>dr. dre</li>
 *      <li>50 Cent</li>
 *    </ul>
 *
 *    <script>
 *      wysihtml5.dom.resolveList(document.getElementById("list"));
 *    </script>
 *
 *    <!-- Will result in: -->
 *    eminem<br>
 *    dr. dre<br>
 *    50 Cent<br>
 */
(function(dom) {
  function _isBlockElement(node) {
    return dom.getStyle("display").from(node) === "block";
  }
  
  function _isLineBreak(node) {
    return node.nodeName === "BR";
  }
  
  function _appendLineBreak(element) {
    var lineBreak = element.ownerDocument.createElement("br");
    element.appendChild(lineBreak);
  }
  
  function resolveList(list, useLineBreaks) {
    if (!list.nodeName.match(/^(MENU|UL|OL)$/)) {
      return;
    }
    
    var doc             = list.ownerDocument,
        fragment        = doc.createDocumentFragment(),
        previousSibling = list.previousElementSibling || list.previousSibling,
        firstChild,
        lastChild,
        isLastChild,
        shouldAppendLineBreak,
        paragraph,
        listItem;
    
    if (useLineBreaks) {
      // Insert line break if list is after a non-block element
      if (previousSibling && !_isBlockElement(previousSibling)) {
        _appendLineBreak(fragment);
      }

      while (listItem = (list.firstElementChild || list.firstChild)) {
        lastChild = listItem.lastChild;
        while (firstChild = listItem.firstChild) {
          isLastChild           = firstChild === lastChild;
          // This needs to be done before appending it to the fragment, as it otherwise will lose style information
          shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);
          fragment.appendChild(firstChild);
          if (shouldAppendLineBreak) {
            _appendLineBreak(fragment);
          }
        }
        
        listItem.parentNode.removeChild(listItem);
      }
    } else {
      while (listItem = (list.firstElementChild || list.firstChild)) {
        if (listItem.querySelector && listItem.querySelector("div, p, ul, ol, menu, blockquote, h1, h2, h3, h4, h5, h6")) {
          while (firstChild = listItem.firstChild) {
            fragment.appendChild(firstChild);
          }
        } else {
          paragraph = doc.createElement("p");
          while (firstChild = listItem.firstChild) {
            paragraph.appendChild(firstChild);
          }
          fragment.appendChild(paragraph);
        }
        listItem.parentNode.removeChild(listItem);
      }
    }

    list.parentNode.replaceChild(fragment, list);
  }
  
  dom.resolveList = resolveList;
})(wysihtml5.dom);/**
 * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way
 *
 * Browser Compatibility:
 *  - Secure in MSIE 6+, but only when the user hasn't made changes to his security level "restricted"
 *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)
 *
 * Please note that this class can't benefit from the HTML5 sandbox attribute for the following reasons:
 *    - sandboxing doesn't work correctly with inlined content (src="javascript:'<html>...</html>'")
 *    - sandboxing of physical documents causes that the dom isn't accessible anymore from the outside (iframe.contentWindow, ...)
 *    - setting the "allow-same-origin" flag would fix that, but then still javascript and dom events refuse to fire
 *    - therefore the "allow-scripts" flag is needed, which then would deactivate any security, as the js executed inside the iframe
 *      can do anything as if the sandbox attribute wasn't set
 *
 * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready
 * @param {Object} [config] Optional parameters
 *
 * @example
 *    new wysihtml5.dom.Sandbox(function(sandbox) {
 *      sandbox.getWindow().document.body.innerHTML = '<img src=foo.gif onerror="alert(document.cookie)">';
 *    });
 */
(function(wysihtml5) {
  var /**
       * Default configuration
       */
      doc                 = document,
      /**
       * Properties to unset/protect on the window object
       */
      windowProperties    = [
        "parent", "top", "opener", "frameElement", "frames",
        "localStorage", "globalStorage", "sessionStorage", "indexedDB"
      ],
      /**
       * Properties on the window object which are set to an empty function
       */
      windowProperties2   = [
        "open", "close", "openDialog", "showModalDialog",
        "alert", "confirm", "prompt",
        "openDatabase", "postMessage",
        "XMLHttpRequest", "XDomainRequest"
      ],
      /**
       * Properties to unset/protect on the document object
       */
      documentProperties  = [
        "referrer",
        "write", "open", "close"
      ];
  
  wysihtml5.dom.Sandbox = Base.extend(
    /** @scope wysihtml5.dom.Sandbox.prototype */ {

    constructor: function(readyCallback, config) {
      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;
      this.config   = wysihtml5.lang.object({}).merge(config).get();
      this.iframe   = this._createIframe();
    },
    
    insertInto: function(element) {
      if (typeof(element) === "string") {
        element = doc.getElementById(element);
      }
      
      element.appendChild(this.iframe);
    },

    getIframe: function() {
      return this.iframe;
    },

    getWindow: function() {
      this._readyError();
    },

    getDocument: function() {
      this._readyError();
    },

    destroy: function() {
      var iframe = this.getIframe();
      iframe.parentNode.removeChild(iframe);
    },

    _readyError: function() {
      throw new Error("wysihtml5.Sandbox: Sandbox iframe isn't loaded yet");
    },

    /**
     * Creates the sandbox iframe
     *
     * Some important notes:
     *  - We can't use HTML5 sandbox for now:
     *    setting it causes that the iframe's dom can't be accessed from the outside
     *    Therefore we need to set the "allow-same-origin" flag which enables accessing the iframe's dom
     *    But then there's another problem, DOM events (focus, blur, change, keypress, ...) aren't fired.
     *    In order to make this happen we need to set the "allow-scripts" flag.
     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.
     *  - Chrome & Safari, doesn't seem to support sandboxing correctly when the iframe's html is inlined (no physical document)
     *  - IE needs to have the security="restricted" attribute set before the iframe is 
     *    inserted into the dom tree
     *  - Believe it or not but in IE "security" in document.createElement("iframe") is false, even
     *    though it supports it
     *  - When an iframe has security="restricted", in IE eval() & execScript() don't work anymore
     *  - IE doesn't fire the onload event when the content is inlined in the src attribute, therefore we rely
     *    on the onreadystatechange event
     */
    _createIframe: function() {
      var that   = this,
          iframe = doc.createElement("iframe");
      iframe.className = "wysihtml5-sandbox";
      wysihtml5.dom.setAttributes({
        "security":           "restricted",
        "allowtransparency":  "true",
        "frameborder":        0,
        "width":              0,
        "height":             0,
        "marginwidth":        0,
        "marginheight":       0
      }).on(iframe);

      // Setting the src like this prevents ssl warnings in IE6
      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {
        iframe.src = "javascript:'<html></html>'";
      }

      iframe.onload = function() {
        iframe.onreadystatechange = iframe.onload = null;
        that._onLoadIframe(iframe);
      };

      iframe.onreadystatechange = function() {
        if (/loaded|complete/.test(iframe.readyState)) {
          iframe.onreadystatechange = iframe.onload = null;
          that._onLoadIframe(iframe);
        }
      };

      return iframe;
    },

    /**
     * Callback for when the iframe has finished loading
     */
    _onLoadIframe: function(iframe) {
      // don't resume when the iframe got unloaded (eg. by removing it from the dom)
      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {
        return;
      }

      var that           = this,
          iframeWindow   = iframe.contentWindow,
          iframeDocument = iframe.contentWindow.document,
          charset        = doc.characterSet || doc.charset || "utf-8",
          sandboxHtml    = this._getHtml({
            charset:      charset,
            stylesheets:  this.config.stylesheets
          });

      // Create the basic dom tree including proper DOCTYPE and charset
      iframeDocument.open("text/html", "replace");
      iframeDocument.write(sandboxHtml);
      iframeDocument.close();

      this.getWindow = function() { return iframe.contentWindow; };
      this.getDocument = function() { return iframe.contentWindow.document; };

      // Catch js errors and pass them to the parent's onerror event
      // addEventListener("error") doesn't work properly in some browsers
      // TODO: apparently this doesn't work in IE9!
      iframeWindow.onerror = function(errorMessage, fileName, lineNumber) {
        throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);
      };

      if (!wysihtml5.browser.supportsSandboxedIframes()) {
        // Unset a bunch of sensitive variables
        // Please note: This isn't hack safe!  
        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information
        // IE is secure though, which is the most important thing, since IE is the only browser, who
        // takes over scripts & styles into contentEditable elements when copied from external websites
        // or applications (Microsoft Word, ...)
        var i, length;
        for (i=0, length=windowProperties.length; i<length; i++) {
          this._unset(iframeWindow, windowProperties[i]);
        }
        for (i=0, length=windowProperties2.length; i<length; i++) {
          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);
        }
        for (i=0, length=documentProperties.length; i<length; i++) {
          this._unset(iframeDocument, documentProperties[i]);
        }
        // This doesn't work in Safari 5 
        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit
        this._unset(iframeDocument, "cookie", "", true);
      }

      this.loaded = true;

      // Trigger the callback
      setTimeout(function() {
        // If the iframe has been removed, don't continue initializing
        if (wysihtml5.dom.contains(doc.documentElement, iframe)) {
          that.callback(that);
        }
      }, 0);
    },

    _getHtml: function(templateVars) {
      var stylesheets = templateVars.stylesheets,
          html        = "",
          i           = 0,
          length;
      stylesheets = typeof(stylesheets) === "string" ? [stylesheets] : stylesheets;
      if (stylesheets) {
        length = stylesheets.length;
        for (; i<length; i++) {
          html += '<link rel="stylesheet" href="' + stylesheets[i] + '">';
        }
      }
      templateVars.stylesheets = html;

      return wysihtml5.lang.string(
        '<!DOCTYPE html><html><head>'
        + '<meta charset="#{charset}">#{stylesheets}</head>'
        + '<body></body></html>'
      ).interpolate(templateVars);
    },

    /**
     * Method to unset/override existing variables
     * @example
     *    // Make cookie unreadable and unwritable
     *    this._unset(document, "cookie", "", true);
     */
    _unset: function(object, property, value, setter) {
      if (property != 'cookie') {
        // TODO: The following line sets a cookie with an empty name in
        // Chrome 54 and breaks all the other cookies set by the app.
        // The if clause is a temproray fix that will unblock users, but
        // we need to find a better solution (Upgrade the lib to 5.X or
        // replacing it altogether). - Anze
        try { object[property] = value; } catch(e) {}
      }

      try { object.__defineGetter__(property, function() { return value; }); } catch(e) {}
      if (setter) {
        try { object.__defineSetter__(property, function() {}); } catch(e) {}
      }

      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {
        try {
          var config = {
            get: function() { return value; }
          };
          if (setter) {
            config.set = function() {};
          }
          Object.defineProperty(object, property, config);
        } catch(e) {}
      }
    }
  });
})(wysihtml5);
(function() {
  var mapping = {
    "className": "class"
  };
  wysihtml5.dom.setAttributes = function(attributes) {
    return {
      on: function(element) {
        for (var i in attributes) {
          element.setAttribute(mapping[i] || i, attributes[i]);
        }
      }
    };
  };
})();wysihtml5.dom.setStyles = function(styles) {
  return {
    on: function(element) {
      var style = element.style;
      if (typeof(styles) === "string") {
        style.cssText += ";" + styles;
        return;
      }
      for (var i in styles) {
        if (i === "float") {
          style.cssFloat = styles[i];
          style.styleFloat = styles[i];
        } else {
          style[i] = styles[i];
        }
      }
    }
  };
};/**
 * Simulate HTML5 placeholder attribute
 *
 * Needed since
 *    - div[contentEditable] elements don't support it
 *    - older browsers (such as IE8 and Firefox 3.6) don't support it at all
 *
 * @param {Object} parent Instance of main wysihtml5.Editor class
 * @param {Element} view Instance of wysihtml5.views.* class
 * @param {String} placeholderText
 *
 * @example
 *    wysihtml.dom.simulatePlaceholder(this, composer, "Foobar");
 */
(function(dom) {
  dom.simulatePlaceholder = function(editor, view, placeholderText) {
    var CLASS_NAME = "placeholder",
        unset = function() {
          if (view.hasPlaceholderSet()) {
            view.clear();
          }
          view.placeholderSet = false;
          dom.removeClass(view.element, CLASS_NAME);
        },
        set = function() {
          if (view.isEmpty()) {
            view.placeholderSet = true;
            view.setValue(placeholderText);
            dom.addClass(view.element, CLASS_NAME);
          }
        };

    editor
      .on("set_placeholder", set)
      .on("unset_placeholder", unset)
      .on("focus:composer", unset)
      .on("paste:composer", unset)
      .on("blur:composer", set);

    set();
  };
})(wysihtml5.dom);
(function(dom) {
  var documentElement = document.documentElement;
  if ("textContent" in documentElement) {
    dom.setTextContent = function(element, text) {
      element.textContent = text;
    };

    dom.getTextContent = function(element) {
      return element.textContent;
    };
  } else if ("innerText" in documentElement) {
    dom.setTextContent = function(element, text) {
      element.innerText = text;
    };

    dom.getTextContent = function(element) {
      return element.innerText;
    };
  } else {
    dom.setTextContent = function(element, text) {
      element.nodeValue = text;
    };

    dom.getTextContent = function(element) {
      return element.nodeValue;
    };
  }
})(wysihtml5.dom);

/**
 * Fix most common html formatting misbehaviors of browsers implementation when inserting
 * content via copy & paste contentEditable
 *
 * @author Christopher Blum
 */
wysihtml5.quirks.cleanPastedHTML = (function() {
  // TODO: We probably need more rules here
  var defaultRules = {
    // When pasting underlined links <a> into a contentEditable, IE thinks, it has to insert <u> to keep the styling
    "a u": wysihtml5.dom.replaceWithChildNodes
  };
  
  function cleanPastedHTML(elementOrHtml, rules, context) {
    rules   = rules || defaultRules;
    context = context || elementOrHtml.ownerDocument || document;
    
    var element,
        isString = typeof(elementOrHtml) === "string",
        method,
        matches,
        matchesLength,
        i,
        j = 0;
    if (isString) {
      element = wysihtml5.dom.getAsDom(elementOrHtml, context);
    } else {
      element = elementOrHtml;
    }
    
    for (i in rules) {
      matches       = element.querySelectorAll(i);
      method        = rules[i];
      matchesLength = matches.length;
      for (; j<matchesLength; j++) {
        method(matches[j]);
      }
    }
    
    matches = elementOrHtml = rules = null;
    
    return isString ? element.innerHTML : element;
  }
  
  return cleanPastedHTML;
})();/**
 * IE and Opera leave an empty paragraph in the contentEditable element after clearing it
 *
 * @param {Object} contentEditableElement The contentEditable element to observe for clearing events
 * @exaple
 *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);
 */
wysihtml5.quirks.ensureProperClearing = (function() {
  var clearIfNecessary = function() {
    var element = this;
    setTimeout(function() {
      var innerHTML = element.innerHTML.toLowerCase();
      if (innerHTML == "<p>&nbsp;</p>" ||
          innerHTML == "<p>&nbsp;</p><p>&nbsp;</p>") {
        element.innerHTML = "";
      }
    }, 0);
  };

  return function(composer) {
    wysihtml5.dom.observe(composer.element, ["cut", "keydown"], clearIfNecessary);
  };
})();
// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398
//
// In Firefox this:
//      var d = document.createElement("div");
//      d.innerHTML ='<a href="~"></a>';
//      d.innerHTML;
// will result in:
//      <a href="%7E"></a>
// which is wrong
(function(wysihtml5) {
  var TILDE_ESCAPED = "%7E";
  wysihtml5.quirks.getCorrectInnerHTML = function(element) {
    var innerHTML = element.innerHTML;
    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {
      return innerHTML;
    }
    
    var elementsWithTilde = element.querySelectorAll("[href*='~'], [src*='~']"),
        url,
        urlToSearch,
        length,
        i;
    for (i=0, length=elementsWithTilde.length; i<length; i++) {
      url         = elementsWithTilde[i].href || elementsWithTilde[i].src;
      urlToSearch = wysihtml5.lang.string(url).replace("~").by(TILDE_ESCAPED);
      innerHTML   = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);
    }
    return innerHTML;
  };
})(wysihtml5);/**
 * Force rerendering of a given element
 * Needed to fix display misbehaviors of IE
 *
 * @param {Element} element The element object which needs to be rerendered
 * @example
 *    wysihtml5.quirks.redraw(document.body);
 */
(function(wysihtml5) {
  var CLASS_NAME = "wysihtml5-quirks-redraw";
  
  wysihtml5.quirks.redraw = function(element) {
    wysihtml5.dom.addClass(element, CLASS_NAME);
    wysihtml5.dom.removeClass(element, CLASS_NAME);
    
    // Following hack is needed for firefox to make sure that image resize handles are properly removed
    try {
      var doc = element.ownerDocument;
      doc.execCommand("italic", false, null);
      doc.execCommand("italic", false, null);
    } catch(e) {}
  };
})(wysihtml5);/**
 * Selection API
 *
 * @example
 *    var selection = new wysihtml5.Selection(editor);
 */
(function(wysihtml5) {
  var dom = wysihtml5.dom;
  
  function _getCumulativeOffsetTop(element) {
    var top = 0;
    if (element.parentNode) {
      do {
        top += element.offsetTop || 0;
        element = element.offsetParent;
      } while (element);
    }
    return top;
  }
  
  wysihtml5.Selection = Base.extend(
    /** @scope wysihtml5.Selection.prototype */ {
    constructor: function(editor) {
      // Make sure that our external range library is initialized
      window.rangy.init();
      
      this.editor   = editor;
      this.composer = editor.composer;
      this.doc      = this.composer.doc;
    },
    
    /**
     * Get the current selection as a bookmark to be able to later restore it
     *
     * @return {Object} An object that represents the current selection
     */
    getBookmark: function() {
      var range = this.getRange();
      return range && range.cloneRange();
    },

    /**
     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark
     *
     * @param {Object} bookmark An object that represents the current selection
     */
    setBookmark: function(bookmark) {
      if (!bookmark) {
        return;
      }

      this.setSelection(bookmark);
    },

    /**
     * Set the caret in front of the given node
     *
     * @param {Object} node The element or text node where to position the caret in front of
     * @example
     *    selection.setBefore(myElement);
     */
    setBefore: function(node) {
      var range = rangy.createRange(this.doc);
      range.setStartBefore(node);
      range.setEndBefore(node);
      return this.setSelection(range);
    },

    /**
     * Set the caret after the given node
     *
     * @param {Object} node The element or text node where to position the caret in front of
     * @example
     *    selection.setBefore(myElement);
     */
    setAfter: function(node) {
      var range = rangy.createRange(this.doc);
      range.setStartAfter(node);
      range.setEndAfter(node);
      return this.setSelection(range);
    },

    /**
     * Ability to select/mark nodes
     *
     * @param {Element} node The node/element to select
     * @example
     *    selection.selectNode(document.getElementById("my-image"));
     */
    selectNode: function(node, avoidInvisibleSpace) {
      var range           = rangy.createRange(this.doc),
          isElement       = node.nodeType === wysihtml5.ELEMENT_NODE,
          canHaveHTML     = "canHaveHTML" in node ? node.canHaveHTML : (node.nodeName !== "IMG"),
          content         = isElement ? node.innerHTML : node.data,
          isEmpty         = (content === "" || content === wysihtml5.INVISIBLE_SPACE),
          displayStyle    = dom.getStyle("display").from(node),
          isBlockElement  = (displayStyle === "block" || displayStyle === "list-item");

      if (isEmpty && isElement && canHaveHTML && !avoidInvisibleSpace) {
        // Make sure that caret is visible in node by inserting a zero width no breaking space
        try { node.innerHTML = wysihtml5.INVISIBLE_SPACE; } catch(e) {}
      }

      if (canHaveHTML) {
        range.selectNodeContents(node);
      } else {
        range.selectNode(node);
      }

      if (canHaveHTML && isEmpty && isElement) {
        range.collapse(isBlockElement);
      } else if (canHaveHTML && isEmpty) {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }

      this.setSelection(range);
    },

    /**
     * Get the node which contains the selection
     *
     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a "ControlRange"
     * @return {Object} The node that contains the caret
     * @example
     *    var nodeThatContainsCaret = selection.getSelectedNode();
     */
    getSelectedNode: function(controlRange) {
      var selection,
          range;

      if (controlRange && this.doc.selection && this.doc.selection.type === "Control") {
        range = this.doc.selection.createRange();
        if (range && range.length) {
          return range.item(0);
        }
      }

      selection = this.getSelection(this.doc);
      if (selection.focusNode === selection.anchorNode) {
        return selection.focusNode;
      } else {
        range = this.getRange(this.doc);
        return range ? range.commonAncestorContainer : this.doc.body;
      }
    },

    executeAndRestore: function(method, restoreScrollPosition) {
      var body                  = this.doc.body,
          oldScrollTop          = restoreScrollPosition && body.scrollTop,
          oldScrollLeft         = restoreScrollPosition && body.scrollLeft,
          className             = "_wysihtml5-temp-placeholder",
          placeholderHtml       = '<span class="' + className + '">' + wysihtml5.INVISIBLE_SPACE + '</span>',
          range                 = this.getRange(this.doc),
          caretPlaceholder,
          newCaretPlaceholder,
          nextSibling,
          node,
          newRange;
      
      // Nothing selected, execute and say goodbye
      if (!range) {
        method(body, body);
        return;
      }
      
      if (wysihtml5.browser.hasInsertNodeIssue()) {
        this.doc.execCommand("insertHTML", false, placeholderHtml);
      } else {
        node = range.createContextualFragment(placeholderHtml);
        range.insertNode(node);
      }
      
      // Make sure that a potential error doesn't cause our placeholder element to be left as a placeholder
      try {
        method(range.startContainer, range.endContainer);
      } catch(e) {
        setTimeout(function() { throw e; }, 0);
      }
      
      caretPlaceholder = this.doc.querySelector("." + className);
      if (caretPlaceholder) {
        newRange = rangy.createRange(this.doc);
        nextSibling = caretPlaceholder.nextSibling;
        // Opera is so fucked up when you wanna set focus before a <br>
        if (wysihtml5.browser.hasInsertNodeIssue() && nextSibling && nextSibling.nodeName === "BR") {
          newCaretPlaceholder = this.doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
          dom.insert(newCaretPlaceholder).after(caretPlaceholder);
          newRange.setStartBefore(newCaretPlaceholder);
          newRange.setEndBefore(newCaretPlaceholder);
        } else {
          newRange.selectNode(caretPlaceholder);
          newRange.deleteContents();
        }
        this.setSelection(newRange);
      } else {
        // fallback for when all hell breaks loose
        body.focus();
      }

      if (restoreScrollPosition) {
        body.scrollTop  = oldScrollTop;
        body.scrollLeft = oldScrollLeft;
      }

      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree
      try {
        caretPlaceholder.parentNode.removeChild(caretPlaceholder);
      } catch(e2) {}
    },

    /**
     * Different approach of preserving the selection (doesn't modify the dom)
     * Takes all text nodes in the selection and saves the selection position in the first and last one
     */
    executeAndRestoreSimple: function(method) {
      var range = this.getRange(),
          body  = this.doc.body,
          newRange,
          firstNode,
          lastNode,
          textNodes,
          rangeBackup;

      // Nothing selected, execute and say goodbye
      if (!range) {
        method(body, body);
        return;
      }

      textNodes = range.getNodes([3]);
      firstNode = textNodes[0] || range.startContainer;
      lastNode  = textNodes[textNodes.length - 1] || range.endContainer;

      rangeBackup = {
        collapsed:      range.collapsed,
        startContainer: firstNode,
        startOffset:    firstNode === range.startContainer ? range.startOffset : 0,
        endContainer:   lastNode,
        endOffset:      lastNode === range.endContainer ? range.endOffset : lastNode.length
      };

      try {
        method(range.startContainer, range.endContainer);
      } catch(e) {
        setTimeout(function() { throw e; }, 0);
      }

      newRange = rangy.createRange(this.doc);
      try { newRange.setStart(rangeBackup.startContainer, rangeBackup.startOffset); } catch(e1) {}
      try { newRange.setEnd(rangeBackup.endContainer, rangeBackup.endOffset); } catch(e2) {}
      try { this.setSelection(newRange); } catch(e3) {}
    },
    
    set: function(node, offset) {
      var newRange = rangy.createRange(this.doc);
      newRange.setStart(node, offset || 0);
      this.setSelection(newRange);
    },
    
    /**
     * Insert html at the caret position and move the cursor after the inserted html
     *
     * @param {String} html HTML string to insert
     * @example
     *    selection.insertHTML("<p>foobar</p>");
     */
    insertHTML: function(html) {
      var range     = rangy.createRange(this.doc),
          node      = range.createContextualFragment(html),
          lastChild = node.lastChild;
      this.insertNode(node);
      if (lastChild) {
        this.setAfter(lastChild);
      }
    },

    /**
     * Insert a node at the caret position and move the cursor behind it
     *
     * @param {Object} node HTML string to insert
     * @example
     *    selection.insertNode(document.createTextNode("foobar"));
     */
    insertNode: function(node) {
      var range = this.getRange();
      if (range) {
        range.insertNode(node);
      }
    },

    /**
     * Wraps current selection with the given node
     *
     * @param {Object} node The node to surround the selected elements with
     */
    surround: function(node) {
      var range = this.getRange();
      if (!range) {
        return;
      }

      try {
        // This only works when the range boundaries are not overlapping other elements
        range.surroundContents(node);
        this.selectNode(node);
      } catch(e) {
        // fallback
        node.appendChild(range.extractContents());
        range.insertNode(node);
      }
    },

    /**
     * Scroll the current caret position into the view
     * FIXME: This is a bit hacky, there might be a smarter way of doing this
     *
     * @example
     *    selection.scrollIntoView();
     */
    scrollIntoView: function() {
      var doc           = this.doc,
          tolerance     = 5, // px
          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,
          tempElement   = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || (function() {
            var element = doc.createElement("span");
            // The element needs content in order to be able to calculate it's position properly
            element.innerHTML = wysihtml5.INVISIBLE_SPACE;
            return element;
          })(),
          offsetTop;

      if (hasScrollBars) {
        this.insertNode(tempElement);
        offsetTop = _getCumulativeOffsetTop(tempElement);
        tempElement.parentNode.removeChild(tempElement);
        if (offsetTop >= (doc.body.scrollTop + doc.documentElement.offsetHeight - tolerance)) {
          doc.body.scrollTop = offsetTop;
        }
      }
    },

    /**
     * Select line where the caret is in
     */
    selectLine: function() {
      if (wysihtml5.browser.supportsSelectionModify()) {
        this._selectLine_W3C();
      } else if (this.doc.selection) {
        this._selectLine_MSIE();
      }
    },

    /**
     * See https://developer.mozilla.org/en/DOM/Selection/modify
     */
    _selectLine_W3C: function() {
      var win       = this.doc.defaultView,
          selection = win.getSelection();
      selection.modify("extend", "left", "lineboundary");
      selection.modify("extend", "right", "lineboundary");
    },

    _selectLine_MSIE: function() {
      var range       = this.doc.selection.createRange(),
          rangeTop    = range.boundingTop,
          scrollWidth = this.doc.body.scrollWidth,
          rangeBottom,
          rangeEnd,
          measureNode,
          i,
          j;

      if (!range.moveToPoint) {
        return;
      }

      if (rangeTop === 0) {
        // Don't know why, but when the selection ends at the end of a line
        // range.boundingTop is 0
        measureNode = this.doc.createElement("span");
        this.insertNode(measureNode);
        rangeTop = measureNode.offsetTop;
        measureNode.parentNode.removeChild(measureNode);
      }

      rangeTop += 1;

      for (i=-10; i<scrollWidth; i+=2) {
        try {
          range.moveToPoint(i, rangeTop);
          break;
        } catch(e1) {}
      }

      // Investigate the following in order to handle multi line selections
      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);
      rangeBottom = rangeTop;
      rangeEnd = this.doc.selection.createRange();
      for (j=scrollWidth; j>=0; j--) {
        try {
          rangeEnd.moveToPoint(j, rangeBottom);
          break;
        } catch(e2) {}
      }

      range.setEndPoint("EndToEnd", rangeEnd);
      range.select();
    },

    getText: function() {
      var selection = this.getSelection();
      return selection ? selection.toString() : "";
    },

    getNodes: function(nodeType, filter) {
      var range = this.getRange();
      if (range) {
        return range.getNodes([nodeType], filter);
      } else {
        return [];
      }
    },
    
    getRange: function() {
      var selection = this.getSelection();
      return selection && selection.rangeCount && selection.getRangeAt(0);
    },

    getSelection: function() {
      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);
    },

    setSelection: function(range) {
      var win       = this.doc.defaultView || this.doc.parentWindow,
          selection = rangy.getSelection(win);
      return selection.setSingleRange(range);
    }
  });
  
})(wysihtml5);
/**
 * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.
 * http://code.google.com/p/rangy/
 *
 * changed in order to be able ...
 *    - to use custom tags
 *    - to detect and replace similar css classes via reg exp
 */
(function(wysihtml5, rangy) {
  var defaultTagName = "span";
  
  var REG_EXP_WHITE_SPACE = /\s+/g;
  
  function hasClass(el, cssClass, regExp) {
    if (!el.className) {
      return false;
    }
    
    var matchingClassNames = el.className.match(regExp) || [];
    return matchingClassNames[matchingClassNames.length - 1] === cssClass;
  }

  function addClass(el, cssClass, regExp) {
    if (el.className) {
      removeClass(el, regExp);
      el.className += " " + cssClass;
    } else {
      el.className = cssClass;
    }
  }

  function removeClass(el, regExp) {
    if (el.className) {
      el.className = el.className.replace(regExp, "");
    }
  }
  
  function hasSameClasses(el1, el2) {
    return el1.className.replace(REG_EXP_WHITE_SPACE, " ") == el2.className.replace(REG_EXP_WHITE_SPACE, " ");
  }

  function replaceWithOwnChildren(el) {
    var parent = el.parentNode;
    while (el.firstChild) {
      parent.insertBefore(el.firstChild, el);
    }
    parent.removeChild(el);
  }

  function elementsHaveSameNonClassAttributes(el1, el2) {
    if (el1.attributes.length != el2.attributes.length) {
      return false;
    }
    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {
      attr1 = el1.attributes[i];
      name = attr1.name;
      if (name != "class") {
        attr2 = el2.attributes.getNamedItem(name);
        if (attr1.specified != attr2.specified) {
          return false;
        }
        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {
          return false;
        }
      }
    }
    return true;
  }

  function isSplitPoint(node, offset) {
    if (rangy.dom.isCharacterDataNode(node)) {
      if (offset == 0) {
        return !!node.previousSibling;
      } else if (offset == node.length) {
        return !!node.nextSibling;
      } else {
        return true;
      }
    }

    return offset > 0 && offset < node.childNodes.length;
  }

  function splitNodeAt(node, descendantNode, descendantOffset) {
    var newNode;
    if (rangy.dom.isCharacterDataNode(descendantNode)) {
      if (descendantOffset == 0) {
        descendantOffset = rangy.dom.getNodeIndex(descendantNode);
        descendantNode = descendantNode.parentNode;
      } else if (descendantOffset == descendantNode.length) {
        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;
        descendantNode = descendantNode.parentNode;
      } else {
        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);
      }
    }
    if (!newNode) {
      newNode = descendantNode.cloneNode(false);
      if (newNode.id) {
        newNode.removeAttribute("id");
      }
      var child;
      while ((child = descendantNode.childNodes[descendantOffset])) {
        newNode.appendChild(child);
      }
      rangy.dom.insertAfter(newNode, descendantNode);
    }
    return (descendantNode == node) ? newNode : splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode));
  }
  
  function Merge(firstNode) {
    this.isElementMerge = (firstNode.nodeType == wysihtml5.ELEMENT_NODE);
    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;
    this.textNodes = [this.firstTextNode];
  }

  Merge.prototype = {
    doMerge: function() {
      var textBits = [], textNode, parent, text;
      for (var i = 0, len = this.textNodes.length; i < len; ++i) {
        textNode = this.textNodes[i];
        parent = textNode.parentNode;
        textBits[i] = textNode.data;
        if (i) {
          parent.removeChild(textNode);
          if (!parent.hasChildNodes()) {
            parent.parentNode.removeChild(parent);
          }
        }
      }
      this.firstTextNode.data = text = textBits.join("");
      return text;
    },

    getLength: function() {
      var i = this.textNodes.length, len = 0;
      while (i--) {
        len += this.textNodes[i].length;
      }
      return len;
    },

    toString: function() {
      var textBits = [];
      for (var i = 0, len = this.textNodes.length; i < len; ++i) {
        textBits[i] = "'" + this.textNodes[i].data + "'";
      }
      return "[Merge(" + textBits.join(",") + ")]";
    }
  };

  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize) {
    this.tagNames = tagNames || [defaultTagName];
    this.cssClass = cssClass || "";
    this.similarClassRegExp = similarClassRegExp;
    this.normalize = normalize;
    this.applyToAnyTagName = false;
  }

  HTMLApplier.prototype = {
    getAncestorWithClass: function(node) {
      var cssClassMatch;
      while (node) {
        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : true;
        if (node.nodeType == wysihtml5.ELEMENT_NODE && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {
          return node;
        }
        node = node.parentNode;
      }
      return false;
    },

    // Normalizes nodes after applying a CSS class to a Range.
    postApply: function(textNodes, range) {
      var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];

      var merges = [], currentMerge;

      var rangeStartNode = firstNode, rangeEndNode = lastNode;
      var rangeStartOffset = 0, rangeEndOffset = lastNode.length;

      var textNode, precedingTextNode;

      for (var i = 0, len = textNodes.length; i < len; ++i) {
        textNode = textNodes[i];
        precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);
        if (precedingTextNode) {
          if (!currentMerge) {
            currentMerge = new Merge(precedingTextNode);
            merges.push(currentMerge);
          }
          currentMerge.textNodes.push(textNode);
          if (textNode === firstNode) {
            rangeStartNode = currentMerge.firstTextNode;
            rangeStartOffset = rangeStartNode.length;
          }
          if (textNode === lastNode) {
            rangeEndNode = currentMerge.firstTextNode;
            rangeEndOffset = currentMerge.getLength();
          }
        } else {
          currentMerge = null;
        }
      }

      // Test whether the first node after the range needs merging
      var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);
      if (nextTextNode) {
        if (!currentMerge) {
          currentMerge = new Merge(lastNode);
          merges.push(currentMerge);
        }
        currentMerge.textNodes.push(nextTextNode);
      }

      // Do the merges
      if (merges.length) {
        for (i = 0, len = merges.length; i < len; ++i) {
          merges[i].doMerge();
        }
        // Set the range boundaries
        range.setStart(rangeStartNode, rangeStartOffset);
        range.setEnd(rangeEndNode, rangeEndOffset);
      }
    },
    
    getAdjacentMergeableTextNode: function(node, forward) {
        var isTextNode = (node.nodeType == wysihtml5.TEXT_NODE);
        var el = isTextNode ? node.parentNode : node;
        var adjacentNode;
        var propName = forward ? "nextSibling" : "previousSibling";
        if (isTextNode) {
          // Can merge if the node's previous/next sibling is a text node
          adjacentNode = node[propName];
          if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {
            return adjacentNode;
          }
        } else {
          // Compare element with its sibling
          adjacentNode = el[propName];
          if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {
            return adjacentNode[forward ? "firstChild" : "lastChild"];
          }
        }
        return null;
    },
    
    areElementsMergeable: function(el1, el2) {
      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || "").toLowerCase())
        && rangy.dom.arrayContains(this.tagNames, (el2.tagName || "").toLowerCase())
        && hasSameClasses(el1, el2)
        && elementsHaveSameNonClassAttributes(el1, el2);
    },

    createContainer: function(doc) {
      var el = doc.createElement(this.tagNames[0]);
      if (this.cssClass) {
        el.className = this.cssClass;
      }
      return el;
    },

    applyToTextNode: function(textNode) {
      var parent = textNode.parentNode;
      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {
        if (this.cssClass) {
          addClass(parent, this.cssClass, this.similarClassRegExp);
        }
      } else {
        var el = this.createContainer(rangy.dom.getDocument(textNode));
        textNode.parentNode.insertBefore(el, textNode);
        el.appendChild(textNode);
      }
    },

    isRemovable: function(el) {
      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) && wysihtml5.lang.string(el.className).trim() == this.cssClass;
    },

    undoToTextNode: function(textNode, range, ancestorWithClass) {
      if (!range.containsNode(ancestorWithClass)) {
        // Split out the portion of the ancestor from which we can remove the CSS class
        var ancestorRange = range.cloneRange();
        ancestorRange.selectNode(ancestorWithClass);

        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {
          splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset);
          range.setEndAfter(ancestorWithClass);
        }
        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {
          ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset);
        }
      }
      
      if (this.similarClassRegExp) {
        removeClass(ancestorWithClass, this.similarClassRegExp);
      }
      if (this.isRemovable(ancestorWithClass)) {
        replaceWithOwnChildren(ancestorWithClass);
      }
    },

    applyToRange: function(range) {
        var textNodes = range.getNodes([wysihtml5.TEXT_NODE]);
        if (!textNodes.length) {
          try {
            var node = this.createContainer(range.endContainer.ownerDocument);
            range.surroundContents(node);
            this.selectNode(range, node);
            return;
          } catch(e) {}
        }
        
        range.splitBoundaries();
        textNodes = range.getNodes([wysihtml5.TEXT_NODE]);
        
        if (textNodes.length) {
          var textNode;

          for (var i = 0, len = textNodes.length; i < len; ++i) {
            textNode = textNodes[i];
            if (!this.getAncestorWithClass(textNode)) {
              this.applyToTextNode(textNode);
            }
          }
          
          range.setStart(textNodes[0], 0);
          textNode = textNodes[textNodes.length - 1];
          range.setEnd(textNode, textNode.length);
          
          if (this.normalize) {
            this.postApply(textNodes, range);
          }
        }
    },

    undoToRange: function(range) {
      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]), textNode, ancestorWithClass;
      if (textNodes.length) {
        range.splitBoundaries();
        textNodes = range.getNodes([wysihtml5.TEXT_NODE]);
      } else {
        var doc = range.endContainer.ownerDocument,
            node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
        range.insertNode(node);
        range.selectNode(node);
        textNodes = [node];
      }
      
      for (var i = 0, len = textNodes.length; i < len; ++i) {
        textNode = textNodes[i];
        ancestorWithClass = this.getAncestorWithClass(textNode);
        if (ancestorWithClass) {
          this.undoToTextNode(textNode, range, ancestorWithClass);
        }
      }
      
      if (len == 1) {
        this.selectNode(range, textNodes[0]);
      } else {
        range.setStart(textNodes[0], 0);
        textNode = textNodes[textNodes.length - 1];
        range.setEnd(textNode, textNode.length);

        if (this.normalize) {
          this.postApply(textNodes, range);
        }
      }
    },
    
    selectNode: function(range, node) {
      var isElement       = node.nodeType === wysihtml5.ELEMENT_NODE,
          canHaveHTML     = "canHaveHTML" in node ? node.canHaveHTML : true,
          content         = isElement ? node.innerHTML : node.data,
          isEmpty         = (content === "" || content === wysihtml5.INVISIBLE_SPACE);

      if (isEmpty && isElement && canHaveHTML) {
        // Make sure that caret is visible in node by inserting a zero width no breaking space
        try { node.innerHTML = wysihtml5.INVISIBLE_SPACE; } catch(e) {}
      }
      range.selectNodeContents(node);
      if (isEmpty && isElement) {
        range.collapse(false);
      } else if (isEmpty) {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }
    },
    
    getTextSelectedByRange: function(textNode, range) {
      var textRange = range.cloneRange();
      textRange.selectNodeContents(textNode);

      var intersectionRange = textRange.intersection(range);
      var text = intersectionRange ? intersectionRange.toString() : "";
      textRange.detach();

      return text;
    },

    isAppliedToRange: function(range) {
      var ancestors = [],
          ancestor,
          textNodes = range.getNodes([wysihtml5.TEXT_NODE]);
      if (!textNodes.length) {
        ancestor = this.getAncestorWithClass(range.startContainer);
        return ancestor ? [ancestor] : false;
      }
      
      for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {
        selectedText = this.getTextSelectedByRange(textNodes[i], range);
        ancestor = this.getAncestorWithClass(textNodes[i]);
        if (selectedText != "" && !ancestor) {
          return false;
        } else {
          ancestors.push(ancestor);
        }
      }
      return ancestors;
    },

    toggleRange: function(range) {
      if (this.isAppliedToRange(range)) {
        this.undoToRange(range);
      } else {
        this.applyToRange(range);
      }
    }
  };

  wysihtml5.selection.HTMLApplier = HTMLApplier;
  
})(wysihtml5, rangy);/**
 * Rich Text Query/Formatting Commands
 * 
 * @example
 *    var commands = new wysihtml5.Commands(editor);
 */
wysihtml5.Commands = Base.extend(
  /** @scope wysihtml5.Commands.prototype */ {
  constructor: function(editor) {
    this.editor   = editor;
    this.composer = editor.composer;
    this.doc      = this.composer.doc;
  },
  
  /**
   * Check whether the browser supports the given command
   *
   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")
   * @example
   *    commands.supports("createLink");
   */
  support: function(command) {
    return wysihtml5.browser.supportsCommand(this.doc, command);
  },
  
  /**
   * Check whether the browser supports the given command
   *
   * @param {String} command The command string which to execute (eg. "bold", "italic", "insertUnorderedList")
   * @param {String} [value] The command value parameter, needed for some commands ("createLink", "insertImage", ...), optional for commands that don't require one ("bold", "underline", ...)
   * @example
   *    commands.exec("insertImage", "http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg");
   */
  exec: function(command, value) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.exec,
        result  = null;
    
    this.editor.fire("beforecommand:composer");
    
    if (method) {
      args.unshift(this.composer);
      result = method.apply(obj, args);
    } else {
      try {
        // try/catch for buggy firefox
        result = this.doc.execCommand(command, false, value);
      } catch(e) {}
    }
    
    this.editor.fire("aftercommand:composer");
    return result;
  },
  
  /**
   * Check whether the current command is active
   * If the caret is within a bold text, then calling this with command "bold" should return true
   *
   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")
   * @param {String} [commandValue] The command value parameter (eg. for "insertImage" the image src)
   * @return {Boolean} Whether the command is active
   * @example
   *    var isCurrentSelectionBold = commands.state("bold");
   */
  state: function(command, commandValue) {
    var obj     = wysihtml5.commands[command],
        args    = wysihtml5.lang.array(arguments).get(),
        method  = obj && obj.state;
    if (method) {
      args.unshift(this.composer);
      return method.apply(obj, args);
    } else {
      try {
        // try/catch for buggy firefox
        return this.doc.queryCommandState(command);
      } catch(e) {
        return false;
      }
    }
  }
});
wysihtml5.commands.bold = {
  exec: function(composer, command) {
    return wysihtml5.commands.formatInline.exec(composer, command, "b");
  },

  state: function(composer, command) {
    // element.ownerDocument.queryCommandState("bold") results:
    // firefox: only <b>
    // chrome:  <b>, <strong>, <h1>, <h2>, ...
    // ie:      <b>, <strong>
    // opera:   <b>, <strong>
    return wysihtml5.commands.formatInline.state(composer, command, "b");
  }
};

(function(wysihtml5) {
  var undef,
      NODE_NAME = "A",
      dom       = wysihtml5.dom;
  
  function _removeFormat(composer, anchors) {
    var length  = anchors.length,
        i       = 0,
        anchor,
        codeElement,
        textContent;
    for (; i<length; i++) {
      anchor      = anchors[i];
      codeElement = dom.getParentElement(anchor, { nodeName: "code" });
      textContent = dom.getTextContent(anchor);

      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking
      // else replace <a> with its childNodes
      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {
        // <code> element is used to prevent later auto-linking of the content
        codeElement = dom.renameElement(anchor, "code");
      } else {
        dom.replaceWithChildNodes(anchor);
      }
    }
  }

  function _format(composer, attributes) {
    var doc             = composer.doc,
        tempClass       = "_wysihtml5-temp-" + (+new Date()),
        tempClassRegExp = /non-matching-class/g,
        i               = 0,
        length,
        anchors,
        anchor,
        hasElementChild,
        isEmpty,
        elementToSetCaretAfter,
        textContent,
        whiteSpace,
        j;
    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp);
    anchors = doc.querySelectorAll(NODE_NAME + "." + tempClass);
    length  = anchors.length;
    for (; i<length; i++) {
      anchor = anchors[i];
      anchor.removeAttribute("class");
      for (j in attributes) {
        anchor.setAttribute(j, attributes[j]);
      }
    }

    elementToSetCaretAfter = anchor;
    if (length === 1) {
      textContent = dom.getTextContent(anchor);
      hasElementChild = !!anchor.querySelector("*");
      isEmpty = textContent === "" || textContent === wysihtml5.INVISIBLE_SPACE;
      if (!hasElementChild && isEmpty) {
        dom.setTextContent(anchor, attributes.text || anchor.href);
        whiteSpace = doc.createTextNode(" ");
        composer.selection.setAfter(anchor);
        dom.insert(whiteSpace).after(anchor);
        elementToSetCaretAfter = whiteSpace;
      }
    }
    composer.selection.setAfter(elementToSetCaretAfter);
  }
  
  wysihtml5.commands.createLink = {
    /**
     * TODO: Use HTMLApplier or formatInline here
     *
     * Turns selection into a link
     * If selection is already a link, it removes the link and wraps it with a <code> element
     * The <code> element is needed to avoid auto linking
     * 
     * @example
     *    // either ...
     *    wysihtml5.commands.createLink.exec(composer, "createLink", "http://www.google.de");
     *    // ... or ...
     *    wysihtml5.commands.createLink.exec(composer, "createLink", { href: "http://www.google.de", target: "_blank" });
     */
    exec: function(composer, command, value) {
      var anchors = this.state(composer, command);
      if (anchors) {
        // Selection contains links
        composer.selection.executeAndRestore(function() {
          _removeFormat(composer, anchors);
        });
      } else {
        // Create links
        value = typeof(value) === "object" ? value : { href: value };
        _format(composer, value);
      }
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatInline.state(composer, command, "A");
    }
  };
})(wysihtml5);/**
 * document.execCommand("fontSize") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var undef,
      REG_EXP = /wysiwyg-font-size-[0-9a-z\-]+/g;
  
  wysihtml5.commands.fontSize = {
    exec: function(composer, command, size) {
      return wysihtml5.commands.formatInline.exec(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);
    },

    state: function(composer, command, size) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);
    },

    value: function() {
      return undef;
    }
  };
})(wysihtml5);
/**
 * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags
 * which we don't want
 * Instead we set a css class
 */
(function(wysihtml5) {
  var REG_EXP = /wysiwyg-color-[0-9a-z]+/g;
  
  wysihtml5.commands.foreColor = {
    exec: function(composer, command, color) {
      return wysihtml5.commands.formatInline.exec(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);
    },

    state: function(composer, command, color) {
      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);
    }
  };
})(wysihtml5);(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      // Following elements are grouped
      // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4
      // instead of creating a H4 within a H1 which would result in semantically invalid html
      BLOCK_ELEMENTS_GROUP    = ["H1", "H2", "H3", "H4", "H5", "H6", "P", "BLOCKQUOTE", "DIV"];
  
  /**
   * Remove similiar classes (based on classRegExp)
   * and add the desired class name
   */
  function _addClass(element, className, classRegExp) {
    if (element.className) {
      _removeClass(element, classRegExp);
      element.className += " " + className;
    } else {
      element.className = className;
    }
  }

  function _removeClass(element, classRegExp) {
    element.className = element.className.replace(classRegExp, "");
  }

  /**
   * Check whether given node is a text node and whether it's empty
   */
  function _isBlankTextNode(node) {
    return node.nodeType === wysihtml5.TEXT_NODE && !wysihtml5.lang.string(node.data).trim();
  }

  /**
   * Returns previous sibling node that is not a blank text node
   */
  function _getPreviousSiblingThatIsNotBlank(node) {
    var previousSibling = node.previousSibling;
    while (previousSibling && _isBlankTextNode(previousSibling)) {
      previousSibling = previousSibling.previousSibling;
    }
    return previousSibling;
  }

  /**
   * Returns next sibling node that is not a blank text node
   */
  function _getNextSiblingThatIsNotBlank(node) {
    var nextSibling = node.nextSibling;
    while (nextSibling && _isBlankTextNode(nextSibling)) {
      nextSibling = nextSibling.nextSibling;
    }
    return nextSibling;
  }

  /**
   * Adds line breaks before and after the given node if the previous and next siblings
   * aren't already causing a visual line break (block element or <br>)
   */
  function _addLineBreakBeforeAndAfter(node) {
    var doc             = node.ownerDocument,
        nextSibling     = _getNextSiblingThatIsNotBlank(node),
        previousSibling = _getPreviousSiblingThatIsNotBlank(node);

    if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {
      node.parentNode.insertBefore(doc.createElement("br"), nextSibling);
    }
    if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {
      node.parentNode.insertBefore(doc.createElement("br"), node);
    }
  }

  /**
   * Removes line breaks before and after the given node
   */
  function _removeLineBreakBeforeAndAfter(node) {
    var nextSibling     = _getNextSiblingThatIsNotBlank(node),
        previousSibling = _getPreviousSiblingThatIsNotBlank(node);

    if (nextSibling && _isLineBreak(nextSibling)) {
      nextSibling.parentNode.removeChild(nextSibling);
    }
    if (previousSibling && _isLineBreak(previousSibling)) {
      previousSibling.parentNode.removeChild(previousSibling);
    }
  }

  function _removeLastChildIfLineBreak(node) {
    var lastChild = node.lastChild;
    if (lastChild && _isLineBreak(lastChild)) {
      lastChild.parentNode.removeChild(lastChild);
    }
  }

  function _isLineBreak(node) {
    return node.nodeName === "BR";
  }

  /**
   * Checks whether the elment causes a visual line break
   * (<br> or block elements)
   */
  function _isLineBreakOrBlockElement(element) {
    if (_isLineBreak(element)) {
      return true;
    }

    if (dom.getStyle("display").from(element) === "block") {
      return true;
    }

    return false;
  }

  /**
   * Execute native query command
   * and if necessary modify the inserted node's className
   */
  function _execCommand(doc, command, nodeName, className) {
    if (className) {
      var eventListener = dom.observe(doc, "DOMNodeInserted", function(event) {
        var target = event.target,
            displayStyle;
        if (target.nodeType !== wysihtml5.ELEMENT_NODE) {
          return;
        }
        displayStyle = dom.getStyle("display").from(target);
        if (displayStyle.substr(0, 6) !== "inline") {
          // Make sure that only block elements receive the given class
          target.className += " " + className;
        }
      });
    }
    doc.execCommand(command, false, nodeName);
    if (eventListener) {
      eventListener.stop();
    }
  }

  function _selectLineAndWrap(composer, element) {
    composer.selection.selectLine();
    composer.selection.surround(element);
    _removeLineBreakBeforeAndAfter(element);
    _removeLastChildIfLineBreak(element);
    composer.selection.selectNode(element, wysihtml5.browser.displaysCaretInEmptyContentEditableCorrectly());
  }

  function _hasClasses(element) {
    return !!wysihtml5.lang.string(element.className).trim();
  }
  
  wysihtml5.commands.formatBlock = {
    exec: function(composer, command, nodeName, className, classRegExp) {
      var doc             = composer.doc,
          blockElement    = this.state(composer, command, nodeName, className, classRegExp),
          useLineBreaks   = composer.config.useLineBreaks,
          defaultNodeName = useLineBreaks ? "DIV" : "P",
          selectedNode;

      nodeName = typeof(nodeName) === "string" ? nodeName.toUpperCase() : nodeName;
      
      if (blockElement) {
        composer.selection.executeAndRestoreSimple(function() {
          if (classRegExp) {
            _removeClass(blockElement, classRegExp);
          }
          var hasClasses = _hasClasses(blockElement);
          if (!hasClasses && (useLineBreaks || nodeName === "P")) {
            // Insert a line break afterwards and beforewards when there are siblings
            // that are not of type line break or block element
            _addLineBreakBeforeAndAfter(blockElement);
            dom.replaceWithChildNodes(blockElement);
          } else {
            // Make sure that styling is kept by renaming the element to a <div> or <p> and copying over the class name
            dom.renameElement(blockElement, nodeName === "P" ? "DIV" : defaultNodeName);
          }
        });
        return;
      }

      // Find similiar block element and rename it (<h2 class="foo"></h2>  =>  <h1 class="foo"></h1>)
      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {
        selectedNode = composer.selection.getSelectedNode();
        blockElement = dom.getParentElement(selectedNode, {
          nodeName: BLOCK_ELEMENTS_GROUP
        });

        if (blockElement) {
          composer.selection.executeAndRestore(function() {
            // Rename current block element to new block element and add class
            if (nodeName) {
              blockElement = dom.renameElement(blockElement, nodeName);
            }
            if (className) {
              _addClass(blockElement, className, classRegExp);
            }
          });
          return;
        }
      }

      if (composer.commands.support(command)) {
        _execCommand(doc, command, nodeName || defaultNodeName, className);
        return;
      }

      blockElement = doc.createElement(nodeName || defaultNodeName);
      if (className) {
        blockElement.className = className;
      }
      _selectLineAndWrap(composer, blockElement);
    },

    state: function(composer, command, nodeName, className, classRegExp) {
      nodeName = typeof(nodeName) === "string" ? nodeName.toUpperCase() : nodeName;
      var selectedNode = composer.selection.getSelectedNode();
      return dom.getParentElement(selectedNode, {
        nodeName:     nodeName,
        className:    className,
        classRegExp:  classRegExp
      });
    }
  };
})(wysihtml5);/**
 * formatInline scenarios for tag "B" (| = caret, |foo| = selected text)
 *
 *   #1 caret in unformatted text:
 *      abcdefg|
 *   output:
 *      abcdefg<b>|</b>
 *   
 *   #2 unformatted text selected:
 *      abc|deg|h
 *   output:
 *      abc<b>|deg|</b>h
 *   
 *   #3 unformatted text selected across boundaries:
 *      ab|c <span>defg|h</span>
 *   output:
 *      ab<b>|c </b><span><b>defg</b>|h</span>
 *
 *   #4 formatted text entirely selected
 *      <b>|abc|</b>
 *   output:
 *      |abc|
 *
 *   #5 formatted text partially selected
 *      <b>ab|c|</b>
 *   output:
 *      <b>ab</b>|c|
 *
 *   #6 formatted text selected across boundaries
 *      <span>ab|c</span> <b>de|fgh</b>
 *   output:
 *      <span>ab|c</span> de|<b>fgh</b>
 */
(function(wysihtml5) {
  var // Treat <b> as <strong> and vice versa
      ALIAS_MAPPING = {
        "strong": "b",
        "em":     "i",
        "b":      "strong",
        "i":      "em"
      },
      htmlApplier = {};
  
  function _getTagNames(tagName) {
    var alias = ALIAS_MAPPING[tagName];
    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];
  }
  
  function _getApplier(tagName, className, classRegExp) {
    var identifier = tagName + ":" + className;
    if (!htmlApplier[identifier]) {
      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true);
    }
    return htmlApplier[identifier];
  }
  
  wysihtml5.commands.formatInline = {
    exec: function(composer, command, tagName, className, classRegExp) {
      var range = composer.selection.getRange();
      if (!range) {
        return false;
      }
      _getApplier(tagName, className, classRegExp).toggleRange(range);
      composer.selection.setSelection(range);
    },

    state: function(composer, command, tagName, className, classRegExp) {
      var doc           = composer.doc,
          aliasTagName  = ALIAS_MAPPING[tagName] || tagName,
          range;

      // Check whether the document contains a node with the desired tagName
      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) &&
          !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {
        return false;
      }

       // Check whether the document contains a node with the desired className
      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {
         return false;
      }

      range = composer.selection.getRange();
      if (!range) {
        return false;
      }

      return _getApplier(tagName, className, classRegExp).isAppliedToRange(range);
    }
  };
})(wysihtml5);wysihtml5.commands.insertHTML = {
  exec: function(composer, command, html) {
    if (composer.commands.support(command)) {
      composer.doc.execCommand(command, false, html);
    } else {
      composer.selection.insertHTML(html);
    }
  },

  state: function() {
    return false;
  }
};
(function(wysihtml5) {
  var NODE_NAME = "IMG";
  
  wysihtml5.commands.insertImage = {
    /**
     * Inserts an <img>
     * If selection is already an image link, it removes it
     * 
     * @example
     *    // either ...
     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", "http://www.google.de/logo.jpg");
     *    // ... or ...
     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", { src: "http://www.google.de/logo.jpg", title: "foo" });
     */
    exec: function(composer, command, value) {
      value = typeof(value) === "object" ? value : { src: value };

      var doc     = composer.doc,
          image   = this.state(composer),
          textNode,
          i,
          parent;

      if (image) {
        // Image already selected, set the caret before it and delete it
        composer.selection.setBefore(image);
        parent = image.parentNode;
        parent.removeChild(image);

        // and it's parent <a> too if it hasn't got any other relevant child nodes
        wysihtml5.dom.removeEmptyTextNodes(parent);
        if (parent.nodeName === "A" && !parent.firstChild) {
          composer.selection.setAfter(parent);
          parent.parentNode.removeChild(parent);
        }

        // firefox and ie sometimes don't remove the image handles, even though the image got removed
        wysihtml5.quirks.redraw(composer.element);
        return;
      }

      image = doc.createElement(NODE_NAME);
      
      for (i in value) {
        if (i === "className") {
          i = "class";
        }
        image.setAttribute(i, value[i]);
      }

      composer.selection.insertNode(image);
      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {
        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);
        composer.selection.insertNode(textNode);
        composer.selection.setAfter(textNode);
      } else {
        composer.selection.setAfter(image);
      }
    },

    state: function(composer) {
      var doc = composer.doc,
          selectedNode,
          text,
          imagesInSelection;

      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {
        return false;
      }

      selectedNode = composer.selection.getSelectedNode();
      if (!selectedNode) {
        return false;
      }

      if (selectedNode.nodeName === NODE_NAME) {
        // This works perfectly in IE
        return selectedNode;
      }

      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {
        return false;
      }

      text = composer.selection.getText();
      text = wysihtml5.lang.string(text).trim();
      if (text) {
        return false;
      }

      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function(node) {
        return node.nodeName === "IMG";
      });

      if (imagesInSelection.length !== 1) {
        return false;
      }

      return imagesInSelection[0];
    }
  };
})(wysihtml5);(function(wysihtml5) {
  var LINE_BREAK = "<br>" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? " " : "");
  
  wysihtml5.commands.insertLineBreak = {
    exec: function(composer, command) {
      if (composer.commands.support(command)) {
        composer.doc.execCommand(command, false, null);
        if (!wysihtml5.browser.autoScrollsToCaret()) {
          composer.selection.scrollIntoView();
        }
      } else {
        composer.commands.exec("insertHTML", LINE_BREAK);
      }
    },

    state: function() {
      return false;
    }
  };
})(wysihtml5);wysihtml5.commands.insertOrderedList = {
  exec: function(composer, command) {
    var doc           = composer.doc,
        selectedNode  = composer.selection.getSelectedNode(),
        list          = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" }),
        otherList     = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" }),
        tempClassName =  "_wysihtml5-temp-" + new Date().getTime(),
        isEmpty,
        tempElement;
    
    if (!list && !otherList && composer.commands.support(command)) {
      doc.execCommand(command, false, null);
      return;
    }
    
    if (list) {
      // Unwrap list
      // <ol><li>foo</li><li>bar</li></ol>
      // becomes:
      // foo<br>bar<br>
      composer.selection.executeAndRestore(function() {
        wysihtml5.dom.resolveList(list, composer.config.useLineBreaks);
      });
    } else if (otherList) {
      // Turn an unordered list into an ordered list
      // <ul><li>foo</li><li>bar</li></ul>
      // becomes:
      // <ol><li>foo</li><li>bar</li></ol>
      composer.selection.executeAndRestore(function() {
        wysihtml5.dom.renameElement(otherList, "ol");
      });
    } else {
      // Create list
      composer.commands.exec("formatBlock", "div", tempClassName);
      tempElement = doc.querySelector("." + tempClassName);
      isEmpty = tempElement.innerHTML === "" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE || tempElement.innerHTML === "<br>";
      composer.selection.executeAndRestore(function() {
        list = wysihtml5.dom.convertToList(tempElement, "ol");
      });
      if (isEmpty) {
        composer.selection.selectNode(list.querySelector("li"), true);
      }
    }
  },
  
  state: function(composer) {
    var selectedNode = composer.selection.getSelectedNode();
    return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" });
  }
};wysihtml5.commands.insertUnorderedList = {
  exec: function(composer, command) {
    var doc           = composer.doc,
        selectedNode  = composer.selection.getSelectedNode(),
        list          = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" }),
        otherList     = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" }),
        tempClassName =  "_wysihtml5-temp-" + new Date().getTime(),
        isEmpty,
        tempElement;
    
    if (!list && !otherList && composer.commands.support(command)) {
      doc.execCommand(command, false, null);
      return;
    }
    
    if (list) {
      // Unwrap list
      // <ul><li>foo</li><li>bar</li></ul>
      // becomes:
      // foo<br>bar<br>
      composer.selection.executeAndRestore(function() {
        wysihtml5.dom.resolveList(list, composer.config.useLineBreaks);
      });
    } else if (otherList) {
      // Turn an ordered list into an unordered list
      // <ol><li>foo</li><li>bar</li></ol>
      // becomes:
      // <ul><li>foo</li><li>bar</li></ul>
      composer.selection.executeAndRestore(function() {
        wysihtml5.dom.renameElement(otherList, "ul");
      });
    } else {
      // Create list
      composer.commands.exec("formatBlock", "div", tempClassName);
      tempElement = doc.querySelector("." + tempClassName);
      isEmpty = tempElement.innerHTML === "" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE || tempElement.innerHTML === "<br>";
      composer.selection.executeAndRestore(function() {
        list = wysihtml5.dom.convertToList(tempElement, "ul");
      });
      if (isEmpty) {
        composer.selection.selectNode(list.querySelector("li"), true);
      }
    }
  },
  
  state: function(composer) {
    var selectedNode = composer.selection.getSelectedNode();
    return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" });
  }
};wysihtml5.commands.italic = {
  exec: function(composer, command) {
    return wysihtml5.commands.formatInline.exec(composer, command, "i");
  },

  state: function(composer, command) {
    // element.ownerDocument.queryCommandState("italic") results:
    // firefox: only <i>
    // chrome:  <i>, <em>, <blockquote>, ...
    // ie:      <i>, <em>
    // opera:   only <i>
    return wysihtml5.commands.formatInline.state(composer, command, "i");
  }
};(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-center",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;
  
  wysihtml5.commands.justifyCenter = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-left",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;
  
  wysihtml5.commands.justifyLeft = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-right",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;
  
  wysihtml5.commands.justifyRight = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);(function(wysihtml5) {
  var CLASS_NAME  = "wysiwyg-text-align-justify",
      REG_EXP     = /wysiwyg-text-align-[0-9a-z]+/g;
  
  wysihtml5.commands.justifyFull = {
    exec: function(composer, command) {
      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    },

    state: function(composer, command) {
      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);
    }
  };
})(wysihtml5);
wysihtml5.commands.redo = {
  exec: function(composer) {
    return composer.undoManager.redo();
  },

  state: function(composer) {
    return false;
  }
};wysihtml5.commands.underline = {
  exec: function(composer, command) {
    return wysihtml5.commands.formatInline.exec(composer, command, "u");
  },

  state: function(composer, command) {
    return wysihtml5.commands.formatInline.state(composer, command, "u");
  }
};wysihtml5.commands.undo = {
  exec: function(composer) {
    return composer.undoManager.undo();
  },

  state: function(composer) {
    return false;
  }
};/**
 * Undo Manager for wysihtml5
 * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface
 */
(function(wysihtml5) {
  var Z_KEY               = 90,
      Y_KEY               = 89,
      BACKSPACE_KEY       = 8,
      DELETE_KEY          = 46,
      MAX_HISTORY_ENTRIES = 25,
      DATA_ATTR_NODE      = "data-wysihtml5-selection-node",
      DATA_ATTR_OFFSET    = "data-wysihtml5-selection-offset",
      UNDO_HTML           = '<span id="_wysihtml5-undo" class="_wysihtml5-temp">' + wysihtml5.INVISIBLE_SPACE + '</span>',
      REDO_HTML           = '<span id="_wysihtml5-redo" class="_wysihtml5-temp">' + wysihtml5.INVISIBLE_SPACE + '</span>',
      dom                 = wysihtml5.dom;
  
  function cleanTempElements(doc) {
    var tempElement;
    while (tempElement = doc.querySelector("._wysihtml5-temp")) {
      tempElement.parentNode.removeChild(tempElement);
    }
  }
  
  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.UndoManager.prototype */ {
    constructor: function(editor) {
      this.editor = editor;
      this.composer = editor.composer;
      this.element = this.composer.element;
      
      this.position = 0;
      this.historyStr = [];
      this.historyDom = [];
      
      this.transact();
      
      this._observe();
    },
    
    _observe: function() {
      var that      = this,
          doc       = this.composer.sandbox.getDocument(),
          lastKey;
          
      // Catch CTRL+Z and CTRL+Y
      dom.observe(this.element, "keydown", function(event) {
        if (event.altKey || (!event.ctrlKey && !event.metaKey)) {
          return;
        }
        
        var keyCode = event.keyCode,
            isUndo = keyCode === Z_KEY && !event.shiftKey,
            isRedo = (keyCode === Z_KEY && event.shiftKey) || (keyCode === Y_KEY);
        
        if (isUndo) {
          that.undo();
          event.preventDefault();
        } else if (isRedo) {
          that.redo();
          event.preventDefault();
        }
      });
      
      // Catch delete and backspace
      dom.observe(this.element, "keydown", function(event) {
        var keyCode = event.keyCode;
        if (keyCode === lastKey) {
          return;
        }
        
        lastKey = keyCode;
        
        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {
          that.transact();
        }
      });
      
      // Now this is very hacky:
      // These days browsers don't offer a undo/redo event which we could hook into
      // to be notified when the user hits undo/redo in the contextmenu.
      // Therefore we simply insert two elements as soon as the contextmenu gets opened.
      // The last element being inserted will be immediately be removed again by a exexCommand("undo")
      //  => When the second element appears in the dom tree then we know the user clicked "redo" in the context menu
      //  => When the first element disappears from the dom tree then we know the user clicked "undo" in the context menu
      if (wysihtml5.browser.hasUndoInContextMenu()) {
        var interval, observed, cleanUp = function() {
          cleanTempElements(doc);
          clearInterval(interval);
        };
        
        dom.observe(this.element, "contextmenu", function() {
          cleanUp();
          that.composer.selection.executeAndRestoreSimple(function() {
            if (that.element.lastChild) {
              that.composer.selection.setAfter(that.element.lastChild);
            }

            // enable undo button in context menu
            doc.execCommand("insertHTML", false, UNDO_HTML);
            // enable redo button in context menu
            doc.execCommand("insertHTML", false, REDO_HTML);
            doc.execCommand("undo", false, null);
          });

          interval = setInterval(function() {
            if (doc.getElementById("_wysihtml5-redo")) {
              cleanUp();
              that.redo();
            } else if (!doc.getElementById("_wysihtml5-undo")) {
              cleanUp();
              that.undo();
            }
          }, 400);

          if (!observed) {
            observed = true;
            dom.observe(document, "mousedown", cleanUp);
            dom.observe(doc, ["mousedown", "paste", "cut", "copy"], cleanUp);
          }
        });
      }
      
      this.editor
        .on("newword:composer", function() {
          that.transact();
        })
        
        .on("beforecommand:composer", function() {
          that.transact();
        });
    },
    
    transact: function() {
      var previousHtml      = this.historyStr[this.position - 1],
          currentHtml       = this.composer.getValue();
      
      if (currentHtml === previousHtml) {
        return;
      }
      
      var length = this.historyStr.length = this.historyDom.length = this.position;
      if (length > MAX_HISTORY_ENTRIES) {
        this.historyStr.shift();
        this.historyDom.shift();
        this.position--;
      }
      
      this.position++;
      
      var range   = this.composer.selection.getRange(),
          node    = range.startContainer || this.element,
          offset  = range.startOffset    || 0,
          element,
          position;
      
      if (node.nodeType === wysihtml5.ELEMENT_NODE) {
        element = node;
      } else {
        element  = node.parentNode;
        position = this.getChildNodeIndex(element, node);
      }
      
      element.setAttribute(DATA_ATTR_OFFSET, offset);
      if (typeof(position) !== "undefined") {
        element.setAttribute(DATA_ATTR_NODE, position);
      }
      
      var clone = this.element.cloneNode(!!currentHtml);
      this.historyDom.push(clone);
      this.historyStr.push(currentHtml);
      
      element.removeAttribute(DATA_ATTR_OFFSET);
      element.removeAttribute(DATA_ATTR_NODE);
    },
    
    undo: function() {
      this.transact();
      
      if (!this.undoPossible()) {
        return;
      }
      
      this.set(this.historyDom[--this.position - 1]);
      this.editor.fire("undo:composer");
    },
    
    redo: function() {
      if (!this.redoPossible()) {
        return;
      }
      
      this.set(this.historyDom[++this.position - 1]);
      this.editor.fire("redo:composer");
    },
    
    undoPossible: function() {
      return this.position > 1;
    },
    
    redoPossible: function() {
      return this.position < this.historyStr.length;
    },
    
    set: function(historyEntry) {
      this.element.innerHTML = "";
      
      var i = 0,
          childNodes = historyEntry.childNodes,
          length = historyEntry.childNodes.length;
      
      for (; i<length; i++) {
        this.element.appendChild(childNodes[i].cloneNode(true));
      }
      
      // Restore selection
      var offset,
          node,
          position;
      
      if (historyEntry.hasAttribute(DATA_ATTR_OFFSET)) {
        offset    = historyEntry.getAttribute(DATA_ATTR_OFFSET);
        position  = historyEntry.getAttribute(DATA_ATTR_NODE);
        node      = this.element;
      } else {
        node      = this.element.querySelector("[" + DATA_ATTR_OFFSET + "]") || this.element;
        offset    = node.getAttribute(DATA_ATTR_OFFSET);
        position  = node.getAttribute(DATA_ATTR_NODE);
        node.removeAttribute(DATA_ATTR_OFFSET);
        node.removeAttribute(DATA_ATTR_NODE);
      }
      
      if (position !== null) {
        node = this.getChildNodeByIndex(node, +position);
      }
      
      this.composer.selection.set(node, offset);
    },
    
    getChildNodeIndex: function(parent, child) {
      var i           = 0,
          childNodes  = parent.childNodes,
          length      = childNodes.length;
      for (; i<length; i++) {
        if (childNodes[i] === child) {
          return i;
        }
      }
    },
    
    getChildNodeByIndex: function(parent, index) {
      return parent.childNodes[index];
    }
  });
})(wysihtml5);
/**
 * TODO: the following methods still need unit test coverage
 */
wysihtml5.views.View = Base.extend(
  /** @scope wysihtml5.views.View.prototype */ {
  constructor: function(parent, textareaElement, config) {
    this.parent   = parent;
    this.element  = textareaElement;
    this.config   = config;
    
    this._observeViewChange();
  },
  
  _observeViewChange: function() {
    var that = this;
    this.parent.on("beforeload", function() {
      that.parent.on("change_view", function(view) {
        if (view === that.name) {
          that.parent.currentView = that;
          that.show();
          // Using tiny delay here to make sure that the placeholder is set before focusing
          setTimeout(function() { that.focus(); }, 0);
        } else {
          that.hide();
        }
      });
    });
  },
  
  focus: function() {
    if (this.element.ownerDocument.querySelector(":focus") === this.element) {
      return;
    }
    
    try { this.element.focus(); } catch(e) {}
  },
  
  hide: function() {
    this.element.style.display = "none";
  },
  
  show: function() {
    this.element.style.display = "";
  },
  
  disable: function() {
    this.element.setAttribute("disabled", "disabled");
  },
  
  enable: function() {
    this.element.removeAttribute("disabled");
  }
});(function(wysihtml5) {
  var dom       = wysihtml5.dom,
      browser   = wysihtml5.browser;
  
  wysihtml5.views.Composer = wysihtml5.views.View.extend(
    /** @scope wysihtml5.views.Composer.prototype */ {
    name: "composer",

    // Needed for firefox in order to display a proper caret in an empty contentEditable
    CARET_HACK: "<br>",

    constructor: function(parent, textareaElement, config) {
      this.base(parent, textareaElement, config);
      this.textarea = this.parent.textarea;
      this._initSandbox();
    },

    clear: function() {
      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? "" : this.CARET_HACK;
    },

    getValue: function(parse) {
      var value = this.isEmpty() ? "" : wysihtml5.quirks.getCorrectInnerHTML(this.element);
      
      if (parse) {
        value = this.parent.parse(value);
      }

      // Replace all "zero width no breaking space" chars
      // which are used as hacks to enable some functionalities
      // Also remove all CARET hacks that somehow got left
      value = wysihtml5.lang.string(value).replace(wysihtml5.INVISIBLE_SPACE).by("");

      return value;
    },

    setValue: function(html, parse) {
      if (parse) {
        html = this.parent.parse(html);
      }
      
      try {
        this.element.innerHTML = html;
      } catch (e) {
        this.element.innerText = html;
      }
    },

    show: function() {
      this.iframe.style.display = this._displayStyle || "";
      
      if (!this.textarea.element.disabled) {
        // Firefox needs this, otherwise contentEditable becomes uneditable
        this.disable();
        this.enable();
      }
    },

    hide: function() {
      this._displayStyle = dom.getStyle("display").from(this.iframe);
      if (this._displayStyle === "none") {
        this._displayStyle = null;
      }
      this.iframe.style.display = "none";
    },

    disable: function() {
      this.parent.fire("disable:composer");
      this.element.removeAttribute("contentEditable");
    },

    enable: function() {
      this.parent.fire("enable:composer");
      this.element.setAttribute("contentEditable", "true");
    },

    focus: function(setToEnd) {
      // IE 8 fires the focus event after .focus()
      // This is needed by our simulate_placeholder.js to work
      // therefore we clear it ourselves this time
      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {
        this.clear();
      }
      
      this.base();
      
      var lastChild = this.element.lastChild;
      if (setToEnd && lastChild) {
        if (lastChild.nodeName === "BR") {
          this.selection.setBefore(this.element.lastChild);
        } else {
          this.selection.setAfter(this.element.lastChild);
        }
      }
    },

    getTextContent: function() {
      return dom.getTextContent(this.element);
    },

    hasPlaceholderSet: function() {
      return this.getTextContent() == this.textarea.element.getAttribute("placeholder") && this.placeholderSet;
    },

    isEmpty: function() {
      var innerHTML = this.element.innerHTML.toLowerCase();
      return innerHTML === ""            ||
             innerHTML === "<br>"        ||
             innerHTML === "<p></p>"     ||
             innerHTML === "<p><br></p>" ||
             this.hasPlaceholderSet();
    },

    _initSandbox: function() {
      var that = this;
      
      this.sandbox = new dom.Sandbox(function() {
        that._create();
      }, {
        stylesheets:  this.config.stylesheets
      });
      this.iframe  = this.sandbox.getIframe();
      
      var textareaElement = this.textarea.element;
      dom.insert(this.iframe).after(textareaElement);
      
      // Create hidden field which tells the server after submit, that the user used an wysiwyg editor
      if (textareaElement.form) {
        var hiddenField = document.createElement("input");
        hiddenField.type   = "hidden";
        hiddenField.name   = "_wysihtml5_mode";
        hiddenField.value  = 1;
        dom.insert(hiddenField).after(textareaElement);
      }
    },

    _create: function() {
      var that = this;
      
      this.doc                = this.sandbox.getDocument();
      this.element            = this.doc.body;
      this.textarea           = this.parent.textarea;
      this.element.innerHTML  = this.textarea.getValue(true);
      
      // Make sure our selection handler is ready
      this.selection = new wysihtml5.Selection(this.parent);
      
      // Make sure commands dispatcher is ready
      this.commands  = new wysihtml5.Commands(this.parent);
      
      dom.copyAttributes([
        "className", "spellcheck", "title", "lang", "dir", "accessKey"
      ]).from(this.textarea.element).to(this.element);
      
      dom.addClass(this.element, this.config.composerClassName);
      // 
      // // Make the editor look like the original textarea, by syncing styles
      if (this.config.style) {
        this.style();
      }
      
      this.observe();
      
      var name = this.config.name;
      if (name) {
        dom.addClass(this.element, name);
        dom.addClass(this.iframe, name);
      }
      
      this.enable();
      
      if (this.textarea.element.disabled) {
        this.disable();
      }
      
      // Simulate html5 placeholder attribute on contentEditable element
      var placeholderText = typeof(this.config.placeholder) === "string"
        ? this.config.placeholder
        : this.textarea.element.getAttribute("placeholder");
      if (placeholderText) {
        dom.simulatePlaceholder(this.parent, this, placeholderText);
      }
      
      // Make sure that the browser avoids using inline styles whenever possible
      this.commands.exec("styleWithCSS", false);
      
      this._initAutoLinking();
      this._initObjectResizing();
      this._initUndoManager();
      this._initLineBreaking();
      
      // Simulate html5 autofocus on contentEditable element
      // This doesn't work on IOS (5.1.1)
      if ((this.textarea.element.hasAttribute("autofocus") || document.querySelector(":focus") == this.textarea.element) && !browser.isIos()) {
        setTimeout(function() { that.focus(true); }, 100);
      }
      
      // IE sometimes leaves a single paragraph, which can't be removed by the user
      if (!browser.clearsContentEditableCorrectly()) {
        wysihtml5.quirks.ensureProperClearing(this);
      }
      
      // Set up a sync that makes sure that textarea and editor have the same content
      if (this.initSync && this.config.sync) {
        this.initSync();
      }
      
      // Okay hide the textarea, we are ready to go
      this.textarea.hide();
      
      // Fire global (before-)load event
      this.parent.fire("beforeload").fire("load");
    },

    _initAutoLinking: function() {
      var that                           = this,
          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),
          supportsAutoLinking            = browser.doesAutoLinkingInContentEditable();
      if (supportsDisablingOfAutoLinking) {
        this.commands.exec("autoUrlDetect", false);
      }

      if (!this.config.autoLink) {
        return;
      }

      // Only do the auto linking by ourselves when the browser doesn't support auto linking
      // OR when he supports auto linking but we were able to turn it off (IE9+)
      if (!supportsAutoLinking || (supportsAutoLinking && supportsDisablingOfAutoLinking)) {
        this.parent.on("newword:composer", function() {
          if (dom.getTextContent(that.element).match(dom.autoLink.URL_REG_EXP)) {
            that.selection.executeAndRestore(function(startContainer, endContainer) {
              dom.autoLink(endContainer.parentNode);
            });
          }
        });
        
        dom.observe(this.element, "blur", function() {
          dom.autoLink(that.element);
        });
      }

      // Assuming we have the following:
      //  <a href="http://www.google.de">http://www.google.de</a>
      // If a user now changes the url in the innerHTML we want to make sure that
      // it's synchronized with the href attribute (as long as the innerHTML is still a url)
      var // Use a live NodeList to check whether there are any links in the document
          links           = this.sandbox.getDocument().getElementsByTagName("a"),
          // The autoLink helper method reveals a reg exp to detect correct urls
          urlRegExp       = dom.autoLink.URL_REG_EXP,
          getTextContent  = function(element) {
            var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();
            if (textContent.substr(0, 4) === "www.") {
              textContent = "http://" + textContent;
            }
            return textContent;
          };

      dom.observe(this.element, "keydown", function(event) {
        if (!links.length) {
          return;
        }

        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),
            link         = dom.getParentElement(selectedNode, { nodeName: "A" }, 4),
            textContent;

        if (!link) {
          return;
        }

        textContent = getTextContent(link);
        // keydown is fired before the actual content is changed
        // therefore we set a timeout to change the href
        setTimeout(function() {
          var newTextContent = getTextContent(link);
          if (newTextContent === textContent) {
            return;
          }

          // Only set href when new href looks like a valid url
          if (newTextContent.match(urlRegExp)) {
            link.setAttribute("href", newTextContent);
          }
        }, 0);
      });
    },

    _initObjectResizing: function() {
      this.commands.exec("enableObjectResizing", true);
      
      // IE sets inline styles after resizing objects
      // The following lines make sure that the width/height css properties
      // are copied over to the width/height attributes
      if (browser.supportsEvent("resizeend")) {
        var properties        = ["width", "height"],
            propertiesLength  = properties.length,
            element           = this.element;
        
        dom.observe(element, "resizeend", function(event) {
          var target = event.target || event.srcElement,
              style  = target.style,
              i      = 0,
              property;
          
          if (target.nodeName !== "IMG") {
            return;
          }
          
          for (; i<propertiesLength; i++) {
            property = properties[i];
            if (style[property]) {
              target.setAttribute(property, parseInt(style[property], 10));
              style[property] = "";
            }
          }
          
          // After resizing IE sometimes forgets to remove the old resize handles
          wysihtml5.quirks.redraw(element);
        });
      }
    },
    
    _initUndoManager: function() {
      this.undoManager = new wysihtml5.UndoManager(this.parent);
    },
    
    _initLineBreaking: function() {
      var that                              = this,
          USE_NATIVE_LINE_BREAK_INSIDE_TAGS = ["LI", "P", "H1", "H2", "H3", "H4", "H5", "H6"],
          LIST_TAGS                         = ["UL", "OL", "MENU"];
      
      function adjust(selectedNode) {
        var parentElement = dom.getParentElement(selectedNode, { nodeName: ["P", "DIV"] }, 2);
        if (parentElement) {
          that.selection.executeAndRestore(function() {
            if (that.config.useLineBreaks) {
              dom.replaceWithChildNodes(parentElement);
            } else if (parentElement.nodeName !== "P") {
              dom.renameElement(parentElement, "p");
            }
          });
        }
      }
      
      if (!this.config.useLineBreaks) {
        dom.observe(this.element, ["focus", "keydown"], function() {
          if (that.isEmpty()) {
            var paragraph = that.doc.createElement("P");
            that.element.innerHTML = "";
            that.element.appendChild(paragraph);
            if (!browser.displaysCaretInEmptyContentEditableCorrectly()) {
              paragraph.innerHTML = "<br>";
              that.selection.setBefore(paragraph.firstChild);
            } else {
              that.selection.selectNode(paragraph, true);
            }
          }
        });
      }
      
      dom.observe(this.doc, "keydown", function(event) {
        var keyCode = event.keyCode;
        
        if (event.shiftKey) {
          return;
        }
        
        if (keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {
          return;
        }
        
        var blockElement = dom.getParentElement(that.selection.getSelectedNode(), { nodeName: USE_NATIVE_LINE_BREAK_INSIDE_TAGS }, 4);
        if (blockElement) {
          setTimeout(function() {
            // Unwrap paragraph after leaving a list or a H1-6
            var selectedNode = that.selection.getSelectedNode(),
                list;
            
            if (blockElement.nodeName === "LI") {
              if (!selectedNode) {
                return;
              }

              list = dom.getParentElement(selectedNode, { nodeName: LIST_TAGS }, 2);

              if (!list) {
                adjust(selectedNode);
              }
            }

            if (keyCode === wysihtml5.ENTER_KEY && blockElement.nodeName.match(/^H[1-6]$/)) {
              adjust(selectedNode);
            }
          }, 0);
          return;
        }
        
        if (that.config.useLineBreaks && keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {
          that.commands.exec("insertLineBreak");
          event.preventDefault();
        }
      });
    }
  });
})(wysihtml5);(function(wysihtml5) {
  var dom             = wysihtml5.dom,
      doc             = document,
      win             = window,
      HOST_TEMPLATE   = doc.createElement("div"),
      /**
       * Styles to copy from textarea to the composer element
       */
      TEXT_FORMATTING = [
        "background-color",
        "color", "cursor",
        "font-family", "font-size", "font-style", "font-variant", "font-weight",
        "line-height", "letter-spacing",
        "text-align", "text-decoration", "text-indent", "text-rendering",
        "word-break", "word-wrap", "word-spacing"
      ],
      /**
       * Styles to copy from textarea to the iframe
       */
      BOX_FORMATTING = [
        "background-color",
        "border-collapse",
        "border-bottom-color", "border-bottom-style", "border-bottom-width",
        "border-left-color", "border-left-style", "border-left-width",
        "border-right-color", "border-right-style", "border-right-width",
        "border-top-color", "border-top-style", "border-top-width",
        "clear", "display", "float",
        "margin-bottom", "margin-left", "margin-right", "margin-top",
        "outline-color", "outline-offset", "outline-width", "outline-style",
        "padding-left", "padding-right", "padding-top", "padding-bottom",
        "position", "top", "left", "right", "bottom", "z-index",
        "vertical-align", "text-align",
        "-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing",
        "-webkit-box-shadow", "-moz-box-shadow", "-ms-box-shadow","box-shadow",
        "-webkit-border-top-right-radius", "-moz-border-radius-topright", "border-top-right-radius",
        "-webkit-border-bottom-right-radius", "-moz-border-radius-bottomright", "border-bottom-right-radius",
        "-webkit-border-bottom-left-radius", "-moz-border-radius-bottomleft", "border-bottom-left-radius",
        "-webkit-border-top-left-radius", "-moz-border-radius-topleft", "border-top-left-radius",
        "width", "height"
      ],
      ADDITIONAL_CSS_RULES = [
        "html                 { height: 100%; }",
        "body                 { height: 100%; padding: 1px 0 0 0; margin: -1px 0 0 0; }",
        "body > p:first-child { margin-top: 0; }",
        "._wysihtml5-temp     { display: none; }",
        wysihtml5.browser.isGecko ?
          "body.placeholder { color: graytext !important; }" : 
          "body.placeholder { color: #a9a9a9 !important; }",
        // Ensure that user see's broken images and can delete them
        "img:-moz-broken      { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }"
      ];
  
  /**
   * With "setActive" IE offers a smart way of focusing elements without scrolling them into view:
   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx
   *
   * Other browsers need a more hacky way: (pssst don't tell my mama)
   * In order to prevent the element being scrolled into view when focusing it, we simply
   * move it out of the scrollable area, focus it, and reset it's position
   */
  var focusWithoutScrolling = function(element) {
    if (element.setActive) {
      // Following line could cause a js error when the textarea is invisible
      // See https://github.com/xing/wysihtml5/issues/9
      try { element.setActive(); } catch(e) {}
    } else {
      var elementStyle = element.style,
          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,
          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,
          originalStyles = {
            position:         elementStyle.position,
            top:              elementStyle.top,
            left:             elementStyle.left,
            WebkitUserSelect: elementStyle.WebkitUserSelect
          };
      
      dom.setStyles({
        position:         "absolute",
        top:              "-99999px",
        left:             "-99999px",
        // Don't ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother
        WebkitUserSelect: "none"
      }).on(element);
      
      element.focus();
      
      dom.setStyles(originalStyles).on(element);
      
      if (win.scrollTo) {
        // Some browser extensions unset this method to prevent annoyances
        // "Better PopUp Blocker" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100
        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1
        win.scrollTo(originalScrollLeft, originalScrollTop);
      }
    }
  };
  
  
  wysihtml5.views.Composer.prototype.style = function() {
    var that                  = this,
        originalActiveElement = doc.querySelector(":focus"),
        textareaElement       = this.textarea.element,
        hasPlaceholder        = textareaElement.hasAttribute("placeholder"),
        originalPlaceholder   = hasPlaceholder && textareaElement.getAttribute("placeholder"),
        originalDisplayValue  = textareaElement.style.display,
        originalDisabled      = textareaElement.disabled,
        displayValueForCopying;
    
    this.focusStylesHost      = HOST_TEMPLATE.cloneNode(false);
    this.blurStylesHost       = HOST_TEMPLATE.cloneNode(false);
    this.disabledStylesHost   = HOST_TEMPLATE.cloneNode(false);
  
    // Remove placeholder before copying (as the placeholder has an affect on the computed style)
    if (hasPlaceholder) {
      textareaElement.removeAttribute("placeholder");
    }
  
    if (textareaElement === originalActiveElement) {
      textareaElement.blur();
    }
    
    // enable for copying styles
    textareaElement.disabled = false;
    
    // set textarea to display="none" to get cascaded styles via getComputedStyle
    textareaElement.style.display = displayValueForCopying = "none";
    
    if ((textareaElement.getAttribute("rows") && dom.getStyle("height").from(textareaElement) === "auto") ||
        (textareaElement.getAttribute("cols") && dom.getStyle("width").from(textareaElement) === "auto")) {
      textareaElement.style.display = displayValueForCopying = originalDisplayValue;
    }
    
    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.iframe).andTo(this.blurStylesHost);
    
    // --------- editor styles ---------
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);
    
    // --------- apply standard rules ---------
    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);
    
    // --------- :disabled styles ---------
    textareaElement.disabled = true;
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.disabledStylesHost);
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.disabledStylesHost);
    textareaElement.disabled = originalDisabled;
    
    // --------- :focus styles ---------
    textareaElement.style.display = originalDisplayValue;
    focusWithoutScrolling(textareaElement);
    textareaElement.style.display = displayValueForCopying;
    
    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);
    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);
    
    // reset textarea
    textareaElement.style.display = originalDisplayValue;
    
    dom.copyStyles(["display"]).from(textareaElement).to(this.iframe);
    
    // Make sure that we don't change the display style of the iframe when copying styles oblur/onfocus
    // this is needed for when the change_view event is fired where the iframe is hidden and then
    // the blur event fires and re-displays it
    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without(["display"]);
    
    // --------- restore focus ---------
    if (originalActiveElement) {
      originalActiveElement.focus();
    } else {
      textareaElement.blur();
    }
    
    // --------- restore placeholder ---------
    if (hasPlaceholder) {
      textareaElement.setAttribute("placeholder", originalPlaceholder);
    }
    
    // --------- Sync focus/blur styles ---------
    this.parent.on("focus:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.focusStylesHost).to(that.iframe);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.focusStylesHost).to(that.element);
    });
    
    this.parent.on("blur:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.blurStylesHost).to(that.iframe);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.blurStylesHost).to(that.element);
    });
    
    this.parent.observe("disable:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.disabledStylesHost).to(that.iframe);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.disabledStylesHost).to(that.element);
    });
    
    this.parent.observe("enable:composer", function() {
      dom.copyStyles(boxFormattingStyles) .from(that.blurStylesHost).to(that.iframe);
      dom.copyStyles(TEXT_FORMATTING)     .from(that.blurStylesHost).to(that.element);
    });
    
    return this;
  };
})(wysihtml5);/**
 * Taking care of events
 *  - Simulating 'change' event on contentEditable element
 *  - Handling drag & drop logic
 *  - Catch paste events
 *  - Dispatch proprietary newword:composer event
 *  - Keyboard shortcuts
 */
(function(wysihtml5) {
  var dom       = wysihtml5.dom,
      browser   = wysihtml5.browser,
      /**
       * Map keyCodes to query commands
       */
      shortcuts = {
        "66": "bold",     // B
        "73": "italic",   // I
        "85": "underline" // U
      };
  
  wysihtml5.views.Composer.prototype.observe = function() {
    var that                = this,
        state               = this.getValue(),
        iframe              = this.sandbox.getIframe(),
        element             = this.element,
        focusBlurElement    = browser.supportsEventsInIframeCorrectly() ? element : this.sandbox.getWindow(),
        pasteEvents         = ["drop", "paste"];

    // --------- destroy:composer event ---------
    dom.observe(iframe, "DOMNodeRemoved", function() {
      clearInterval(domNodeRemovedInterval);
      that.parent.fire("destroy:composer");
    });

    // DOMNodeRemoved event is not supported in IE 8
    var domNodeRemovedInterval = setInterval(function() {
      if (!dom.contains(document.documentElement, iframe)) {
        clearInterval(domNodeRemovedInterval);
        that.parent.fire("destroy:composer");
      }
    }, 250);

    // --------- Focus & blur logic ---------
    dom.observe(focusBlurElement, "focus", function() {
      that.parent.fire("focus").fire("focus:composer");

      // Delay storing of state until all focus handler are fired
      // especially the one which resets the placeholder
      setTimeout(function() { state = that.getValue(); }, 0);
    });

    dom.observe(focusBlurElement, "blur", function() {
      if (state !== that.getValue()) {
        that.parent.fire("change").fire("change:composer");
      }
      that.parent.fire("blur").fire("blur:composer");
    });

    // --------- Drag & Drop logic ---------
    dom.observe(element, "dragenter", function() {
      that.parent.fire("unset_placeholder");
    });

    dom.observe(element, pasteEvents, function() {
      setTimeout(function() {
        that.parent.fire("paste").fire("paste:composer");
      }, 0);
    });

    // --------- neword event ---------
    dom.observe(element, "keyup", function(event) {
      var keyCode = event.keyCode;
      if (keyCode === wysihtml5.SPACE_KEY || keyCode === wysihtml5.ENTER_KEY) {
        that.parent.fire("newword:composer");
      }
    });

    this.parent.on("paste:composer", function() {
      setTimeout(function() { that.parent.fire("newword:composer"); }, 0);
    });

    // --------- Make sure that images are selected when clicking on them ---------
    if (!browser.canSelectImagesInContentEditable()) {
      dom.observe(element, "mousedown", function(event) {
        var target = event.target;
        if (target.nodeName === "IMG") {
          that.selection.selectNode(target);
          event.preventDefault();
        }
      });
    }
    
    if (browser.hasHistoryIssue() && browser.supportsSelectionModify()) {
      dom.observe(element, "keydown", function(event) {
        if (!event.metaKey && !event.ctrlKey) {
          return;
        }
        
        var keyCode   = event.keyCode,
            win       = element.ownerDocument.defaultView,
            selection = win.getSelection();
        
        if (keyCode === 37 || keyCode === 39) {
          if (keyCode === 37) {
            selection.modify("extend", "left", "lineboundary");
            if (!event.shiftKey) {
              selection.collapseToStart();
            }
          }
          if (keyCode === 39) {
            selection.modify("extend", "right", "lineboundary");
            if (!event.shiftKey) {
              selection.collapseToEnd();
            }
          }
          event.preventDefault();
        }
      });
    }
    
    // --------- Shortcut logic ---------
    dom.observe(element, "keydown", function(event) {
      var keyCode  = event.keyCode,
          command  = shortcuts[keyCode];
      if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {
        that.commands.exec(command);
        event.preventDefault();
      }
    });

    // --------- Make sure that when pressing backspace/delete on selected images deletes the image and it's anchor ---------
    dom.observe(element, "keydown", function(event) {
      var target  = that.selection.getSelectedNode(true),
          keyCode = event.keyCode,
          parent;
      if (target && target.nodeName === "IMG" && (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY)) { // 8 => backspace, 46 => delete
        parent = target.parentNode;
        // delete the <img>
        parent.removeChild(target);
        // and it's parent <a> too if it hasn't got any other child nodes
        if (parent.nodeName === "A" && !parent.firstChild) {
          parent.parentNode.removeChild(parent);
        }

        setTimeout(function() { wysihtml5.quirks.redraw(element); }, 0);
        event.preventDefault();
      }
    });
    
    // --------- IE 8+9 focus the editor when the iframe is clicked (without actually firing the 'focus' event on the <body>) ---------
    if (browser.hasIframeFocusIssue()) {
      dom.observe(this.iframe, "focus", function() {
        setTimeout(function() {
          if (that.doc.querySelector(":focus") !== that.element) {
            that.focus();
          }
        }, 0);
      });

      dom.observe(this.element, "blur", function() {
        setTimeout(function() {
          that.selection.getSelection().removeAllRanges();
        }, 0);
      });
    }
    
    // --------- Show url in tooltip when hovering links or images ---------
    var titlePrefixes = {
      IMG: "Image: ",
      A:   "Link: "
    };
    
    dom.observe(element, "mouseover", function(event) {
      var target   = event.target,
          nodeName = target.nodeName,
          title;
      if (nodeName !== "A" && nodeName !== "IMG") {
        return;
      }
      var hasTitle = target.hasAttribute("title");
      if(!hasTitle){
        title = titlePrefixes[nodeName] + (target.getAttribute("href") || target.getAttribute("src"));
        target.setAttribute("title", title);
      }
    });
  };
})(wysihtml5);/**
 * Class that takes care that the value of the composer and the textarea is always in sync
 */
(function(wysihtml5) {
  var INTERVAL = 400;
  
  wysihtml5.views.Synchronizer = Base.extend(
    /** @scope wysihtml5.views.Synchronizer.prototype */ {

    constructor: function(editor, textarea, composer) {
      this.editor   = editor;
      this.textarea = textarea;
      this.composer = composer;

      this._observe();
    },

    /**
     * Sync html from composer to textarea
     * Takes care of placeholders
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea
     */
    fromComposerToTextarea: function(shouldParseHtml) {
      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue()).trim(), shouldParseHtml);
    },

    /**
     * Sync value of textarea to composer
     * Takes care of placeholders
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer
     */
    fromTextareaToComposer: function(shouldParseHtml) {
      var textareaValue = this.textarea.getValue();
      if (textareaValue) {
        this.composer.setValue(textareaValue, shouldParseHtml);
      } else {
        this.composer.clear();
        this.editor.fire("set_placeholder");
      }
    },

    /**
     * Invoke syncing based on view state
     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea
     */
    sync: function(shouldParseHtml) {
      if (this.editor.currentView.name === "textarea") {
        this.fromTextareaToComposer(shouldParseHtml);
      } else {
        this.fromComposerToTextarea(shouldParseHtml);
      }
    },

    /**
     * Initializes interval-based syncing
     * also makes sure that on-submit the composer's content is synced with the textarea
     * immediately when the form gets submitted
     */
    _observe: function() {
      var interval,
          that          = this,
          form          = this.textarea.element.form,
          startInterval = function() {
            interval = setInterval(function() { that.fromComposerToTextarea(); }, INTERVAL);
          },
          stopInterval  = function() {
            clearInterval(interval);
            interval = null;
          };

      startInterval();

      if (form) {
        // If the textarea is in a form make sure that after onreset and onsubmit the composer
        // has the correct state
        wysihtml5.dom.observe(form, "submit", function() {
          that.sync(true);
        });
        wysihtml5.dom.observe(form, "reset", function() {
          setTimeout(function() { that.fromTextareaToComposer(); }, 0);
        });
      }

      this.editor.on("change_view", function(view) {
        if (view === "composer" && !interval) {
          that.fromTextareaToComposer(true);
          startInterval();
        } else if (view === "textarea") {
          that.fromComposerToTextarea(true);
          stopInterval();
        }
      });

      this.editor.on("destroy:composer", stopInterval);
    }
  });
})(wysihtml5);
wysihtml5.views.Textarea = wysihtml5.views.View.extend(
  /** @scope wysihtml5.views.Textarea.prototype */ {
  name: "textarea",
  
  constructor: function(parent, textareaElement, config) {
    this.base(parent, textareaElement, config);
    
    this._observe();
  },
  
  clear: function() {
    this.element.value = "";
  },
  
  getValue: function(parse) {
    var value = this.isEmpty() ? "" : this.element.value;
    if (parse) {
      value = this.parent.parse(value);
    }
    return value;
  },
  
  setValue: function(html, parse) {
    if (parse) {
      html = this.parent.parse(html);
    }
    this.element.value = html;
  },
  
  hasPlaceholderSet: function() {
    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),
        placeholderText     = this.element.getAttribute("placeholder") || null,
        value               = this.element.value,
        isEmpty             = !value;
    return (supportsPlaceholder && isEmpty) || (value === placeholderText);
  },
  
  isEmpty: function() {
    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();
  },
  
  _observe: function() {
    var element = this.element,
        parent  = this.parent,
        eventMapping = {
          focusin:  "focus",
          focusout: "blur"
        },
        /**
         * Calling focus() or blur() on an element doesn't synchronously trigger the attached focus/blur events
         * This is the case for focusin and focusout, so let's use them whenever possible, kkthxbai
         */
        events = wysihtml5.browser.supportsEvent("focusin") ? ["focusin", "focusout", "change"] : ["focus", "blur", "change"];
    
    parent.on("beforeload", function() {
      wysihtml5.dom.observe(element, events, function(event) {
        var eventName = eventMapping[event.type] || event.type;
        parent.fire(eventName).fire(eventName + ":textarea");
      });
      
      wysihtml5.dom.observe(element, ["paste", "drop"], function() {
        setTimeout(function() { parent.fire("paste").fire("paste:textarea"); }, 0);
      });
    });
  }
});/**
 * Toolbar Dialog
 *
 * @param {Element} link The toolbar link which causes the dialog to show up
 * @param {Element} container The dialog container
 *
 * @example
 *    <!-- Toolbar link -->
 *    <a data-wysihtml5-command="insertImage">insert an image</a>
 *
 *    <!-- Dialog -->
 *    <div data-wysihtml5-dialog="insertImage" style="display: none;">
 *      <label>
 *        URL: <input data-wysihtml5-dialog-field="src" value="http://">
 *      </label>
 *      <label>
 *        Alternative text: <input data-wysihtml5-dialog-field="alt" value="">
 *      </label>
 *    </div>
 *
 *    <script>
 *      var dialog = new wysihtml5.toolbar.Dialog(
 *        document.querySelector("[data-wysihtml5-command='insertImage']"),
 *        document.querySelector("[data-wysihtml5-dialog='insertImage']")
 *      );
 *      dialog.observe("save", function(attributes) {
 *        // do something
 *      });
 *    </script>
 */
(function(wysihtml5) {
  var dom                     = wysihtml5.dom,
      CLASS_NAME_OPENED       = "wysihtml5-command-dialog-opened",
      SELECTOR_FORM_ELEMENTS  = "input, select, textarea",
      SELECTOR_FIELDS         = "[data-wysihtml5-dialog-field]",
      ATTRIBUTE_FIELDS        = "data-wysihtml5-dialog-field";
      
  
  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.toolbar.Dialog.prototype */ {
    constructor: function(link, container) {
      this.link       = link;
      this.container  = container;
    },

    _observe: function() {
      if (this._observed) {
        return;
      }
      
      var that = this,
          callbackWrapper = function(event) {
            var attributes = that._serialize();
            if (attributes == that.elementToChange) {
              that.fire("edit", attributes);
            } else {
              that.fire("save", attributes);
            }
            that.hide();
            event.preventDefault();
            event.stopPropagation();
          };

      dom.observe(that.link, "click", function() {
        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {
          setTimeout(function() { that.hide(); }, 0);
        }
      });

      dom.observe(this.container, "keydown", function(event) {
        var keyCode = event.keyCode;
        if (keyCode === wysihtml5.ENTER_KEY) {
          callbackWrapper(event);
        }
        if (keyCode === wysihtml5.ESCAPE_KEY) {
          that.hide();
        }
      });

      dom.delegate(this.container, "[data-wysihtml5-dialog-action=save]", "click", callbackWrapper);

      dom.delegate(this.container, "[data-wysihtml5-dialog-action=cancel]", "click", function(event) {
        that.fire("cancel");
        that.hide();
        event.preventDefault();
        event.stopPropagation();
      });

      var formElements  = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),
          i             = 0,
          length        = formElements.length,
          _clearInterval = function() { clearInterval(that.interval); };
      for (; i<length; i++) {
        dom.observe(formElements[i], "change", _clearInterval);
      }

      this._observed = true;
    },

    /**
     * Grabs all fields in the dialog and puts them in key=>value style in an object which
     * then gets returned
     */
    _serialize: function() {
      var data    = this.elementToChange || {},
          fields  = this.container.querySelectorAll(SELECTOR_FIELDS),
          length  = fields.length,
          i       = 0;
      for (; i<length; i++) {
        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;
      }
      return data;
    },

    /**
     * Takes the attributes of the "elementToChange"
     * and inserts them in their corresponding dialog input fields
     * 
     * Assume the "elementToChange" looks like this:
     *    <a href="http://www.google.com" target="_blank">foo</a>
     *
     * and we have the following dialog:
     *    <input type="text" data-wysihtml5-dialog-field="href" value="">
     *    <input type="text" data-wysihtml5-dialog-field="target" value="">
     * 
     * after calling _interpolate() the dialog will look like this
     *    <input type="text" data-wysihtml5-dialog-field="href" value="http://www.google.com">
     *    <input type="text" data-wysihtml5-dialog-field="target" value="_blank">
     *
     * Basically it adopted the attribute values into the corresponding input fields
     *
     */
    _interpolate: function(avoidHiddenFields) {
      var field,
          fieldName,
          newValue,
          focusedElement = document.querySelector(":focus"),
          fields         = this.container.querySelectorAll(SELECTOR_FIELDS),
          length         = fields.length,
          i              = 0;
      for (; i<length; i++) {
        field = fields[i];
        
        // Never change elements where the user is currently typing in
        if (field === focusedElement) {
          continue;
        }
        
        // Don't update hidden fields
        // See https://github.com/xing/wysihtml5/pull/14
        if (avoidHiddenFields && field.type === "hidden") {
          continue;
        }
        
        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);
        newValue  = this.elementToChange ? (this.elementToChange[fieldName] || "") : field.defaultValue;
        field.value = newValue;
      }
    },

    /**
     * Show the dialog element
     */
    show: function(elementToChange) {
      if (dom.hasClass(this.link, CLASS_NAME_OPENED)) {
        return;
      }
      
      var that        = this,
          firstField  = this.container.querySelector(SELECTOR_FORM_ELEMENTS);
      this.elementToChange = elementToChange;
      this._observe();
      this._interpolate();
      if (elementToChange) {
        this.interval = setInterval(function() { that._interpolate(true); }, 500);
      }
      dom.addClass(this.link, CLASS_NAME_OPENED);
      this.container.style.display = "";
      this.fire("show");
      if (firstField && !elementToChange) {
        try {
          firstField.focus();
        } catch(e) {}
      }
    },

    /**
     * Hide the dialog element
     */
    hide: function() {
      clearInterval(this.interval);
      this.elementToChange = null;
      dom.removeClass(this.link, CLASS_NAME_OPENED);
      this.container.style.display = "none";
      this.fire("hide");
    }
  });
})(wysihtml5);
/**
 * Converts speech-to-text and inserts this into the editor
 * As of now (2011/03/25) this only is supported in Chrome >= 11
 *
 * Note that it sends the recorded audio to the google speech recognition api:
 * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec
 *
 * Current HTML5 draft can be found here
 * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html
 * 
 * "Accessing Google Speech API Chrome 11"
 * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/
 */
(function(wysihtml5) {
  var dom = wysihtml5.dom;
  
  var linkStyles = {
    position: "relative"
  };
  
  var wrapperStyles = {
    left:     0,
    margin:   0,
    opacity:  0,
    overflow: "hidden",
    padding:  0,
    position: "absolute",
    top:      0,
    zIndex:   1
  };
  
  var inputStyles = {
    cursor:     "inherit",
    fontSize:   "50px",
    height:     "50px",
    marginTop:  "-25px",
    outline:    0,
    padding:    0,
    position:   "absolute",
    right:      "-4px",
    top:        "50%"
  };
  
  var inputAttributes = {
    "x-webkit-speech": "",
    "speech":          ""
  };
  
  wysihtml5.toolbar.Speech = function(parent, link) {
    var input = document.createElement("input");
    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {
      link.style.display = "none";
      return;
    }
    var lang = parent.editor.textarea.element.getAttribute("lang");
    if (lang) {
      inputAttributes.lang = lang;
    }

    var wrapper = document.createElement("div");
    
    wysihtml5.lang.object(wrapperStyles).merge({
      width:  link.offsetWidth  + "px",
      height: link.offsetHeight + "px"
    });
    
    dom.insert(input).into(wrapper);
    dom.insert(wrapper).into(link);
    
    dom.setStyles(inputStyles).on(input);
    dom.setAttributes(inputAttributes).on(input);
    
    dom.setStyles(wrapperStyles).on(wrapper);
    dom.setStyles(linkStyles).on(link);
    
    var eventName = "onwebkitspeechchange" in input ? "webkitspeechchange" : "speechchange";
    dom.observe(input, eventName, function() {
      parent.execCommand("insertText", input.value);
      input.value = "";
    });
    
    dom.observe(input, "click", function(event) {
      if (dom.hasClass(link, "wysihtml5-command-disabled")) {
        event.preventDefault();
      }
      
      event.stopPropagation();
    });
  };
})(wysihtml5);/**
 * Toolbar
 *
 * @param {Object} parent Reference to instance of Editor instance
 * @param {Element} container Reference to the toolbar container element
 *
 * @example
 *    <div id="toolbar">
 *      <a data-wysihtml5-command="createLink">insert link</a>
 *      <a data-wysihtml5-command="formatBlock" data-wysihtml5-command-value="h1">insert h1</a>
 *    </div>
 *
 *    <script>
 *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById("toolbar"));
 *    </script>
 */
(function(wysihtml5) {
  var CLASS_NAME_COMMAND_DISABLED   = "wysihtml5-command-disabled",
      CLASS_NAME_COMMANDS_DISABLED  = "wysihtml5-commands-disabled",
      CLASS_NAME_COMMAND_ACTIVE     = "wysihtml5-command-active",
      CLASS_NAME_ACTION_ACTIVE      = "wysihtml5-action-active",
      dom                           = wysihtml5.dom;
  
  wysihtml5.toolbar.Toolbar = Base.extend(
    /** @scope wysihtml5.toolbar.Toolbar.prototype */ {
    constructor: function(editor, container) {
      this.editor     = editor;
      this.container  = typeof(container) === "string" ? document.getElementById(container) : container;
      this.composer   = editor.composer;

      this._getLinks("command");
      this._getLinks("action");

      this._observe();
      this.show();
      
      var speechInputLinks  = this.container.querySelectorAll("[data-wysihtml5-command=insertSpeech]"),
          length            = speechInputLinks.length,
          i                 = 0;
      for (; i<length; i++) {
        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);
      }
    },

    _getLinks: function(type) {
      var links   = this[type + "Links"] = wysihtml5.lang.array(this.container.querySelectorAll("[data-wysihtml5-" + type + "]")).get(),
          length  = links.length,
          i       = 0,
          mapping = this[type + "Mapping"] = {},
          link,
          group,
          name,
          value,
          dialog;
      for (; i<length; i++) {
        link    = links[i];
        name    = link.getAttribute("data-wysihtml5-" + type);
        value   = link.getAttribute("data-wysihtml5-" + type + "-value");
        group   = this.container.querySelector("[data-wysihtml5-" + type + "-group='" + name + "']");
        dialog  = this._getDialog(link, name);
        
        mapping[name + ":" + value] = {
          link:   link,
          group:  group,
          name:   name,
          value:  value,
          dialog: dialog,
          state:  false
        };
      }
    },

    _getDialog: function(link, command) {
      var that          = this,
          dialogElement = this.container.querySelector("[data-wysihtml5-dialog='" + command + "']"),
          dialog,
          caretBookmark;
      
      if (dialogElement) {
        dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);

        dialog.on("show", function() {
          caretBookmark = that.composer.selection.getBookmark();

          that.editor.fire("show:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });

        dialog.on("save", function(attributes) {
          if (caretBookmark) {
            that.composer.selection.setBookmark(caretBookmark);
          }
          that._execCommand(command, attributes);
          
          that.editor.fire("save:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });

        dialog.on("cancel", function() {
          that.editor.focus(false);
          that.editor.fire("cancel:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });
        });
      }
      return dialog;
    },

    /**
     * @example
     *    var toolbar = new wysihtml5.Toolbar();
     *    // Insert a <blockquote> element or wrap current selection in <blockquote>
     *    toolbar.execCommand("formatBlock", "blockquote");
     */
    execCommand: function(command, commandValue) {
      if (this.commandsDisabled) {
        return;
      }

      var commandObj = this.commandMapping[command + ":" + commandValue];

      // Show dialog when available
      if (commandObj && commandObj.dialog && !commandObj.state) {
        commandObj.dialog.show();
      } else {
        this._execCommand(command, commandValue);
      }
    },

    _execCommand: function(command, commandValue) {
      // Make sure that composer is focussed (false => don't move caret to the end)
      this.editor.focus(false);

      this.composer.commands.exec(command, commandValue);
      this._updateLinkStates();
    },

    execAction: function(action) {
      var editor = this.editor;
      if (action === "change_view") {
        if (editor.currentView === editor.textarea) {
          editor.fire("change_view", "composer");
        } else {
          editor.fire("change_view", "textarea");
        }
      }
    },

    _observe: function() {
      var that      = this,
          editor    = this.editor,
          container = this.container,
          links     = this.commandLinks.concat(this.actionLinks),
          length    = links.length,
          i         = 0;
      
      for (; i<length; i++) {
        // 'javascript:;' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied
        // (you know, a:link { ... } doesn't match anchors with missing href attribute)
        dom.setAttributes({
          href:         "javascript:;",
          unselectable: "on"
        }).on(links[i]);
      }

      // Needed for opera and chrome
      dom.delegate(container, "[data-wysihtml5-command], [data-wysihtml5-action]", "mousedown", function(event) { event.preventDefault(); });
      
      dom.delegate(container, "[data-wysihtml5-command]", "click", function(event) {
        var link          = this,
            command       = link.getAttribute("data-wysihtml5-command"),
            commandValue  = link.getAttribute("data-wysihtml5-command-value");
        that.execCommand(command, commandValue);
        event.preventDefault();
      });

      dom.delegate(container, "[data-wysihtml5-action]", "click", function(event) {
        var action = this.getAttribute("data-wysihtml5-action");
        that.execAction(action);
        event.preventDefault();
      });

      editor.on("focus:composer", function() {
        that.bookmark = null;
        clearInterval(that.interval);
        that.interval = setInterval(function() { that._updateLinkStates(); }, 500);
      });

      editor.on("blur:composer", function() {
        clearInterval(that.interval);
      });

      editor.on("destroy:composer", function() {
        clearInterval(that.interval);
      });

      editor.on("change_view", function(currentView) {
        // Set timeout needed in order to let the blur event fire first
        setTimeout(function() {
          that.commandsDisabled = (currentView !== "composer");
          that._updateLinkStates();
          if (that.commandsDisabled) {
            dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);
          } else {
            dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);
          }
        }, 0);
      });
    },

    _updateLinkStates: function() {
      var commandMapping    = this.commandMapping,
          actionMapping     = this.actionMapping,
          i,
          state,
          action,
          command;
      // every millisecond counts... this is executed quite often
      for (i in commandMapping) {
        command = commandMapping[i];
        if (this.commandsDisabled) {
          state = false;
          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            command.dialog.hide();
          }
        } else {
          state = this.composer.commands.state(command.name, command.value);
          if (wysihtml5.lang.object(state).isArray()) {
            // Grab first and only object/element in state array, otherwise convert state into boolean
            // to avoid showing a dialog for multiple selected elements which may have different attributes
            // eg. when two links with different href are selected, the state will be an array consisting of both link elements
            // but the dialog interface can only update one
            state = state.length === 1 ? state[0] : true;
          }
          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);
          }
        }

        if (command.state === state) {
          continue;
        }

        command.state = state;
        if (state) {
          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            if (typeof(state) === "object") {
              command.dialog.show(state);
            } else {
              command.dialog.hide();
            }
          }
        } else {
          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);
          if (command.group) {
            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);
          }
          if (command.dialog) {
            command.dialog.hide();
          }
        }
      }
      
      for (i in actionMapping) {
        action = actionMapping[i];
        
        if (action.name === "change_view") {
          action.state = this.editor.currentView === this.editor.textarea;
          if (action.state) {
            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);
          } else {
            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);
          }
        }
      }
    },

    show: function() {
      this.container.style.display = "";
    },

    hide: function() {
      this.container.style.display = "none";
    }
  });
  
})(wysihtml5);
/**
 * WYSIHTML5 Editor
 *
 * @param {Element} textareaElement Reference to the textarea which should be turned into a rich text interface
 * @param {Object} [config] See defaultConfig object below for explanation of each individual config option
 *
 * @events
 *    load
 *    beforeload (for internal use only)
 *    focus
 *    focus:composer
 *    focus:textarea
 *    blur
 *    blur:composer
 *    blur:textarea
 *    change
 *    change:composer
 *    change:textarea
 *    paste
 *    paste:composer
 *    paste:textarea
 *    newword:composer
 *    destroy:composer
 *    undo:composer
 *    redo:composer
 *    beforecommand:composer
 *    aftercommand:composer
 *    enable:composer
 *    disable:composer
 *    change_view
 */
(function(wysihtml5) {
  var undef;
  
  var defaultConfig = {
    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe's body 
    name:                 undef,
    // Whether the editor should look like the textarea (by adopting styles)
    style:                true,
    // Id of the toolbar element, pass falsey value if you don't want any toolbar logic
    toolbar:              undef,
    // Whether urls, entered by the user should automatically become clickable-links
    autoLink:             true,
    // Object which includes parser rules to apply when html gets inserted via copy & paste
    // See parser_rules/*.js for examples
    parserRules:          { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },
    // Parser method to use when the user inserts content via copy & paste
    parser:               wysihtml5.dom.parse,
    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the 'stylesheets' option
    composerClassName:    "wysihtml5-editor",
    // Class name to add to the body when the wysihtml5 editor is supported
    bodyClassName:        "wysihtml5-supported",
    // By default wysihtml5 will insert a <br> for line breaks, set this to false to use <p>
    useLineBreaks:        true,
    // Array (or single string) of stylesheet urls to be loaded in the editor's iframe
    stylesheets:          [],
    // Placeholder text to use, defaults to the placeholder attribute on the textarea element
    placeholderText:      undef,
    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)
    supportTouchDevices:  true
  };
  
  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(
    /** @scope wysihtml5.Editor.prototype */ {
    constructor: function(textareaElement, config) {
      this.textareaElement  = typeof(textareaElement) === "string" ? document.getElementById(textareaElement) : textareaElement;
      this.config           = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();
      this.textarea         = new wysihtml5.views.Textarea(this, this.textareaElement, this.config);
      this.currentView      = this.textarea;
      this._isCompatible    = wysihtml5.browser.supported();
      
      // Sort out unsupported/unwanted browsers here
      if (!this._isCompatible || (!this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice())) {
        var that = this;
        setTimeout(function() { that.fire("beforeload").fire("load"); }, 0);
        return;
      }
      
      // Add class name to body, to indicate that the editor is supported
      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);
      
      this.composer = new wysihtml5.views.Composer(this, this.textareaElement, this.config);
      this.currentView = this.composer;
      
      if (typeof(this.config.parser) === "function") {
        this._initParser();
      }
      
      this.on("beforeload", function() {
        this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);
        if (this.config.toolbar) {
          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar);
        }
      });
    },
    
    isCompatible: function() {
      return this._isCompatible;
    },

    clear: function() {
      this.currentView.clear();
      return this;
    },

    getValue: function(parse) {
      return this.currentView.getValue(parse);
    },

    setValue: function(html, parse) {
      this.fire("unset_placeholder");
      
      if (!html) {
        return this.clear();
      }
      
      this.currentView.setValue(html, parse);
      return this;
    },

    focus: function(setToEnd) {
      this.currentView.focus(setToEnd);
      return this;
    },

    /**
     * Deactivate editor (make it readonly)
     */
    disable: function() {
      this.currentView.disable();
      return this;
    },
    
    /**
     * Activate editor
     */
    enable: function() {
      this.currentView.enable();
      return this;
    },
    
    isEmpty: function() {
      return this.currentView.isEmpty();
    },
    
    hasPlaceholderSet: function() {
      return this.currentView.hasPlaceholderSet();
    },
    
    parse: function(htmlOrElement) {
      var returnValue = this.config.parser(htmlOrElement, this.config.parserRules, this.composer.sandbox.getDocument(), true);
      if (typeof(htmlOrElement) === "object") {
        wysihtml5.quirks.redraw(htmlOrElement);
      }
      return returnValue;
    },
    
    /**
     * Prepare html parser logic
     *  - Observes for paste and drop
     */
    _initParser: function() {
      this.on("paste:composer", function() {
        var keepScrollPosition  = true,
            that                = this;
        that.composer.selection.executeAndRestore(function() {
          wysihtml5.quirks.cleanPastedHTML(that.composer.element);
          that.parse(that.composer.element);
        }, keepScrollPosition);
      });
    }
  });
})(wysihtml5);

!function($, wysi) {
	"use strict"

	var templates = {
		"font-styles": "<li class='dropdown'>" +
							"<a class='btn dropdown-toggle' data-toggle='dropdown' href='#'>" +
								"<i class='icon-font'></i>&nbsp;<span class='current-font'>Normal text</span>&nbsp;<b class='caret'></b>" +
							"</a>" +
						    "<ul class='dropdown-menu'>" +
						      	"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='div'>Normal text</a></li>" +
					            "<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h1'>Heading 1</a></li>" +
					            "<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h2'>Heading 2</a></li>" +
						    "</ul>" +
						"</li>",
		"emphasis":     "<li>" +
							"<div class='btn-group'>"
							    + "<a class='btn' data-wysihtml5-command='bold' title='CTRL+B'>Bold</a>"
							    + "<a class='btn' data-wysihtml5-command='italic' title='CTRL+I'>Italic</a>"
							    //,+ "<a class='btn' data-wysihtml5-command='underline' title='CTRL+U'>Underline</a>"
							+ "</div>"
						+ "</li>",
		"lists": 	"<li>"
						+ "<div class='btn-group'>"
					    	+ "<a class='btn' data-wysihtml5-command='insertUnorderedList' title='Unordered List'><i class='icon-list'></i></a>"
						    + "<a class='btn' data-wysihtml5-command='insertOrderedList' title='Ordered List'><i class='icon-th-list'></i></a>"
						    + "<a class='btn' data-wysihtml5-command='Outdent' title='Outdent'><i class='icon-indent-right'></i></a>"
						    + "<a class='btn' data-wysihtml5-command='Indent' title='Indent'><i class='icon-indent-left'></i></a>"
						+ "</div>"
					+ "</li>",

		"link": 	"<li>"

						+ "<div class='bootstrap-wysihtml5-insert-link-modal modal hide'>"
							+ "<div class='modal-header inner-modal-header'>"
  							+ "<div class='pull-right'>"
    							+ "<a class='btn btn-mini close' data-dismiss='modal'><i class='fa fa-times black'></i></a>"
  							+ "</div>"
							  + "<h2>Insert Link</h2>"
							+ "</div>"
							+ "<div class='modal-body'>"
							  + "<input value='http://' class='bootstrap-wysihtml5-insert-link-url input-xlarge'>"
							+ "</div>"
							+ "<div class='modal-footer inner-modal-footer'>"
  							+ "<div class='row-fluid'>"
    							+ "<div class='span3'>"
      							+ "<div class='deny-buttons'>"
        							+ "<a href='#' class='btn' data-dismiss='modal'>Cancel</a>"
      							+ "</div>"
    							+ "</div>"
    							+ "<div class='span6'>"
    							+ "</div>"
    							+ "<div class='span3'>"
      							+ "<div class='confirm-buttons'>"
        							+ "<a href='#' class='btn btn-primary' data-dismiss='modal'>Insert link</a>"
        						+ "</div>"
    							+ "</div>"
  							+ "</div>"
							+ "</div>"
						+ "</div>"

				    	+ "<a class='btn' data-wysihtml5-command='popupCreateLink' title='Link'><i class='icon-share'></i></a>"

					+ "</li>",

			"image": "<li>"

						+ "<div class='bootstrap-wysihtml5-insert-image-modal modal hide fade'>"
							+ "<div class='modal-header'>"
							+ "<a class='close' data-dismiss='modal'>×</a>"
							  + "<h3>Insert Image</h3>"
							+ "</div>"
							+ "<div class='modal-body'>"
							  + "<input value='http://' class='bootstrap-wysihtml5-insert-image-url input-xlarge'>"
							+ "</div>"
							+ "<div class='modal-footer'>"
							  + "<a href='#' class='btn' data-dismiss='modal'>Cancel</a>"
							  + "<a href='#' class='btn btn-primary' data-dismiss='modal'>Insert image</a>"
							+ "</div>"
						+ "</div>"

						+ "<a class='btn' data-wysihtml5-command='insertImage' title='Insert image'><i class='icon-picture'></i></a>"

					+ "</li>",

		"html":
						"<li>"
							+ "<div class='btn-group'>"
								+ "<a class='btn' data-wysihtml5-action='change_view' title='Edit HTML'><i class='icon-pencil'></i></a>"
							+ "</div>"
						+ "</li>"
	};

	var defaultOptions = {
		"font-styles": true,
		"emphasis": true,
		"lists": true,
		"html": false,
		"link": true,
		"image": true,
		events: {},
		parserRules: {
			tags: {
				"b":  {},
				"i":  {},
				"br": {},
				"ol": {},
				"ul": {},
				"li": {},
				"h1": {},
				"h2": {},
				"u": 1,
				"img": {
					"check_attributes": {
			            "width": "numbers",
			            "alt": "alt",
			            "src": "url",
			            "height": "numbers"
			        }
				},
				"a":  {
					set_attributes: {
						target: "_blank",
						rel:    "nofollow"
					},
					check_attributes: {
						href:   "url" // important to avoid XSS
					}
				}
			}
		}
	};

	var Wysihtml5 = function(el, options) {
		this.el = el;
		this.toolbar = this.createToolbar(el, options || defaultOptions);
		this.editor =  this.createEditor(options);

		window.editor = this.editor;

  		$('iframe.wysihtml5-sandbox').each(function(i, el){
			$(el.contentWindow).off('focus.wysihtml5').on({
			  'focus.wysihtml5' : function(){
			     $('li.dropdown').removeClass('open');
			   }
			});
		});
	};

	Wysihtml5.prototype = {
		constructor: Wysihtml5,

		createEditor: function(options) {
			var parserRules = defaultOptions.parserRules;

			if(options && options.parserRules) {
				parserRules = options.parserRules;
			}

			var editor = new wysi.Editor(this.el.attr('id'), {
	    		toolbar: this.toolbar.attr('id'),
				parserRules: parserRules
	  		});

	  		if(options && options.events) {
				for(var eventName in options.events) {
					editor.on(eventName, options.events[eventName]);
				}
			}

	  		return editor;
		},

		createToolbar: function(el, options) {
			var self = this;
			var toolbar = $("<ul/>", {
				'id' : el.attr('id') + "-wysihtml5-toolbar",
				'class' : "wysihtml5-toolbar",
				'style': "display:none"
			});

			for(var key in defaultOptions) {
				var value = false;

				if(options[key] != undefined) {
					if(options[key] == true) {
						value = true;
					}
				} else {
					value = defaultOptions[key];
				}

				if(value == true) {
					toolbar.append(templates[key]);

					if(key == "html") {
						this.initHtml(toolbar);
					}

					if(key == "link") {
						this.initInsertLink(toolbar);
					}

					if(key == "image") {
						this.initInsertImage(toolbar);
					}
				}
			}

			var self = this;

			toolbar.find("a[data-wysihtml5-command='formatBlock']").click(function(e) {
				var el = $(e.srcElement);
				self.toolbar.find('.current-font').text(el.html())
			});

			this.el.before(toolbar);

			return toolbar;
		},

		initHtml: function(toolbar) {
			var changeViewSelector = "a[data-wysihtml5-action='change_view']";
			toolbar.find(changeViewSelector).click(function(e) {
				toolbar.find('a.btn').not(changeViewSelector).toggleClass('disabled');
			});
		},

		initInsertImage: function(toolbar) {
			var self = this;
			var insertImageModal = toolbar.find('.bootstrap-wysihtml5-insert-image-modal');
			var urlInput = insertImageModal.find('.bootstrap-wysihtml5-insert-image-url');
			var insertButton = insertImageModal.find('a.btn-primary');
			var initialValue = urlInput.val();

			var insertImage = function() {
				var url = urlInput.val();
				urlInput.val(initialValue);
				self.editor.composer.commands.exec("insertImage", url);
			};

			urlInput.keypress(function(e) {
				if(e.which == 13) {
					insertImage();
					insertImageModal.modal('hide');
				}
			});

			insertButton.click(insertImage);

			insertImageModal.on('shown', function() {
				urlInput.focus();
			});

			insertImageModal.on('hide', function() {
				self.editor.currentView.element.focus();
			});

			toolbar.find('a[data-wysihtml5-command=insertImage]').click(function() {
				insertImageModal.modal('show');
				insertImageModal.on('click', '[data-dismiss="modal"]', function(e) {
					e.stopPropagation();
				});
			});
		},

		initInsertLink: function(toolbar) {
			var self = this;
			var insertLinkModal = toolbar.find('.bootstrap-wysihtml5-insert-link-modal');
			var urlInput = insertLinkModal.find('.bootstrap-wysihtml5-insert-link-url');
			var insertButton = insertLinkModal.find('a.btn-primary');
			var initialValue = urlInput.val();

			var insertLink = function() {
				var url = urlInput.val();
				urlInput.val(initialValue);
				self.editor.composer.commands.exec("createLink", {
					href: url,
					target: "_blank",
					rel: "nofollow"
				});
			};
			var pressedEnter = false;

			urlInput.keypress(function(e) {
				if(e.which == 13) {
					insertLink();
					insertLinkModal.modal('hide');
				}
			});

			insertButton.click(insertLink);

			insertLinkModal.on('shown', function() {
				urlInput.focus();
			});

			insertLinkModal.on('hide', function() {
				self.editor.currentView.element.focus();
			});

			toolbar.find('a[data-wysihtml5-command=popupCreateLink]').click(function() {
				insertLinkModal.modal('show');
				insertLinkModal.on('click', '[data-dismiss="modal"]', function(e) {
					e.stopPropagation();
				});
			});
		}
	};

	$.fn.wysihtml5 = function (options) {
		return this.each(function () {
			var $this = $(this);
	      	$this.data('wysihtml5', new Wysihtml5($this, options));
	    })
  	};

  	$.fn.wysihtml5.Constructor = Wysihtml5;

}(window.jQuery, window.wysihtml5);

//! moment.js
//! version : 2.15.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):a.moment=b()}(this,function(){"use strict";function a(){return md.apply(null,arguments)}
// This is done to register the method called with moment()
// without creating circular dependencies.
function b(a){md=a}function c(a){return a instanceof Array||"[object Array]"===Object.prototype.toString.call(a)}function d(a){
// IE8 will treat undefined and null as object if it wasn't for
// input != null
return null!=a&&"[object Object]"===Object.prototype.toString.call(a)}function e(a){var b;for(b in a)
// even if its not own property I'd still call it non-empty
return!1;return!0}function f(a){return a instanceof Date||"[object Date]"===Object.prototype.toString.call(a)}function g(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function h(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function i(a,b){for(var c in b)h(b,c)&&(a[c]=b[c]);return h(b,"toString")&&(a.toString=b.toString),h(b,"valueOf")&&(a.valueOf=b.valueOf),a}function j(a,b,c,d){return qb(a,b,c,d,!0).utc()}function k(){
// We need to deep clone this object.
return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null}}function l(a){return null==a._pf&&(a._pf=k()),a._pf}function m(a){if(null==a._isValid){var b=l(a),c=nd.call(b.parsedDateParts,function(a){return null!=a}),d=!isNaN(a._d.getTime())&&b.overflow<0&&!b.empty&&!b.invalidMonth&&!b.invalidWeekday&&!b.nullInput&&!b.invalidFormat&&!b.userInvalidated&&(!b.meridiem||b.meridiem&&c);if(a._strict&&(d=d&&0===b.charsLeftOver&&0===b.unusedTokens.length&&void 0===b.bigHour),null!=Object.isFrozen&&Object.isFrozen(a))return d;a._isValid=d}return a._isValid}function n(a){var b=j(NaN);return null!=a?i(l(b),a):l(b).userInvalidated=!0,b}function o(a){return void 0===a}function p(a,b){var c,d,e;if(o(b._isAMomentObject)||(a._isAMomentObject=b._isAMomentObject),o(b._i)||(a._i=b._i),o(b._f)||(a._f=b._f),o(b._l)||(a._l=b._l),o(b._strict)||(a._strict=b._strict),o(b._tzm)||(a._tzm=b._tzm),o(b._isUTC)||(a._isUTC=b._isUTC),o(b._offset)||(a._offset=b._offset),o(b._pf)||(a._pf=l(b)),o(b._locale)||(a._locale=b._locale),od.length>0)for(c in od)d=od[c],e=b[d],o(e)||(a[d]=e);return a}
// Moment prototype object
function q(b){p(this,b),this._d=new Date(null!=b._d?b._d.getTime():NaN),pd===!1&&(pd=!0,a.updateOffset(this),pd=!1)}function r(a){return a instanceof q||null!=a&&null!=a._isAMomentObject}function s(a){return 0>a?Math.ceil(a)||0:Math.floor(a)}function t(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=s(b)),c}
// compare two arrays, return the number of differences
function u(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&t(a[d])!==t(b[d]))&&g++;return g+f}function v(b){a.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+b)}function w(b,c){var d=!0;return i(function(){if(null!=a.deprecationHandler&&a.deprecationHandler(null,b),d){for(var e,f=[],g=0;g<arguments.length;g++){if(e="","object"==typeof arguments[g]){e+="\n["+g+"] ";for(var h in arguments[0])e+=h+": "+arguments[0][h]+", ";e=e.slice(0,-2)}else e=arguments[g];f.push(e)}v(b+"\nArguments: "+Array.prototype.slice.call(f).join("")+"\n"+(new Error).stack),d=!1}return c.apply(this,arguments)},c)}function x(b,c){null!=a.deprecationHandler&&a.deprecationHandler(b,c),qd[b]||(v(c),qd[b]=!0)}function y(a){return a instanceof Function||"[object Function]"===Object.prototype.toString.call(a)}function z(a){var b,c;for(c in a)b=a[c],y(b)?this[c]=b:this["_"+c]=b;this._config=a,
// Lenient ordinal parsing accepts just a number in addition to
// number + (possibly) stuff coming from _ordinalParseLenient.
this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)}function A(a,b){var c,e=i({},a);for(c in b)h(b,c)&&(d(a[c])&&d(b[c])?(e[c]={},i(e[c],a[c]),i(e[c],b[c])):null!=b[c]?e[c]=b[c]:delete e[c]);for(c in a)h(a,c)&&!h(b,c)&&d(a[c])&&(
// make sure changes to properties don't modify parent config
e[c]=i({},e[c]));return e}function B(a){null!=a&&this.set(a)}function C(a,b,c){var d=this._calendar[a]||this._calendar.sameElse;return y(d)?d.call(b,c):d}function D(a){var b=this._longDateFormat[a],c=this._longDateFormat[a.toUpperCase()];return b||!c?b:(this._longDateFormat[a]=c.replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a])}function E(){return this._invalidDate}function F(a){return this._ordinal.replace("%d",a)}function G(a,b,c,d){var e=this._relativeTime[c];return y(e)?e(a,b,c,d):e.replace(/%d/i,a)}function H(a,b){var c=this._relativeTime[a>0?"future":"past"];return y(c)?c(b):c.replace(/%s/i,b)}function I(a,b){var c=a.toLowerCase();zd[c]=zd[c+"s"]=zd[b]=a}function J(a){return"string"==typeof a?zd[a]||zd[a.toLowerCase()]:void 0}function K(a){var b,c,d={};for(c in a)h(a,c)&&(b=J(c),b&&(d[b]=a[c]));return d}function L(a,b){Ad[a]=b}function M(a){var b=[];for(var c in a)b.push({unit:c,priority:Ad[c]});return b.sort(function(a,b){return a.priority-b.priority}),b}function N(b,c){return function(d){return null!=d?(P(this,b,d),a.updateOffset(this,c),this):O(this,b)}}function O(a,b){return a.isValid()?a._d["get"+(a._isUTC?"UTC":"")+b]():NaN}function P(a,b,c){a.isValid()&&a._d["set"+(a._isUTC?"UTC":"")+b](c)}
// MOMENTS
function Q(a){return a=J(a),y(this[a])?this[a]():this}function R(a,b){if("object"==typeof a){a=K(a);for(var c=M(a),d=0;d<c.length;d++)this[c[d].unit](a[c[d].unit])}else if(a=J(a),y(this[a]))return this[a](b);return this}function S(a,b,c){var d=""+Math.abs(a),e=b-d.length,f=a>=0;return(f?c?"+":"":"-")+Math.pow(10,Math.max(0,e)).toString().substr(1)+d}
// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function T(a,b,c,d){var e=d;"string"==typeof d&&(e=function(){return this[d]()}),a&&(Ed[a]=e),b&&(Ed[b[0]]=function(){return S(e.apply(this,arguments),b[1],b[2])}),c&&(Ed[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function U(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function V(a){var b,c,d=a.match(Bd);for(b=0,c=d.length;c>b;b++)Ed[d[b]]?d[b]=Ed[d[b]]:d[b]=U(d[b]);return function(b){var e,f="";for(e=0;c>e;e++)f+=d[e]instanceof Function?d[e].call(b,a):d[e];return f}}
// format date using native date object
function W(a,b){return a.isValid()?(b=X(b,a.localeData()),Dd[b]=Dd[b]||V(b),Dd[b](a)):a.localeData().invalidDate()}function X(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Cd.lastIndex=0;d>=0&&Cd.test(a);)a=a.replace(Cd,c),Cd.lastIndex=0,d-=1;return a}function Y(a,b,c){Wd[a]=y(b)?b:function(a,d){return a&&c?c:b}}function Z(a,b){return h(Wd,a)?Wd[a](b._strict,b._locale):new RegExp($(a))}
// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function $(a){return _(a.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e}))}function _(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function aa(a,b){var c,d=b;for("string"==typeof a&&(a=[a]),"number"==typeof b&&(d=function(a,c){c[b]=t(a)}),c=0;c<a.length;c++)Xd[a[c]]=d}function ba(a,b){aa(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function ca(a,b,c){null!=b&&h(Xd,a)&&Xd[a](b,c._a,c,a)}function da(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function ea(a,b){return a?c(this._months)?this._months[a.month()]:this._months[(this._months.isFormat||fe).test(b)?"format":"standalone"][a.month()]:this._months}function fa(a,b){return a?c(this._monthsShort)?this._monthsShort[a.month()]:this._monthsShort[fe.test(b)?"format":"standalone"][a.month()]:this._monthsShort}function ga(a,b,c){var d,e,f,g=a.toLocaleLowerCase();if(!this._monthsParse)for(
// this is not used
this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],d=0;12>d;++d)f=j([2e3,d]),this._shortMonthsParse[d]=this.monthsShort(f,"").toLocaleLowerCase(),this._longMonthsParse[d]=this.months(f,"").toLocaleLowerCase();return c?"MMM"===b?(e=sd.call(this._shortMonthsParse,g),-1!==e?e:null):(e=sd.call(this._longMonthsParse,g),-1!==e?e:null):"MMM"===b?(e=sd.call(this._shortMonthsParse,g),-1!==e?e:(e=sd.call(this._longMonthsParse,g),-1!==e?e:null)):(e=sd.call(this._longMonthsParse,g),-1!==e?e:(e=sd.call(this._shortMonthsParse,g),-1!==e?e:null))}function ha(a,b,c){var d,e,f;if(this._monthsParseExact)return ga.call(this,a,b,c);
// TODO: add sorting
// Sorting makes sure if one month (or abbr) is a prefix of another
// see sorting in computeMonthsParse
for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){
// test the regex
if(e=j([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}}
// MOMENTS
function ia(a,b){var c;if(!a.isValid())
// No op
return a;if("string"==typeof b)if(/^\d+$/.test(b))b=t(b);else
// TODO: Another silent failure?
if(b=a.localeData().monthsParse(b),"number"!=typeof b)return a;return c=Math.min(a.date(),da(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a}function ja(b){return null!=b?(ia(this,b),a.updateOffset(this,!0),this):O(this,"Month")}function ka(){return da(this.year(),this.month())}function la(a){return this._monthsParseExact?(h(this,"_monthsRegex")||na.call(this),a?this._monthsShortStrictRegex:this._monthsShortRegex):(h(this,"_monthsShortRegex")||(this._monthsShortRegex=ie),this._monthsShortStrictRegex&&a?this._monthsShortStrictRegex:this._monthsShortRegex)}function ma(a){return this._monthsParseExact?(h(this,"_monthsRegex")||na.call(this),a?this._monthsStrictRegex:this._monthsRegex):(h(this,"_monthsRegex")||(this._monthsRegex=je),this._monthsStrictRegex&&a?this._monthsStrictRegex:this._monthsRegex)}function na(){function a(a,b){return b.length-a.length}var b,c,d=[],e=[],f=[];for(b=0;12>b;b++)c=j([2e3,b]),d.push(this.monthsShort(c,"")),e.push(this.months(c,"")),f.push(this.months(c,"")),f.push(this.monthsShort(c,""));for(
// Sorting makes sure if one month (or abbr) is a prefix of another it
// will match the longer piece.
d.sort(a),e.sort(a),f.sort(a),b=0;12>b;b++)d[b]=_(d[b]),e[b]=_(e[b]);for(b=0;24>b;b++)f[b]=_(f[b]);this._monthsRegex=new RegExp("^("+f.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+e.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+d.join("|")+")","i")}
// HELPERS
function oa(a){return pa(a)?366:365}function pa(a){return a%4===0&&a%100!==0||a%400===0}function qa(){return pa(this.year())}function ra(a,b,c,d,e,f,g){
//can't just apply() to create a date:
//http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
var h=new Date(a,b,c,d,e,f,g);
//the date constructor remaps years 0-99 to 1900-1999
return 100>a&&a>=0&&isFinite(h.getFullYear())&&h.setFullYear(a),h}function sa(a){var b=new Date(Date.UTC.apply(null,arguments));
//the Date.UTC function remaps years 0-99 to 1900-1999
return 100>a&&a>=0&&isFinite(b.getUTCFullYear())&&b.setUTCFullYear(a),b}
// start-of-first-week - start-of-year
function ta(a,b,c){var// first-week day -- which january is always in the first week (4 for iso, 1 for other)
d=7+b-c,
// first-week day local weekday -- which local weekday is fwd
e=(7+sa(a,0,d).getUTCDay()-b)%7;return-e+d-1}
//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function ua(a,b,c,d,e){var f,g,h=(7+c-d)%7,i=ta(a,d,e),j=1+7*(b-1)+h+i;return 0>=j?(f=a-1,g=oa(f)+j):j>oa(a)?(f=a+1,g=j-oa(a)):(f=a,g=j),{year:f,dayOfYear:g}}function va(a,b,c){var d,e,f=ta(a.year(),b,c),g=Math.floor((a.dayOfYear()-f-1)/7)+1;return 1>g?(e=a.year()-1,d=g+wa(e,b,c)):g>wa(a.year(),b,c)?(d=g-wa(a.year(),b,c),e=a.year()+1):(e=a.year(),d=g),{week:d,year:e}}function wa(a,b,c){var d=ta(a,b,c),e=ta(a+1,b,c);return(oa(a)-d+e)/7}
// HELPERS
// LOCALES
function xa(a){return va(a,this._week.dow,this._week.doy).week}function ya(){return this._week.dow}function za(){return this._week.doy}
// MOMENTS
function Aa(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")}function Ba(a){var b=va(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")}
// HELPERS
function Ca(a,b){return"string"!=typeof a?a:isNaN(a)?(a=b.weekdaysParse(a),"number"==typeof a?a:null):parseInt(a,10)}function Da(a,b){return"string"==typeof a?b.weekdaysParse(a)%7||7:isNaN(a)?null:a}function Ea(a,b){return a?c(this._weekdays)?this._weekdays[a.day()]:this._weekdays[this._weekdays.isFormat.test(b)?"format":"standalone"][a.day()]:this._weekdays}function Fa(a){return a?this._weekdaysShort[a.day()]:this._weekdaysShort}function Ga(a){return a?this._weekdaysMin[a.day()]:this._weekdaysMin}function Ha(a,b,c){var d,e,f,g=a.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],d=0;7>d;++d)f=j([2e3,1]).day(d),this._minWeekdaysParse[d]=this.weekdaysMin(f,"").toLocaleLowerCase(),this._shortWeekdaysParse[d]=this.weekdaysShort(f,"").toLocaleLowerCase(),this._weekdaysParse[d]=this.weekdays(f,"").toLocaleLowerCase();return c?"dddd"===b?(e=sd.call(this._weekdaysParse,g),-1!==e?e:null):"ddd"===b?(e=sd.call(this._shortWeekdaysParse,g),-1!==e?e:null):(e=sd.call(this._minWeekdaysParse,g),-1!==e?e:null):"dddd"===b?(e=sd.call(this._weekdaysParse,g),-1!==e?e:(e=sd.call(this._shortWeekdaysParse,g),-1!==e?e:(e=sd.call(this._minWeekdaysParse,g),-1!==e?e:null))):"ddd"===b?(e=sd.call(this._shortWeekdaysParse,g),-1!==e?e:(e=sd.call(this._weekdaysParse,g),-1!==e?e:(e=sd.call(this._minWeekdaysParse,g),-1!==e?e:null))):(e=sd.call(this._minWeekdaysParse,g),-1!==e?e:(e=sd.call(this._weekdaysParse,g),-1!==e?e:(e=sd.call(this._shortWeekdaysParse,g),-1!==e?e:null)))}function Ia(a,b,c){var d,e,f;if(this._weekdaysParseExact)return Ha.call(this,a,b,c);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),d=0;7>d;d++){
// test the regex
if(e=j([2e3,1]).day(d),c&&!this._fullWeekdaysParse[d]&&(this._fullWeekdaysParse[d]=new RegExp("^"+this.weekdays(e,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[d]=new RegExp("^"+this.weekdaysShort(e,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[d]=new RegExp("^"+this.weekdaysMin(e,"").replace(".",".?")+"$","i")),this._weekdaysParse[d]||(f="^"+this.weekdays(e,"")+"|^"+this.weekdaysShort(e,"")+"|^"+this.weekdaysMin(e,""),this._weekdaysParse[d]=new RegExp(f.replace(".",""),"i")),c&&"dddd"===b&&this._fullWeekdaysParse[d].test(a))return d;if(c&&"ddd"===b&&this._shortWeekdaysParse[d].test(a))return d;if(c&&"dd"===b&&this._minWeekdaysParse[d].test(a))return d;if(!c&&this._weekdaysParse[d].test(a))return d}}
// MOMENTS
function Ja(a){if(!this.isValid())return null!=a?this:NaN;var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Ca(a,this.localeData()),this.add(a-b,"d")):b}function Ka(a){if(!this.isValid())return null!=a?this:NaN;var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")}function La(a){if(!this.isValid())return null!=a?this:NaN;
// behaves the same as moment#day except
// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
// as a setter, sunday should belong to the previous week.
if(null!=a){var b=Da(a,this.localeData());return this.day(this.day()%7?b:b-7)}return this.day()||7}function Ma(a){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||Pa.call(this),a?this._weekdaysStrictRegex:this._weekdaysRegex):(h(this,"_weekdaysRegex")||(this._weekdaysRegex=pe),this._weekdaysStrictRegex&&a?this._weekdaysStrictRegex:this._weekdaysRegex)}function Na(a){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||Pa.call(this),a?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(h(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=qe),this._weekdaysShortStrictRegex&&a?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Oa(a){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||Pa.call(this),a?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(h(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=re),this._weekdaysMinStrictRegex&&a?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Pa(){function a(a,b){return b.length-a.length}var b,c,d,e,f,g=[],h=[],i=[],k=[];for(b=0;7>b;b++)c=j([2e3,1]).day(b),d=this.weekdaysMin(c,""),e=this.weekdaysShort(c,""),f=this.weekdays(c,""),g.push(d),h.push(e),i.push(f),k.push(d),k.push(e),k.push(f);for(
// Sorting makes sure if one weekday (or abbr) is a prefix of another it
// will match the longer piece.
g.sort(a),h.sort(a),i.sort(a),k.sort(a),b=0;7>b;b++)h[b]=_(h[b]),i[b]=_(i[b]),k[b]=_(k[b]);this._weekdaysRegex=new RegExp("^("+k.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+h.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+g.join("|")+")","i")}
// FORMATTING
function Qa(){return this.hours()%12||12}function Ra(){return this.hours()||24}function Sa(a,b){T(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}
// PARSING
function Ta(a,b){return b._meridiemParse}
// LOCALES
function Ua(a){
// IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
// Using charAt should be more compatible.
return"p"===(a+"").toLowerCase().charAt(0)}function Va(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"}function Wa(a){return a?a.toLowerCase().replace("_","-"):a}
// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function Xa(a){for(var b,c,d,e,f=0;f<a.length;){for(e=Wa(a[f]).split("-"),b=e.length,c=Wa(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=Ya(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&u(e,c,!0)>=b-1)
//the next array item is better than a shallower substring of this one
break;b--}f++}return null}function Ya(a){var b=null;
// TODO: Find a better way to register and load all the locales in Node
if(!we[a]&&"undefined"!=typeof module&&module&&module.require)try{b=se._abbr,module.require("./locale/"+a),
// because defineLocale currently also sets the global locale, we
// want to undo that for lazy loaded locales
Za(b)}catch(c){}return we[a]}
// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function Za(a,b){var c;
// moment.duration._locale = moment._locale = data;
return a&&(c=o(b)?ab(a):$a(a,b),c&&(se=c)),se._abbr}function $a(a,b){if(null!==b){var c=ve;
// treat as if there is no base config
// backwards compat for now: also set the locale
return b.abbr=a,null!=we[a]?(x("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),c=we[a]._config):null!=b.parentLocale&&(null!=we[b.parentLocale]?c=we[b.parentLocale]._config:x("parentLocaleUndefined","specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/")),we[a]=new B(A(c,b)),Za(a),we[a]}
// useful for testing
return delete we[a],null}function _a(a,b){if(null!=b){var c,d=ve;
// MERGE
null!=we[a]&&(d=we[a]._config),b=A(d,b),c=new B(b),c.parentLocale=we[a],we[a]=c,
// backwards compat for now: also set the locale
Za(a)}else
// pass null for config to unupdate, useful for tests
null!=we[a]&&(null!=we[a].parentLocale?we[a]=we[a].parentLocale:null!=we[a]&&delete we[a]);return we[a]}
// returns locale data
function ab(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return se;if(!c(a)){if(b=Ya(a))return b;a=[a]}return Xa(a)}function bb(){return rd(we)}function cb(a){var b,c=a._a;return c&&-2===l(a).overflow&&(b=c[Zd]<0||c[Zd]>11?Zd:c[$d]<1||c[$d]>da(c[Yd],c[Zd])?$d:c[_d]<0||c[_d]>24||24===c[_d]&&(0!==c[ae]||0!==c[be]||0!==c[ce])?_d:c[ae]<0||c[ae]>59?ae:c[be]<0||c[be]>59?be:c[ce]<0||c[ce]>999?ce:-1,l(a)._overflowDayOfYear&&(Yd>b||b>$d)&&(b=$d),l(a)._overflowWeeks&&-1===b&&(b=de),l(a)._overflowWeekday&&-1===b&&(b=ee),l(a).overflow=b),a}
// date from iso format
function db(a){var b,c,d,e,f,g,h=a._i,i=xe.exec(h)||ye.exec(h);if(i){for(l(a).iso=!0,b=0,c=Ae.length;c>b;b++)if(Ae[b][1].exec(i[1])){e=Ae[b][0],d=Ae[b][2]!==!1;break}if(null==e)return void(a._isValid=!1);if(i[3]){for(b=0,c=Be.length;c>b;b++)if(Be[b][1].exec(i[3])){
// match[2] should be 'T' or space
f=(i[2]||" ")+Be[b][0];break}if(null==f)return void(a._isValid=!1)}if(!d&&null!=f)return void(a._isValid=!1);if(i[4]){if(!ze.exec(i[4]))return void(a._isValid=!1);g="Z"}a._f=e+(f||"")+(g||""),jb(a)}else a._isValid=!1}
// date from iso format or fallback
function eb(b){var c=Ce.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(db(b),void(b._isValid===!1&&(delete b._isValid,a.createFromInputFallback(b))))}
// Pick the first defined of two or three arguments.
function fb(a,b,c){return null!=a?a:null!=b?b:c}function gb(b){
// hooks is actually the exported moment object
var c=new Date(a.now());return b._useUTC?[c.getUTCFullYear(),c.getUTCMonth(),c.getUTCDate()]:[c.getFullYear(),c.getMonth(),c.getDate()]}
// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function hb(a){var b,c,d,e,f=[];if(!a._d){
// Default to current date.
// * if no year, month, day of month are given, default to today
// * if day of month is given, default month and year
// * if month is given, default only year
// * if year is given, don't default anything
for(d=gb(a),a._w&&null==a._a[$d]&&null==a._a[Zd]&&ib(a),a._dayOfYear&&(e=fb(a._a[Yd],d[Yd]),a._dayOfYear>oa(e)&&(l(a)._overflowDayOfYear=!0),c=sa(e,0,a._dayOfYear),a._a[Zd]=c.getUTCMonth(),a._a[$d]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=f[b]=d[b];
// Zero out whatever was not defaulted, including time
for(;7>b;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];
// Check for 24:00:00.000
24===a._a[_d]&&0===a._a[ae]&&0===a._a[be]&&0===a._a[ce]&&(a._nextDay=!0,a._a[_d]=0),a._d=(a._useUTC?sa:ra).apply(null,f),
// Apply timezone offset from input. The actual utcOffset can be changed
// with parseZone.
null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[_d]=24)}}function ib(a){var b,c,d,e,f,g,h,i;b=a._w,null!=b.GG||null!=b.W||null!=b.E?(f=1,g=4,c=fb(b.GG,a._a[Yd],va(rb(),1,4).year),d=fb(b.W,1),e=fb(b.E,1),(1>e||e>7)&&(i=!0)):(f=a._locale._week.dow,g=a._locale._week.doy,c=fb(b.gg,a._a[Yd],va(rb(),f,g).year),d=fb(b.w,1),null!=b.d?(e=b.d,(0>e||e>6)&&(i=!0)):null!=b.e?(e=b.e+f,(b.e<0||b.e>6)&&(i=!0)):e=f),1>d||d>wa(c,f,g)?l(a)._overflowWeeks=!0:null!=i?l(a)._overflowWeekday=!0:(h=ua(c,d,e,f,g),a._a[Yd]=h.year,a._dayOfYear=h.dayOfYear)}
// date from string and format string
function jb(b){
// TODO: Move this to another part of the creation flow to prevent circular deps
if(b._f===a.ISO_8601)return void db(b);b._a=[],l(b).empty=!0;
// This array is used to make a Date, either with `new Date` or `Date.UTC`
var c,d,e,f,g,h=""+b._i,i=h.length,j=0;for(e=X(b._f,b._locale).match(Bd)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(Z(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&l(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),j+=d.length),Ed[f]?(d?l(b).empty=!1:l(b).unusedTokens.push(f),ca(f,d,b)):b._strict&&!d&&l(b).unusedTokens.push(f);
// add remaining unparsed input length to the string
l(b).charsLeftOver=i-j,h.length>0&&l(b).unusedInput.push(h),
// clear _12h flag if hour is <= 12
b._a[_d]<=12&&l(b).bigHour===!0&&b._a[_d]>0&&(l(b).bigHour=void 0),l(b).parsedDateParts=b._a.slice(0),l(b).meridiem=b._meridiem,
// handle meridiem
b._a[_d]=kb(b._locale,b._a[_d],b._meridiem),hb(b),cb(b)}function kb(a,b,c){var d;
// Fallback
return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}
// date from string and array of format strings
function lb(a){var b,c,d,e,f;if(0===a._f.length)return l(a).invalidFormat=!0,void(a._d=new Date(NaN));for(e=0;e<a._f.length;e++)f=0,b=p({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._f=a._f[e],jb(b),m(b)&&(f+=l(b).charsLeftOver,f+=10*l(b).unusedTokens.length,l(b).score=f,(null==d||d>f)&&(d=f,c=b));i(a,c||b)}function mb(a){if(!a._d){var b=K(a._i);a._a=g([b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],function(a){return a&&parseInt(a,10)}),hb(a)}}function nb(a){var b=new q(cb(ob(a)));
// Adding is smart enough around DST
return b._nextDay&&(b.add(1,"d"),b._nextDay=void 0),b}function ob(a){var b=a._i,d=a._f;return a._locale=a._locale||ab(a._l),null===b||void 0===d&&""===b?n({nullInput:!0}):("string"==typeof b&&(a._i=b=a._locale.preparse(b)),r(b)?new q(cb(b)):(c(d)?lb(a):f(b)?a._d=b:d?jb(a):pb(a),m(a)||(a._d=null),a))}function pb(b){var d=b._i;void 0===d?b._d=new Date(a.now()):f(d)?b._d=new Date(d.valueOf()):"string"==typeof d?eb(b):c(d)?(b._a=g(d.slice(0),function(a){return parseInt(a,10)}),hb(b)):"object"==typeof d?mb(b):"number"==typeof d?
// from milliseconds
b._d=new Date(d):a.createFromInputFallback(b)}function qb(a,b,f,g,h){var i={};
// object construction must be done this way.
// https://github.com/moment/moment/issues/1423
return"boolean"==typeof f&&(g=f,f=void 0),(d(a)&&e(a)||c(a)&&0===a.length)&&(a=void 0),i._isAMomentObject=!0,i._useUTC=i._isUTC=h,i._l=f,i._i=a,i._f=b,i._strict=g,nb(i)}function rb(a,b,c,d){return qb(a,b,c,d,!1)}
// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function sb(a,b){var d,e;if(1===b.length&&c(b[0])&&(b=b[0]),!b.length)return rb();for(d=b[0],e=1;e<b.length;++e)b[e].isValid()&&!b[e][a](d)||(d=b[e]);return d}
// TODO: Use [].sort instead?
function tb(){var a=[].slice.call(arguments,0);return sb("isBefore",a)}function ub(){var a=[].slice.call(arguments,0);return sb("isAfter",a)}function vb(a){var b=K(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;
// representation for dateAddRemove
this._milliseconds=+k+1e3*j+// 1000
6e4*i+// 1000 * 60
1e3*h*60*60,//using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
// Because of dateAddRemove treats 24 hours as different from a
// day when working around DST, we need to store them separately
this._days=+g+7*f,
// It is impossible translate months into days without knowing
// which months you are are talking about, so we have to store
// it separately.
this._months=+e+3*d+12*c,this._data={},this._locale=ab(),this._bubble()}function wb(a){return a instanceof vb}function xb(a){return 0>a?-1*Math.round(-1*a):Math.round(a)}
// FORMATTING
function yb(a,b){T(a,0,0,function(){var a=this.utcOffset(),c="+";return 0>a&&(a=-a,c="-"),c+S(~~(a/60),2)+b+S(~~a%60,2)})}function zb(a,b){var c=(b||"").match(a)||[],d=c[c.length-1]||[],e=(d+"").match(Ge)||["-",0,0],f=+(60*e[1])+t(e[2]);return"+"===e[0]?f:-f}
// Return a moment from input, that is local/utc/zone equivalent to model.
function Ab(b,c){var d,e;
// Use low-level api, because this fn is low-level api.
return c._isUTC?(d=c.clone(),e=(r(b)||f(b)?b.valueOf():rb(b).valueOf())-d.valueOf(),d._d.setTime(d._d.valueOf()+e),a.updateOffset(d,!1),d):rb(b).local()}function Bb(a){
// On Firefox.24 Date#getTimezoneOffset returns a floating point.
// https://github.com/moment/moment/pull/1871
return 15*-Math.round(a._d.getTimezoneOffset()/15)}
// MOMENTS
// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function Cb(b,c){var d,e=this._offset||0;return this.isValid()?null!=b?("string"==typeof b?b=zb(Td,b):Math.abs(b)<16&&(b=60*b),!this._isUTC&&c&&(d=Bb(this)),this._offset=b,this._isUTC=!0,null!=d&&this.add(d,"m"),e!==b&&(!c||this._changeInProgress?Sb(this,Nb(b-e,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?e:Bb(this):null!=b?this:NaN}function Db(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Eb(a){return this.utcOffset(0,a)}function Fb(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(Bb(this),"m")),this}function Gb(){if(this._tzm)this.utcOffset(this._tzm);else if("string"==typeof this._i){var a=zb(Sd,this._i);0===a?this.utcOffset(0,!0):this.utcOffset(zb(Sd,this._i))}return this}function Hb(a){return this.isValid()?(a=a?rb(a).utcOffset():0,(this.utcOffset()-a)%60===0):!1}function Ib(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Jb(){if(!o(this._isDSTShifted))return this._isDSTShifted;var a={};if(p(a,this),a=ob(a),a._a){var b=a._isUTC?j(a._a):rb(a._a);this._isDSTShifted=this.isValid()&&u(a._a,b.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}function Kb(){return this.isValid()?!this._isUTC:!1}function Lb(){return this.isValid()?this._isUTC:!1}function Mb(){return this.isValid()?this._isUTC&&0===this._offset:!1}function Nb(a,b){var c,d,e,f=a,
// matching against regexp is expensive, do it on demand
g=null;// checks for null or undefined
return wb(a)?f={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(f={},b?f[b]=a:f.milliseconds=a):(g=He.exec(a))?(c="-"===g[1]?-1:1,f={y:0,d:t(g[$d])*c,h:t(g[_d])*c,m:t(g[ae])*c,s:t(g[be])*c,ms:t(xb(1e3*g[ce]))*c}):(g=Ie.exec(a))?(c="-"===g[1]?-1:1,f={y:Ob(g[2],c),M:Ob(g[3],c),w:Ob(g[4],c),d:Ob(g[5],c),h:Ob(g[6],c),m:Ob(g[7],c),s:Ob(g[8],c)}):null==f?f={}:"object"==typeof f&&("from"in f||"to"in f)&&(e=Qb(rb(f.from),rb(f.to)),f={},f.ms=e.milliseconds,f.M=e.months),d=new vb(f),wb(a)&&h(a,"_locale")&&(d._locale=a._locale),d}function Ob(a,b){
// We'd normally use ~~inp for this, but unfortunately it also
// converts floats to ints.
// inp may be undefined, so careful calling replace on it.
var c=a&&parseFloat(a.replace(",","."));
// apply sign while we're at it
return(isNaN(c)?0:c)*b}function Pb(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function Qb(a,b){var c;return a.isValid()&&b.isValid()?(b=Ab(b,a),a.isBefore(b)?c=Pb(a,b):(c=Pb(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c):{milliseconds:0,months:0}}
// TODO: remove 'name' arg after deprecation is removed
function Rb(a,b){return function(c,d){var e,f;
//invert the arguments, but complain about it
return null===d||isNaN(+d)||(x(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=Nb(c,d),Sb(this,e,a),this}}function Sb(b,c,d,e){var f=c._milliseconds,g=xb(c._days),h=xb(c._months);b.isValid()&&(e=null==e?!0:e,f&&b._d.setTime(b._d.valueOf()+f*d),g&&P(b,"Date",O(b,"Date")+g*d),h&&ia(b,O(b,"Month")+h*d),e&&a.updateOffset(b,g||h))}function Tb(a,b){var c=a.diff(b,"days",!0);return-6>c?"sameElse":-1>c?"lastWeek":0>c?"lastDay":1>c?"sameDay":2>c?"nextDay":7>c?"nextWeek":"sameElse"}function Ub(b,c){
// We want to compare the start of today, vs this.
// Getting start-of-today depends on whether we're local/utc/offset or not.
var d=b||rb(),e=Ab(d,this).startOf("day"),f=a.calendarFormat(this,e)||"sameElse",g=c&&(y(c[f])?c[f].call(this,d):c[f]);return this.format(g||this.localeData().calendar(f,this,rb(d)))}function Vb(){return new q(this)}function Wb(a,b){var c=r(a)?a:rb(a);return this.isValid()&&c.isValid()?(b=J(o(b)?"millisecond":b),"millisecond"===b?this.valueOf()>c.valueOf():c.valueOf()<this.clone().startOf(b).valueOf()):!1}function Xb(a,b){var c=r(a)?a:rb(a);return this.isValid()&&c.isValid()?(b=J(o(b)?"millisecond":b),"millisecond"===b?this.valueOf()<c.valueOf():this.clone().endOf(b).valueOf()<c.valueOf()):!1}function Yb(a,b,c,d){return d=d||"()",("("===d[0]?this.isAfter(a,c):!this.isBefore(a,c))&&(")"===d[1]?this.isBefore(b,c):!this.isAfter(b,c))}function Zb(a,b){var c,d=r(a)?a:rb(a);return this.isValid()&&d.isValid()?(b=J(b||"millisecond"),"millisecond"===b?this.valueOf()===d.valueOf():(c=d.valueOf(),this.clone().startOf(b).valueOf()<=c&&c<=this.clone().endOf(b).valueOf())):!1}function $b(a,b){return this.isSame(a,b)||this.isAfter(a,b)}function _b(a,b){return this.isSame(a,b)||this.isBefore(a,b)}function ac(a,b,c){var d,e,f,g;// 1000
// 1000 * 60
// 1000 * 60 * 60
// 1000 * 60 * 60 * 24, negate dst
// 1000 * 60 * 60 * 24 * 7, negate dst
return this.isValid()?(d=Ab(a,this),d.isValid()?(e=6e4*(d.utcOffset()-this.utcOffset()),b=J(b),"year"===b||"month"===b||"quarter"===b?(g=bc(this,d),"quarter"===b?g/=3:"year"===b&&(g/=12)):(f=this-d,g="second"===b?f/1e3:"minute"===b?f/6e4:"hour"===b?f/36e5:"day"===b?(f-e)/864e5:"week"===b?(f-e)/6048e5:f),c?g:s(g)):NaN):NaN}function bc(a,b){
// difference in months
var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),
// b is in (anchor - 1 month, anchor + 1 month)
f=a.clone().add(e,"months");
//check for negative zero, return zero if negative zero
// linear across the month
// linear across the month
return 0>b-f?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)||0}function cc(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function dc(){var a=this.clone().utc();return 0<a.year()&&a.year()<=9999?y(Date.prototype.toISOString)?this.toDate().toISOString():W(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):W(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")}function ec(b){b||(b=this.isUtc()?a.defaultFormatUtc:a.defaultFormat);var c=W(this,b);return this.localeData().postformat(c)}function fc(a,b){return this.isValid()&&(r(a)&&a.isValid()||rb(a).isValid())?Nb({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function gc(a){return this.from(rb(),a)}function hc(a,b){return this.isValid()&&(r(a)&&a.isValid()||rb(a).isValid())?Nb({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function ic(a){return this.to(rb(),a)}
// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function jc(a){var b;return void 0===a?this._locale._abbr:(b=ab(a),null!=b&&(this._locale=b),this)}function kc(){return this._locale}function lc(a){
// the following switch intentionally omits break keywords
// to utilize falling through the cases.
switch(a=J(a)){case"year":this.month(0);/* falls through */
case"quarter":case"month":this.date(1);/* falls through */
case"week":case"isoWeek":case"day":case"date":this.hours(0);/* falls through */
case"hour":this.minutes(0);/* falls through */
case"minute":this.seconds(0);/* falls through */
case"second":this.milliseconds(0)}
// weeks are a special case
// quarters are also special
return"week"===a&&this.weekday(0),"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this}function mc(a){
// 'date' is an alias for 'day', so it should be considered as such.
return a=J(a),void 0===a||"millisecond"===a?this:("date"===a&&(a="day"),this.startOf(a).add(1,"isoWeek"===a?"week":a).subtract(1,"ms"))}function nc(){return this._d.valueOf()-6e4*(this._offset||0)}function oc(){return Math.floor(this.valueOf()/1e3)}function pc(){return new Date(this.valueOf())}function qc(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function rc(){var a=this;return{years:a.year(),months:a.month(),date:a.date(),hours:a.hours(),minutes:a.minutes(),seconds:a.seconds(),milliseconds:a.milliseconds()}}function sc(){
// new Date(NaN).toJSON() === null
return this.isValid()?this.toISOString():null}function tc(){return m(this)}function uc(){return i({},l(this))}function vc(){return l(this).overflow}function wc(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function xc(a,b){T(0,[a,a.length],0,b)}
// MOMENTS
function yc(a){return Cc.call(this,a,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function zc(a){return Cc.call(this,a,this.isoWeek(),this.isoWeekday(),1,4)}function Ac(){return wa(this.year(),1,4)}function Bc(){var a=this.localeData()._week;return wa(this.year(),a.dow,a.doy)}function Cc(a,b,c,d,e){var f;return null==a?va(this,d,e).year:(f=wa(a,d,e),b>f&&(b=f),Dc.call(this,a,b,c,d,e))}function Dc(a,b,c,d,e){var f=ua(a,b,c,d,e),g=sa(f.year,0,f.dayOfYear);return this.year(g.getUTCFullYear()),this.month(g.getUTCMonth()),this.date(g.getUTCDate()),this}
// MOMENTS
function Ec(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}
// HELPERS
// MOMENTS
function Fc(a){var b=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")}function Gc(a,b){b[ce]=t(1e3*("0."+a))}
// MOMENTS
function Hc(){return this._isUTC?"UTC":""}function Ic(){return this._isUTC?"Coordinated Universal Time":""}function Jc(a){return rb(1e3*a)}function Kc(){return rb.apply(null,arguments).parseZone()}function Lc(a){return a}function Mc(a,b,c,d){var e=ab(),f=j().set(d,b);return e[c](f,a)}function Nc(a,b,c){if("number"==typeof a&&(b=a,a=void 0),a=a||"",null!=b)return Mc(a,b,c,"month");var d,e=[];for(d=0;12>d;d++)e[d]=Mc(a,d,c,"month");return e}
// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function Oc(a,b,c,d){"boolean"==typeof a?("number"==typeof b&&(c=b,b=void 0),b=b||""):(b=a,c=b,a=!1,"number"==typeof b&&(c=b,b=void 0),b=b||"");var e=ab(),f=a?e._week.dow:0;if(null!=c)return Mc(b,(c+f)%7,d,"day");var g,h=[];for(g=0;7>g;g++)h[g]=Mc(b,(g+f)%7,d,"day");return h}function Pc(a,b){return Nc(a,b,"months")}function Qc(a,b){return Nc(a,b,"monthsShort")}function Rc(a,b,c){return Oc(a,b,c,"weekdays")}function Sc(a,b,c){return Oc(a,b,c,"weekdaysShort")}function Tc(a,b,c){return Oc(a,b,c,"weekdaysMin")}function Uc(){var a=this._data;return this._milliseconds=Ue(this._milliseconds),this._days=Ue(this._days),this._months=Ue(this._months),a.milliseconds=Ue(a.milliseconds),a.seconds=Ue(a.seconds),a.minutes=Ue(a.minutes),a.hours=Ue(a.hours),a.months=Ue(a.months),a.years=Ue(a.years),this}function Vc(a,b,c,d){var e=Nb(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}
// supports only 2.0-style add(1, 's') or add(duration)
function Wc(a,b){return Vc(this,a,b,1)}
// supports only 2.0-style subtract(1, 's') or subtract(duration)
function Xc(a,b){return Vc(this,a,b,-1)}function Yc(a){return 0>a?Math.floor(a):Math.ceil(a)}function Zc(){var a,b,c,d,e,f=this._milliseconds,g=this._days,h=this._months,i=this._data;
// if we have a mix of positive and negative values, bubble down first
// check: https://github.com/moment/moment/issues/2166
// The following code bubbles up values, see the tests for
// examples of what that means.
// convert days to months
// 12 months -> 1 year
return f>=0&&g>=0&&h>=0||0>=f&&0>=g&&0>=h||(f+=864e5*Yc(_c(h)+g),g=0,h=0),i.milliseconds=f%1e3,a=s(f/1e3),i.seconds=a%60,b=s(a/60),i.minutes=b%60,c=s(b/60),i.hours=c%24,g+=s(c/24),e=s($c(g)),h+=e,g-=Yc(_c(e)),d=s(h/12),h%=12,i.days=g,i.months=h,i.years=d,this}function $c(a){
// 400 years have 146097 days (taking into account leap year rules)
// 400 years have 12 months === 4800
return 4800*a/146097}function _c(a){
// the reverse of daysToMonths
return 146097*a/4800}function ad(a){var b,c,d=this._milliseconds;if(a=J(a),"month"===a||"year"===a)return b=this._days+d/864e5,c=this._months+$c(b),"month"===a?c:c/12;switch(b=this._days+Math.round(_c(this._months)),a){case"week":return b/7+d/6048e5;case"day":return b+d/864e5;case"hour":return 24*b+d/36e5;case"minute":return 1440*b+d/6e4;case"second":return 86400*b+d/1e3;
// Math.floor prevents floating point math errors here
case"millisecond":return Math.floor(864e5*b)+d;default:throw new Error("Unknown unit "+a)}}
// TODO: Use this.as('ms')?
function bd(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*t(this._months/12)}function cd(a){return function(){return this.as(a)}}function dd(a){return a=J(a),this[a+"s"]()}function ed(a){return function(){return this._data[a]}}function fd(){return s(this.days()/7)}
// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function gd(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function hd(a,b,c){var d=Nb(a).abs(),e=jf(d.as("s")),f=jf(d.as("m")),g=jf(d.as("h")),h=jf(d.as("d")),i=jf(d.as("M")),j=jf(d.as("y")),k=e<kf.s&&["s",e]||1>=f&&["m"]||f<kf.m&&["mm",f]||1>=g&&["h"]||g<kf.h&&["hh",g]||1>=h&&["d"]||h<kf.d&&["dd",h]||1>=i&&["M"]||i<kf.M&&["MM",i]||1>=j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,gd.apply(null,k)}
// This function allows you to set the rounding function for relative time strings
function id(a){return void 0===a?jf:"function"==typeof a?(jf=a,!0):!1}
// This function allows you to set a threshold for relative time strings
function jd(a,b){return void 0===kf[a]?!1:void 0===b?kf[a]:(kf[a]=b,!0)}function kd(a){var b=this.localeData(),c=hd(this,!a,b);return a&&(c=b.pastFuture(+this,c)),b.postformat(c)}function ld(){
// for ISO strings we do not use the normal bubbling rules:
//  * milliseconds bubble up until they become hours
//  * days do not bubble at all
//  * months bubble up until they become years
// This is because there is no context-free conversion between hours and days
// (think of clock changes)
// and also not between days and months (28-31 days per month)
var a,b,c,d=lf(this._milliseconds)/1e3,e=lf(this._days),f=lf(this._months);a=s(d/60),b=s(a/60),d%=60,a%=60,c=s(f/12),f%=12;
// inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
var g=c,h=f,i=e,j=b,k=a,l=d,m=this.asSeconds();return m?(0>m?"-":"")+"P"+(g?g+"Y":"")+(h?h+"M":"")+(i?i+"D":"")+(j||k||l?"T":"")+(j?j+"H":"")+(k?k+"M":"")+(l?l+"S":""):"P0D"}var md,nd;nd=Array.prototype.some?Array.prototype.some:function(a){for(var b=Object(this),c=b.length>>>0,d=0;c>d;d++)if(d in b&&a.call(this,b[d],d,b))return!0;return!1};
// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var od=a.momentProperties=[],pd=!1,qd={};a.suppressDeprecationWarnings=!1,a.deprecationHandler=null;var rd;rd=Object.keys?Object.keys:function(a){var b,c=[];for(b in a)h(a,b)&&c.push(b);return c};var sd,td={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},ud={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},vd="Invalid date",wd="%d",xd=/\d{1,2}/,yd={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},zd={},Ad={},Bd=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Cd=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Dd={},Ed={},Fd=/\d/,Gd=/\d\d/,Hd=/\d{3}/,Id=/\d{4}/,Jd=/[+-]?\d{6}/,Kd=/\d\d?/,Ld=/\d\d\d\d?/,Md=/\d\d\d\d\d\d?/,Nd=/\d{1,3}/,Od=/\d{1,4}/,Pd=/[+-]?\d{1,6}/,Qd=/\d+/,Rd=/[+-]?\d+/,Sd=/Z|[+-]\d\d:?\d\d/gi,Td=/Z|[+-]\d\d(?::?\d\d)?/gi,Ud=/[+-]?\d+(\.\d{1,3})?/,Vd=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,Wd={},Xd={},Yd=0,Zd=1,$d=2,_d=3,ae=4,be=5,ce=6,de=7,ee=8;sd=Array.prototype.indexOf?Array.prototype.indexOf:function(a){
// I know
var b;for(b=0;b<this.length;++b)if(this[b]===a)return b;return-1},T("M",["MM",2],"Mo",function(){return this.month()+1}),T("MMM",0,0,function(a){return this.localeData().monthsShort(this,a)}),T("MMMM",0,0,function(a){return this.localeData().months(this,a)}),I("month","M"),L("month",8),Y("M",Kd),Y("MM",Kd,Gd),Y("MMM",function(a,b){return b.monthsShortRegex(a)}),Y("MMMM",function(a,b){return b.monthsRegex(a)}),aa(["M","MM"],function(a,b){b[Zd]=t(a)-1}),aa(["MMM","MMMM"],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);null!=e?b[Zd]=e:l(c).invalidMonth=a});
// LOCALES
var fe=/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/,ge="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),he="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),ie=Vd,je=Vd;
// FORMATTING
T("Y",0,0,function(){var a=this.year();return 9999>=a?""+a:"+"+a}),T(0,["YY",2],0,function(){return this.year()%100}),T(0,["YYYY",4],0,"year"),T(0,["YYYYY",5],0,"year"),T(0,["YYYYYY",6,!0],0,"year"),
// ALIASES
I("year","y"),
// PRIORITIES
L("year",1),
// PARSING
Y("Y",Rd),Y("YY",Kd,Gd),Y("YYYY",Od,Id),Y("YYYYY",Pd,Jd),Y("YYYYYY",Pd,Jd),aa(["YYYYY","YYYYYY"],Yd),aa("YYYY",function(b,c){c[Yd]=2===b.length?a.parseTwoDigitYear(b):t(b)}),aa("YY",function(b,c){c[Yd]=a.parseTwoDigitYear(b)}),aa("Y",function(a,b){b[Yd]=parseInt(a,10)}),
// HOOKS
a.parseTwoDigitYear=function(a){return t(a)+(t(a)>68?1900:2e3)};
// MOMENTS
var ke=N("FullYear",!0);
// FORMATTING
T("w",["ww",2],"wo","week"),T("W",["WW",2],"Wo","isoWeek"),
// ALIASES
I("week","w"),I("isoWeek","W"),
// PRIORITIES
L("week",5),L("isoWeek",5),
// PARSING
Y("w",Kd),Y("ww",Kd,Gd),Y("W",Kd),Y("WW",Kd,Gd),ba(["w","ww","W","WW"],function(a,b,c,d){b[d.substr(0,1)]=t(a)});var le={dow:0,// Sunday is the first day of the week.
doy:6};
// FORMATTING
T("d",0,"do","day"),T("dd",0,0,function(a){return this.localeData().weekdaysMin(this,a)}),T("ddd",0,0,function(a){return this.localeData().weekdaysShort(this,a)}),T("dddd",0,0,function(a){return this.localeData().weekdays(this,a)}),T("e",0,0,"weekday"),T("E",0,0,"isoWeekday"),
// ALIASES
I("day","d"),I("weekday","e"),I("isoWeekday","E"),
// PRIORITY
L("day",11),L("weekday",11),L("isoWeekday",11),
// PARSING
Y("d",Kd),Y("e",Kd),Y("E",Kd),Y("dd",function(a,b){return b.weekdaysMinRegex(a)}),Y("ddd",function(a,b){return b.weekdaysShortRegex(a)}),Y("dddd",function(a,b){return b.weekdaysRegex(a)}),ba(["dd","ddd","dddd"],function(a,b,c,d){var e=c._locale.weekdaysParse(a,d,c._strict);
// if we didn't get a weekday name, mark the date as invalid
null!=e?b.d=e:l(c).invalidWeekday=a}),ba(["d","e","E"],function(a,b,c,d){b[d]=t(a)});
// LOCALES
var me="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),ne="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),oe="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),pe=Vd,qe=Vd,re=Vd;T("H",["HH",2],0,"hour"),T("h",["hh",2],0,Qa),T("k",["kk",2],0,Ra),T("hmm",0,0,function(){return""+Qa.apply(this)+S(this.minutes(),2)}),T("hmmss",0,0,function(){return""+Qa.apply(this)+S(this.minutes(),2)+S(this.seconds(),2)}),T("Hmm",0,0,function(){return""+this.hours()+S(this.minutes(),2)}),T("Hmmss",0,0,function(){return""+this.hours()+S(this.minutes(),2)+S(this.seconds(),2)}),Sa("a",!0),Sa("A",!1),
// ALIASES
I("hour","h"),
// PRIORITY
L("hour",13),Y("a",Ta),Y("A",Ta),Y("H",Kd),Y("h",Kd),Y("HH",Kd,Gd),Y("hh",Kd,Gd),Y("hmm",Ld),Y("hmmss",Md),Y("Hmm",Ld),Y("Hmmss",Md),aa(["H","HH"],_d),aa(["a","A"],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),aa(["h","hh"],function(a,b,c){b[_d]=t(a),l(c).bigHour=!0}),aa("hmm",function(a,b,c){var d=a.length-2;b[_d]=t(a.substr(0,d)),b[ae]=t(a.substr(d)),l(c).bigHour=!0}),aa("hmmss",function(a,b,c){var d=a.length-4,e=a.length-2;b[_d]=t(a.substr(0,d)),b[ae]=t(a.substr(d,2)),b[be]=t(a.substr(e)),l(c).bigHour=!0}),aa("Hmm",function(a,b,c){var d=a.length-2;b[_d]=t(a.substr(0,d)),b[ae]=t(a.substr(d))}),aa("Hmmss",function(a,b,c){var d=a.length-4,e=a.length-2;b[_d]=t(a.substr(0,d)),b[ae]=t(a.substr(d,2)),b[be]=t(a.substr(e))});var se,te=/[ap]\.?m?\.?/i,ue=N("Hours",!0),ve={calendar:td,longDateFormat:ud,invalidDate:vd,ordinal:wd,ordinalParse:xd,relativeTime:yd,months:ge,monthsShort:he,week:le,weekdays:me,weekdaysMin:oe,weekdaysShort:ne,meridiemParse:te},we={},xe=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/,ye=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/,ze=/Z|[+-]\d\d(?::?\d\d)?/,Ae=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],
// YYYYMM is NOT allowed by the standard
["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Be=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Ce=/^\/?Date\((\-?\d+)/i;a.createFromInputFallback=w("value provided is not in a recognized ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),
// constant that refers to the ISO standard
a.ISO_8601=function(){};var De=w("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var a=rb.apply(null,arguments);return this.isValid()&&a.isValid()?this>a?this:a:n()}),Ee=w("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var a=rb.apply(null,arguments);return this.isValid()&&a.isValid()?a>this?this:a:n()}),Fe=function(){return Date.now?Date.now():+new Date};yb("Z",":"),yb("ZZ",""),
// PARSING
Y("Z",Td),Y("ZZ",Td),aa(["Z","ZZ"],function(a,b,c){c._useUTC=!0,c._tzm=zb(Td,a)});
// HELPERS
// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var Ge=/([\+\-]|\d\d)/gi;
// HOOKS
// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
a.updateOffset=function(){};
// ASP.NET json date format regex
var He=/^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Ie=/^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;Nb.fn=vb.prototype;var Je=Rb(1,"add"),Ke=Rb(-1,"subtract");a.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",a.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Le=w("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(a){return void 0===a?this.localeData():this.locale(a)});
// FORMATTING
T(0,["gg",2],0,function(){return this.weekYear()%100}),T(0,["GG",2],0,function(){return this.isoWeekYear()%100}),xc("gggg","weekYear"),xc("ggggg","weekYear"),xc("GGGG","isoWeekYear"),xc("GGGGG","isoWeekYear"),
// ALIASES
I("weekYear","gg"),I("isoWeekYear","GG"),
// PRIORITY
L("weekYear",1),L("isoWeekYear",1),
// PARSING
Y("G",Rd),Y("g",Rd),Y("GG",Kd,Gd),Y("gg",Kd,Gd),Y("GGGG",Od,Id),Y("gggg",Od,Id),Y("GGGGG",Pd,Jd),Y("ggggg",Pd,Jd),ba(["gggg","ggggg","GGGG","GGGGG"],function(a,b,c,d){b[d.substr(0,2)]=t(a)}),ba(["gg","GG"],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),
// FORMATTING
T("Q",0,"Qo","quarter"),
// ALIASES
I("quarter","Q"),
// PRIORITY
L("quarter",7),
// PARSING
Y("Q",Fd),aa("Q",function(a,b){b[Zd]=3*(t(a)-1)}),
// FORMATTING
T("D",["DD",2],"Do","date"),
// ALIASES
I("date","D"),
// PRIOROITY
L("date",9),
// PARSING
Y("D",Kd),Y("DD",Kd,Gd),Y("Do",function(a,b){return a?b._ordinalParse:b._ordinalParseLenient}),aa(["D","DD"],$d),aa("Do",function(a,b){b[$d]=t(a.match(Kd)[0],10)});
// MOMENTS
var Me=N("Date",!0);
// FORMATTING
T("DDD",["DDDD",3],"DDDo","dayOfYear"),
// ALIASES
I("dayOfYear","DDD"),
// PRIORITY
L("dayOfYear",4),
// PARSING
Y("DDD",Nd),Y("DDDD",Hd),aa(["DDD","DDDD"],function(a,b,c){c._dayOfYear=t(a)}),
// FORMATTING
T("m",["mm",2],0,"minute"),
// ALIASES
I("minute","m"),
// PRIORITY
L("minute",14),
// PARSING
Y("m",Kd),Y("mm",Kd,Gd),aa(["m","mm"],ae);
// MOMENTS
var Ne=N("Minutes",!1);
// FORMATTING
T("s",["ss",2],0,"second"),
// ALIASES
I("second","s"),
// PRIORITY
L("second",15),
// PARSING
Y("s",Kd),Y("ss",Kd,Gd),aa(["s","ss"],be);
// MOMENTS
var Oe=N("Seconds",!1);
// FORMATTING
T("S",0,0,function(){return~~(this.millisecond()/100)}),T(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),T(0,["SSS",3],0,"millisecond"),T(0,["SSSS",4],0,function(){return 10*this.millisecond()}),T(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),T(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),T(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),T(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),T(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),
// ALIASES
I("millisecond","ms"),
// PRIORITY
L("millisecond",16),
// PARSING
Y("S",Nd,Fd),Y("SS",Nd,Gd),Y("SSS",Nd,Hd);var Pe;for(Pe="SSSS";Pe.length<=9;Pe+="S")Y(Pe,Qd);for(Pe="S";Pe.length<=9;Pe+="S")aa(Pe,Gc);
// MOMENTS
var Qe=N("Milliseconds",!1);
// FORMATTING
T("z",0,0,"zoneAbbr"),T("zz",0,0,"zoneName");var Re=q.prototype;Re.add=Je,Re.calendar=Ub,Re.clone=Vb,Re.diff=ac,Re.endOf=mc,Re.format=ec,Re.from=fc,Re.fromNow=gc,Re.to=hc,Re.toNow=ic,Re.get=Q,Re.invalidAt=vc,Re.isAfter=Wb,Re.isBefore=Xb,Re.isBetween=Yb,Re.isSame=Zb,Re.isSameOrAfter=$b,Re.isSameOrBefore=_b,Re.isValid=tc,Re.lang=Le,Re.locale=jc,Re.localeData=kc,Re.max=Ee,Re.min=De,Re.parsingFlags=uc,Re.set=R,Re.startOf=lc,Re.subtract=Ke,Re.toArray=qc,Re.toObject=rc,Re.toDate=pc,Re.toISOString=dc,Re.toJSON=sc,Re.toString=cc,Re.unix=oc,Re.valueOf=nc,Re.creationData=wc,
// Year
Re.year=ke,Re.isLeapYear=qa,
// Week Year
Re.weekYear=yc,Re.isoWeekYear=zc,
// Quarter
Re.quarter=Re.quarters=Ec,
// Month
Re.month=ja,Re.daysInMonth=ka,
// Week
Re.week=Re.weeks=Aa,Re.isoWeek=Re.isoWeeks=Ba,Re.weeksInYear=Bc,Re.isoWeeksInYear=Ac,
// Day
Re.date=Me,Re.day=Re.days=Ja,Re.weekday=Ka,Re.isoWeekday=La,Re.dayOfYear=Fc,
// Hour
Re.hour=Re.hours=ue,
// Minute
Re.minute=Re.minutes=Ne,
// Second
Re.second=Re.seconds=Oe,
// Millisecond
Re.millisecond=Re.milliseconds=Qe,
// Offset
Re.utcOffset=Cb,Re.utc=Eb,Re.local=Fb,Re.parseZone=Gb,Re.hasAlignedHourOffset=Hb,Re.isDST=Ib,Re.isLocal=Kb,Re.isUtcOffset=Lb,Re.isUtc=Mb,Re.isUTC=Mb,
// Timezone
Re.zoneAbbr=Hc,Re.zoneName=Ic,
// Deprecations
Re.dates=w("dates accessor is deprecated. Use date instead.",Me),Re.months=w("months accessor is deprecated. Use month instead",ja),Re.years=w("years accessor is deprecated. Use year instead",ke),Re.zone=w("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",Db),Re.isDSTShifted=w("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",Jb);var Se=Re,Te=B.prototype;Te.calendar=C,Te.longDateFormat=D,Te.invalidDate=E,Te.ordinal=F,Te.preparse=Lc,Te.postformat=Lc,Te.relativeTime=G,Te.pastFuture=H,Te.set=z,
// Month
Te.months=ea,Te.monthsShort=fa,Te.monthsParse=ha,Te.monthsRegex=ma,Te.monthsShortRegex=la,
// Week
Te.week=xa,Te.firstDayOfYear=za,Te.firstDayOfWeek=ya,
// Day of Week
Te.weekdays=Ea,Te.weekdaysMin=Ga,Te.weekdaysShort=Fa,Te.weekdaysParse=Ia,Te.weekdaysRegex=Ma,Te.weekdaysShortRegex=Na,Te.weekdaysMinRegex=Oa,
// Hours
Te.isPM=Ua,Te.meridiem=Va,Za("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===t(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),
// Side effect imports
a.lang=w("moment.lang is deprecated. Use moment.locale instead.",Za),a.langData=w("moment.langData is deprecated. Use moment.localeData instead.",ab);var Ue=Math.abs,Ve=cd("ms"),We=cd("s"),Xe=cd("m"),Ye=cd("h"),Ze=cd("d"),$e=cd("w"),_e=cd("M"),af=cd("y"),bf=ed("milliseconds"),cf=ed("seconds"),df=ed("minutes"),ef=ed("hours"),ff=ed("days"),gf=ed("months"),hf=ed("years"),jf=Math.round,kf={s:45,// seconds to minute
m:45,// minutes to hour
h:22,// hours to day
d:26,// days to month
M:11},lf=Math.abs,mf=vb.prototype;mf.abs=Uc,mf.add=Wc,mf.subtract=Xc,mf.as=ad,mf.asMilliseconds=Ve,mf.asSeconds=We,mf.asMinutes=Xe,mf.asHours=Ye,mf.asDays=Ze,mf.asWeeks=$e,mf.asMonths=_e,mf.asYears=af,mf.valueOf=bd,mf._bubble=Zc,mf.get=dd,mf.milliseconds=bf,mf.seconds=cf,mf.minutes=df,mf.hours=ef,mf.days=ff,mf.weeks=fd,mf.months=gf,mf.years=hf,mf.humanize=kd,mf.toISOString=ld,mf.toString=ld,mf.toJSON=ld,mf.locale=jc,mf.localeData=kc,
// Deprecations
mf.toIsoString=w("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",ld),mf.lang=Le,
// Side effect imports
// FORMATTING
T("X",0,0,"unix"),T("x",0,0,"valueOf"),
// PARSING
Y("x",Rd),Y("X",Ud),aa("X",function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),aa("x",function(a,b,c){c._d=new Date(t(a))}),
// Side effect imports
a.version="2.15.0",b(rb),a.fn=Se,a.min=tb,a.max=ub,a.now=Fe,a.utc=j,a.unix=Jc,a.months=Pc,a.isDate=f,a.locale=Za,a.invalid=n,a.duration=Nb,a.isMoment=r,a.weekdays=Rc,a.parseZone=Kc,a.localeData=ab,a.isDuration=wb,a.monthsShort=Qc,a.weekdaysMin=Tc,a.defineLocale=$a,a.updateLocale=_a,a.locales=bb,a.weekdaysShort=Sc,a.normalizeUnits=J,a.relativeTimeRounding=id,a.relativeTimeThreshold=jd,a.calendarFormat=Tb,a.prototype=Se;var nf=a;return nf});
//! moment-timezone.js
//! version : 0.5.0
//! author : Tim Wood
//! license : MIT
//! github.com/moment/moment-timezone
!function(a,b){"use strict";"function"==typeof define&&define.amd?define(["moment"],b):"object"==typeof module&&module.exports?module.exports=b(require("moment")):b(a.moment)}(this,function(a){"use strict";function b(a){return a>96?a-87:a>64?a-29:a-48}function c(a){var c,d=0,e=a.split("."),f=e[0],g=e[1]||"",h=1,i=0,j=1;for(45===a.charCodeAt(0)&&(d=1,j=-1),d;d<f.length;d++)c=b(f.charCodeAt(d)),i=60*i+c;for(d=0;d<g.length;d++)h/=60,c=b(g.charCodeAt(d)),i+=c*h;return i*j}function d(a){for(var b=0;b<a.length;b++)a[b]=c(a[b])}function e(a,b){for(var c=0;b>c;c++)a[c]=Math.round((a[c-1]||0)+6e4*a[c]);a[b-1]=1/0}function f(a,b){var c,d=[];for(c=0;c<b.length;c++)d[c]=a[b[c]];return d}function g(a){var b=a.split("|"),c=b[2].split(" "),g=b[3].split(""),h=b[4].split(" ");return d(c),d(g),d(h),e(h,g.length),{name:b[0],abbrs:f(b[1].split(" "),g),offsets:f(c,g),untils:h,population:0|b[5]}}function h(a){a&&this._set(g(a))}function i(a){var b=a.toTimeString(),c=b.match(/\(.+\)/);c=c&&c[0]?c[0].match(/[A-Z]/g).join(""):b.match(/[A-Z]{3,5}/g)[0],"GMT"===c&&(c=void 0),this.at=+a,this.abbr=c,this.offset=a.getTimezoneOffset()}function j(a){this.zone=a,this.offsetScore=0,this.abbrScore=0}function k(a,b){for(var c,d;d=6e4*((b.at-a.at)/12e4|0);)c=new i(new Date(a.at+d)),c.offset===a.offset?a=c:b=c;return a}function l(){var a,b,c,d=(new Date).getFullYear()-2,e=new i(new Date(d,0,1)),f=[e];for(c=1;48>c;c++)b=new i(new Date(d,c,1)),b.offset!==e.offset&&(a=k(e,b),f.push(a),f.push(new i(new Date(a.at+6e4)))),e=b;for(c=0;4>c;c++)f.push(new i(new Date(d+c,0,1))),f.push(new i(new Date(d+c,6,1)));return f}function m(a,b){return a.offsetScore!==b.offsetScore?a.offsetScore-b.offsetScore:a.abbrScore!==b.abbrScore?a.abbrScore-b.abbrScore:b.zone.population-a.zone.population}function n(a,b){var c,e;for(d(b),c=0;c<b.length;c++)e=b[c],I[e]=I[e]||{},I[e][a]=!0}function o(a){var b,c,d,e=a.length,f={},g=[];for(b=0;e>b;b++){d=I[a[b].offset]||{};for(c in d)d.hasOwnProperty(c)&&(f[c]=!0)}for(b in f)f.hasOwnProperty(b)&&g.push(H[b]);return g}function p(){var a,b,c,d=l(),e=d.length,f=o(d),g=[];for(b=0;b<f.length;b++){for(a=new j(t(f[b]),e),c=0;e>c;c++)a.scoreOffsetAt(d[c]);g.push(a)}return g.sort(m),g.length>0?g[0].zone.name:void 0}function q(a){return(!D||a)&&(D=p()),D}function r(a){return(a||"").toLowerCase().replace(/\//g,"_")}function s(a){var b,c,d,e;for("string"==typeof a&&(a=[a]),b=0;b<a.length;b++)d=a[b].split("|"),c=d[0],e=r(c),F[e]=a[b],H[e]=c,d[5]&&n(e,d[2].split(" "))}function t(a,b){a=r(a);var c,d=F[a];return d instanceof h?d:"string"==typeof d?(d=new h(d),F[a]=d,d):G[a]&&b!==t&&(c=t(G[a],t))?(d=F[a]=new h,d._set(c),d.name=H[a],d):null}function u(){var a,b=[];for(a in H)H.hasOwnProperty(a)&&(F[a]||F[G[a]])&&H[a]&&b.push(H[a]);return b.sort()}function v(a){var b,c,d,e;for("string"==typeof a&&(a=[a]),b=0;b<a.length;b++)c=a[b].split("|"),d=r(c[0]),e=r(c[1]),G[d]=e,H[d]=c[0],G[e]=d,H[e]=c[1]}function w(a){s(a.zones),v(a.links),A.dataVersion=a.version}function x(a){return x.didShowError||(x.didShowError=!0,z("moment.tz.zoneExists('"+a+"') has been deprecated in favor of !moment.tz.zone('"+a+"')")),!!t(a)}function y(a){return!(!a._a||void 0!==a._tzm)}function z(a){"undefined"!=typeof console&&"function"==typeof console.error&&console.error(a)}function A(b){var c=Array.prototype.slice.call(arguments,0,-1),d=arguments[arguments.length-1],e=t(d),f=a.utc.apply(null,c);return e&&!a.isMoment(b)&&y(f)&&f.add(e.parse(f),"minutes"),f.tz(d),f}function B(a){return function(){return this._z?this._z.abbr(this):a.call(this)}}function C(a){return function(){return this._z=null,a.apply(this,arguments)}}if(void 0!==a.tz)return z("Moment Timezone "+a.tz.version+" was already loaded "+(a.tz.dataVersion?"with data from ":"without any data")+a.tz.dataVersion),a;var D,E="0.5.0",F={},G={},H={},I={},J=a.version.split("."),K=+J[0],L=+J[1];(2>K||2===K&&6>L)&&z("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js "+a.version+". See momentjs.com"),h.prototype={_set:function(a){this.name=a.name,this.abbrs=a.abbrs,this.untils=a.untils,this.offsets=a.offsets,this.population=a.population},_index:function(a){var b,c=+a,d=this.untils;for(b=0;b<d.length;b++)if(c<d[b])return b},parse:function(a){var b,c,d,e,f=+a,g=this.offsets,h=this.untils,i=h.length-1;for(e=0;i>e;e++)if(b=g[e],c=g[e+1],d=g[e?e-1:e],c>b&&A.moveAmbiguousForward?b=c:b>d&&A.moveInvalidForward&&(b=d),f<h[e]-6e4*b)return g[e];return g[i]},abbr:function(a){return this.abbrs[this._index(a)]},offset:function(a){return this.offsets[this._index(a)]}},j.prototype.scoreOffsetAt=function(a){this.offsetScore+=Math.abs(this.zone.offset(a.at)-a.offset),this.zone.abbr(a.at).match(/[A-Z]/g).join("")!==a.abbr&&this.abbrScore++},A.version=E,A.dataVersion="",A._zones=F,A._links=G,A._names=H,A.add=s,A.link=v,A.load=w,A.zone=t,A.zoneExists=x,A.guess=q,A.names=u,A.Zone=h,A.unpack=g,A.unpackBase60=c,A.needsOffset=y,A.moveInvalidForward=!0,A.moveAmbiguousForward=!1;var M=a.fn;a.tz=A,a.defaultZone=null,a.updateOffset=function(b,c){var d,e=a.defaultZone;void 0===b._z&&(e&&y(b)&&!b._isUTC&&(b._d=a.utc(b._a)._d,b.utc().add(e.parse(b),"minutes")),b._z=e),b._z&&(d=b._z.offset(b),Math.abs(d)<16&&(d/=60),void 0!==b.utcOffset?b.utcOffset(-d,c):b.zone(d,c))},M.tz=function(b){return b?(this._z=t(b),this._z?a.updateOffset(this):z("Moment Timezone has no data for "+b+". See http://momentjs.com/timezone/docs/#/data-loading/."),this):this._z?this._z.name:void 0},M.zoneName=B(M.zoneName),M.zoneAbbr=B(M.zoneAbbr),M.utc=C(M.utc),a.tz.setDefault=function(b){return(2>K||2===K&&9>L)&&z("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js "+a.version+"."),a.defaultZone=b?t(b):null,a};var N=a.momentProperties;return"[object Array]"===Object.prototype.toString.call(N)?(N.push("_z"),N.push("_a")):N&&(N._z=null),w({version:"2015g",zones:["Africa/Abidjan|LMT GMT|g.8 0|01|-2ldXH.Q|48e5","Africa/Accra|LMT GMT GHST|.Q 0 -k|012121212121212121212121212121212121212121212121|-26BbX.8 6tzX.8 MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE|41e5","Africa/Nairobi|LMT EAT BEAT BEAUT|-2r.g -30 -2u -2J|01231|-1F3Cr.g 3Dzr.g okMu MFXJ|47e5","Africa/Algiers|PMT WET WEST CET CEST|-9.l 0 -10 -10 -20|0121212121212121343431312123431213|-2nco9.l cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 DA0 Imo0 rd0 De0 9Xz0 1fb0 1ap0 16K0 2yo0 mEp0 hwL0 jxA0 11A0 dDd0 17b0 11B0 1cN0 2Dy0 1cN0 1fB0 1cL0|26e5","Africa/Lagos|LMT WAT|-d.A -10|01|-22y0d.A|17e6","Africa/Bissau|LMT WAT GMT|12.k 10 0|012|-2ldWV.E 2xonV.E|39e4","Africa/Maputo|LMT CAT|-2a.k -20|01|-2GJea.k|26e5","Africa/Cairo|EET EEST|-20 -30|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1bIO0 vb0 1ip0 11z0 1iN0 1nz0 12p0 1pz0 10N0 1pz0 16p0 1jz0 s3d0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1WL0 rd0 1Rz0 wp0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1qL0 Xd0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1ny0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 WL0 1qN0 Rb0 1wp0 On0 1zd0 Lz0 1EN0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0|15e6","Africa/Casablanca|LMT WET WEST CET|u.k 0 -10 -10|0121212121212121213121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2gMnt.E 130Lt.E rb0 Dd0 dVb0 b6p0 TX0 EoB0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4mn0 SyN0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0 11A0 5A0 e00 17c0 1fA0 1a00 1a00 1fA0 17c0 1io0 14o0 1lc0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1lc0 14o0 1fA0|32e5","Africa/Ceuta|WET WEST CET CEST|0 -10 -10 -20|010101010101010101010232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-25KN0 11z0 drd0 18o0 3I00 17c0 1fA0 1a00 1io0 1a00 1y7p0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4VB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|85e3","Africa/El_Aaiun|LMT WAT WET WEST|Q.M 10 0 -10|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1rDz7.c 1GVA7.c 6L0 AL0 1Nd0 XX0 1Cp0 pz0 1cBB0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0 11A0 5A0 e00 17c0 1fA0 1a00 1a00 1fA0 17c0 1io0 14o0 1lc0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1lc0 14o0 1fA0|20e4","Africa/Johannesburg|SAST SAST SAST|-1u -20 -30|012121|-2GJdu 1Ajdu 1cL0 1cN0 1cL0|84e5","Africa/Khartoum|LMT CAT CAST EAT|-2a.8 -20 -30 -30|01212121212121212121212121212121213|-1yW2a.8 1zK0a.8 16L0 1iN0 17b0 1jd0 17b0 1ip0 17z0 1i10 17X0 1hB0 18n0 1hd0 19b0 1gp0 19z0 1iN0 17b0 1ip0 17z0 1i10 18n0 1hd0 18L0 1gN0 19b0 1gp0 19z0 1iN0 17z0 1i10 17X0 yGd0|51e5","Africa/Monrovia|MMT LRT GMT|H.8 I.u 0|012|-23Lzg.Q 29s01.m|11e5","Africa/Ndjamena|LMT WAT WAST|-10.c -10 -20|0121|-2le10.c 2J3c0.c Wn0|13e5","Africa/Tripoli|LMT CET CEST EET|-Q.I -10 -20 -20|012121213121212121212121213123123|-21JcQ.I 1hnBQ.I vx0 4iP0 xx0 4eN0 Bb0 7ip0 U0n0 A10 1db0 1cN0 1db0 1dd0 1db0 1eN0 1bb0 1e10 1cL0 1c10 1db0 1dd0 1db0 1cN0 1db0 1q10 fAn0 1ep0 1db0 AKq0 TA0 1o00|11e5","Africa/Tunis|PMT CET CEST|-9.l -10 -20|0121212121212121212121212121212121|-2nco9.l 18pa9.l 1qM0 DA0 3Tc0 11B0 1ze0 WM0 7z0 3d0 14L0 1cN0 1f90 1ar0 16J0 1gXB0 WM0 1rA0 11c0 nwo0 Ko0 1cM0 1cM0 1rA0 10M0 zuM0 10N0 1aN0 1qM0 WM0 1qM0 11A0 1o00|20e5","Africa/Windhoek|SWAT SAST SAST CAT WAT WAST|-1u -20 -30 -20 -10 -20|012134545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-2GJdu 1Ajdu 1cL0 1SqL0 9NA0 11D0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0|32e4","America/Adak|NST NWT NPT BST BDT AHST HST HDT|b0 a0 a0 b0 a0 a0 a0 90|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17SX0 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326","America/Anchorage|CAT CAWT CAPT AHST AHDT YST AKST AKDT|a0 90 90 a0 90 90 90 80|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17T00 8wX0 iA0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4","America/Port_of_Spain|LMT AST|46.4 40|01|-2kNvR.U|43e3","America/Araguaina|LMT BRT BRST|3c.M 30 20|0121212121212121212121212121212121212121212121212121|-2glwL.c HdKL.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 ny10 Lz0|14e4","America/Argentina/Buenos_Aires|CMT ART ARST ART ARST|4g.M 40 30 30 20|0121212121212121212121212121212121212121213434343434343234343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 g0p0 10M0 j3c0 uL0 1qN0 WL0","America/Argentina/Catamarca|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|0121212121212121212121212121212121212121213434343454343235343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 g0p0 10M0 ako0 7B0 8zb0 uL0","America/Argentina/Cordoba|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|0121212121212121212121212121212121212121213434343454343234343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 g0p0 10M0 j3c0 uL0 1qN0 WL0","America/Argentina/Jujuy|CMT ART ARST ART ARST WART WARST|4g.M 40 30 30 20 40 30|01212121212121212121212121212121212121212134343456543432343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1ze0 TX0 1ld0 WK0 1wp0 TX0 g0p0 10M0 j3c0 uL0","America/Argentina/La_Rioja|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|01212121212121212121212121212121212121212134343434534343235343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 g0p0 10M0 ako0 7B0 8zb0 uL0","America/Argentina/Mendoza|CMT ART ARST ART ARST WART WARST|4g.M 40 30 30 20 40 30|0121212121212121212121212121212121212121213434345656543235343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1u20 SL0 1vd0 Tb0 1wp0 TW0 g0p0 10M0 agM0 Op0 7TX0 uL0","America/Argentina/Rio_Gallegos|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|0121212121212121212121212121212121212121213434343434343235343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 g0p0 10M0 ako0 7B0 8zb0 uL0","America/Argentina/Salta|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|01212121212121212121212121212121212121212134343434543432343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 g0p0 10M0 j3c0 uL0","America/Argentina/San_Juan|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|01212121212121212121212121212121212121212134343434534343235343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 g0p0 10M0 ak00 m10 8lb0 uL0","America/Argentina/San_Luis|CMT ART ARST ART ARST WART WARST|4g.M 40 30 30 20 40 30|01212121212121212121212121212121212121212134343456536353465653|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 XX0 1q20 SL0 AN0 kin0 10M0 ak00 m10 8lb0 8L0 jd0 1qN0 WL0 1qN0","America/Argentina/Tucuman|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|012121212121212121212121212121212121212121343434345434323534343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 g0p0 10M0 ako0 4N0 8BX0 uL0 1qN0 WL0","America/Argentina/Ushuaia|CMT ART ARST ART ARST WART|4g.M 40 30 30 20 40|0121212121212121212121212121212121212121213434343434343235343|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 g0p0 10M0 ajA0 8p0 8zb0 uL0","America/Curacao|LMT ANT AST|4z.L 4u 40|012|-2kV7o.d 28KLS.d|15e4","America/Asuncion|AMT PYT PYT PYST|3O.E 40 30 30|012131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313|-1x589.k 1DKM9.k 3CL0 3Dd0 10L0 1pB0 10n0 1pB0 10n0 1pB0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1lB0 14n0 1dd0 1cL0 1fd0 WL0 1rd0 1aL0 1dB0 Xz0 1qp0 Xb0 1qN0 10L0 1rB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 WN0 1qL0 11B0 1nX0 1ip0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 TX0 1tB0 19X0 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0|28e5","America/Atikokan|CST CDT CWT CPT EST|60 50 50 50 50|0101234|-25TQ0 1in0 Rnb0 3je0 8x30 iw0|28e2","America/Bahia|LMT BRT BRST|2y.4 30 20|01212121212121212121212121212121212121212121212121212121212121|-2glxp.U HdLp.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 l5B0 Rb0|27e5","America/Bahia_Banderas|LMT MST CST PST MDT CDT|71 70 60 80 60 50|0121212131414141414141414141414141414152525252525252525252525252525252525252525252525252525252|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|84e3","America/Barbados|LMT BMT AST ADT|3W.t 3W.t 40 30|01232323232|-1Q0I1.v jsM0 1ODC1.v IL0 1ip0 17b0 1ip0 17b0 1ld0 13b0|28e4","America/Belem|LMT BRT BRST|3d.U 30 20|012121212121212121212121212121|-2glwK.4 HdKK.4 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|20e5","America/Belize|LMT CST CHDT CDT|5Q.M 60 5u 50|01212121212121212121212121212121212121212121212121213131|-2kBu7.c fPA7.c Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1f0Mu qn0 lxB0 mn0|57e3","America/Blanc-Sablon|AST ADT AWT APT|40 30 30 30|010230|-25TS0 1in0 UGp0 8x50 iu0|11e2","America/Boa_Vista|LMT AMT AMST|42.E 40 30|0121212121212121212121212121212121|-2glvV.k HdKV.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 smp0 WL0 1tB0 2L0|62e2","America/Bogota|BMT COT COST|4U.g 50 40|0121|-2eb73.I 38yo3.I 2en0|90e5","America/Boise|PST PDT MST MWT MPT MDT|80 70 70 60 60 60|0101023425252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-261q0 1nX0 11B0 1nX0 8C10 JCL0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 Dd0 1Kn0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e4","America/Cambridge_Bay|zzz MST MWT MPT MDDT MDT CST CDT EST|0 70 60 60 50 60 60 50 50|0123141515151515151515151515151515151515151515678651515151515151515151515151515151515151515151515151515151515151515151515151|-21Jc0 RO90 8x20 ix0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11A0 1nX0 2K0 WQ0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e2","America/Campo_Grande|LMT AMT AMST|3C.s 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2glwl.w HdLl.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0|77e4","America/Cancun|LMT CST EST EDT CDT|5L.4 60 50 40 50|0123232341414141414141414141414141414141412|-1UQG0 2q2o0 yLB0 1lb0 14p0 1lb0 14p0 Lz0 xB0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4","America/Caracas|CMT VET VET|4r.E 4u 40|0121|-2kV7w.k 28KM2.k 1IwOu|29e5","America/Cayenne|LMT GFT GFT|3t.k 40 30|012|-2mrwu.E 2gWou.E|58e3","America/Cayman|KMT EST EDT|57.b 50 40|0121212121212121212121212121212121212121212121|-2l1uQ.N 4duNQ.N 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|58e3","America/Chicago|CST CDT EST CWT CPT|60 50 50 50 50|01010101010101010101010101010101010102010101010103401010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 1wp0 TX0 WN0 1qL0 1cN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 11B0 1Hz0 14p0 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5","America/Chihuahua|LMT MST CST CDT MDT|74.k 70 60 50 60|0121212323241414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4","America/Costa_Rica|SJMT CST CDT|5A.d 60 50|0121212121|-1Xd6n.L 2lu0n.L Db0 1Kp0 Db0 pRB0 15b0 1kp0 mL0|12e5","America/Creston|MST PST|70 80|010|-29DR0 43B0|53e2","America/Cuiaba|LMT AMT AMST|3I.k 40 30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2glwf.E HdLf.E 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 4a10 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0|54e4","America/Danmarkshavn|LMT WGT WGST GMT|1e.E 30 20 0|01212121212121212121212121212121213|-2a5WJ.k 2z5fJ.k 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 DC0|8","America/Dawson|YST YDT YWT YPT YDDT PST PDT|90 80 80 80 70 80 70|0101023040565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-25TN0 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 jrA0 fNd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|13e2","America/Dawson_Creek|PST PDT PWT PPT MST|80 70 70 70 70|0102301010101010101010101010101010101010101010101010101014|-25TO0 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 ML0|12e3","America/Denver|MST MDT MWT MPT|70 60 60 60|01010101023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 11B0 1qL0 WN0 mn0 Ord0 8x20 ix0 LCN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5","America/Detroit|LMT CST EST EWT EPT EDT|5w.b 60 50 40 40 40|01234252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2Cgir.N peqr.N 156L0 8x40 iv0 6fd0 11z0 Jy10 SL0 dnB0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e5","America/Edmonton|LMT MST MDT MWT MPT|7x.Q 70 60 60 60|01212121212121341212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2yd4q.8 shdq.8 1in0 17d0 hz0 2dB0 1fz0 1a10 11z0 1qN0 WL0 1qN0 11z0 IGN0 8x20 ix0 3NB0 11z0 LFB0 1cL0 3Cp0 1cL0 66N0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|10e5","America/Eirunepe|LMT ACT ACST AMT|4D.s 50 40 40|0121212121212121212121212121212131|-2glvk.w HdLk.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0 yTd0 d5X0|31e3","America/El_Salvador|LMT CST CDT|5U.M 60 50|012121|-1XiG3.c 2Fvc3.c WL0 1qN0 WL0|11e5","America/Tijuana|LMT MST PST PDT PWT PPT|7M.4 70 80 70 70 70|012123245232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQE0 4PX0 8mM0 8lc0 SN0 1cL0 pHB0 83r0 zI0 5O10 1Rz0 cOP0 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 BUp0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|20e5","America/Fort_Nelson|PST PDT PWT PPT MST|80 70 70 70 70|01023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010104|-25TO0 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2","America/Fort_Wayne|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|010101023010101010101010101040454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 QI10 Db0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 5Tz0 1o10 qLb0 1cL0 1cN0 1cL0 1qhd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Fortaleza|LMT BRT BRST|2y 30 20|0121212121212121212121212121212121212121|-2glxq HdLq 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 5z0 2mN0 On0|34e5","America/Glace_Bay|LMT AST ADT AWT APT|3X.M 40 30 30 30|012134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsI0.c CwO0.c 1in0 UGp0 8x50 iu0 iq10 11z0 Jg10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3","America/Godthab|LMT WGT WGST|3q.U 30 20|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5Ux.4 2z5dx.4 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3","America/Goose_Bay|NST NDT NST NDT NWT NPT AST ADT ADDT|3u.Q 2u.Q 3u 2u 2u 2u 40 30 20|010232323232323245232323232323232323232323232323232323232326767676767676767676767676767676767676767676768676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-25TSt.8 1in0 DXb0 2HbX.8 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 S10 g0u 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|76e2","America/Grand_Turk|KMT EST EDT AST|57.b 50 40 40|0121212121212121212121212121212121212121212121212121212121212121212121212123|-2l1uQ.N 2HHBQ.N 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2","America/Guatemala|LMT CST CDT|62.4 60 50|0121212121|-24KhV.U 2efXV.U An0 mtd0 Nz0 ifB0 17b0 zDB0 11z0|13e5","America/Guayaquil|QMT ECT|5e 50|01|-1yVSK|27e5","America/Guyana|LMT GBGT GYT GYT GYT|3Q.E 3J 3J 30 40|01234|-2dvU7.k 24JzQ.k mlc0 Bxbf|80e4","America/Halifax|LMT AST ADT AWT APT|4e.o 40 30 30 30|0121212121212121212121212121212121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsHJ.A xzzJ.A 1db0 3I30 1in0 3HX0 IL0 1E10 ML0 1yN0 Pb0 1Bd0 Mn0 1Bd0 Rz0 1w10 Xb0 1w10 LX0 1w10 Xb0 1w10 Lz0 1C10 Jz0 1E10 OL0 1yN0 Un0 1qp0 Xb0 1qp0 11X0 1w10 Lz0 1HB0 LX0 1C10 FX0 1w10 Xb0 1qp0 Xb0 1BB0 LX0 1td0 Xb0 1qp0 Xb0 Rf0 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 6i10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4","America/Havana|HMT CST CDT|5t.A 50 40|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Meuu.o 72zu.o ML0 sld0 An0 1Nd0 Db0 1Nd0 An0 6Ep0 An0 1Nd0 An0 JDd0 Mn0 1Ap0 On0 1fd0 11X0 1qN0 WL0 1wp0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 14n0 1ld0 14L0 1kN0 15b0 1kp0 1cL0 1cN0 1fz0 1a10 1fz0 1fB0 11z0 14p0 1nX0 11B0 1nX0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 1a10 1in0 1a10 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 17c0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 11A0 6i00 Rc0 1wo0 U00 1tA0 Rc0 1wo0 U00 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5","America/Hermosillo|LMT MST CST PST MDT|7n.Q 70 60 80 60|0121212131414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0|64e4","America/Indiana/Knox|CST CDT CWT CPT EST|60 50 50 50 50|0101023010101010101010101010101010101040101010101010101010101010101010101010101010101010141010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 3Cn0 8wp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 z8o0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Marengo|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101023010101010101010104545454545414545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 dyN0 11z0 6fd0 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1e6p0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Petersburg|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010104010101010101010101010141014545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 njX0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 3Fb0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 19co0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Tell_City|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010454541010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 g0p0 11z0 1o10 11z0 1qL0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 caL0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Vevay|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|010102304545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 kPB0 Awn0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1lnd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Vincennes|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010454541014545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 g0p0 11z0 1o10 11z0 1qL0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 caL0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Indiana/Winamac|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010101010454541054545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1za0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Inuvik|zzz PST PDDT MST MDT|0 80 60 70 60|0121343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-FnA0 tWU0 1fA0 wPe0 2pz0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|35e2","America/Iqaluit|zzz EWT EPT EST EDDT EDT CST CDT|0 40 40 50 30 40 60 50|01234353535353535353535353535353535353535353567353535353535353535353535353535353535353535353535353535353535353535353535353|-16K00 7nX0 iv0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|67e2","America/Jamaica|KMT EST EDT|57.b 50 40|0121212121212121212121|-2l1uQ.N 2uM1Q.N 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0|94e4","America/Juneau|PST PWT PPT PDT YDT YST AKST AKDT|80 70 70 70 80 90 90 80|01203030303030303030303030403030356767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cM0 1cM0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|33e3","America/Kentucky/Louisville|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101010102301010101010101010101010101454545454545414545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 3Fd0 Nb0 LPd0 11z0 RB0 8x30 iw0 Bb0 10N0 2bB0 8in0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 xz0 gso0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Kentucky/Monticello|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101023010101010101010101010101010101010101010101010101010101010101010101454545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 SWp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/La_Paz|CMT BOST BOT|4w.A 3w.A 40|012|-1x37r.o 13b0|19e5","America/Lima|LMT PET PEST|58.A 50 40|0121212121212121|-2tyGP.o 1bDzP.o zX0 1aN0 1cL0 1cN0 1cL0 1PrB0 zX0 1O10 zX0 6Gp0 zX0 98p0 zX0|11e6","America/Los_Angeles|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 5Wp0 1Vb0 3dB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6","America/Maceio|LMT BRT BRST|2m.Q 30 20|012121212121212121212121212121212121212121|-2glxB.8 HdLB.8 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 8Q10 WL0 1tB0 5z0 2mN0 On0|93e4","America/Managua|MMT CST EST CDT|5J.c 60 50 50|0121313121213131|-1quie.M 1yAMe.M 4mn0 9Up0 Dz0 1K10 Dz0 s3F0 1KH0 DB0 9In0 k8p0 19X0 1o30 11y0|22e5","America/Manaus|LMT AMT AMST|40.4 40 30|01212121212121212121212121212121|-2glvX.U HdKX.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0|19e5","America/Martinique|FFMT AST ADT|44.k 40 30|0121|-2mPTT.E 2LPbT.E 19X0|39e4","America/Matamoros|LMT CST CDT|6E 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|45e4","America/Mazatlan|LMT MST CST PST MDT|75.E 70 60 80 60|0121212131414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|44e4","America/Menominee|CST CDT CWT CPT EST|60 50 50 50 50|01010230101041010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 LCN0 1fz0 6410 9Jb0 1cM0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|85e2","America/Merida|LMT CST EST CDT|5W.s 60 50 50|0121313131313131313131313131313131313131313131313131313131313131313131313131313131313131|-1UQG0 2q2o0 2hz0 wu30 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|11e5","America/Metlakatla|PST PWT PPT PDT|80 70 70 70|0120303030303030303030303030303030|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0|14e2","America/Mexico_City|LMT MST CST CDT CWT|6A.A 70 60 50 50|012121232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 gEn0 TX0 3xd0 Jb0 6zB0 SL0 e5d0 17b0 1Pff0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6","America/Miquelon|LMT AST PMST PMDT|3I.E 40 30 20|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2mKkf.k 2LTAf.k gQ10 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2","America/Moncton|EST AST ADT AWT APT|50 40 30 30 30|012121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsH0 CwN0 1in0 zAo0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1K10 Lz0 1zB0 NX0 1u10 Wn0 S20 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14n1 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 ReX 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|64e3","America/Monterrey|LMT CST CDT|6F.g 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|41e5","America/Montevideo|MMT UYT UYHST UYST UYT UYHST|3I.I 3u 30 20 30 2u|012121212121212121212121213434343434345454543453434343434343434343434343434343434343434|-20UIf.g 8jzJ.g 1cLu 1dcu 1cLu 1dcu 1cLu ircu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu WLu 1qMu WLu 1qMu 11zu 1o0u 11zu NAu 11bu 2iMu zWu Dq10 19X0 pd0 jz0 cm10 19X0 1fB0 1on0 11d0 1oL0 1nB0 1fzu 1aou 1fzu 1aou 1fzu 3nAu Jb0 3MN0 1SLu 4jzu 2PB0 Lb0 3Dd0 1pb0 ixd0 An0 1MN0 An0 1wp0 On0 1wp0 Rb0 1zd0 On0 1wp0 Rb0 s8p0 1fB0 1ip0 11z0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0|17e5","America/Toronto|EST EDT EWT EPT|50 40 40 40|01010101010101010101010101010101010101010101012301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TR0 1in0 11Wu 1nzu 1fD0 WJ0 1wr0 Nb0 1Ap0 On0 1zd0 On0 1wp0 TX0 1tB0 TX0 1tB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 4kM0 8x40 iv0 1o10 11z0 1nX0 11z0 1o10 11z0 1o10 1qL0 11D0 1nX0 11B0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e5","America/Nassau|LMT EST EDT|59.u 50 40|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2kNuO.u 26XdO.u 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|24e4","America/New_York|EST EDT EWT EPT|50 40 40 40|01010101010101010101010101010101010101010101010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 11B0 1qL0 1a10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x40 iv0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6","America/Nipigon|EST EDT EWT EPT|50 40 40 40|010123010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TR0 1in0 Rnb0 3je0 8x40 iv0 19yN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|16e2","America/Nome|NST NWT NPT BST BDT YST AKST AKDT|b0 a0 a0 b0 a0 90 90 80|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17SX0 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cl0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|38e2","America/Noronha|LMT FNT FNST|29.E 20 10|0121212121212121212121212121212121212121|-2glxO.k HdKO.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|30e2","America/North_Dakota/Beulah|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101014545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/North_Dakota/Center|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101014545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/North_Dakota/New_Salem|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101454545454545454545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","America/Ojinaga|LMT MST CST CDT MDT|6V.E 70 60 50 60|0121212323241414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3","America/Panama|CMT EST|5j.A 50|01|-2uduE.o|15e5","America/Pangnirtung|zzz AST AWT APT ADDT ADT EDT EST CST CDT|0 40 30 30 20 30 40 50 60 50|012314151515151515151515151515151515167676767689767676767676767676767676767676767676767676767676767676767676767676767676767|-1XiM0 PnG0 8x50 iu0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1o00 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2","America/Paramaribo|LMT PMT PMT NEGT SRT SRT|3E.E 3E.Q 3E.A 3u 3u 30|012345|-2nDUj.k Wqo0.c qanX.I 1dmLN.o lzc0|24e4","America/Phoenix|MST MDT MWT|70 60 60|01010202010|-261r0 1nX0 11B0 1nX0 SgN0 4Al1 Ap0 1db0 SWqX 1cL0|42e5","America/Port-au-Prince|PPMT EST EDT|4N 50 40|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-28RHb 2FnMb 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14q0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 i6n0 1nX0 11B0 1nX0 d430 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5","America/Rio_Branco|LMT ACT ACST AMT|4v.c 50 40 40|01212121212121212121212121212131|-2glvs.M HdLs.M 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0 d5X0|31e4","America/Porto_Velho|LMT AMT AMST|4f.A 40 30|012121212121212121212121212121|-2glvI.o HdKI.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|37e4","America/Puerto_Rico|AST AWT APT|40 30 30|0120|-17lU0 7XT0 iu0|24e5","America/Rainy_River|CST CDT CWT CPT|60 50 50 50|010123010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TQ0 1in0 Rnb0 3je0 8x30 iw0 19yN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|842","America/Rankin_Inlet|zzz CST CDDT CDT EST|0 60 40 50 50|012131313131313131313131313131313131313131313431313131313131313131313131313131313131313131313131313131313131313131313131|-vDc0 keu0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e2","America/Recife|LMT BRT BRST|2j.A 30 20|0121212121212121212121212121212121212121|-2glxE.o HdLE.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|33e5","America/Regina|LMT MST MDT MWT MPT CST|6W.A 70 60 60 60 60|012121212121212121212121341212121212121212121212121215|-2AD51.o uHe1.o 1in0 s2L0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 66N0 1cL0 1cN0 19X0 1fB0 1cL0 1fB0 1cL0 1cN0 1cL0 M30 8x20 ix0 1ip0 1cL0 1ip0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 3NB0 1cL0 1cN0|19e4","America/Resolute|zzz CST CDDT CDT EST|0 60 40 50 50|012131313131313131313131313131313131313131313431313131313431313131313131313131313131313131313131313131313131313131313131|-SnA0 GWS0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|229","America/Santa_Isabel|LMT MST PST PDT PWT PPT|7D.s 70 80 70 70 70|012123245232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQE0 4PX0 8mM0 8lc0 SN0 1cL0 pHB0 83r0 zI0 5O10 1Rz0 cOP0 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 BUp0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|23e3","America/Santarem|LMT AMT AMST BRT|3C.M 40 30 30|0121212121212121212121212121213|-2glwl.c HdLl.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0|21e4","America/Santiago|SMT CLT CLT CLST CLST CLT|4G.K 50 40 40 30 30|01020313131313121242124242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424245|-2q2jh.e fJAh.e 5knG.K 1Vzh.e jRAG.K 1pbh.e 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 9Bz0 jb0 1oN0 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 1wn0|62e5","America/Santo_Domingo|SDMT EST EDT EHDT AST|4E 50 40 4u 40|01213131313131414|-1ttjk 1lJMk Mn0 6sp0 Lbu 1Cou yLu 1RAu wLu 1QMu xzu 1Q0u xXu 1PAu 13jB0 e00|29e5","America/Sao_Paulo|LMT BRT BRST|36.s 30 20|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2glwR.w HdKR.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 pTd0 PX0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0|20e6","America/Scoresbysund|LMT CGT CGST EGST EGT|1r.Q 20 10 0 10|0121343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-2a5Ww.8 2z5ew.8 1a00 1cK0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|452","America/Sitka|PST PWT PPT PDT YST AKST AKDT|80 70 70 70 90 90 80|01203030303030303030303030303030345656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|90e2","America/St_Johns|NST NDT NST NDT NWT NPT NDDT|3u.Q 2u.Q 3u 2u 2u 2u 1u|01010101010101010101010101010101010102323232323232324523232323232323232323232323232323232323232323232323232323232323232323232323232323232326232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-28oit.8 14L0 1nB0 1in0 1gm0 Dz0 1JB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1fB0 19X0 1fB0 19X0 10O0 eKX.8 19X0 1iq0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4","America/Swift_Current|LMT MST MDT MWT MPT CST|7b.k 70 60 60 60 60|012134121212121212121215|-2AD4M.E uHdM.E 1in0 UGp0 8x20 ix0 1o10 17b0 1ip0 11z0 1o10 11z0 1o10 11z0 isN0 1cL0 3Cp0 1cL0 1cN0 11z0 1qN0 WL0 pMp0|16e3","America/Tegucigalpa|LMT CST CDT|5M.Q 60 50|01212121|-1WGGb.8 2ETcb.8 WL0 1qN0 WL0 GRd0 AL0|11e5","America/Thule|LMT AST ADT|4z.8 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5To.Q 31NBo.Q 1cL0 1cN0 1cL0 1fB0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|656","America/Thunder_Bay|CST EST EWT EPT EDT|60 50 40 40 40|0123141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-2q5S0 1iaN0 8x40 iv0 XNB0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4","America/Vancouver|PST PDT PWT PPT|80 70 70 70|0102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TO0 1in0 UGp0 8x10 iy0 1o10 17b0 1ip0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5","America/Whitehorse|YST YDT YWT YPT YDDT PST PDT|90 80 80 80 70 80 70|0101023040565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-25TN0 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 3NA0 vrd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3","America/Winnipeg|CST CDT CWT CPT|60 50 50 50|010101023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aIi0 WL0 3ND0 1in0 Jap0 Rb0 aCN0 8x30 iw0 1tB0 11z0 1ip0 11z0 1o10 11z0 1o10 11z0 1rd0 10L0 1op0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 1cL0 1cN0 11z0 6i10 WL0 6i10 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|66e4","America/Yakutat|YST YWT YPT YDT AKST AKDT|90 80 80 80 90 80|01203030303030303030303030303030304545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-17T10 8x00 iz0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cn0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|642","America/Yellowknife|zzz MST MWT MPT MDDT MDT|0 70 60 60 50 60|012314151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151|-1pdA0 hix0 8x20 ix0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3","Antarctica/Casey|zzz AWST CAST|0 -80 -b0|012121|-2q00 1DjS0 T90 40P0 KL0|10","Antarctica/Davis|zzz DAVT DAVT|0 -70 -50|01012121|-vyo0 iXt0 alj0 1D7v0 VB0 3Wn0 KN0|70","Antarctica/DumontDUrville|zzz PMT DDUT|0 -a0 -a0|0102|-U0o0 cfq0 bFm0|80","Antarctica/Macquarie|AEST AEDT zzz MIST|-a0 -b0 0 -b0|0102010101010101010101010101010101010101010101010101010101010101010101010101010101010101013|-29E80 19X0 4SL0 1ayy0 Lvs0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0|1","Antarctica/Mawson|zzz MAWT MAWT|0 -60 -50|012|-CEo0 2fyk0|60","Pacific/Auckland|NZMT NZST NZST NZDT|-bu -cu -c0 -d0|01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1GCVu Lz0 1tB0 11zu 1o0u 11zu 1o0u 11zu 1o0u 14nu 1lcu 14nu 1lcu 1lbu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1qLu WMu 1qLu 11Au 1n1bu IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|14e5","Antarctica/Palmer|zzz ARST ART ART ARST CLT CLST CLT|0 30 40 30 20 40 30 30|012121212123435656565656565656565656565656565656565656565656565656565656565656567|-cao0 nD0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 jsN0 14N0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 1wn0|40","Antarctica/Rothera|zzz ROTT|0 30|01|gOo0|130","Antarctica/Syowa|zzz SYOT|0 -30|01|-vs00|20","Antarctica/Troll|zzz UTC CEST|0 0 -20|01212121212121212121212121212121212121212121212121212121212121212121|1puo0 hd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40","Antarctica/Vostok|zzz VOST|0 -60|01|-tjA0|25","Europe/Oslo|CET CEST|-10 -20|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2awM0 Qm0 W6o0 5pf0 WM0 1fA0 1cM0 1cM0 1cM0 1cM0 wJc0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1qM0 WM0 zpc0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|62e4","Asia/Riyadh|LMT AST|-36.Q -30|01|-TvD6.Q|57e5","Asia/Almaty|LMT ALMT ALMT ALMST|-57.M -50 -60 -70|0123232323232323232323232323232323232323232323232|-1Pc57.M eUo7.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 3Cl0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|15e5","Asia/Amman|LMT EET EEST|-2n.I -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1yW2n.I 1HiMn.I KL0 1oN0 11b0 1oN0 11b0 1pd0 1dz0 1cp0 11b0 1op0 11b0 fO10 1db0 1e10 1cL0 1cN0 1cL0 1cN0 1fz0 1pd0 10n0 1ld0 14n0 1hB0 15b0 1ip0 19X0 1cN0 1cL0 1cN0 17b0 1ld0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1So0 y00 1fc0 1dc0 1co0 1dc0 1cM0 1cM0 1cM0 1o00 11A0 1lc0 17c0 1cM0 1cM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e5","Asia/Anadyr|LMT ANAT ANAT ANAST ANAST ANAST ANAT|-bN.U -c0 -d0 -e0 -d0 -c0 -b0|01232414141414141414141561414141414141414141414141414141414141561|-1PcbN.U eUnN.U 23CL0 1db0 1cN0 1dc0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qN0 WM0|13e3","Asia/Aqtau|LMT FORT FORT SHET SHET SHEST AQTT AQTST AQTST AQTT|-3l.4 -40 -50 -50 -60 -60 -50 -60 -50 -40|012345353535353535353536767676898989898989898989896|-1Pc3l.4 eUnl.4 1jcL0 JDc0 1cL0 1dc0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2UK0 Fz0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cN0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 RW0|15e4","Asia/Aqtobe|LMT AKTT AKTT AKTST AKTT AQTT AQTST|-3M.E -40 -50 -60 -60 -50 -60|01234323232323232323232565656565656565656565656565|-1Pc3M.E eUnM.E 23CL0 1db0 1cM0 1dc0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2UK0 Fz0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|27e4","Asia/Ashgabat|LMT ASHT ASHT ASHST ASHST TMT TMT|-3R.w -40 -50 -60 -50 -40 -50|012323232323232323232324156|-1Pc3R.w eUnR.w 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 ba0 xC0|41e4","Asia/Baghdad|BMT AST ADT|-2V.A -30 -40|012121212121212121212121212121212121212121212121212121|-26BeV.A 2ACnV.A 11b0 1cp0 1dz0 1dd0 1db0 1cN0 1cp0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1de0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0|66e5","Asia/Qatar|LMT GST AST|-3q.8 -40 -30|012|-21Jfq.8 27BXq.8|96e4","Asia/Baku|LMT BAKT BAKT BAKST BAKST AZST AZT AZT AZST|-3j.o -30 -40 -50 -40 -40 -30 -40 -50|0123232323232323232323245657878787878787878787878787878787878787878787878787878787878787878787878787878787878787|-1Pc3j.o 1jUoj.o WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 10K0 c30 1cJ0 1cL0 8wu0 1o00 11z0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5","Asia/Bangkok|BMT ICT|-6G.4 -70|01|-218SG.4|15e6","Asia/Beirut|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-21aq0 1on0 1410 1db0 19B0 1in0 1ip0 WL0 1lQp0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 q6N0 En0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1op0 11b0 dA10 17b0 1iN0 17b0 1iN0 17b0 1iN0 17b0 1vB0 SL0 1mp0 13z0 1iN0 17b0 1iN0 17b0 1jd0 12n0 1a10 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5","Asia/Bishkek|LMT FRUT FRUT FRUST FRUST KGT KGST KGT|-4W.o -50 -60 -70 -60 -50 -60 -60|01232323232323232323232456565656565656565656565656567|-1Pc4W.o eUnW.o 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 11c0 1tX0 17b0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1cPu 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 T8u|87e4","Asia/Brunei|LMT BNT BNT|-7D.E -7u -80|012|-1KITD.E gDc9.E|42e4","Asia/Kolkata|HMT BURT IST IST|-5R.k -6u -5u -6u|01232|-18LFR.k 1unn.k HB0 7zX0|15e6","Asia/Chita|LMT YAKT YAKT YAKST YAKST YAKT IRKT|-7x.Q -80 -90 -a0 -90 -a0 -80|012323232323232323232324123232323232323232323232323232323232323256|-21Q7x.Q pAnx.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|33e4","Asia/Choibalsan|LMT ULAT ULAT CHOST CHOT CHOT CHOST|-7C -70 -80 -a0 -90 -80 -90|0123434343434343434343434343434343434343434343456565656565656565656565656565656565656565656565|-2APHC 2UkoC cKn0 1da0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 3Db0 h1f0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|38e3","Asia/Shanghai|CST CDT|-80 -90|01010101010101010|-1c1I0 LX0 16p0 1jz0 1Myp0 Rb0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0|23e6","Asia/Colombo|MMT IST IHST IST LKT LKT|-5j.w -5u -60 -6u -6u -60|01231451|-2zOtj.w 1rFbN.w 1zzu 7Apu 23dz0 11zu n3cu|22e5","Asia/Dhaka|HMT BURT IST DACT BDT BDST|-5R.k -6u -5u -60 -60 -70|01213454|-18LFR.k 1unn.k HB0 m6n0 LqMu 1x6n0 1i00|16e6","Asia/Damascus|LMT EET EEST|-2p.c -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-21Jep.c Hep.c 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1xRB0 11X0 1oN0 10L0 1pB0 11b0 1oN0 10L0 1mp0 13X0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 Nb0 1AN0 Nb0 bcp0 19X0 1gp0 19X0 3ld0 1xX0 Vd0 1Bz0 Sp0 1vX0 10p0 1dz0 1cN0 1cL0 1db0 1db0 1g10 1an0 1ap0 1db0 1fd0 1db0 1cN0 1db0 1dd0 1db0 1cp0 1dz0 1c10 1dX0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 19z0 1fB0 1qL0 11B0 1on0 Wp0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|26e5","Asia/Dili|LMT TLT JST TLT WITA|-8m.k -80 -90 -90 -80|012343|-2le8m.k 1dnXm.k 8HA0 1ew00 Xld0|19e4","Asia/Dubai|LMT GST|-3F.c -40|01|-21JfF.c|39e5","Asia/Dushanbe|LMT DUST DUST DUSST DUSST TJT|-4z.c -50 -60 -70 -60 -50|0123232323232323232323245|-1Pc4z.c eUnz.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 14N0|76e4","Asia/Gaza|EET EET EEST IST IDT|-20 -30 -30 -20 -30|010101010102020202020202020202023434343434343434343434343430202020202020202020202020202020202020202020202020202020202020202020202020202020202020|-1c2q0 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 pBd0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 npB0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 11z0 1o10 14o0 1lA1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0|18e5","Asia/Hebron|EET EET EEST IST IDT|-20 -30 -30 -20 -30|01010101010202020202020202020202343434343434343434343434343020202020202020202020202020202020202020202020202020202020202020202020202020202020202020|-1c2q0 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 pBd0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 npB0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 12L0 1mN0 14o0 1lc0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0|25e4","Asia/Ho_Chi_Minh|LMT PLMT ICT IDT JST|-76.E -76.u -70 -80 -90|0123423232|-2yC76.E bK00.a 1h7b6.u 5lz0 18o0 3Oq0 k5b0 aW00 BAM0|90e5","Asia/Hong_Kong|LMT HKT HKST JST|-7A.G -80 -90 -90|0121312121212121212121212121212121212121212121212121212121212121212121|-2CFHA.G 1sEP6.G 1cL0 ylu 93X0 1qQu 1tX0 Rd0 1In0 NB0 1cL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1kL0 14N0 1nX0 U10 1tz0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 Rd0 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 17d0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1cL0 6fd0 14n0|73e5","Asia/Hovd|LMT HOVT HOVT HOVST|-66.A -60 -70 -80|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2APG6.A 2Uko6.A cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|81e3","Asia/Irkutsk|IMT IRKT IRKT IRKST IRKST IRKT|-6V.5 -70 -80 -90 -80 -90|012323232323232323232324123232323232323232323232323232323232323252|-21zGV.5 pjXV.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4","Europe/Istanbul|IMT EET EEST TRST TRT|-1U.U -20 -30 -40 -30|012121212121212121212121212121212121212121212121212121234343434342121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ogNU.U dzzU.U 11b0 8tB0 1on0 1410 1db0 19B0 1in0 3Rd0 Un0 1oN0 11b0 zSp0 CL0 mN0 1Vz0 1gN0 1pz0 5Rd0 1fz0 1yp0 ML0 1kp0 17b0 1ip0 17b0 1fB0 19X0 1jB0 18L0 1ip0 17z0 qdd0 xX0 3S10 Tz0 dA10 11z0 1o10 11z0 1qN0 11z0 1ze0 11B0 WM0 1qO0 WI0 1nX0 1rB0 10L0 11B0 1in0 17d0 1in0 2pX0 19E0 1fU0 16Q0 1iI0 16Q0 1iI0 1Vd0 pb0 3Kp0 14o0 1df0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WO0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|13e6","Asia/Jakarta|BMT JAVT WIB JST WIB WIB|-77.c -7k -7u -90 -80 -70|01232425|-1Q0Tk luM0 mPzO 8vWu 6kpu 4PXu xhcu|31e6","Asia/Jayapura|LMT WIT ACST|-9m.M -90 -9u|0121|-1uu9m.M sMMm.M L4nu|26e4","Asia/Jerusalem|JMT IST IDT IDDT|-2k.E -20 -30 -40|01212121212132121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-26Bek.E SyMk.E 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 3LB0 Em0 or0 1cn0 1dB0 16n0 10O0 1ja0 1tC0 14o0 1cM0 1a00 11A0 1Na0 An0 1MP0 AJ0 1Kp0 LC0 1oo0 Wl0 EQN0 Db0 1fB0 Rb0 npB0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 1hB0 1dX0 1ep0 1aL0 1eN0 17X0 1nf0 11z0 1tB0 19W0 1e10 17b0 1ep0 1gL0 18N0 1fz0 1eN0 17b0 1gq0 1gn0 19d0 1dz0 1c10 17X0 1hB0 1gn0 19d0 1dz0 1c10 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4","Asia/Kabul|AFT AFT|-40 -4u|01|-10Qs0|46e5","Asia/Kamchatka|LMT PETT PETT PETST PETST|-ay.A -b0 -c0 -d0 -c0|01232323232323232323232412323232323232323232323232323232323232412|-1SLKy.A ivXy.A 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qN0 WM0|18e4","Asia/Karachi|LMT IST IST KART PKT PKST|-4s.c -5u -6u -50 -50 -60|012134545454|-2xoss.c 1qOKW.c 7zX0 eup0 LqMu 1fy01 1cL0 dK0X 11b0 1610 1jX0|24e6","Asia/Urumqi|LMT XJT|-5O.k -60|01|-1GgtO.k|32e5","Asia/Kathmandu|LMT IST NPT|-5F.g -5u -5J|012|-21JhF.g 2EGMb.g|12e5","Asia/Khandyga|LMT YAKT YAKT YAKST YAKST VLAT VLAST VLAT YAKT|-92.d -80 -90 -a0 -90 -a0 -b0 -b0 -a0|01232323232323232323232412323232323232323232323232565656565656565782|-21Q92.d pAp2.d 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 qK0 yN0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|66e2","Asia/Krasnoyarsk|LMT KRAT KRAT KRAST KRAST KRAT|-6b.q -60 -70 -80 -70 -80|012323232323232323232324123232323232323232323232323232323232323252|-21Hib.q prAb.q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5","Asia/Kuala_Lumpur|SMT MALT MALST MALT MALT JST MYT|-6T.p -70 -7k -7k -7u -90 -80|01234546|-2Bg6T.p 17anT.p 7hXE dM00 17bO 8Fyu 1so1u|71e5","Asia/Kuching|LMT BORT BORT BORTST JST MYT|-7l.k -7u -80 -8k -90 -80|01232323232323232425|-1KITl.k gDbP.k 6ynu AnE 1O0k AnE 1NAk AnE 1NAk AnE 1NAk AnE 1O0k AnE 1NAk AnE pAk 8Fz0 1so10|13e4","Asia/Macau|LMT MOT MOST CST|-7y.k -80 -90 -80|0121212121212121212121212121212121212121213|-2le7y.k 1XO34.k 1wn0 Rd0 1wn0 R9u 1wqu U10 1tz0 TVu 1tz0 17gu 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cJu 1cL0 1cN0 1fz0 1cN0 1cOu 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cJu 1cL0 1cN0 1fz0 1cN0 1cL0 KEp0|57e4","Asia/Magadan|LMT MAGT MAGT MAGST MAGST MAGT|-a3.c -a0 -b0 -c0 -b0 -c0|012323232323232323232324123232323232323232323232323232323232323251|-1Pca3.c eUo3.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|95e3","Asia/Makassar|LMT MMT WITA JST|-7V.A -7V.A -80 -90|01232|-21JjV.A vfc0 myLV.A 8ML0|15e5","Asia/Manila|PHT PHST JST|-80 -90 -90|010201010|-1kJI0 AL0 cK10 65X0 mXB0 vX0 VK10 1db0|24e6","Asia/Nicosia|LMT EET EEST|-2d.s -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Vc2d.s 2a3cd.s 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|32e4","Asia/Novokuznetsk|LMT KRAT KRAT KRAST KRAST NOVST NOVT NOVT|-5M.M -60 -70 -80 -70 -70 -60 -70|012323232323232323232324123232323232323232323232323232323232325672|-1PctM.M eULM.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qN0 WM0 8Hz0|55e4","Asia/Novosibirsk|LMT NOVT NOVT NOVST NOVST|-5v.E -60 -70 -80 -70|0123232323232323232323241232341414141414141414141414141414141414121|-21Qnv.E pAFv.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 ml0 Os0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|15e5","Asia/Omsk|LMT OMST OMST OMSST OMSST OMST|-4R.u -50 -60 -70 -60 -70|012323232323232323232324123232323232323232323232323232323232323252|-224sR.u pMLR.u 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|12e5","Asia/Oral|LMT URAT URAT URAST URAT URAST ORAT ORAST ORAT|-3p.o -40 -50 -60 -60 -50 -40 -50 -50|012343232323232323251516767676767676767676767676768|-1Pc3p.o eUnp.o 23CL0 1db0 1cM0 1dc0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 2UK0 Fz0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 RW0|27e4","Asia/Pontianak|LMT PMT WIB JST WIB WITA WIB|-7h.k -7h.k -7u -90 -80 -80 -70|012324256|-2ua7h.k XE00 munL.k 8Rau 6kpu 4PXu xhcu Wqnu|23e4","Asia/Pyongyang|LMT KST JCST JST KST|-8n -8u -90 -90 -90|012341|-2um8n 97XR 12FXu jdA0 2Onc0|29e5","Asia/Qyzylorda|LMT KIZT KIZT KIZST KIZT QYZT QYZT QYZST|-4l.Q -40 -50 -60 -60 -50 -60 -70|012343232323232323232325676767676767676767676767676|-1Pc4l.Q eUol.Q 23CL0 1db0 1cM0 1dc0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2UK0 dC0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|73e4","Asia/Rangoon|RMT BURT JST MMT|-6o.E -6u -90 -6u|0123|-21Jio.E SmnS.E 7j9u|48e5","Asia/Sakhalin|LMT JCST JST SAKT SAKST SAKST SAKT|-9u.M -90 -90 -b0 -c0 -b0 -a0|0123434343434343434343435634343434343565656565656565656565656565636|-2AGVu.M 1iaMu.M je00 1qFa0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o10 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|58e4","Asia/Samarkand|LMT SAMT SAMT SAMST TAST UZST UZT|-4r.R -40 -50 -60 -60 -60 -50|01234323232323232323232356|-1Pc4r.R eUor.R 23CL0 1db0 1cM0 1dc0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 11x0 bf0|36e4","Asia/Seoul|LMT KST JCST JST KST KDT KDT|-8r.Q -8u -90 -90 -90 -9u -a0|01234151515151515146464|-2um8r.Q 97XV.Q 12FXu jjA0 kKo0 2I0u OL0 1FB0 Rb0 1qN0 TX0 1tB0 TX0 1tB0 TX0 1tB0 TX0 2ap0 12FBu 11A0 1o00 11A0|23e6","Asia/Singapore|SMT MALT MALST MALT MALT JST SGT SGT|-6T.p -70 -7k -7k -7u -90 -7u -80|012345467|-2Bg6T.p 17anT.p 7hXE dM00 17bO 8Fyu Mspu DTA0|56e5","Asia/Srednekolymsk|LMT MAGT MAGT MAGST MAGST MAGT SRET|-ae.Q -a0 -b0 -c0 -b0 -c0 -b0|012323232323232323232324123232323232323232323232323232323232323256|-1Pcae.Q eUoe.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|35e2","Asia/Taipei|JWST JST CST CDT|-80 -90 -80 -90|01232323232323232323232323232323232323232|-1iw80 joM0 1yo0 Tz0 1ip0 1jX0 1cN0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 10N0 1BX0 10p0 1pz0 10p0 1pz0 10p0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1BB0 ML0 1Bd0 ML0 uq10 1db0 1cN0 1db0 97B0 AL0|74e5","Asia/Tashkent|LMT TAST TAST TASST TASST UZST UZT|-4B.b -50 -60 -70 -60 -60 -50|01232323232323232323232456|-1Pc4B.b eUnB.b 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 11y0 bf0|23e5","Asia/Tbilisi|TBMT TBIT TBIT TBIST TBIST GEST GET GET GEST|-2X.b -30 -40 -50 -40 -40 -30 -40 -50|0123232323232323232323245656565787878787878787878567|-1Pc2X.b 1jUnX.b WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 3y0 19f0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cM0 1cL0 1fB0 3Nz0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 An0 Os0 WM0|11e5","Asia/Tehran|LMT TMT IRST IRST IRDT IRDT|-3p.I -3p.I -3u -40 -50 -4u|01234325252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2btDp.I 1d3c0 1huLT.I TXu 1pz0 sN0 vAu 1cL0 1dB0 1en0 pNB0 UL0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 64p0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0|14e6","Asia/Thimphu|LMT IST BTT|-5W.A -5u -60|012|-Su5W.A 1BGMs.A|79e3","Asia/Tokyo|JCST JST JDT|-90 -90 -a0|0121212121|-1iw90 pKq0 QL0 1lB0 13X0 1zB0 NX0 1zB0 NX0|38e6","Asia/Ulaanbaatar|LMT ULAT ULAT ULAST|-77.w -70 -80 -90|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2APH7.w 2Uko7.w cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|12e5","Asia/Ust-Nera|LMT YAKT YAKT MAGST MAGT MAGST MAGT MAGT VLAT VLAT|-9w.S -80 -90 -c0 -b0 -b0 -a0 -c0 -b0 -a0|0123434343434343434343456434343434343434343434343434343434343434789|-21Q9w.S pApw.S 23CL0 1d90 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|65e2","Asia/Vladivostok|LMT VLAT VLAT VLAST VLAST VLAT|-8L.v -90 -a0 -b0 -a0 -b0|012323232323232323232324123232323232323232323232323232323232323252|-1SJIL.v itXL.v 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4","Asia/Yakutsk|LMT YAKT YAKT YAKST YAKST YAKT|-8C.W -80 -90 -a0 -90 -a0|012323232323232323232324123232323232323232323232323232323232323252|-21Q8C.W pAoC.W 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|28e4","Asia/Yekaterinburg|LMT PMT SVET SVET SVEST SVEST YEKT YEKST YEKT|-42.x -3J.5 -40 -50 -60 -50 -50 -60 -60|0123434343434343434343435267676767676767676767676767676767676767686|-2ag42.x 7mQh.s qBvJ.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|14e5","Asia/Yerevan|LMT YERT YERT YERST YERST AMST AMT AMT AMST|-2W -30 -40 -50 -40 -40 -30 -40 -50|0123232323232323232323245656565657878787878787878787878787878787|-1Pc2W 1jUnW WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1am0 2r0 1cJ0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 3Fb0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|13e5","Atlantic/Azores|HMT AZOT AZOST AZOMT AZOT AZOST WET|1S.w 20 10 0 10 0 0|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121454545454545454545454545454545456545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2ldW5.s aPX5.s Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4","Atlantic/Bermuda|LMT AST ADT|4j.i 40 30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1BnRE.G 1LTbE.G 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e3","Atlantic/Canary|LMT CANT WET WEST|11.A 10 0 -10|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UtaW.o XPAW.o 1lAK0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Atlantic/Cape_Verde|LMT CVT CVST CVT|1y.4 20 10 10|01213|-2xomp.U 1qOMp.U 7zX0 1djf0|50e4","Atlantic/Faroe|LMT WET WEST|r.4 0 -10|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2uSnw.U 2Wgow.U 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|49e3","Atlantic/Madeira|FMT MADT MADST MADMT WET WEST|17.A 10 0 -10 0 -10|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2ldWQ.o aPWQ.o Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e4","Atlantic/Reykjavik|LMT IST ISST GMT|1s 10 0 0|012121212121212121212121212121212121212121212121212121212121212121213|-2uWmw mfaw 1Bd0 ML0 1LB0 Cn0 1LB0 3fX0 C10 HrX0 1cO0 LB0 1EL0 LA0 1C00 Oo0 1wo0 Rc0 1wo0 Rc0 1wo0 Rc0 1zc0 Oo0 1zc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0|12e4","Atlantic/South_Georgia|GST|20|0||30","Atlantic/Stanley|SMT FKT FKST FKT FKST|3P.o 40 30 30 20|0121212121212134343212121212121212121212121212121212121212121212121212|-2kJw8.A 12bA8.A 19X0 1fB0 19X0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 Cn0 1Cc10 WL0 1qL0 U10 1tz0 U10 1qM0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 U10 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qN0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 U10 1tz0 U10 1tz0 U10|21e2","Australia/Sydney|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|40e5","Australia/Adelaide|ACST ACDT|-9u -au|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 WM0 1qM0 Rc0 1zc0 U00 1tA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|11e5","Australia/Brisbane|AEST AEDT|-a0 -b0|01010101010101010|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0|20e5","Australia/Broken_Hill|ACST ACDT|-9u -au|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|18e3","Australia/Currie|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-29E80 19X0 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|746","Australia/Darwin|ACST ACDT|-9u -au|010101010|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0|12e4","Australia/Eucla|ACWST ACWDT|-8J -9J|0101010101010101010|-293kI xcX 10jd0 yL0 1cN0 1cL0 1gSp0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|368","Australia/Hobart|AEST AEDT|-a0 -b0|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-29E80 19X0 10jd0 yL0 1cN0 1cL0 1fB0 19X0 VfB0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|21e4","Australia/Lord_Howe|AEST LHST LHDT LHDT|-a0 -au -bu -b0|0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313|raC0 1zdu Rb0 1zd0 On0 1zd0 On0 1zd0 On0 1zd0 TXu 1qMu WLu 1tAu WLu 1tAu TXu 1tAu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu 11zu 1o0u 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 11Au 1nXu 1qMu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu 11zu 1o0u WLu 1qMu 14nu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu|347","Australia/Lindeman|AEST AEDT|-a0 -b0|010101010101010101010|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0|10","Australia/Melbourne|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1qM0 11A0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|39e5","Australia/Perth|AWST AWDT|-80 -90|0101010101010101010|-293jX xcX 10jd0 yL0 1cN0 1cL0 1gSp0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|18e5","CET|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00","CST6CDT|CST CDT CWT CPT|60 50 50 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","Pacific/Easter|EMT EAST EASST EAST EASST EAST|7h.s 70 60 60 50 50|012121212121212121212121212123434343434343434343434343434343434343434343434343434343434343434345|-1uSgG.w 1s4IG.w WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 1wn0|30e2","EET|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00","EST|EST|50|0|","EST5EDT|EST EDT EWT EPT|50 40 40 40|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 SgN0 8x40 iv0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","Europe/Dublin|DMT IST GMT BST IST|p.l -y.D 0 -10 -10|01232323232324242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242|-2ax9y.D Rc0 1fzy.D 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 g5X0 14p0 1wn0 17d0 1io0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Etc/GMT+0|GMT|0|0|","Etc/GMT+1|GMT+1|10|0|","Etc/GMT+10|GMT+10|a0|0|","Etc/GMT+11|GMT+11|b0|0|","Etc/GMT+12|GMT+12|c0|0|","Etc/GMT+2|GMT+2|20|0|","Etc/GMT+3|GMT+3|30|0|","Etc/GMT+4|GMT+4|40|0|","Etc/GMT+5|GMT+5|50|0|","Etc/GMT+6|GMT+6|60|0|","Etc/GMT+7|GMT+7|70|0|","Etc/GMT+8|GMT+8|80|0|","Etc/GMT+9|GMT+9|90|0|","Etc/GMT-1|GMT-1|-10|0|","Etc/GMT-10|GMT-10|-a0|0|","Etc/GMT-11|GMT-11|-b0|0|","Etc/GMT-12|GMT-12|-c0|0|","Etc/GMT-13|GMT-13|-d0|0|","Etc/GMT-14|GMT-14|-e0|0|","Etc/GMT-2|GMT-2|-20|0|","Etc/GMT-3|GMT-3|-30|0|","Etc/GMT-4|GMT-4|-40|0|","Etc/GMT-5|GMT-5|-50|0|","Etc/GMT-6|GMT-6|-60|0|","Etc/GMT-7|GMT-7|-70|0|","Etc/GMT-8|GMT-8|-80|0|","Etc/GMT-9|GMT-9|-90|0|","Etc/UCT|UCT|0|0|","Etc/UTC|UTC|0|0|","Europe/Amsterdam|AMT NST NEST NET CEST CET|-j.w -1j.w -1k -k -20 -10|010101010101010101010101010101010101010101012323234545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-2aFcj.w 11b0 1iP0 11A0 1io0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1co0 1io0 1yo0 Pc0 1a00 1fA0 1Bc0 Mo0 1tc0 Uo0 1tA0 U00 1uo0 W00 1s00 VA0 1so0 Vc0 1sM0 UM0 1wo0 Rc0 1u00 Wo0 1rA0 W00 1s00 VA0 1sM0 UM0 1w00 fV0 BCX.w 1tA0 U00 1u00 Wo0 1sm0 601k WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|16e5","Europe/Andorra|WET CET CEST|0 -10 -20|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-UBA0 1xIN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|79e3","Europe/Athens|AMT EET EEST CEST CET|-1y.Q -20 -30 -20 -10|012123434121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a61x.Q CNbx.Q mn0 kU10 9b0 3Es0 Xa0 1fb0 1dd0 k3X0 Nz0 SCp0 1vc0 SO0 1cM0 1a00 1ao0 1fc0 1a10 1fG0 1cg0 1dX0 1bX0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5","Europe/London|GMT BST BDST|0 -10 -20|0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2axa0 Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6","Europe/Belgrade|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-19RC0 3IP0 WM0 1fA0 1cM0 1cM0 1rc0 Qo0 1vmo0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Berlin|CET CEST CEMT|-10 -20 -30|01010101010101210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 kL0 Nc0 m10 WM0 1ao0 1cp0 dX0 jz0 Dd0 1io0 17c0 1fA0 1a00 1ehA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e5","Europe/Prague|CET CEST|-10 -20|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 16M0 1lc0 1tA0 17A0 11c0 1io0 17c0 1io0 17c0 1fc0 1ao0 1bNc0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|13e5","Europe/Brussels|WET CET CEST WEST|0 -10 -20 -10|0121212103030303030303030303030303030303030303030303212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ehc0 3zX0 11c0 1iO0 11A0 1o00 11A0 my0 Ic0 1qM0 Rc0 1EM0 UM0 1u00 10o0 1io0 1io0 17c0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a30 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 y00 5Wn0 WM0 1fA0 1cM0 16M0 1iM0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|21e5","Europe/Bucharest|BMT EET EEST|-1I.o -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1xApI.o 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Axc0 On0 1fA0 1a10 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|19e5","Europe/Budapest|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1ip0 17b0 1op0 1tb0 Q2m0 3Ne0 WM0 1fA0 1cM0 1cM0 1oJ0 1dc0 1030 1fA0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1iM0 1fA0 8Ha0 Rb0 1wN0 Rb0 1BB0 Lz0 1C20 LB0 SNX0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e5","Europe/Zurich|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-19Lc0 11A0 1o00 11A0 1xG10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|38e4","Europe/Chisinau|CMT BMT EET EEST CEST CET MSK MSD|-1T -1I.o -20 -30 -20 -10 -30 -40|0123232323232323232345454676767676767676767623232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-26jdT wGMa.A 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 27A0 2en0 39g0 WM0 1fA0 1cM0 V90 1t7z0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1ty0 2bD0 1cM0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11D0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4","Europe/Copenhagen|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2azC0 Tz0 VuO0 60q0 WM0 1fA0 1cM0 1cM0 1cM0 S00 1HA0 Nc0 1C00 Dc0 1Nc0 Ao0 1h5A0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Gibraltar|GMT BST BDST CET CEST|0 -10 -20 -10 -20|010101010101010101010101010101010101010101010101012121212121010121010101010101010101034343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-2axa0 Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 10Jz0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|30e3","Europe/Helsinki|HMT EET EEST|-1D.N -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1WuND.N OULD.N 1dA0 1xGq0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Kaliningrad|CET CEST CET CEST MSK MSD EEST EET FET|-10 -20 -20 -30 -30 -40 -30 -20 -30|0101010101010232454545454545454545454676767676767676767676767676767676767676787|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 Am0 Lb0 1en0 op0 1pNz0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 1cJ0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|44e4","Europe/Kiev|KMT EET MSK CEST CET MSD EEST|-22.4 -20 -30 -20 -10 -40 -30|0123434252525252525252525256161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161|-1Pc22.4 eUo2.4 rnz0 2Hg0 WM0 1fA0 da0 1v4m0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 Db0 3220 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|34e5","Europe/Lisbon|LMT WET WEST WEMT CET CEST|A.J 0 -10 -20 -10 -20|012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121214121212121212121212121212121212124545454212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ldXn.f aPWn.f Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 pvy0 1cM0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5","Europe/Luxembourg|LMT CET CEST WET WEST WEST WET|-o.A -10 -20 0 -10 -20 -10|0121212134343434343434343434343434343434343434343434565651212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2DG0o.A t6mo.A TB0 1nX0 Up0 1o20 11A0 rW0 CM0 1qP0 R90 1EO0 UK0 1u20 10m0 1ip0 1in0 17e0 19W0 1fB0 1db0 1cp0 1in0 17d0 1fz0 1a10 1in0 1a10 1in0 17f0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 vA0 60L0 WM0 1fA0 1cM0 17c0 1io0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Europe/Madrid|WET WEST WEMT CET CEST|0 -10 -20 -10 -20|01010101010101010101010121212121234343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-28dd0 11A0 1go0 19A0 1co0 1dA0 b1A0 18o0 3I00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 iyo0 Rc0 18o0 1hc0 1io0 1a00 14o0 5aL0 MM0 1vc0 17A0 1i00 1bc0 1eo0 17d0 1in0 17A0 6hA0 10N0 XIL0 1a10 1in0 17d0 19X0 1cN0 1fz0 1a10 1fX0 1cp0 1cO0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|62e5","Europe/Malta|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2as10 M00 1cM0 1cM0 14o0 1o00 WM0 1qM0 17c0 1cM0 M3A0 5M20 WM0 1fA0 1cM0 1cM0 1cM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 Lz0 1C10 Lz0 1EN0 Lz0 1C10 Lz0 1zd0 Oo0 1C00 On0 1cp0 1cM0 1lA0 Xc0 1qq0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1iN0 19z0 1fB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|42e4","Europe/Minsk|MMT EET MSK CEST CET MSD EEST FET|-1O -20 -30 -20 -10 -40 -30 -30|012343432525252525252525252616161616161616161616161616161616161616172|-1Pc1O eUnO qNX0 3gQ0 WM0 1fA0 1cM0 Al0 1tsn0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 3Fc0 1cN0 1cK0 1cM0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hy0|19e5","Europe/Monaco|PMT WET WEST WEMT CET CEST|-9.l 0 -10 -20 -10 -20|01212121212121212121212121212121212121212121212121232323232345454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2nco9.l cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 2RV0 11z0 11B0 1ze0 WM0 1fA0 1cM0 1fa0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|38e3","Europe/Moscow|MMT MMT MST MDST MSD MSK MSM EET EEST MSK|-2u.h -2v.j -3v.j -4v.j -40 -30 -50 -20 -30 -40|012132345464575454545454545454545458754545454545454545454545454545454545454595|-2ag2u.h 2pyW.W 1bA0 11X0 GN0 1Hb0 c20 imv.j 3DA0 dz0 15A0 c10 2q10 iM10 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rU0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|16e6","Europe/Paris|PMT WET WEST CEST CET WEMT|-9.l 0 -10 -20 -10 -20|0121212121212121212121212121212121212121212121212123434352543434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-2nco8.l cNb8.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 Ik0 5M30 WM0 1fA0 1cM0 Vx0 hB0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6","Europe/Riga|RMT LST EET MSK CEST CET MSD EEST|-1A.y -2A.y -20 -30 -20 -10 -40 -30|010102345454536363636363636363727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272|-25TzA.y 11A0 1iM0 ko0 gWm0 yDXA.y 2bX0 3fE0 WM0 1fA0 1cM0 1cM0 4m0 1sLy0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 1o00 11A0 1o00 11A0 1qM0 3oo0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|64e4","Europe/Rome|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2as10 M00 1cM0 1cM0 14o0 1o00 WM0 1qM0 17c0 1cM0 M3A0 5M20 WM0 1fA0 1cM0 16K0 1iO0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 Lz0 1C10 Lz0 1EN0 Lz0 1C10 Lz0 1zd0 Oo0 1C00 On0 1C10 Lz0 1zd0 On0 1C10 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1zc0 Oo0 1fC0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|39e5","Europe/Samara|LMT SAMT SAMT KUYT KUYST MSD MSK EEST KUYT SAMST SAMST|-3k.k -30 -40 -40 -50 -40 -30 -30 -30 -50 -40|012343434343434343435656782929292929292929292929292929292929292a12|-22WNk.k qHak.k bcn0 1Qqo0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cN0 8o0 14j0 1cL0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qN0 WM0|12e5","Europe/Simferopol|SMT EET MSK CEST CET MSD EEST MSK|-2g -20 -30 -20 -10 -40 -30 -40|012343432525252525252525252161616525252616161616161616161616161616161616172|-1Pc2g eUog rEn0 2qs0 WM0 1fA0 1cM0 3V0 1u0L0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 4eL0 1cL0 1cN0 1cL0 1cN0 dX0 WL0 1cN0 1cL0 1fB0 1o30 11B0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0|33e4","Europe/Sofia|EET CET CEST EEST|-20 -10 -20 -30|01212103030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030|-168L0 WM0 1fA0 1cM0 1cM0 1cN0 1mKH0 1dd0 1fb0 1ap0 1fb0 1a20 1fy0 1a30 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Europe/Stockholm|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2azC0 TB0 2yDe0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|15e5","Europe/Tallinn|TMT CET CEST EET MSK MSD EEST|-1D -10 -20 -20 -30 -40 -30|012103421212454545454545454546363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363|-26oND teD 11A0 1Ta0 4rXl KSLD 2FX0 2Jg0 WM0 1fA0 1cM0 18J0 1sTX0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o10 11A0 1qM0 5QM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e4","Europe/Tirane|LMT CET CEST|-1j.k -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glBj.k 14pcj.k 5LC0 WM0 4M0 1fCK0 10n0 1op0 11z0 1pd0 11z0 1qN0 WL0 1qp0 Xb0 1qp0 Xb0 1qp0 11z0 1lB0 11z0 1qN0 11z0 1iN0 16n0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|42e4","Europe/Uzhgorod|CET CEST MSK MSD EET EEST|-10 -20 -30 -40 -20 -30|010101023232323232323232320454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-1cqL0 6i00 WM0 1fA0 1cM0 1ml0 1Cp0 1r3W0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 1Nf0 2pw0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e4","Europe/Vienna|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 3KM0 14o0 LA00 6i00 WM0 1fA0 1cM0 1cM0 1cM0 400 2qM0 1a00 1cM0 1cM0 1io0 17c0 1gHa0 19X0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|18e5","Europe/Vilnius|WMT KMT CET EET MSK CEST MSD EEST|-1o -1z.A -10 -20 -30 -20 -40 -30|012324525254646464646464646464647373737373737352537373737373737373737373737373737373737373737373737373737373737373737373|-293do 6ILM.o 1Ooz.A zz0 Mfd0 29W0 3is0 WM0 1fA0 1cM0 LV0 1tgL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11B0 1o00 11A0 1qM0 8io0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4","Europe/Volgograd|LMT TSAT STAT STAT VOLT VOLST VOLST VOLT MSD MSK MSK|-2V.E -30 -30 -40 -40 -50 -40 -30 -40 -30 -40|0123454545454545454546767489898989898989898989898989898989898989a9|-21IqV.E cLXV.E cEM0 1gqn0 Lco0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 2pz0 1cJ0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5","Europe/Warsaw|WMT CET CEST EET EEST|-1o -10 -20 -20 -30|012121234312121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ctdo 1LXo 11d0 1iO0 11A0 1o00 11A0 1on0 11A0 6zy0 HWP0 5IM0 WM0 1fA0 1cM0 1dz0 1mL0 1en0 15B0 1aq0 1nA0 11A0 1io0 17c0 1fA0 1a00 iDX0 LA0 1cM0 1cM0 1C00 Oo0 1cM0 1cM0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1C00 LA0 uso0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e5","Europe/Zaporozhye|CUT EET MSK CEST CET MSD EEST|-2k -20 -30 -20 -10 -40 -30|01234342525252525252525252526161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161|-1Pc2k eUok rdb0 2RE0 WM0 1fA0 8m0 1v9a0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cK0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|77e4","HST|HST|a0|0|","Indian/Chagos|LMT IOT IOT|-4N.E -50 -60|012|-2xosN.E 3AGLN.E|30e2","Indian/Christmas|CXT|-70|0||21e2","Indian/Cocos|CCT|-6u|0||596","Indian/Kerguelen|zzz TFT|0 -50|01|-MG00|130","Indian/Mahe|LMT SCT|-3F.M -40|01|-2yO3F.M|79e3","Indian/Maldives|MMT MVT|-4S -50|01|-olgS|35e4","Indian/Mauritius|LMT MUT MUST|-3O -40 -50|012121|-2xorO 34unO 14L0 12kr0 11z0|15e4","Indian/Reunion|LMT RET|-3F.Q -40|01|-2mDDF.Q|84e4","Pacific/Kwajalein|MHT KWAT MHT|-b0 c0 -c0|012|-AX0 W9X0|14e3","MET|MET MEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00","MST|MST|70|0|","MST7MDT|MST MDT MWT MPT|70 60 60 60|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","Pacific/Chatham|CHAST CHAST CHADT|-cf -cJ -dJ|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-WqAf 1adef IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|600","PST8PDT|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0","Pacific/Apia|LMT WSST SST SDT WSDT WSST|bq.U bu b0 a0 -e0 -d0|01232345454545454545454545454545454545454545454545454545454|-2nDMx.4 1yW03.4 2rRbu 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|37e3","Pacific/Bougainville|PGT JST BST|-a0 -90 -b0|0102|-16Wy0 7CN0 2MQp0|18e4","Pacific/Chuuk|CHUT|-a0|0||49e3","Pacific/Efate|LMT VUT VUST|-bd.g -b0 -c0|0121212121212121212121|-2l9nd.g 2Szcd.g 1cL0 1oN0 10L0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 Lz0 1Nd0 An0|66e3","Pacific/Enderbury|PHOT PHOT PHOT|c0 b0 -d0|012|nIc0 B8n0|1","Pacific/Fakaofo|TKT TKT|b0 -d0|01|1Gfn0|483","Pacific/Fiji|LMT FJT FJST|-bT.I -c0 -d0|0121212121212121212121212121212121212121212121212121212121212121|-2bUzT.I 3m8NT.I LA0 1EM0 IM0 nJc0 LA0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0|88e4","Pacific/Funafuti|TVT|-c0|0||45e2","Pacific/Galapagos|LMT ECT GALT|5W.o 50 60|012|-1yVS1.A 2dTz1.A|25e3","Pacific/Gambier|LMT GAMT|8X.M 90|01|-2jof0.c|125","Pacific/Guadalcanal|LMT SBT|-aD.M -b0|01|-2joyD.M|11e4","Pacific/Guam|GST ChST|-a0 -a0|01|1fpq0|17e4","Pacific/Honolulu|HST HDT HST|au 9u a0|010102|-1thLu 8x0 lef0 8Pz0 46p0|37e4","Pacific/Kiritimati|LINT LINT LINT|aE a0 -e0|012|nIaE B8nk|51e2","Pacific/Kosrae|KOST KOST|-b0 -c0|010|-AX0 1bdz0|66e2","Pacific/Majuro|MHT MHT|-b0 -c0|01|-AX0|28e3","Pacific/Marquesas|LMT MART|9i 9u|01|-2joeG|86e2","Pacific/Pago_Pago|LMT NST BST SST|bm.M b0 b0 b0|0123|-2nDMB.c 2gVzB.c EyM0|37e2","Pacific/Nauru|LMT NRT JST NRT|-b7.E -bu -90 -c0|01213|-1Xdn7.E PvzB.E 5RCu 1ouJu|10e3","Pacific/Niue|NUT NUT NUT|bk bu b0|012|-KfME 17y0a|12e2","Pacific/Norfolk|NMT NFT NFST NFT|-bc -bu -cu -b0|01213|-Kgbc W01G On0 1COp0|25e4","Pacific/Noumea|LMT NCT NCST|-b5.M -b0 -c0|01212121|-2l9n5.M 2EqM5.M xX0 1PB0 yn0 HeP0 Ao0|98e3","Pacific/Palau|PWT|-90|0||21e3","Pacific/Pitcairn|PNT PST|8u 80|01|18Vku|56","Pacific/Pohnpei|PONT|-b0|0||34e3","Pacific/Port_Moresby|PGT|-a0|0||25e4","Pacific/Rarotonga|CKT CKHST CKT|au 9u a0|012121212121212121212121212|lyWu IL0 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu|13e3","Pacific/Tahiti|LMT TAHT|9W.g a0|01|-2joe1.I|18e4","Pacific/Tarawa|GILT|-c0|0||29e3","Pacific/Tongatapu|TOT TOT TOST|-ck -d0 -e0|01212121|-1aB0k 2n5dk 15A0 1wo0 xz0 1Q10 xz0|75e3","Pacific/Wake|WAKT|-c0|0||16e3","Pacific/Wallis|WFT|-c0|0||94","WET|WET WEST|0 -10|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00"],
links:["Africa/Abidjan|Africa/Bamako","Africa/Abidjan|Africa/Banjul","Africa/Abidjan|Africa/Conakry","Africa/Abidjan|Africa/Dakar","Africa/Abidjan|Africa/Freetown","Africa/Abidjan|Africa/Lome","Africa/Abidjan|Africa/Nouakchott","Africa/Abidjan|Africa/Ouagadougou","Africa/Abidjan|Africa/Sao_Tome","Africa/Abidjan|Africa/Timbuktu","Africa/Abidjan|Atlantic/St_Helena","Africa/Cairo|Egypt","Africa/Johannesburg|Africa/Maseru","Africa/Johannesburg|Africa/Mbabane","Africa/Khartoum|Africa/Juba","Africa/Lagos|Africa/Bangui","Africa/Lagos|Africa/Brazzaville","Africa/Lagos|Africa/Douala","Africa/Lagos|Africa/Kinshasa","Africa/Lagos|Africa/Libreville","Africa/Lagos|Africa/Luanda","Africa/Lagos|Africa/Malabo","Africa/Lagos|Africa/Niamey","Africa/Lagos|Africa/Porto-Novo","Africa/Maputo|Africa/Blantyre","Africa/Maputo|Africa/Bujumbura","Africa/Maputo|Africa/Gaborone","Africa/Maputo|Africa/Harare","Africa/Maputo|Africa/Kigali","Africa/Maputo|Africa/Lubumbashi","Africa/Maputo|Africa/Lusaka","Africa/Nairobi|Africa/Addis_Ababa","Africa/Nairobi|Africa/Asmara","Africa/Nairobi|Africa/Asmera","Africa/Nairobi|Africa/Dar_es_Salaam","Africa/Nairobi|Africa/Djibouti","Africa/Nairobi|Africa/Kampala","Africa/Nairobi|Africa/Mogadishu","Africa/Nairobi|Indian/Antananarivo","Africa/Nairobi|Indian/Comoro","Africa/Nairobi|Indian/Mayotte","Africa/Tripoli|Libya","America/Adak|America/Atka","America/Adak|US/Aleutian","America/Anchorage|US/Alaska","America/Argentina/Buenos_Aires|America/Buenos_Aires","America/Argentina/Catamarca|America/Argentina/ComodRivadavia","America/Argentina/Catamarca|America/Catamarca","America/Argentina/Cordoba|America/Cordoba","America/Argentina/Cordoba|America/Rosario","America/Argentina/Jujuy|America/Jujuy","America/Argentina/Mendoza|America/Mendoza","America/Atikokan|America/Coral_Harbour","America/Chicago|US/Central","America/Curacao|America/Aruba","America/Curacao|America/Kralendijk","America/Curacao|America/Lower_Princes","America/Denver|America/Shiprock","America/Denver|Navajo","America/Denver|US/Mountain","America/Detroit|US/Michigan","America/Edmonton|Canada/Mountain","America/Fort_Wayne|America/Indiana/Indianapolis","America/Fort_Wayne|America/Indianapolis","America/Fort_Wayne|US/East-Indiana","America/Halifax|Canada/Atlantic","America/Havana|Cuba","America/Indiana/Knox|America/Knox_IN","America/Indiana/Knox|US/Indiana-Starke","America/Jamaica|Jamaica","America/Kentucky/Louisville|America/Louisville","America/Los_Angeles|US/Pacific","America/Los_Angeles|US/Pacific-New","America/Manaus|Brazil/West","America/Mazatlan|Mexico/BajaSur","America/Mexico_City|Mexico/General","America/New_York|US/Eastern","America/Noronha|Brazil/DeNoronha","America/Phoenix|US/Arizona","America/Port_of_Spain|America/Anguilla","America/Port_of_Spain|America/Antigua","America/Port_of_Spain|America/Dominica","America/Port_of_Spain|America/Grenada","America/Port_of_Spain|America/Guadeloupe","America/Port_of_Spain|America/Marigot","America/Port_of_Spain|America/Montserrat","America/Port_of_Spain|America/St_Barthelemy","America/Port_of_Spain|America/St_Kitts","America/Port_of_Spain|America/St_Lucia","America/Port_of_Spain|America/St_Thomas","America/Port_of_Spain|America/St_Vincent","America/Port_of_Spain|America/Tortola","America/Port_of_Spain|America/Virgin","America/Regina|Canada/East-Saskatchewan","America/Regina|Canada/Saskatchewan","America/Rio_Branco|America/Porto_Acre","America/Rio_Branco|Brazil/Acre","America/Santiago|Chile/Continental","America/Sao_Paulo|Brazil/East","America/St_Johns|Canada/Newfoundland","America/Tijuana|America/Ensenada","America/Tijuana|Mexico/BajaNorte","America/Toronto|America/Montreal","America/Toronto|Canada/Eastern","America/Vancouver|Canada/Pacific","America/Whitehorse|Canada/Yukon","America/Winnipeg|Canada/Central","Asia/Ashgabat|Asia/Ashkhabad","Asia/Bangkok|Asia/Phnom_Penh","Asia/Bangkok|Asia/Vientiane","Asia/Dhaka|Asia/Dacca","Asia/Dubai|Asia/Muscat","Asia/Ho_Chi_Minh|Asia/Saigon","Asia/Hong_Kong|Hongkong","Asia/Jerusalem|Asia/Tel_Aviv","Asia/Jerusalem|Israel","Asia/Kathmandu|Asia/Katmandu","Asia/Kolkata|Asia/Calcutta","Asia/Macau|Asia/Macao","Asia/Makassar|Asia/Ujung_Pandang","Asia/Nicosia|Europe/Nicosia","Asia/Qatar|Asia/Bahrain","Asia/Riyadh|Asia/Aden","Asia/Riyadh|Asia/Kuwait","Asia/Seoul|ROK","Asia/Shanghai|Asia/Chongqing","Asia/Shanghai|Asia/Chungking","Asia/Shanghai|Asia/Harbin","Asia/Shanghai|PRC","Asia/Singapore|Singapore","Asia/Taipei|ROC","Asia/Tehran|Iran","Asia/Thimphu|Asia/Thimbu","Asia/Tokyo|Japan","Asia/Ulaanbaatar|Asia/Ulan_Bator","Asia/Urumqi|Asia/Kashgar","Atlantic/Faroe|Atlantic/Faeroe","Atlantic/Reykjavik|Iceland","Australia/Adelaide|Australia/South","Australia/Brisbane|Australia/Queensland","Australia/Broken_Hill|Australia/Yancowinna","Australia/Darwin|Australia/North","Australia/Hobart|Australia/Tasmania","Australia/Lord_Howe|Australia/LHI","Australia/Melbourne|Australia/Victoria","Australia/Perth|Australia/West","Australia/Sydney|Australia/ACT","Australia/Sydney|Australia/Canberra","Australia/Sydney|Australia/NSW","Etc/GMT+0|Etc/GMT","Etc/GMT+0|Etc/GMT-0","Etc/GMT+0|Etc/GMT0","Etc/GMT+0|Etc/Greenwich","Etc/GMT+0|GMT","Etc/GMT+0|GMT+0","Etc/GMT+0|GMT-0","Etc/GMT+0|GMT0","Etc/GMT+0|Greenwich","Etc/UCT|UCT","Etc/UTC|Etc/Universal","Etc/UTC|Etc/Zulu","Etc/UTC|UTC","Etc/UTC|Universal","Etc/UTC|Zulu","Europe/Belgrade|Europe/Ljubljana","Europe/Belgrade|Europe/Podgorica","Europe/Belgrade|Europe/Sarajevo","Europe/Belgrade|Europe/Skopje","Europe/Belgrade|Europe/Zagreb","Europe/Chisinau|Europe/Tiraspol","Europe/Dublin|Eire","Europe/Helsinki|Europe/Mariehamn","Europe/Istanbul|Asia/Istanbul","Europe/Istanbul|Turkey","Europe/Lisbon|Portugal","Europe/London|Europe/Belfast","Europe/London|Europe/Guernsey","Europe/London|Europe/Isle_of_Man","Europe/London|Europe/Jersey","Europe/London|GB","Europe/London|GB-Eire","Europe/Moscow|W-SU","Europe/Oslo|Arctic/Longyearbyen","Europe/Oslo|Atlantic/Jan_Mayen","Europe/Prague|Europe/Bratislava","Europe/Rome|Europe/San_Marino","Europe/Rome|Europe/Vatican","Europe/Warsaw|Poland","Europe/Zurich|Europe/Busingen","Europe/Zurich|Europe/Vaduz","Pacific/Auckland|Antarctica/McMurdo","Pacific/Auckland|Antarctica/South_Pole","Pacific/Auckland|NZ","Pacific/Chatham|NZ-CHAT","Pacific/Chuuk|Pacific/Truk","Pacific/Chuuk|Pacific/Yap","Pacific/Easter|Chile/EasterIsland","Pacific/Guam|Pacific/Saipan","Pacific/Honolulu|Pacific/Johnston","Pacific/Honolulu|US/Hawaii","Pacific/Kwajalein|Kwajalein","Pacific/Pago_Pago|Pacific/Midway","Pacific/Pago_Pago|Pacific/Samoa","Pacific/Pago_Pago|US/Samoa","Pacific/Pohnpei|Pacific/Ponape"]}),a});
/**
 * Copyright (c) 2011-2013 Felix Gnass
 * Licensed under the MIT license
 */
(function(root, factory) {

  /* CommonJS */
  if (typeof exports == 'object')  module.exports = factory()

  /* AMD module */
  else if (typeof define == 'function' && define.amd) define(factory)

  /* Browser global */
  else root.Spinner = factory()
}
(this, function() {
  "use strict";

  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
    , animations = {} /* Animation rules keyed by their name */
    , useCssAnimations /* Whether to use CSS animations or setTimeout */

  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div')
      , n

    for(n in prop) el[n] = prop[n]
    return el
  }

  /**
   * Appends children and returns the parent.
   */
  function ins(parent /* child1, child2, ...*/) {
    for (var i=1, n=arguments.length; i<n; i++)
      parent.appendChild(arguments[i])

    return parent
  }

  /**
   * Insert a new stylesheet to hold the @keyframe or VML rules.
   */
  var sheet = (function() {
    var el = createEl('style', {type : 'text/css'})
    ins(document.getElementsByTagName('head')[0], el)
    return el.sheet || el.styleSheet
  }())

  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation(alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')
      , start = 0.01 + i/lines * 100
      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
      , pre = prefix && '-' + prefix + '-' || ''

    if (!animations[name]) {
      sheet.insertRule(
        '@' + pre + 'keyframes ' + name + '{' +
        '0%{opacity:' + z + '}' +
        start + '%{opacity:' + alpha + '}' +
        (start+0.01) + '%{opacity:1}' +
        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
        '100%{opacity:' + z + '}' +
        '}', sheet.cssRules.length)

      animations[name] = 1
    }

    return name
  }

  /**
   * Tries various vendor prefixes and returns the first supported property.
   */
  function vendor(el, prop) {
    var s = el.style
      , pp
      , i

    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
    for(i=0; i<prefixes.length; i++) {
      pp = prefixes[i]+prop
      if(s[pp] !== undefined) return pp
    }
    if(s[prop] !== undefined) return prop
  }

  /**
   * Sets multiple style properties at once.
   */
  function css(el, prop) {
    for (var n in prop)
      el.style[vendor(el, n)||n] = prop[n]

    return el
  }

  /**
   * Fills in default values.
   */
  function merge(obj) {
    for (var i=1; i < arguments.length; i++) {
      var def = arguments[i]
      for (var n in def)
        if (obj[n] === undefined) obj[n] = def[n]
    }
    return obj
  }

  /**
   * Returns the absolute page-offset of the given element.
   */
  function pos(el) {
    var o = { x:el.offsetLeft, y:el.offsetTop }
    while((el = el.offsetParent))
      o.x+=el.offsetLeft, o.y+=el.offsetTop

    return o
  }

  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
    return typeof color == 'string' ? color : color[idx % color.length]
  }

  // Built-in defaults

  var defaults = {
    lines: 12,            // The number of lines to draw
    length: 7,            // The length of each line
    width: 5,             // The line thickness
    radius: 10,           // The radius of the inner circle
    rotate: 0,            // Rotation offset
    corners: 1,           // Roundness (0..1)
    color: '#000',        // #rgb or #rrggbb
    direction: 1,         // 1: clockwise, -1: counterclockwise
    speed: 1,             // Rounds per second
    trail: 100,           // Afterglow percentage
    opacity: 1/4,         // Opacity of the lines
    fps: 20,              // Frames per second when using setTimeout()
    zIndex: 2e9,          // Use a high z-index by default
    className: 'spinner', // CSS class to assign to the element
    top: 'auto',          // center vertically
    left: 'auto',         // center horizontally
    position: 'relative'  // element position
  }

  /** The constructor */
  function Spinner(o) {
    if (typeof this == 'undefined') return new Spinner(o)
    this.opts = merge(o || {}, Spinner.defaults, defaults)
  }

  // Global defaults that override the built-ins:
  Spinner.defaults = {}

  merge(Spinner.prototype, {

    /**
     * Adds the spinner to the given target element. If this instance is already
     * spinning, it is automatically removed from its previous target b calling
     * stop() internally.
     */
    spin: function(target) {
      this.stop()

      var self = this
        , o = self.opts
        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})
        , mid = o.radius+o.length+o.width
        , ep // element position
        , tp // target position

      if (target) {
        target.insertBefore(el, target.firstChild||null)
        tp = pos(target)
        ep = pos(el)
        css(el, {
          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',
          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'
        })
      }

      el.setAttribute('role', 'progressbar')
      self.lines(el, self.opts)

      if (!useCssAnimations) {
        // No CSS animation support, use setTimeout() instead
        var i = 0
          , start = (o.lines - 1) * (1 - o.direction) / 2
          , alpha
          , fps = o.fps
          , f = fps/o.speed
          , ostep = (1-o.opacity) / (f*o.trail / 100)
          , astep = f/o.lines

        ;(function anim() {
          i++;
          for (var j = 0; j < o.lines; j++) {
            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)

            self.opacity(el, j * o.direction + start, alpha, o)
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))
        })()
      }
      return self
    },

    /**
     * Stops and removes the Spinner.
     */
    stop: function() {
      var el = this.el
      if (el) {
        clearTimeout(this.timeout)
        if (el.parentNode) el.parentNode.removeChild(el)
        this.el = undefined
      }
      return this
    },

    /**
     * Internal method that draws the individual lines. Will be overwritten
     * in VML fallback mode below.
     */
    lines: function(el, o) {
      var i = 0
        , start = (o.lines - 1) * (1 - o.direction) / 2
        , seg

      function fill(color, shadow) {
        return css(createEl(), {
          position: 'absolute',
          width: (o.length+o.width) + 'px',
          height: o.width + 'px',
          background: color,
          boxShadow: shadow,
          transformOrigin: 'left',
          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',
          borderRadius: (o.corners * o.width>>1) + 'px'
        })
      }

      for (; i < o.lines; i++) {
        seg = css(createEl(), {
          position: 'absolute',
          top: 1+~(o.width/2) + 'px',
          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
          opacity: o.opacity,
          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'
        })

        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))
        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))
      }
      return el
    },

    /**
     * Internal method that adjusts the opacity of a single line.
     * Will be overwritten in VML fallback mode below.
     */
    opacity: function(el, i, val) {
      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
    }

  })


  function initVML() {

    /* Utility function to create a VML tag */
    function vml(tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
    }

    // No CSS transforms but VML support, add a CSS rule for VML elements:
    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')

    Spinner.prototype.lines = function(el, o) {
      var r = o.length+o.width
        , s = 2*r

      function grp() {
        return css(
          vml('group', {
            coordsize: s + ' ' + s,
            coordorigin: -r + ' ' + -r
          }),
          { width: s, height: s }
        )
      }

      var margin = -(o.width+o.length)*2 + 'px'
        , g = css(grp(), {position: 'absolute', top: margin, left: margin})
        , i

      function seg(i, dx, filter) {
        ins(g,
          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),
            ins(css(vml('roundrect', {arcsize: o.corners}), {
                width: r,
                height: o.width,
                left: o.radius,
                top: -o.width>>1,
                filter: filter
              }),
              vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),
              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
            )
          )
        )
      }

      if (o.shadow)
        for (i = 1; i <= o.lines; i++)
          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')

      for (i = 1; i <= o.lines; i++) seg(i)
      return ins(el, g)
    }

    Spinner.prototype.opacity = function(el, i, val, o) {
      var c = el.firstChild
      o = o.shadow && o.lines || 0
      if (c && i+o < c.childNodes.length) {
        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild
        if (c) c.opacity = val
      }
    }
  }

  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})

  if (!vendor(probe, 'transform') && probe.adj) initVML()
  else useCssAnimations = vendor(probe, 'animation')

  return Spinner

}));

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  var ADMIN_PERMISSION;
  var _CONDITIONS_MAP = {
    contains: function (instance, args) {
      var value = Permission._resolve_permission_variable(args.value);
      var list_value = instance[args.list_property];
      var i;
      for (i = 0; i < list_value.length; i++) {
        if (list_value[i].id == value.id) {
          return true;
        }
      }
      return false;
    },
    is: function (instance, args) {
      var value = Permission._resolve_permission_variable(args.value);
      var property_value = instance[args.property_name];
      if (property_value instanceof can.Stub) {
        property_value = property_value.reify();
      }
      return value == property_value;
    },
    'in': function (instance, args) {
      var value = Permission._resolve_permission_variable(args.value);
      var property_value = instance[args.property_name];
      if (property_value instanceof can.Stub) {
        property_value = property_value.reify();
      }
      return value.indexOf(property_value) >= 0;
    },
    forbid: function (instance, args, action) {
      var blacklist = args.blacklist[action] || [];
      return blacklist.indexOf(instance.type) < 0;
    }
  };
  var permissions_compute = can.compute(GGRC.permissions);

  can.Construct('Permission', {

    _admin_permission_for_context: function (context_id) {
      return new Permission(
      ADMIN_PERMISSION.action, ADMIN_PERMISSION.resource_type, context_id);
    },

    _all_resource_permission: function (permission) {
      return new Permission(
      permission.action, ADMIN_PERMISSION.resource_type, permission.context_id);
    },

    _permission_match: function (permissions, permission) {
      var resource_types = permissions[permission.action] || {};
      var resource_type = resource_types[permission.resource_type] || {};
      var contexts = resource_type.contexts || [];

      return (contexts.indexOf(permission.context_id) > -1);
    },

    _is_allowed: function (permissions, permission) {
      if (!permissions) {
        return false; // ?
      }
      if (this._permission_match(
            permissions,
            new Permission(
              permission.action,
              permission.resource_type, null))) {
        return true;
      }
      if (this._permission_match(permissions, permission)) {
        return true;
      }
      if (this._permission_match(permissions,
          this._all_resource_permission(permission))) {
        return true;
      }
      if (this._permission_match(permissions, ADMIN_PERMISSION)) {
        return true;
      }
      if (this._permission_match(permissions,
          this._admin_permission_for_context(permission.context_id))) {
        return true;
      }
      // Check for System Admin permission
      if (this._permission_match(permissions,
          this._admin_permission_for_context(0))) {
        return true;
      }
      return false;
    },

    _resolve_permission_variable: function (value) {
      if ($.type(value) == 'string') {
        if (value[0] == '$') {
          if (value == '$current_user') {
            return CMS.Models.get_instance('Person', GGRC.current_user.id);
          }
          throw new Error('unknown permission variable: ' + value);
        }
      }
      return value;
    },

    _is_allowed_for: function (permissions, instance, action) {
      // Check for admin permission
      var checkAdmin = function (contextId) {
        var permission = this._admin_permission_for_context(contextId);
        var conditions;
        var i;
        var condition;
        if (this._permission_match(permissions, permission)) {
          conditions = _.toArray(_.exists(permissions,
            permission.action,
            permission.resource_type,
            'conditions',
            contextId));
          if (!conditions.length) {
            return true;
          }
          for (i = 0; i < conditions.length; i++) {
            condition = conditions[i];
            if (_CONDITIONS_MAP[condition.condition](
                instance, condition.terms, action)) {
              return true;
            }
          }
          return false;
        }
        return false;
      }.bind(this);

      var action_obj = permissions[action] || {};
      var instance_type = instance.constructor ?
                          instance.constructor.shortName :
                          instance.type;
      var type_obj = action_obj[instance_type] || {};
      var conditions_by_context = type_obj.conditions || {};
      var resources = type_obj.resources || [];
      var context = instance.context || {id: null};
      var conditions = conditions_by_context[context.id] || [];
      var condition;
      var i;

      if (checkAdmin(0) || checkAdmin(null)) {
        return true;
      }
      if (~resources.indexOf(instance.id)) {
        return true;
      }
      if (!this._is_allowed(permissions,
          new Permission(action, instance_type, null)) &&
        !this._is_allowed(permissions,
          new Permission(action, instance_type, context.id))) {
        return false;
      }
      // Check any conditions applied per instance
      // If there are no conditions, the user has unconditional access to
      // the current instance. We can safely return true in this case.
      if (conditions.length === 0) {
        return true;
      }
      for (i = 0; i < conditions.length; i++) {
        condition = conditions[i];
        if (_CONDITIONS_MAP[condition.condition](
            instance, condition.terms, action)) {
          return true;
        }
      }
      return false;
    },

    is_allowed: function (action, resource_type, context_id) {
      return this._is_allowed(
        permissions_compute(), new this(action, resource_type, context_id));
    },

    is_allowed_for: function (action, resource) {
      return this._is_allowed_for(permissions_compute(), resource, action);
    },

    is_allowed_any: function (action, resource_type) {
      var allowed = this.is_allowed(action, resource_type);
      var perms = permissions_compute();

      if (!allowed) {
        allowed = _.exists(perms, action, resource_type, 'contexts', 'length');
      }
      return !!allowed;
    },

    page_context_id: function () {
      var page_instance = GGRC.page_instance();
      return (page_instance && page_instance.context &&
              page_instance.context.id) || null;
    },

    refresh: function () {
      return $.ajax({
        url: '/permissions',
        type: 'get',
        dataType: 'json'
      }).then(function (perm) {
        permissions_compute(perm);
        GGRC.permissions = perm;
      });
    }
  }, {
    // prototype
    setup: function (action, resource_type, context_id) {
      this.action = action;
      this.resource_type = resource_type;
      this.context_id = context_id;
      return this;
    }
  });

  ADMIN_PERMISSION = new Permission('__GGRC_ADMIN__', '__GGRC_ALL__', 0);
})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

!function($) {
  "use strict"; // jshint ;_;

  // Insert http:// before links
  var createLink = wysihtml5.commands.createLink
    , old_exec = createLink.exec;
  createLink.exec = function(composer, command, value) {
    var url = typeof(value) === "object" ? value.href : value;

    // Inject the http:// if no prefix was included
    url = url.indexOf('//') > -1 ? url : 'http://' + url;

    // If there are multiple prefixes, remove the first http://
    // This can occur if the user pastes a URL without deleting the default "http://"
    if (url.match(/^http:\/\/.+?\/\//))
      url = url.replace(/^http:\/\//, '');

    if (typeof(value) === "object")
      value.href = url;
    else
      value = url;
    return old_exec.call(this, composer, command, value);
  }

  // Patch iframe issues
  // Sometimes the plugin will throw a "cannot read property document of null" error
  if (window.rangy) {
    rangy.addInitListener(function() {
      rangy.dom.getIframeDocument = function(iframeEl, no_recurse) {
        if (typeof iframeEl.contentDocument) {
          return iframeEl.contentDocument;
        } else if (typeof iframeEl.contentWindow) {
          return iframeEl.contentWindow.document;
        } else if (!no_recurse) {
          // Add the iframe to the DOM
          rangy.dom.getBody(document).appendChild(iframeEl);
          return rangy.dom.getIframeDocument(iframeEl, true);
        } else {
          throw new Error("getIframeWindow: No Document object found for iframe element");
        }
      };

      rangy.dom.getIframeWindow = function(iframeEl, no_recurse) {
        if (typeof iframeEl.contentWindow) {
          return iframeEl.contentWindow;
        } else if (typeof iframeEl.contentDocument) {
          return iframeEl.contentDocument.defaultView;
        } else if (!no_recurse) {
          // Add the iframe to the DOM
          rangy.dom.getBody(document).appendChild(iframeEl);
          return rangy.dom.getIframeWindow(iframeEl, true);
        } else {
          throw new Error("getIframeWindow: No Window object found for iframe element");
        }
      };
    });
  }

  // We took the implementation from https://github.com/Voog/wysihtml
  // We trigger events in fake textarea
  var originalObserve = wysihtml5.views.Composer.prototype.observe,
    dom = wysihtml5.dom,
    browser = wysihtml5.browser,
    handleUserInteraction = function (event) {
      this.parent.fire("beforeinteraction").fire("beforeinteraction:composer");
      setTimeout((function() {
        this.parent.fire("interaction").fire("interaction:composer");
      }).bind(this), 0);
    },
    addListeners = function (target, events, callback) {
      for (var i = 0, max = events.length; i < max; i++) {
        target.addEventListener(events[i], callback, false);
      }
    };
  wysihtml5.views.Composer.prototype.observe = function () {
    var element = this.element,
        focusBlurElement = browser.supportsEventsInIframeCorrectly() ? element : this.sandbox.getWindow();

    addListeners(focusBlurElement, ["focus", "keyup"], handleUserInteraction.bind(this));
    return originalObserve.apply(this, arguments);
  };

}(window.jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

!function ($) {

  "use strict"; // jshint ;_;


 /* STICKY_POPOVER PUBLIC CLASS DEFINITION
* =============================== */

  var StickyPopover = function ( element, options ) {
    this.init('sticky_popover', element, options)
  }


  /* NOTE: STICKY_POPOVER EXTENDS BOOTSTRAP-POPOVER.js and BOOTSTRAP-TOOLTIP.js
========================================== */

  StickyPopover.prototype = $.extend({}, $.fn.popover.Constructor.prototype, {

    constructor: StickyPopover

  , init: function(type, element, options) {
      if (options.trigger == 'sticky-hover') {
        options.sticky_hover = true;
        options.trigger = 'hover';
      } else if (options.trigger == 'click') {
        options.trigger_click = true;
        options.trigger = 'manual';
      }
      $.fn.popover.Constructor.prototype.init.apply(this, arguments);

      // `displayState` is used to avoid duplicate calls to `show`
      //   (otherwise it flickers if `animation` is true
      this.displayState = this.displayState || 'hide';

      if (this.options.show)
        this.show();
      if (this.options.trigger_click) {
        this.$element.on('click', $.proxy(this.click_toggle, this));
      }
    }
  , click_toggle: function(e) {
      e && e.preventDefault();
      this.toggle();
    }
  , show: function(force) {
      // Overload `show` to listen for mouseovers on the popover div
      if (force || this.displayState !== 'show') {
        if (this.displayState !== 'show') {
          this.$element.trigger($.Event('show'));
        } else { 
          //fix the opacity value as it currently stands to prevent show-hide-show after loading.
          this.tip().css({opacity : window.getComputedStyle(this.tip()[0]).opacity});
        }

        if (this.$element.children('.popover-data-title').length > 0) {
          this.$element.attr(
              'data-original-title',
              this.$element.children('.popover-data-title').html());
        }

        if (this.$element.children('.popover-data-content').length > 0) {
          this.$element.attr(
              'data-content',
              this.$element.children('.popover-data-content').html());
        }

        this.displayState = 'show';
        this.trigger_load();
        $.fn.popover.Constructor.prototype.show.apply(this);
        this.tip().css({opacity : ""});
        if (this.options.sticky_hover) {
          this.tip().
            on('mouseenter', $.proxy(this.tip_enter, this)).
            on('mouseleave', $.proxy(this.tip_leave, this));
        }
      }
    }
  , hide: function() {
      if (this.displayState === 'show') {
        this.displayState = 'hide';
        $.fn.popover.Constructor.prototype.hide.apply(this);
      }
    }
  , trigger_load: function() {
      var self = this,
          href = this.$element.data('popover-href'),
          loaded = this.$element.data('popover-loaded');

      if (!href) return;

      if (!loaded) {
        $.ajax({
          url : href
          , type : "get"
          , dataType : "html"
          , success : function(data) {
            var $data = $(data.trim());
            self.$element.attr('data-original-title', $data.filter('.popover-title').html());
            self.$element.attr('data-content', $data.filter('.popover-content').html());
            self.$element.data('popover-loaded', true);
            if (self.displayState === 'show')
              self.show(true);
          }
        });
      }
    }
  , tip_enter: function(e) {
      // Handle `mouseenter` on the popover element
      // Must set 'e.currentTarget' or it looks for `data.sticky_popover`
      //   in the wrong place
      e.currentTarget = this.$element[0];
      $.fn.popover.Constructor.prototype.enter.apply(this, arguments);
    }
  , tip_leave: function(e) {
      // Handle `mouseenter` on the popover element
      // Must set 'e.currentTarget' or it looks for `data.sticky_popover`
      //   in the wrong place
      e.currentTarget = this.$element[0];
      $.fn.popover.Constructor.prototype.leave.apply(this, arguments);
    }
  })


 /* STICKY_POPOVER PLUGIN DEFINITION
* ======================= */

  $.fn.sticky_popover = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('sticky_popover')
        , options = typeof option == 'object' && option
      if (!data) {
        $this.data('sticky_popover', (data = new StickyPopover(this, options)));
        // Make instantiated popovers findable by $('[data-sticky_popover]');
        $this.attr('data-sticky_popover', true);
      }
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.sticky_popover.Constructor = StickyPopover

  $.fn.sticky_popover.defaults = $.extend({}, $.fn.popover.defaults, {
  })

}(window.jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function ($, Permission) {
  'use strict';

  function preload_content() {
    var template =
      ['<div class="modal-header">'
      , '  <a class="pull-right modal-dismiss" href="#" data-dismiss="modal">'
      , '    <i class="fa fa-times black"></i>'
      , '  </a>'
      , '  <h2>Loading...</h2>'
      , '</div>'
      , '<div class="modal-body" style="padding-top:150px;"></div>'
      , '<div class="modal-footer">'
      , '</div>'
      ];
    return $(template.join('\n'))
      .filter('.modal-body')
        .html(
          $(new Spinner().spin().el)
            .css({
              width: '100px', height: '100px',
              left: '50%', top: '50%',
              zIndex: calculate_spinner_z_index
            })
        ).end();
  }

  function emit_loaded(responseText, textStatus, xhr) {
    if (xhr.status == 403) {
      // For now, only inject the response HTML in the case
      // of an authorization error
      $(this).html(responseText);
    }
    $(this).trigger('loaded');
  }

  function refresh_page() {
    setTimeout(can.proxy(GGRC.navigate, GGRC), 10);
  }

  var handlers = {
    'modal': function ($target, $trigger, option) {
      $target.modal(option).draggable({handle: '.modal-header'});
    },

    'listform': function ($target, $trigger, option) {
      var list_target = $trigger.data('list-target');
      $target.modal_relationship_selector(option, $trigger);

      // Close the modal and rewrite the target list
      $target.on('ajax:json', function (e, data, xhr) {
        if (data.errors) {
        } else if (list_target == 'refresh') {
          refresh_page();
        } else if (list_target) {
          $(list_target).tmpl_setitems(data);
          $target.modal_relationship_selector('hide');
        }
      });
    },

    'listnewform': function ($target, $trigger, option) {
      $target.modal_form(option, $trigger);
      var list_target = $trigger.data('list-target')
        , selector_target = $trigger.data('selector-target')
        ;

      // Close the modal and append to the target list
      $target.on('ajax:json', function (e, data, xhr) {
        if (data.errors) {
        } else {
          if (list_target) {
            $(list_target).tmpl_additem(data);
          }
          if (selector_target) {
            $(selector_target).trigger('list-add-item', data);
          }
          // $(tablist_target).trigger('list-add-item', data);
          $target.modal_form('hide');
        }
      });
    },

    'listeditform': function ($target, $trigger, option) {
      $target.modal_form(option, $trigger);
      var list_target = $trigger.data('list-target')
        , selector_target = $trigger.data('selector-target')
        ;

      // Close the modal and append to the target list
      $target.on('ajax:json', function (e, data, xhr) {
        if (data.errors) {
        } else {
          if (list_target) {
            $(list_target).tmpl_mergeitems([data]);
          }
          if (selector_target) {
            $(selector_target).trigger('list-update-item', data);
          }
          $target.modal_form('hide');
          $trigger.trigger('modal:success', data);
        }
      });
    },

    'deleteform': function ($target, $trigger, option) {
      var form_target = $trigger.data('form-target')
        , model = CMS.Models[$trigger.attr('data-object-singular')]
        , instance
        , delete_counts = new can.Observe({loading: true, counts: ''})
        ;

      if ($trigger.attr('data-object-id') === 'page') {
        instance = GGRC.page_instance();
      } else {
        instance = model.findInCacheById($trigger.attr('data-object-id'));
      }

      instance.get_orphaned_count().done(function (counts) {
        delete_counts.attr('loading', false);
        delete_counts.attr('counts', counts);
      }).fail(function () {
        delete_counts.attr('loading', false);
      });

      $target
      .modal_form(option, $trigger)
      .ggrc_controllers_delete({
        $trigger: $trigger
        , skip_refresh: !$trigger.data('refresh')
        , new_object_form: false
        , button_view: GGRC.mustache_path + '/modals/delete_cancel_buttons.mustache'
        , model: model
        , instance: instance
        , delete_counts: delete_counts
        , modal_title: 'Delete ' + $trigger.attr('data-object-singular')
        , content_view: GGRC.mustache_path + '/base_objects/confirm_delete.mustache'
      });

      $target.on('modal:success', function (e, data) {
        var model_name = $trigger.attr('data-object-plural').toLowerCase();
        if ($trigger.attr('data-object-id') === 'page' || (instance === GGRC.page_instance())) {
          GGRC.navigate('/dashboard');
        } else if (model_name == 'people' || model_name == 'roles') {
          window.location.assign('/admin#' + model_name + '_list_widget');
          GGRC.navigate();
        } else {
          $trigger.trigger('modal:success', data);
          $target.modal_form('hide');
        }
      });
    },

    'unmapform': function ($target, $trigger, option) {
      var form_target = $trigger.data('form-target')
      , object_params = $trigger.attr('data-object-params')
      , model = CMS.Models[$trigger.attr('data-object-singular')]
      , instance;
      if ($trigger.attr('data-object-id') === 'page') {
        instance = GGRC.page_instance();
      } else {
        instance = model.findInCacheById($trigger.attr('data-object-id'));
      }
      if (object_params) {
        object_params = JSON.parse(object_params.replace(/\\n/g, '\n'));
      } else {
        object_params = {};
      }

      $target
      .modal_form(option, $trigger)
      .ggrc_controllers_unmap({
        $trigger: $trigger
        , new_object_form: false
        , button_view: GGRC.mustache_path + '/modals/unmap_cancel_buttons.mustache'
        , model: model
        , instance: instance
        , object_params: object_params
        , modal_title: $trigger.attr('data-modal-title') || ('Delete ' + $trigger.attr('data-object-singular'))
        , content_view: $trigger.attr('data-content-view') || (GGRC.mustache_path + '/base_objects/confirm_unmap.mustache')
      });

      $target.on('modal:success', function (e, data) {
        $trigger.children('.result').each(function (i, result_el) {
          var $result_el = $(result_el)
            , result = $result_el.data('result')
            , mappings = result && result.get_mappings()
            , i
            ;

          can.each(mappings, function (mapping) {
            mapping.refresh().done(function () {
              if (mapping instanceof CMS.Models.Control) {
                mapping.removeAttr('directive');
                mapping.save();
              }
              else {
                mapping.destroy();
              }
            });
          });
        });
      });
    },

    'form': function ($target, $trigger, option) {
      var form_target = $trigger.data('form-target')
      , object_params = $trigger.attr('data-object-params')
      , triggerParent = $trigger.closest('.add-button')
      , model = CMS.Models[$trigger.attr('data-object-singular')] || CMS.ModelHelpers[$trigger.attr('data-object-singular')]
      , mapping = $trigger.data('mapping')
      , instance;

      if ($trigger.attr('data-object-id') === 'page') {
        instance = GGRC.page_instance();
      } else {
        instance = model.findInCacheById($trigger.attr('data-object-id'));
      }
      if (object_params) {
        object_params = JSON.parse(object_params.replace(/\\n/g, '\n'));
      } else {
        object_params = {};
      }

      var modal_title = (instance ? 'Edit ' : 'New ') + ($trigger.attr('data-object-singular-override') || model.title_singular || $trigger.attr('data-object-singular'));
      // If this was initiated via quick join link
      if (object_params.section) {
        modal_title = 'Map ' + modal_title + ' to ' + object_params.section.title;
      }
      var title_override = $trigger.attr('data-modal-title-override');
      if (title_override) {
        modal_title = title_override;
      }

      var content_view = $trigger.data('template') || GGRC.mustache_path + '/' + $trigger.attr('data-object-plural') + '/modal_content.mustache';

      $target
      .modal_form(option, $trigger)
      .ggrc_controllers_modals({
        new_object_form: !$trigger.attr('data-object-id'),
        object_params: object_params,
        button_view: GGRC.Controllers.Modals.BUTTON_VIEW_SAVE_CANCEL_DELETE,
        model: model,
        current_user: GGRC.current_user,
        instance: instance,
        modal_title: object_params.modal_title || modal_title,
        content_view: content_view,
        mapping: mapping,
        $trigger: $trigger,
      });

      $target.on('modal:success', function (e, data, xhr) {
        var WARN_MSG = [
          'The $trigger element was not found in the DOM, thus some',
          'application events will not be propagated.'
        ].join(' ');
        var args = arguments;

        if (form_target == 'refresh') {
          refresh_page();
        } else if (form_target == 'redirect') {
          if (typeof xhr !== 'undefined' && 'getResponseHeader' in xhr) {
            GGRC.navigate(xhr.getResponseHeader('location'));
          } else if (data._redirect) {
            GGRC.navigate(data._redirect);
          } else {
            GGRC.navigate(data.selfLink.replace('/api', ''));
          }
        } else if (form_target == 'refresh_page_instance') {
          GGRC.page_instance().refresh();
        } else {
          var dirty;
          $target.modal_form('hide');
          if ($trigger.data('dirty')) {
            dirty = $($trigger.data('dirty').split(',')).map(function (i, val) {
              return '[href="' + val.trim() + '"]';
            }).get().join(',');
            $(dirty).data('tab-loaded', false);
          }
          if (dirty) {
            var $active = $(dirty).filter('.active [href]');
            $active.closest('.active').removeClass('active');
            $active.click();
          }

          // For some reason it can happen that the original $trigger element
          // is removed from the DOM and replaced with another identical
          // element. We thus need to trigger the event on that new element
          // (present in the DOM) if we want event handlers to be invoked.
          if (!document.contains($trigger[0])) {
            $trigger = $('[data-link-purpose="open-edit-modal"]');
            if (_.isEmpty($trigger)) {
              console.warn(WARN_MSG);
              return;
            }
          }

          $trigger.trigger('routeparam', $trigger.data('route'));

          if (triggerParent && triggerParent.length) {
            $trigger = triggerParent;
          }

          Permission.refresh().then(function () {
            $trigger.trigger(
              'modal:success', Array.prototype.slice.call(args, 1)
            );
          });
        }
      });
    },

    'helpform': function ($target, $trigger, option) {
      $target.modal_form(option, $trigger).ggrc_controllers_help({slug: $trigger.attr('data-help-slug')});
    }

  };


  var arrangeBackgroundModals = function (modals, referenceModal) {
    modals = $(modals).not(referenceModal);
    if (modals.length < 1) return;

    var $header = referenceModal.find('.modal-header');
    var header_height = $header.height() + parseInt($header.css('padding-top')) + parseInt($header.css('padding-bottom'));
    var _top = parseInt($(referenceModal).offset().top);

    modals.css({
      'overflow': 'hidden'
      , 'height': function () {
        return header_height;
      }
      , 'top': function (i) {
        return _top - (modals.length - i) * (header_height);
      }
      , 'margin-top': 0
      , 'position': 'absolute'
    });
    modals.off('scroll.modalajax');
    modals.on('scroll.modalajax', function () {
      $(this).scrollTop(0); // fix for Chrome rendering bug when resizing block elements containing CSS sprites.
    });
  };

  var arrangeTopModal = function (modals, modal) {
    if (!modal || !modal.length)
      return;

    var $header = modal.find('.modal-header:first');
    var header_height = $header.height() + parseInt($header.css('padding-top')) + parseInt($header.css('padding-bottom'));

    var offsetParent = modal.offsetParent();
    var _scrollY = 0;
    var _top = 0;
    var _left = modal.position().left;
    if (!offsetParent.length || offsetParent.is('html, body')) {
      offsetParent = $(window);
      _scrollY = window.scrollY;
      _top = _scrollY
        + (offsetParent.height()
          - modal.height()) / 5
        + header_height / 5;

      window.scrollY + ($(window).height() - modal.height()) / 2 + (modals.length - 1) * parseInt(modal.find('.modal-header').height());
    } else {
      _top = offsetParent.closest('.modal').offset().top - offsetParent.offset().top + header_height;
      _left = offsetParent.closest('.modal').offset().left + offsetParent.closest('.modal').width() / 2 - offsetParent.offset().left;
    }
    if (_top < 0) {
      _top = 0;
    }
    modal
    .css('top', _top + 'px')
    .css({'position': 'absolute', 'margin-top': 0, 'left': _left});
  };

  var _modal_show = $.fn.modal.Constructor.prototype.show;
  $.fn.modal.Constructor.prototype.show = function () {
    var that = this;
    var $el = this.$element;
    var shownevents, keyevents;
    if (!(shownevents = $._data($el[0], 'events').shown)
        || $(shownevents).filter(function () {
          return $.inArray('arrange', this.namespace.split('.')) > -1;
        }).length < 1) {
      $el.on('shown.arrange, loaded.arrange', function (ev) {
        if (ev.target === ev.currentTarget)
          reconfigureModals.call(that);
      });
    }

    if ($el.is('body > * *')) {
      this.$cloneEl = $('<div>').appendTo($el.parent());
      can.each($el[0].attributes, function (attr) {
        that.$cloneEl.attr(attr.name, attr.value);
      });
      $el.find('*').uniqueId();
      this.$cloneEl.html($el.html());
      $el.detach().appendTo(document.body);
      this.$cloneEl.removeAttr('id').find('*').attr('data-original-id', function () {
        return this.id;
      }).removeAttr('id');

      $el.on(['click', 'mouseup', 'keypress', 'keydown', 'keyup', 'show', 'shown', 'hide', 'hidden'].join('.clone ') + '.clone', function (e) {
        that.$cloneEl
        ? that.$cloneEl.find("[data-original-id='" + e.target.id + "']").trigger(new $.Event(e))
        : $el.off('.clone');
      });
    }


    // prevent form submissions when descendant elements are also modals.
    if (!(keyevents = $._data($el[0], 'events').keypress)
        || $(keyevents).filter(function () {
          return $.inArray('preventdoublesubmit', this.namespace.split('.')) > -1;
        }).length < 1) {
      $el.on('keypress.preventdoublesubmit', function (ev) {
        if (ev.which === 13 && !$(document.activeElement).hasClass('wysihtml5')) {
          ev.preventDefault();
          if (ev.originalEvent) {
            ev.originalEvent.preventDefault();
          }
          return false;
        }
      });
    }
    if (!(keyevents = $._data($el[0], 'events').keyup)
        || $(keyevents).filter(function () {
          return $.inArray('preventdoubleescape', this.namespace.split('.')) > -1;
        }).length < 1) {
      $el.on('keyup.preventdoubleescape', function (ev) {
        if (ev.which === 27 && $(ev.target).closest('.modal').length) {
          $(ev.target).closest('.modal').attr('tabindex', -1).focus();
          ev.stopPropagation();
          ev.originalEvent && ev.originalEvent.stopPropagation();
          that.hide();
        }
      });
      $el.attr('tabindex') || $el.attr('tabindex', -1);
      setTimeout(function () { $el.focus(); }, 1);
    }

    _modal_show.apply(this, arguments);
    // reconfigureModals.call(this);   //handled by modal shown event firing.
  };

  var reconfigureModals = function () {
    var modalBackdrops = $('.modal-backdrop').css('z-index', function (i) {
      return 2990 + i * 20;
    });

    var modals = $('.modal:visible');
    modals.each(function (i) {
      var parent = this.parentNode;
      if (parent !== document.body) {
        modalBackdrops
        .eq(i)
        .detach()
        .appendTo(parent);
      }
    });
    modalBackdrops.slice(modals.length).remove();

    modals.not(this.$element).css('z-index', function (i) {
      return 3000 + i * 20;
    });
    this.$element.css('z-index', 3000 + (modals.length - 1) * 20);

    arrangeTopModal(modals, this.$element);
    arrangeBackgroundModals(modals, this.$element);
  };

  var _modal_hide = $.fn.modal.Constructor.prototype.hide;
  $.fn.modal.Constructor.prototype.hide = function (ev) {
    if (ev && (ev.modalHidden))
      return;  // We already hid one

    if (this.$cloneEl) {
      this.$element.detach().appendTo(this.$cloneEl.parent());
      this.$cloneEl.remove();
      this.$cloneEl = null;
      this.$element.off('.clone');
    }

    _modal_hide.apply(this, arguments);

    var animated =
        $('.modal').filter(':animated');
    if (animated.length) {
      animated.stop(true, true);
    }

    var modals = $('.modal:visible');
    var lastModal = modals.last();
    lastModal.css({'height': '', 'overflow': '', top: '', 'margin-top': ''});
    arrangeTopModal(modals, lastModal);
    arrangeBackgroundModals(modals, lastModal);
    if (ev) ev.modal_hidden = true; // mark that we've hidden one
  };

  GGRC.register_modal_hook = function (toggle, launch_fn) {
    $(function () {
      $('body').on(
        'click.modal-ajax.data-api keydown.modal-ajax.data-api',
        toggle ? '[data-toggle=modal-ajax-' + toggle + ']' : '[data-toggle=modal-ajax]',
        function (e) {
          var $this = $(this);
          var loadHref;
          var modalId;
          var target;
          var $target;
          var option;
          var href;
          var newTarget;

          if ($this.hasClass('disabled')) {
            return;
          }
          if (e.type === 'keydown' && e.which !== 13) {
            return;  // activate for keydown on Enter/Return only.
          }

          href = $this.attr('data-href') || $this.attr('href');
          loadHref = !$this.data().noHrefLoad;

          modalId = 'ajax-modal-' +
                     href.replace(/[\/\?=\&#%]/g, '-').replace(/^-/, '');
          target = $this.attr('data-target') || $('#' + modalId);

          $target = $(target);
          newTarget = $target.length === 0;

          if (newTarget) {
            $target = $('<div id="' + modalId + '" class="modal hide"></div>');
            $target.addClass($this.attr('data-modal-class'));
            $this.attr('data-target', '#' + modalId);
          }

          $target.on('hidden', function (ev) {
            if (ev.target === ev.currentTarget) {
              $target.remove();
            }
          });

          if (newTarget || $this.data('modal-reset') === 'reset') {
            $target.html(preload_content());
            if (
              $this.prop('protocol') === window.location.protocol &&
              loadHref
            ) {
              $target.load(href, emit_loaded);
            }
          }

          option = $target.data('modal-help') ?
                   'toggle' : $.extend({}, $target.data(), $this.data());

          launch_fn.apply($target, [$target, $this, option]);
        });
    });
  };
  $(function () {
    can.each({
      '': handlers['modal'],
      'form': handlers['form'],
      'helpform': handlers['helpform'],
      'listform': handlers['listform'],
      'listnewform': handlers['listnewform'],
      'listeditform': handlers['listeditform'],
      'deleteform': handlers['deleteform'],
      'unmapform': handlers['unmapform']
    },
      function (launch_fn, toggle) {
        GGRC.register_modal_hook(toggle, launch_fn);
      }
    );
  });
})(window.jQuery, window.Permission);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function ($) {
  'use strict';

  /* MODAL_FORM PUBLIC CLASS DEFINITION
   * =============================== */

  var ModalForm = function (element, options, trigger) {
    this.options = options;
    this.$element = $(element);
    this.$trigger = $(trigger);

    this.init();
  };

  /* NOTE: MODAL_FORM EXTENDS BOOTSTRAP-MODAL.js
   * ========================================== */

  ModalForm.prototype = new $.fn.modal.Constructor(null, {remote: false});

  $.extend(ModalForm.prototype, {

    init: function () {
      this.$element
        .on('preload', function () {
          this.is_form_dirty(true);
          this.control = this.$element.control();
          if (this.control.options && this.control.options.instance) {
            this.instance = this.control.options.instance;
            this.instance.backup();
          }
        }.bind(this))
        .on('keypress', 'form', $.proxy(this.keypress_submit, this))
        .on('keyup', 'form', $.proxy(this.keyup_escape, this))
        .on('click.modal-form.close', '[data-dismiss="modal"]', $.proxy(this.hide, this))
        .on('click.modal-form.reset', 'input[type=reset], [data-dismiss="modal-reset"]', $.proxy(this.reset, this))
        .on('click.modal-form.submit', 'input[type=submit], [data-toggle="modal-submit"]', $.proxy(this.submit, this))
        .on('shown.modal-form', $.proxy(this.focus_first_input, this))
        .on('loaded.modal-form', $.proxy(this.focus_first_input, this))
        .on('loaded.modal-form', function (ev) {
          $('a[data-wysihtml5-command], a[data-wysihtml5-action]', ev.target).attr('tabindex', '-1');
          $(this).trigger('shown'); // this will reposition the modal stack
        })
        .on('delete-object', $.proxy(this.delete_object, this))
        .draggable({handle: '.modal-header'});
    },

    doNothing: function (e) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
    },
    delete_object: function (e, data, xhr) {
        // If this modal is contained within another modal, pass the event onward
      var $trigger_modal = this.$trigger.closest('.modal');
      var delete_target;

      if ($trigger_modal.length > 0) {
        $trigger_modal.trigger('delete-object', [data, xhr]);
      } else {
        delete_target = this.$trigger.data('delete-target');
        if (delete_target === 'refresh') {
            // Refresh the page
          GGRC.navigate(window.location.href.replace(/#.*/, ''));
        } else if (xhr && xhr.getResponseHeader('location')) {
            // Otherwise redirect if possible
          GGRC.navigate(xhr.getResponseHeader('location'));
        } else {
            // Otherwise refresh the page
          GGRC.navigate(window.location.href.replace(/#.*/, ''));
        }
      }
    },
    $form: function () {
      return this.$element.find('form').first();
    },

    is_form_dirty: function (cache_values) {
      var that = this;
      var cache = {};
      var dirty = false;

      // Generate a hash of the form values
      can.each(this.$form().serializeArray(), function (field) {
        var val;
        if (cache[field.name]) {
          val = cache[field.name] + ',' + field.value;
        } else {
          val = field.value;
        }
        cache[field.name] = val;
      });

      if (cache_values || !this._cached_values) {
        // Cache the initial form values as requested
        this._cached_values = cache;
      } else {
        // Otherwise compute a diff to determine whether the form is dirty
        can.each(cache, function (value, key) {
          if (!dirty) {
            dirty = (value !== that._cached_values[key] &&
              (!!value || that._cached_values[key] !== undefined));
          }
        });
      }

      return dirty;
    },

    submit: function (e) {
      var $form = this.$form();
      var that = this;

      if (!$form.data('submitpending')) {
        $('[data-toggle=modal-submit]', $form)
            .each(function () {
              $(this).data('origText', $(this).text());
            })
            .addClass('disabled pending-ajax')
            .attr('disabled', true);

        $form.data('submitpending', true)
          .one('ajax:beforeSend', function (ev, _xhr) {
            that.xhr = _xhr;
          })
          .submit();
      }
      if (e.type === 'click') {
        e.preventDefault();
      }
    },

    keypress_submit: function (e) {
      if (e.which === 13 && !$(e.target).is('textarea')) {
        if (!e.isDefaultPrevented()) {
          e.preventDefault();
          this.$form().submit();
        }
      }
    },

    keyup_escape: function (e) {
      if ($(document.activeElement).is('select, [data-toggle=datepicker]') && e.which === 27) {
        this.$element.attr('tabindex', -1).focus();
        e.stopPropagation();
      }
    },

    reset: function (e) {
      var form = this.$form()[0];
      if (form) {
        form.reset();
      }
      this.hide(e);
    },

    hide: function (e) {
      var instance = this.instance;
      var pending;
      var hasPending;
      var changedInstance;

      if (e) {
        e.preventDefault();
      }

      // If the hide was initiated by the backdrop, check for dirty form data before continuing
      if (e && $(e.target).is('.modal-backdrop,.fa-times')) {
        if ($(e.target).is('.disabled')) {
            // In the case of a disabled modal backdrop, treat it like any other disabled data-dismiss,
            //  i.e. do nothing.
          e.stopPropagation();
          return;
        }
        if (instance) {
          changedInstance = instance.isDirty(true);
          hasPending = GGRC.Utils.hasPending(instance);
        }
        if (this.is_form_dirty() || changedInstance || hasPending) {
            // Confirm that the user wants to lose the data prior to hiding
          GGRC.Controllers.Modals.confirm({
            modal_title: 'Discard Changes',
            modal_description: 'Are you sure that you want to discard your changes?',
            modal_confirm: 'Discard',
            skip_refresh: true
          }, function () {
            can.trigger(instance, 'modal:dismiss');
            this.$element
              .find("[data-dismiss='modal'], [data-dismiss='modal-reset']")
              .trigger('click');
            this.hide();
          }.bind(this));
          return;
        }
      }

      // Hide the modal like normal
      if (instance) {
        pending = instance.attr('_pending_joins');
        if (pending && pending.length) {
          instance.attr('_pending_joins', []);
        }
        can.trigger(instance, 'modal:dismiss');
      }
      $.fn.modal.Constructor.prototype.hide.apply(this, [e]);
      this.$element.off('modal_form');
    },

    focus_first_input: function (ev) {
      var that = this;
      setTimeout(function () {
        var $first_input;
        $first_input = that.$element.find('*[autofocus]');
        if (!$first_input.length) {
          $first_input = that.$element
              .find('input[type="text"], input[type="checkbox"], select, textarea')
              .not('[placeholder*=autofill], label:contains(autofill) + *, [disabled]')
              .first();
        }
        if ($first_input.length && (!ev || that.$element.is(ev.target))) {
          $first_input.get(0).focus();
        }
      }, 100);
    }
  });

  $.fn.modal_form = function (option, trigger, params) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('modal_form');
      var options = $.extend({}, $.fn.modal_form.defaults,
        $this.data(), typeof option === 'object' && option);

      if (!data) {
        $this.data('modal_form', (data = new ModalForm(this, options, trigger)));
      }
      if (typeof option === 'string') {
        data[option]();
      } else if (options.show) {
        data.show();
      }
    });
  };

  $.fn.modal_form.Constructor = ModalForm;
  $.fn.modal_form.defaults = $.extend({}, $.fn.modal.defaults, {
  });

  /* MODAL-FORM DATA-API
   * =================== */

  $(function () {
    $('body').on('click.modal-form.data-api', '[data-toggle="modal-form"]', function (e) {
      var $this = $(this);
      var href;
      var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
      var option = $target.data('modal-form') ? 'toggle' : $.extend({}, $target.data(), $this.data());

      e.preventDefault();
      $target.modal_form(option);
    });
  });

  // Default flash handler
  $(function () {
    // Default form complete handler
    $('body').on('ajax:complete', function (e, xhr, status) {
      var data = null;
      var modal_form;
      var flash_types;
      var type_i;
      var message;
      var flash;

      try {
        data = JSON.parse(xhr.responseText);
      } catch (exc) {
        // console.debug('exc', exc);
      }

      if (!e.stopRedirect) {
        // Maybe handle AJAX/JSON redirect or refresh
        if (xhr.status === 278) {
          // Handle 278 redirect (AJAX redirect)
          GGRC.navigate(xhr.getResponseHeader('location'));
        } else if (xhr.status === 279) {
          // Handle 279 page refresh
          GGRC.navigate(window.location.href.replace(/#.*/, ''));
        } else {
          modal_form = $('.modal:visible:last').data('modal_form');
          if (modal_form && xhr === modal_form.xhr) {
            delete modal_form.xhr;
            $('[data-toggle=modal-submit]', modal_form.$element)
            .removeAttr('disabled')
            .removeClass('disabled pending-ajax')
            .each(function () {
              $(this).text($(this).data('origText'));
            });
            $('form', modal_form.$element).data('submitpending', false);
          }
        }
      }

      if (data) {
        // Parse and dispatch JSON object
        $(e.target).trigger('ajax:json', [data, xhr]);
      } else if (xhr.responseText) {
        // Dispatch as html, if there is html to dispatch.  (no result should not blank out forms)
        $(e.target).trigger('ajax:html', [xhr.responseText, xhr]);
      }

      if (!e.stopFlash) {
        // Maybe handle AJAX flash messages
        flash_types = ['error', 'alert', 'notice', 'warning'];

        for (type_i in flash_types) {
          if (!flash_types.hasOwnProperty(type_i)) {
            continue;
          }
          message = xhr.getResponseHeader('x-flash-' + flash_types[type_i]);
          message = JSON.parse(message);
          if (message) {
            if (!flash) {
              flash = {};
            }
            flash[flash_types[type_i]] = message;
          }
        }
        if (flash) {
          $(document.body).trigger('ajax:flash', flash);
        }
      }
    });

    $('body').on('ajax:flash', function (e, flash, redirectLink) {
      var $target;
      var $flashHolder;
      var type;
      var message;
      var messageI;
      var flashClass;
      var addLink;
      var $link;
      var flashClassMappings = {
        notice: 'success',
        Running: 'progress',
        Pending: 'progress'
      };
      var $html;
      var gotMessage = _.some(_.values(flash), function (msg) {
        return !!msg;
      });

      if (!gotMessage) {
        // sometimes ajax:flash is triggered with bad data
        return;
      }

      // Find or create the flash-message holder
      $target = $(e.target);
      if ($target.has('.modal-body').length < 1) {
        $target = $('body');
      }
      $flashHolder = $target.find('.flash');

      if ($flashHolder.length === 0) {
        $flashHolder = $('<div class="flash"></div>');
        $target.find('.modal-body').prepend($flashHolder);
      } else {
        $flashHolder.empty();
      }

      for (type in flash) {
        if (flash[type]) {
          if (_.isString(flash[type])) {
            flash[type] = [flash[type]];
          }

          flashClass = flashClassMappings[type] || type;

          $html = $('<div></div>');
          $html.addClass('alert').addClass('alert-' + flashClass);
          if (flashClass !== 'progress') {
            $html.addClass('alert-autohide');
          }
          $html.append('<a href="#" class="close" data-dismiss="alert">x</a>');

          for (messageI in flash[type]) {
            if (!flash[type].hasOwnProperty(messageI)) {
              continue;
            }
            message = flash[type][messageI];
            // Skip error codes. To force display use String(...) when
            // triggering the flash.
            if (_.isString(message)) {
              addLink = message.indexOf('{reload_link}') > -1;
              message = message.replace('{reload_link}', '');
              $html.append($('<span></span>').text(message));
              if (addLink) {
                $html.removeClass('alert-autohide');
                $link = $('<a href="javascript://">Show results</a>');
                $link.on('click', function () {
                  if (redirectLink) {
                    $('html').addClass('no-js');
                    window.location.href = redirectLink;
                  }
                  window.location.reload();
                });
                $html.append($link);
              }
            }
          }
          $flashHolder.append($html);
        }
      }
    });

    $('body').on('ajax:html', '.modal > form', function (e, html, xhr) {
      var sel = "script[type='text/javascript'], script[language='javascript'], script:not([type])";
      var $frag = $(html);
      $frag.filter(sel).add($frag.find(sel)).each(function () {
        $(this).remove();
        setTimeout($(this).html(), 10);
      });
      $(this).find('.modal-body').html($frag);
    });
  });
})(window.jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (_) {
  _.mixin({
    exists: function (obj, key) {
      var keys;
      var slice = Array.prototype.slice;

      if (!key) {
        return obj;
      }
      if (arguments.length > 2) {
        keys = slice.call(arguments).slice(1);
      } else {
        keys = key.split('.');
      }
      return keys.reduce(function (base, memo) {
        return (_.isUndefined(base) || _.isNull(base)) ? base : base[memo];
      }, obj);
    },
    /*
     * Splits string into array and trims its values
     *
     * @param {String} values - Input string that should be manipulated
     * @param {String} splitter - String that is used to split `values`
     *                            - Default splitter is comma - `,`
     * @param {Object} options - Additional options
     *                           - Unique - returns only unique values
     *                           - Compact - removes `falsy` values
     * @return {Array} - Returns array of splited values
     */
    splitTrim: function (values, splitter, options) {
      if (!values || !values.length) {
        return [];
      }
      if (_.isUndefined(splitter)) {
        splitter = ',';
      }
      if (_.isObject(splitter)) {
        options = splitter;
        splitter = ',';
      }

      values = values.split(splitter);
      values = _.map(values, _.trim);

      options = options || {};
      if (options.unique) {
        values = _.uniq(values);
      }
      if (options.compact) {
        values = _.compact(values);
      }
      return values;
    },
    /*
     * Get array of keys that are truthy
     *
     * @param {Object} object - Object with key - values
     * @return {Array} - Returns array of truthy keys
     */
    getExistingKeys: function (object) {
      return _.keys(_.pick(object, _.identity));
    }
  });
})(_);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function(can) {
  can.Construct("PersistentNotifier", {
    defaults: {
      one_time_cbs: true,
      while_queue_has_elements: function() {},
      when_queue_empties: function() {}
    }
  }, {
    init: function(options) {
      var that = this;
      this.dfds = [];
      this.list_empty_cbs = [];
      can.each(this.constructor.defaults, function(val, key) {
        that[key] = val;
      });
      can.each(options, function(val, key) {
        that[key] = val;
      });
    },
    queue: function(dfd) {
      var idx,
        oldlen = this.list_empty_cbs.length,
        that = this;
      if (!dfd || !dfd.then) {
        throw "ERROR: attempted to queue something other than a Deferred or Promise";
      }
      idx = this.dfds.indexOf(dfd);

      if (!~idx) { //enforce uniqueness
        this.dfds.push(dfd);
        dfd.always(function() {
          var i = that.dfds.indexOf(dfd);
          ~i && that.dfds.splice(i, 1);
          if (that.dfds.length < 1) {
            can.each(that.list_empty_cbs, Function.prototype.call);
            if (that.one_time_cbs) {
              that.list_empty_cbs = [];
            }
            that.when_queue_empties();
          }
        });
      }
      if (oldlen < 1 && that.dfds.length > 0) {
        that.while_queue_has_elements();
      }
    },
    on_empty: function(fn) {
      if (!this.one_time_cbs || this.dfds.length < 1) {
        fn();
      }
      if ((this.dfds.length > 0 || !this.one_time_cbs) && !~this.list_empty_cbs.indexOf(fn)) {
        this.list_empty_cbs.push(fn);
      }
    },
    off_empty: function(fn) {
      var idx;
      if (~(idx = this.list_empty_cbs.indexOf(fn)))
        this.list_empty_cbs.splice(idx, 1);
    }
  });
})(can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function(GGRC) {
  GGRC.mustache_path = '/static/mustache';

  GGRC.hooks = GGRC.hooks || {};
  GGRC.extensions = GGRC.extensions || [];
  if (!GGRC.widget_descriptors) {
    GGRC.widget_descriptors = {};
  }
  if (!GGRC.default_widgets) {
    GGRC.default_widgets = [];
  }

  GGRC.register_hook = function(path, hook) {
    var h, parent_path, last;
    parent_path = path.split(".");
    last = parent_path.pop();
    parent_path = can.getObject(parent_path.join("."), GGRC.hooks, true);
    if (!(h = parent_path[last])) {
      h = new can.Observe.List();
      parent_path[last] = h;
    }
    h.push(hook);
  };

  GGRC.current_url_compute = can.compute(function() {
    var path = window.location.pathname,
      fragment = window.location.hash;
    return window.encodeURIComponent(path + fragment);
  });

  var onbeforeunload = function (evnt) {
      evnt = evnt || window.event;
      var message = 'There are operations in progress. Are you sure you want to leave the page?';
      if (evnt) {
        evnt.returnValue = message;
      }
      return message;
    },
    notifier = new PersistentNotifier({
      while_queue_has_elements: function() {
        window.onbeforeunload = onbeforeunload;
      },
      when_queue_empties: function() {
        window.onbeforeunload = $.noop;
      },
      name: 'GGRC/window'
    });

  $.extend(GGRC, {
    get_object_type_decision_tree: function() {
      var tree = {},
        extensions = GGRC.extensions || []
      ;

      can.each(extensions, function(extension) {
        if (extension.object_type_decision_tree) {
          if (can.isFunction(extension.object_type_decision_tree)) {
            $.extend(tree, extension.object_type_decision_tree());
          } else {
            $.extend(tree, extension.object_type_decision_tree);
          }
        }
      });

      return tree;
    },

    infer_object_type: function(data) {
      var decision_tree = GGRC.get_object_type_decision_tree();

      function resolve_by_key(subtree, data) {
        var kind = data[subtree._key];
        var model;
        can.each(subtree, function(v, k) {
          if (k != "_key" && v.meta_kinds.indexOf(kind) >= 0) {
            model = v;
          }
        });
        return model;
      }

      function resolve(subtree, data) {
        if (typeof subtree === "undefined")
          return null;
        return can.isPlainObject(subtree) ?
          subtree._discriminator(data) :
          subtree;
      }

      if (!data) {
        return null;
      } else {
        return can.reduce(Object.keys(data), function (a, b) {
          return a || resolve(decision_tree[b], data[b]);
        }, null);
      }
    },
    make_model_instance: function(data) {
      if (!data) {
        return null;
      } else if (!!GGRC.page_model && GGRC.page_object === data) {
        return GGRC.page_model;
      } else {
        return GGRC.page_model = GGRC.infer_object_type(data).model($.extend({}, data));
      }
    },

    page_instance: function() {
      if (!GGRC._page_instance && GGRC.page_object) {
        GGRC._page_instance = GGRC.make_model_instance(GGRC.page_object);
      }
      return GGRC._page_instance;
    },

    eventqueue: [],
    eventqueueTimeout: null,
    eventqueueTimegap: 20, //ms

    queue_exec_next: function() {
      var fn = GGRC.eventqueue.shift();
      if (fn)
        fn();
      if (GGRC.eventqueue.length > 0)
        GGRC.eventqueueTimeout = setTimeout(GGRC.queue_exec_next, GGRC.eventqueueTimegap);
      else
        GGRC.eventqueueTimeout = null;
    },

    queue_event: function(events) {
      if (typeof (events) === "function")
        events = [events];
      GGRC.eventqueue.push.apply(GGRC.eventqueue, events);
      if (!GGRC.eventqueueTimeout)
        GGRC.eventqueueTimeout = setTimeout(GGRC.queue_exec_next, GGRC.eventqueueTimegap);
    },

    navigate: function(url) {
      function go() {
        if (!url) {
          window.location.reload();
        } else {
          window.location.assign(url);
        }
      }
      notifier.on_empty(go);
    },

    delay_leaving_page_until: $.proxy(notifier, "queue")
  });

  GGRC.Errors = (function () {
    var messages = {
      'default': 'There was an error!',
      '401': 'The server says you are not authorized. Are you logged in?',
      '403': 'You don\'t have the permission to access the ' +
      'requested resource. It is either read-protected or not ' +
      'readable by the server.',
      '409': 'There was a conflict in the object you were trying to update. ' +
      'The version on the server is newer.',
      '412': 'One of the form fields isn\'t right. ' +
      'Check the form for any highlighted fields.'
    };

    function notifier(type, message) {
      var props = {};

      type = type || 'warning';
      props[type] = message || GGRC.Errors.messages.default;
      $('body').trigger('ajax:flash', props);
    }

    function notifierXHR(type, message) {
      return function (err) {
        var status = err && err.status ? err.status : null;

        if (status && !message) {
          message = GGRC.Errors.messages[status];
        }

        notifier(type, message);
      };
    }

    return {
      messages: messages,
      notifier: notifier,
      notifierXHR: notifierXHR
    };
  })();

  /*
    The GGRC Math library provides basic arithmetic across arbitrary precision numbers represented
    as strings.  We wrote this initially to handle easy re-sorting of items in tree views, since
    we could easily get hundreds of re-sorts by halving the distance from zero to MAX_SAFE_INT
    until we got down to 10^-250 which would overflow the string on the data side with zeroes.
  */
  GGRC.Math = GGRC.Math || {};
  $.extend(GGRC.Math, {
    /*
      @param a an addend represented as a decimal notation string
      @param b an addend represented as a decimal notation string

      @return the sum of the numbers represented in a and b, as a decimal notation string.
    */
    string_add: function(a, b) {
      var _a, _b, i,
        _c = 0,
        ret = [],
        adi = a.indexOf("."),
        bdi = b.indexOf(".");

      if (adi < 0) {
        a = a + ".";
        adi = a.length - 1;
      }
      if (bdi < 0) {
        b = b + ".";
        bdi = b.length - 1;
      }
      while (adi < bdi) {
        a = "0" + a;
        adi++;
      }
      while (bdi < adi) {
        b = "0" + b;
        bdi++;
      }

      for (i = Math.max(a.length, b.length) - 1; i >= 0; i--) {
        _a = a[i] || 0;
        _b = b[i] || 0;
        if (_a === "." || _b === ".") {
          if (_a !== "." || _b !== ".")
            throw "Decimal alignment error";
          ret.unshift(".");
        } else {
          ret.unshift((+_a) + (+_b) + _c);
          _c = Math.floor(ret[0] / 10);
          ret[0] = (ret[0] % 10).toString(10);
        }
      }
      if (_c > 0) {
        ret.unshift(_c.toString(10));
      }
      if (ret[ret.length - 1] === ".") {
        ret.pop();
      }
      return ret.join("");
    },

    /*
      @param a a decimal notation string

      @return one half of the number represented in a, as a decimal notation string.
    */
    string_half: function(a) {
      var i, _a,
        _c = 0,
        ret = [];

      if (!~a.indexOf(".")) {
        a = a + ".";
      }
      for (i = 0; i < a.length; i++) {
        _a = a[i];
        if (_a === ".") {
          ret.push(".");
        } else {
          _a = Math.floor((+_a + _c) / 2);
          if (+a[i] % 2) {
            _c = 10;
          } else {
            _c = 0;
          }
          ret.push(_a.toString(10));
        }
      }
      if (_c > 0) {
        ret.push("5");
      }
      if (ret[ret.length - 1] === ".") {
        ret.pop();
      }
      while (ret[0] === "0" && ret.length > 1) {
        ret.shift();
      }
      return ret.join("");
    },

    /*
      @param a a number represented as a decimal notation string
      @param b a number represented as a decimal notation string

      @return the maximum of the numbers represented in a and b, as a decimal notation string.
    */
    string_max: function(a, b) {
      return this.string_less_than(a, b) ? b : a;
    },

    /*
      @param a a number represented as a decimal notation string
      @param b a number represented as a decimal notation string

      @return true if the number represented in a is less than that in b, false otherwise
    */
    string_less_than: function(a, b) {
      var i,
        _a = ("" + a).replace(/^0*/, ""),
        _b = ("" + b).replace(/^0*/, ""),
        adi = _a.indexOf("."),
        bdi = _b.indexOf(".");

      if (adi < 0) {
        _a = _a + ".";
        adi = _a.length - 1;
      }
      if (bdi < 0) {
        _b = _b + ".";
        bdi = _b.length - 1;
      }
      if (adi < bdi) {
        return true;
      }
      if (bdi < adi) {
        return false;
      }
      for (i = 0; i < _a.length - 1; i++) {
        if (_a[i] === ".") {
        // continue
        } else {
          if ((+_a[i] || 0) < (+_b[i] || 0)) {
            return true;
          } else if ((+_a[i] || 0) > (+_b[i] || 0)) {
            return false;
          }
        }
      }
      return _b.length >= _a.length ? false : true;
    }

  });
})(window.GGRC = window.GGRC || {});

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function ($, GGRC, moment, Permission) {
  'use strict';

  var customAttributesType = {
    Text: 'input',
    'Rich Text': 'text',
    'Map:Person': 'person',
    Date: 'date',
    Input: 'input',
    Checkbox: 'checkbox',
    Dropdown: 'dropdown'
  };
  /**
   * A module containing various utility functions.
   */
  GGRC.Utils = {
    win: window,
    filters: {
      /**
       * Performs filtering on provided array like instances
       * @param {Array} items - array like instance
       * @param {Function} filter - filtering function
       * @return {Array} - filtered array
       */
      applyFilter: function (items, filter) {
        return Array.prototype.filter.call(items, filter);
      },
      /**
       * Helper function to create a filtering function
       * @param {Object|null} filterObj - filtering params
       * @return {Function} - filtering function
       */
      makeTypeFilter: function (filterObj) {
        return function (item) {
          var type = item.instance.type.toString().toLowerCase();
          if (!filterObj) {
            return true;
          }
          if (filterObj.only && Array.isArray(filterObj.only)) {
            // Do sanity transformation
            filterObj.only = filterObj.only.map(function (item) {
              return item.toString().toLowerCase();
            });
            return filterObj.only.indexOf(type) > -1;
          }
          if (filterObj.exclude && Array.isArray(filterObj.exclude)) {
            // Do sanity transformation
            filterObj.exclude = filterObj.exclude.map(function (item) {
              return item.toString().toLowerCase();
            });
            return filterObj.exclude.indexOf(type) === -1;
          }
        };
      },
      applyTypeFilter: function (items, filterObj) {
        var filter = GGRC.Utils.filters.makeTypeFilter(filterObj);
        return GGRC.Utils.filters.applyFilter(items, filter);
      }
    },
    sortingHelpers: {
      commentSort: function (a, b) {
        if (a.created_at < b.created_at) {
          return 1;
        } else if (a.created_at > b.created_at) {
          return -1;
        }
        return 0;
      }
    },
    events: {
      isInnerClick: function (el, target) {
        el = el instanceof $ ? el : $(el);
        return el.has(target).length || el.is(target);
      }
    },
    inViewport: function (el) {
      var bounds;
      var isVisible;

      el = el instanceof $ ? el[0] : el;
      bounds = el.getBoundingClientRect();

      isVisible = this.win.innerHeight > bounds.bottom &&
        this.win.innerWidth > bounds.right;

      return isVisible;
    },
    firstWorkingDay: function (date) {
      date = moment(date);
      // 6 is Saturday 0 is Sunday
      while (_.contains([0, 6], date.day())) {
        date.add(1, 'day');
      }
      return date.toDate();
    },
    formatDate: function (date, hideTime) {
      var currentTimezone = moment.tz.guess();
      var inst;

      if (date === undefined || date === null) {
        return '';
      }

      inst = moment(new Date(date.isComputed ? date() : date));
      if (hideTime === true) {
        return inst.format('MM/DD/YYYY');
      }
      return inst.tz(currentTimezone).format('MM/DD/YYYY hh:mm:ss A z');
    },
    getPickerElement: function (picker) {
      return _.find(_.values(picker), function (val) {
        if (val instanceof Node) {
          return /picker\-dialog/.test(val.className);
        }
        return false;
      });
    },
    download: function (filename, text) {
      var element = document.createElement('a');
      element.setAttribute(
        'href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
      element.setAttribute('download', filename);
      element.style.display = 'none';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    },
    loadScript: function (url, callback) {
      var script = document.createElement('script');
      script.type = 'text/javascript';
      if (script.readyState) {
        script.onreadystatechange = function () {
          if (script.readyState === 'loaded' ||
            script.readyState === 'complete') {
            script.onreadystatechange = null;
            callback();
          }
        };
      } else {
        script.onload = function () {
          callback();
        };
      }
      script.src = url;
      document.getElementsByTagName('head')[0].appendChild(script);
    },
    export_request: function (request) {
      return $.ajax({
        type: 'POST',
        dataType: 'text',
        headers: $.extend({
          'Content-Type': 'application/json',
          'X-export-view': 'blocks',
          'X-requested-by': 'gGRC'
        }, request.headers || {}),
        url: '/_service/export_csv',
        data: JSON.stringify(request.data || {})
      });
    },
    hasPending: function (parentInstance, instance, how) {
      var list = parentInstance._pending_joins;
      how = how || 'add';

      if (!list || !list.length) {
        return false;
      }
      if (list instanceof can.List) {
        list = list.serialize();
      }

      return _.find(list, function (pending) {
        var method = pending.how === how;
        if (!instance) {
          return method;
        }
        return method && pending.what === instance;
      });
    },
    is_mapped: function (target, destination, mapping) {
      var tablePlural;
      var bindings;

      // Should check all passed arguments are presented
      if (!target || !destination) {
        console.error('Incorrect arguments list: ', arguments);
        return false;
      }
      if (_.isUndefined(mapping)) {
        tablePlural = CMS.Models[destination.type].table_plural;
        mapping = (target.has_binding(tablePlural) ? '' : 'related_') +
          tablePlural;
      }
      bindings = target.get_binding(mapping);
      if (bindings && bindings.list && bindings.list.length) {
        return _.find(bindings.list, function (item) {
          return item.instance.id === destination.id;
        });
      }
      if (target.objects && target.objects.length) {
        return _.find(target.objects, function (item) {
          return item.id === destination.id && item.type === destination.type;
        });
      }
    },
    /**
     * Get list of mappable objects for certain type
     *
     * @param {String} type - Type of object we want to
     *                      get list of mappable objects for
     * @param {Object} options - Options
     *   @param {Array} options.whitelist - List of objects that will always appear
     *   @param {Array} options.forbidden - List of objects that will always be removed
     *
     * @return {Array} - List of mappable objects
     */
    getMappableTypes: function (type, options) {
      var result;
      var canonical = GGRC.Mappings.get_canonical_mappings_for(type);
      var list = GGRC.tree_view.base_widgets_by_type[type];
      var forbidden;
      var forbiddenList = {
        Program: ['Audit', 'RiskAssessment'],
        Audit: ['Assessment', 'Program', 'Request'],
        Assessment: ['Workflow', 'TaskGroup'],
        Request: ['Workflow', 'TaskGroup', 'Person', 'Audit'],
        Person: '*',
        AssessmentTemplate: '*'
      };
      options = options || {};
      if (!type) {
        return [];
      }
      if (options.forbidden) {
        forbidden = options.forbidden;
      } else {
        forbidden = forbiddenList[type] || [];
      }
      result = _.intersection.apply(_, _.compact([_.keys(canonical), list]));
      if (_.isString(forbidden) && forbidden === '*') {
        forbidden = [];
        result = [];
      }
      result = _.partial(_.without, result);
      result = result.apply(result, forbidden);

      if (options.whitelist) {
        result = _.union(result, options.whitelist);
      }
      return result;
    },
    /**
     * Determine if two types of models can be mapped
     *
     * @param {String} target - the target type of model
     * @param {String} source - the source type of model
     * @param {Object} options - accepts:
     *        {Array} whitelist - list of added objects
     *        {Array} forbidden - list blacklisted objects
     *
     * @return {Boolean} - true if mapping is allowed, false otherwise
     */
    isMappableType: function (target, source, options) {
      var result;
      if (!target || !source) {
        return false;
      }
      result = this.getMappableTypes(target, options);
      return _.contains(result, source);
    },
    /**
     * Determine if `source` is allowed to be mapped to `target`.
     *
     * By symmetry, this method can be also used to check whether `source` can
     * be unmapped from `target`.
     *
     * @param {Object} source - the source object the mapping
     * @param {Object} target - the target object of the mapping
     * @param {Object} options - the options objects, similar to the one that is
     *   passed as an argument to Mustache helpers
     *
     * @return {Boolean} - true if mapping is allowed, false otherwise
     */
    allowed_to_map: function (source, target, options) {
      var canMap = false;
      var types;
      var targetType;
      var sourceType;
      var targetContext;
      var sourceContext;
      var createContexts;
      var canonical;
      var hasWidget;
      var canonicalMapping;

      // NOTE: the names in every type pair must be sorted alphabetically!
      var FORBIDDEN = Object.freeze({
        'audit program': true,
        'audit request': true,
        'program riskassessment': true,
        'assessmenttemplate cacheable': true,
        'cacheable person': true,
        'person risk': true,
        'person threat': true
      });

      if (target instanceof can.Model) {
        targetType = target.constructor.shortName;
      } else {
        targetType = target.type || target;
      }
      sourceType = source.constructor.shortName || source;

      // special case check:
      // - mapping an Audit to a Program is not allowed
      // - mapping an Audit to a Request is not allowed
      // (and vice versa)
      types = [sourceType.toLowerCase(), targetType.toLowerCase()].sort();
      if (FORBIDDEN[types.join(' ')]) {
        return false;
      }

      // special check for snapshot:
      if (options &&
        options.context &&
        options.context.parent_instance &&
        options.context.parent_instance.snapshot) {
        // Avoid add mapping for snapshot
        return false;
      }

      canonical = GGRC.Mappings.get_canonical_mapping_name(
        sourceType, targetType);
      canonicalMapping = GGRC.Mappings.get_canonical_mapping(
        sourceType, targetType);

      if (canonical && canonical.indexOf('_') === 0) {
        canonical = null;
      }

      hasWidget = _.contains(
        GGRC.tree_view.base_widgets_by_type[sourceType] || [],
        targetType);

      if (_.exists(options, 'hash.join') && (!canonical || !hasWidget) ||
        (canonical && !canonicalMapping.model_name)) {
        return false;
      }
      targetContext = _.exists(target, 'context.id');
      sourceContext = _.exists(source, 'context.id');
      createContexts = _.exists(
        GGRC, 'permissions.create.Relationship.contexts');

      canMap = Permission.is_allowed_for('update', source) ||
        sourceType === 'Person' ||
        _.contains(createContexts, sourceContext) ||
        // Also allow mapping to source if the source is about to be created.
        _.isUndefined(source.created_at);

      if (target instanceof can.Model) {
        canMap = canMap &&
          (Permission.is_allowed_for('update', target) ||
          targetType === 'Person' ||
          _.contains(createContexts, targetContext));
      }
      return canMap;
    },
    /**
     * Return Model Constructor Instance
     * @param {String} type - Model type
     * @return {CMS.Model.Cacheble|null} - Return Model Constructor
     */
    getModelByType: function (type) {
      if (!type || typeof type !== 'string') {
        console.debug('Type is not provided or has incorrect format',
          'Value of Type is: ', type);
        return null;
      }
      return CMS.Models[type] || GGRC.Models[type];
    },
    /**
     * Return normalized Custom Attribute Type from Custom Attribute Definition
     * @param {String} type - String Custom Attribute Value from JSON
     * @return {String} - Normalized Custom Attribute Type
     */
    mapCAType: function (type) {
      return customAttributesType[type] || 'input';
    },
    isEmptyCA: function (value, type) {
      var result = false;
      var types = ['Text', 'Rich Text', 'Date', 'Checkbox', 'Dropdown',
        'Map:Person'];
      var options = {
        Checkbox: function (value) {
          return !value || value === '0';
        },
        'Rich Text': function (value) {
          value = GGRC.Utils.getPlainText(value);
          return _.isEmpty(value);
        }
      };
      if (types.indexOf(type) > -1 && options[type]) {
        result = options[type](value);
      } else if (types.indexOf(type) > -1) {
        result = _.isEmpty(value);
      }
      return result;
    },
    /**
     * Remove all HTML tags from the string
     * @param {String} originalText - original string for parsing
     * @return {string} - plain text without tags
     */
    getPlainText: function (originalText) {
      originalText = originalText || '';
      return originalText.replace(/<[^>]*>?/g, '').trim();
    },
    /**
     * Add subtree for object tree view
     * @param {Number} depth - for subtree
     * @return {Object} - mapping of related objects
     */
    getRelatedObjects: function (depth) {
      var basedRelatedObjects;
      var relatedObject;
      var mustachePath = GGRC.mustache_path;
      if (!depth) {
        return {};
      }

      basedRelatedObjects = {
        model: can.Model.Cacheable,
        mapping: 'related_objects',
        show_view: mustachePath + '/base_objects/tree.mustache',
        footer_view: mustachePath + '/base_objects/tree_footer.mustache',
        add_item_view: mustachePath + '/base_objects/tree_add_item.mustache',
        draw_children: false
      };

      relatedObject = $.extend(basedRelatedObjects, {
        child_options: [this.getRelatedObjects(depth - 1)]
      });

      if (depth === 1) {
        return relatedObject;
      }

      relatedObject.draw_children = true;

      return relatedObject;
    },
    /**
     * A function that returns the highest role in an array of strings of roles
     * or a comma-separated string of roles.
     *
     * @param {CMS.Models.Cacheable} obj - Assignable object with defined
     *   assignable_list class property holding assignable roles ordered in
     *   increasing importance.
     * Return highest assignee role from a list of roles
     * @param {Array|String} roles - An Array of strings or a String with comma
     *   separated values of roles.
     * @return {string} - Highest role from an array of strings or 'none' if
     *   none found.
     */
    get_highest_assignee_role: function (obj, roles) {
      var roleOrder = _.map(
        _.map(obj.class.assignable_list, 'type'),
        _.capitalize);

      if (_.isString(roles)) {
        roles = roles.split(',');
      }

      roles = _.map(roles, _.capitalize);

      roles.unshift('none');
      return _.max(roles, Array.prototype.indexOf.bind(roleOrder));
    }
  };

  /**
   * Util methods for work with QueryAPI.
   */
  GGRC.Utils.QueryAPI = (function () {
    /**
     * @typedef LimitArray
     * @type {array}
     * @property {number} 0  - Lower bound is inclusive.
     * @property {number} 1  - Upper bound is exclusive.
     */

    /**
     * @typedef QueryAPIRequest
     * @type {Object}
     * @property {string} object_name - The name of object
     * @property {LimitArray} limit - The boundaries of the requested values.
     * @property {object} filters - Filter properties
     */

    var widgetsCounts = new can.Map({});

    /**
     * Build params for request on Query API.
     *
     * @param {String} objName - Name of requested object
     * @param {Object} page - Information about page state.
     * @param {Number} page.current - Current page
     * @param {Number} page.pageSize - Page size
     * @param {String} page.sortBy - sortBy
     * @param {String} page.sortDirection - sortDirection
     * @param {String} page.filter - Filter string
     * @param {Object} relevant - Information about relevant object
     * @param {Object} relevant.type - Type of relevant object
     * @param {Object} relevant.id - Id of relevant object
     * @param {Object} relevant.operation - Type of operation.
     * @param {Object} additionalFilter - An additional filter to be applied
     * @return {QueryAPIRequest} Array of QueryAPIRequest
     */
    function buildParams(objName, page, relevant, additionalFilter) {
      return [buildParam(objName, page, relevant, undefined, additionalFilter)];
    }

    /**
     * Build params for request on Query API.
     *
     * @param {String} objName - Name of requested object
     * @param {Object} page - Information about page state.
     * @param {Number} page.current - Current page
     * @param {Number} page.pageSize - Page size
     * @param {String} page.sortBy - sortBy
     * @param {String} page.sortDirection - sortDirection
     * @param {String} page.filter - Filter string
     * @param {Object} relevant - Information about relevant object
     * @param {Object} relevant.type - Type of relevant object
     * @param {Object} relevant.id - Id of relevant object
     * @param {Object} relevant.operation - Type of operation.
     * @param {Array} fields - Array of requested fields.
     * @param {Object} additionalFilter - An additional filter to be applied
     * @return {QueryAPIRequest} Object of QueryAPIRequest
     */
    function buildParam(objName, page, relevant, fields, additionalFilter) {
      var first;
      var last;
      var params = {};

      if (!objName) {
        return {};
      }

      params.object_name = objName;
      if (relevant && !relevant.operation) {
        relevant.operation = _getTreeViewOperation(objName);
      }
      params.filters = _makeFilter(page.filter, relevant, additionalFilter);

      if (page.current && page.pageSize) {
        first = (page.current - 1) * page.pageSize;
        last = page.current * page.pageSize;
        params.limit = [first, last];
      }
      if (page.sortBy) {
        params.order_by = [{
          name: page.sortBy,
          desc: page.sortDirection === 'desc'
        }];
      }
      if (fields) {
        params.fields = fields;
      }
      return params;
    }

    /**
     * Counts for related objects.
     *
     * @return {can.Map} Promise which return total count of objects.
     */
    function getCounts() {
      return widgetsCounts;
    }

    function initCounts(widgets, relevant) {
      var params = can.makeArray(widgets)
        .map(function (widget) {
          var param;
          if (GGRC.Utils.Snapshots.isSnapshotRelated(relevant.type, widget)) {
            param = buildParam('Snapshot', {},
              makeExpression(widget, relevant.type, relevant.id), null,
              GGRC.query_parser.parse('child_type = ' + widget));
          } else if (typeof widget === 'string') {
            param = buildParam(widget, {},
              makeExpression(widget, relevant.type, relevant.id));
          } else {
            param = buildParam(widget.name, {},
              makeExpression(widget.name, relevant.type, relevant.id),
              null, widget.additionalFilter);
          }
          param.type = 'count';
          return param;
        });

      return makeRequest({
        data: params
      }).then(function (data) {
        data.forEach(function (info, i) {
          var widget = widgets[i];
          var name = typeof widget === 'string' ? widget : widget.name;
          var countsName = typeof widget === 'string' ?
            widget : (widget.countsName || widget.name);
          if (GGRC.Utils.Snapshots.isSnapshotRelated(relevant.type, name)) {
            name = 'Snapshot';
          }
          widgetsCounts.attr(countsName, info[name].total);
        });
      });
    }

    /**
     * Params for request on Query API
     * @param {Object} params - Params for request
     * @param {Object} params.headers - Custom headers for request.
     * @param {Object} params.data - Object with parameters on Query API needed.
     * @return {Promise} Promise on Query API request.
     */
    function makeRequest(params) {
      var reqParams = params.data || [];
      return $.ajax({
        type: 'POST',
        headers: $.extend({
          'Content-Type': 'application/json'
        }, params.headers || {}),
        url: '/query',
        data: JSON.stringify(reqParams)
      });
    }

    function makeExpression(parent, type, id, operation) {
      var isObjectBrowser = /^\/objectBrowser\/?$/
        .test(window.location.pathname);
      var expression;

      if (!isObjectBrowser) {
        expression = {
          type: type,
          id: id
        };

        expression.operation = operation ? operation :
          _getTreeViewOperation(parent);
      }
      return expression;
    }

    function _makeFilter(filter, relevant, additionalFilter) {
      var relevantFilter;
      var filterList = [];

      if (relevant) {
        relevantFilter = GGRC.query_parser.parse('#' + relevant.type + ',' +
                                                 relevant.id + '#');
        filterList.push(relevantFilter);

        if (relevant.operation &&
            relevant.operation !== relevantFilter.expression.op.name) {
          relevantFilter.expression.op.name = relevant.operation;
        }
      }

      if (filter) {
        filterList.push(GGRC.query_parser.parse(filter));
      }

      if (additionalFilter) {
        filterList.push(additionalFilter);
      }

      if (filterList.length) {
        return filterList.reduce(function (left, right) {
          return GGRC.query_parser.join_queries(left, right);
        });
      }
      return {expression: {}};
    }

    function _getTreeViewOperation(objectName) {
      var isDashboard = /dashboard/.test(window.location);
      var operation;
      if (isDashboard) {
        operation = 'owned';
      } else if (objectName === 'Person') {
        operation = 'related_people';
      }
      return operation;
    }

    return {
      buildParam: buildParam,
      buildParams: buildParams,
      makeRequest: makeRequest,
      getCounts: getCounts,
      makeExpression: makeExpression,
      initCounts: initCounts
    };
  })();

  /**
   * Util methods for work with Snapshots.
   */
  GGRC.Utils.Snapshots = (function () {
    /**
     * Set extra attrs for snapshoted objects or snapshots
     * @param {Object} instance - Object instance
     */
    function setAttrs(instance) {
      // Get list of objects that supports 'snapshot scope' from config
      var className = instance.type;
      if (className === 'Audit') {
        instance.attr('is_snapshotable', true);
      }
    }

    /**
     * Check whether object is snapshot
     * @param {Object} instance - Object instance
     * @return {Boolean} True or False
     */
    function isSnapshot(instance) {
      return instance && instance.snapshot;
    }

    /**
     * Check whether object is in spanshot scope
     * @param {Object} parentInstance - Object (parent) instance
     * @return {Boolean} True or False
     */
    function isSnapshotScope(parentInstance) {
      var instance = parentInstance || GGRC.page_instance();
      return instance ? instance.is_snapshotable : false;
    }

    /**
     * Convert snapshot to object
     * @param {Object} instance - Snapshot instance
     * @return {Object} The object
     */
    function toObject(instance) {
      var model = CMS.Models[instance.child_type];
      var content = instance.revision.content;
      var type = model.root_collection;
      content.isLatestRevision = instance.is_latest_revision;
      content.originalLink = '/' + type + '/' + content.id;
      content.snapshot = new CMS.Models.Snapshot(instance);
      content.related_sources = [];
      content.related_destinations = [];
      content.custom_attribute_values = content.custom_attributes;
      content.viewLink = content.snapshot.viewLink;
      content.selfLink = content.snapshot.selfLink;
      content.type = instance.child_type;
      return new model(content);
    }

    /**
     * Convert array of snapshots to array of object
     * @param {Object} values - array of snapshots
     * @return {Object} The array of objects
     */
    function toObjects(values) {
      return new can.List(values.map(toObject));
    }

    /**
     * Transform query for objects into query for snapshots of the same type
     * @param {Object} params - original query
     * @return {Object} The transformed query
     */
    function transformQuery(params) {
      var data = params.data[0];
      var type = data.object_name;
      var expression = data.filters.expression;
      data.object_name = 'Snapshot';
      data.filters.expression = {
        left: {
          left: 'child_type',
          op: {name: '='},
          right: type
        },
        op: {name: 'AND'},
        right: expression
      };
      return params;
    }

    /**
     * Check whether provided model name should be snapshot or default one
     * @param {String} modelName - model to check
     * @return {Boolean} True or False
     */
    function isSnapshotModel(modelName) {
      return GGRC.config.snapshotable_objects.indexOf(modelName) > -1;
    }

    /**
     * Check if the relationship is of type snapshot.
     * @param {String} parent - Parent of the related objects
     * @param {String} child - Child of the related objects
     * @return {Boolean} True or False
     */
    function isSnapshotRelated(parent, child) {
      return GGRC.config.snapshotable_parents.indexOf(parent) > -1 &&
            isSnapshotModel(child) > -1;
    }

    /**
     * Check whether provided model name is snapshot parent
     * @param {String} parent - Model name
     * @return {Boolean} True or False
     */
    function isSnapshotParent(parent) {
      return GGRC.config.snapshotable_parents.indexOf(parent) > -1;
    }

    return {
      isSnapshot: isSnapshot,
      isSnapshotScope: isSnapshotScope,
      isSnapshotParent: isSnapshotParent,
      isSnapshotRelated: isSnapshotRelated,
      isSnapshotModel: isSnapshotModel,
      toObject: toObject,
      toObjects: toObjects,
      transformQuery: transformQuery,
      setAttrs: setAttrs
    };
  })();
})(jQuery, window.GGRC = window.GGRC || {}, window.moment, window.Permission);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function($, moment) {
  // On-demand creation of datepicker() objects
  var $body = $("body"),
      format = {
        changeMonth: true,
        changeYear: true,
        prevText: "",
        nextText: "",
        dateFormat: "mm/dd/yy"
      };

  $body.on("focus", "[data-toggle=\"datepicker\"]", function (ev) {
    var $this = $(this);

    if ($this.data("datepicker")) {
      return;
    }
    $this.datepicker(format);

    if ($this.is("[data-before], [data-after]")) {
      $this.trigger("change");
    }
  });

  // On-demand creation of datepicker() objects, initial date today or later
  $body.on("focus", "[data-toggle=\"datepicker_today_or_later\"]", function (ev) {
    var $this = $(this);

    if ($this.data("datepicker")) {
      return;
    }
    $this.datepicker(format)
         .datepicker("option", "minDate", new Date());
  });
})(jQuery, moment);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can) {
  can.extend(can.Control.prototype, {
    // Returns a function which will be halted unless `this.element` exists
    //   - useful for callbacks which depend on the controller's presence in
    //     the DOM
    _ifNotRemoved: function(fn) {
      var that = this;
      return function() {
        if (!that.element) {
          return;
        }
        return fn.apply(this, arguments);
      };
    },

    //make buttons non-clickable when saving
    bindXHRToButton : function(xhr, el, newtext, disable) {
      // binding of an ajax to a click is something we do manually
      var $el = $(el)
      , oldtext = $el.text();

      if(newtext) {
        $el[0].innerHTML = newtext;
      }
      $el.addClass("disabled pending-ajax");
      if (disable !== false) {
        $el.attr("disabled", true);
      }
      xhr.always(function() {
        // If .text(str) is used instead of innerHTML, the click event may not fire depending on timing
        if ($el.length) {
          $el.removeAttr("disabled").removeClass("disabled pending-ajax")[0].innerHTML = oldtext;
        }
      });
    }
  });
})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function($) {
  $.fn.cms_wysihtml5 = function() {
    if ($(this).data('_wysihtml5_initialized')) {
      return;
    }

    $(this).data('_wysihtml5_initialized', true);
    this.wysihtml5({
      link: true,
      image: false,
      html: true,
      'font-styles': false,
      parserRules: wysihtml5ParserRules
    });
    this.each(function() {
      var $that = $(this),
        editor = $that.data("wysihtml5").editor,
        $textarea = $(editor.textarea.element);

      if ($that.data("cms_events_bound")) {
        return;
      }
      editor.on('beforeinteraction:composer', function() {
        $that.val(this.getValue()).trigger('change');
      });

      var $wysiarea = $that.closest(".wysiwyg-area").resizable({
        handles: "s",
        minHeight: 100,
        alsoResize: "#" + $that.uniqueId().attr("id") + ", #" + $that.closest(".wysiwyg-area").uniqueId().attr("id") + " iframe",
        autoHide: false
      }).bind("resizestop", function(ev) {
        ev.stopPropagation();
        $that.css({
          "display": "block",
          "height": $that.height() + 20
        }); //10px offset between reported height and styled height.
        $textarea.css('width', $textarea.width() + 20);
        editor.composer.style(); // re-copy new size of textarea to composer
        editor.fire('change_view', editor.currentView.name);
      });
      var $sandbox = $wysiarea.find(".wysihtml5-sandbox");

      $($sandbox.prop("contentWindow"))
        .bind("mouseover mousemove mouseup", function(ev) {
          var e = new $.Event(ev.type === "mouseup" ? "mouseup" : "mousemove"); //jQUI resize listens on this.
          e.pageX = $sandbox.offset().left + ev.pageX;
          e.pageY = $sandbox.offset().top + ev.pageY;
          $sandbox.trigger(e);
        });

      $that.data("cms_events_bound", true);
    });

    return this;
  };
})(jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function ($) {
  'use strict';
  var MAX_RESULTS = 20;
  var SEARCH_DEBOUNCE = 50;

  $.widget('ggrc.autocomplete', $.ui.autocomplete, {
    options: {
      // Ensure that the input.change event still occurs
      change: function (event, ui) {
        if (!$(event.target).parents(document.body).length) {
          console.warn(
            'autocomplete menu change event is coming from detached nodes');
        }
        $(event.target).trigger('change');
      },
      minLength: 0,
      source: _.debounce(function (request, response) {
        // Search based on the term
        var query = request.term || '';
        var queue = new RefreshQueue();
        var isNextPage = _.isNumber(request.start);
        var dfd;

        if (query.indexOf('@') > -1) {
          query = '"' + query + '"';
        }

        this.last_request = request;
        if (isNextPage) {
          dfd = $.when(this.last_stubs);
        } else {
          request.start = 0;
          dfd = this.options.source_for_refreshable_objects.call(this, request);
        }

        dfd.then(function (objects) {
          this.last_stubs = objects;
          can.each(
            objects.slice(request.start, request.start + MAX_RESULTS),
            function (object) {
              queue.enqueue(object);
            }
          );
          queue.trigger().then(function (objs) {
            objs = this.options.apply_filter(objs, request);
            if (objs.length || isNextPage) {
              // Envelope the object to not break model instance due to
              // shallow copy done by jQuery in `response()`
              objs = can.map(objs, function (obj) {
                return {
                  item: obj
                };
              });
              response(objs);
            } else {
              // show the no-results option iff no results come through here,
              //  and not merely showing paging.
              this._suggest([]);
              this._trigger('open');
            }
          }.bind(this));
        }.bind(this));

        if (this.options.controller) {
          this.options.controller.bindXHRToButton(dfd,
            $(this.element), null, false);
        }
      }, SEARCH_DEBOUNCE),

      apply_filter: function (objects) {
        return objects;
      },

      source_for_refreshable_objects: function (request) {
        var that = this;

        if (this.options.searchlist) {
          this.options.searchlist.then(function () {
            var filteredList = [];
            return $.map(arguments, function (item) {
              var searchAttr;
              var term;
              if (!item) {
                return;
              }
              searchAttr = item.title || '';
              term = request.term.toLowerCase();

              // Filter out duplicates:
              if (filteredList.indexOf(item._cid) > -1) {
                return;
              }
              filteredList.push(item._cid);

              // Perform search based on term:
              if (searchAttr.toLowerCase().indexOf(term) === -1) {
                return;
              }
              return item;
            });
          });
          return this.options.searchlist;
        }

        return GGRC.Models.Search.search_for_types(
          request.term || '',
          this.options.searchtypes,
          this.options.search_params
        )
        .then(function (searchResult) {
          var objects = [];

          can.each(that.options.searchtypes, function (searchtype) {
            objects.push.apply(objects,
              searchResult.getResultsForType(searchtype));
          });
          return objects;
        });
      },

      select: function (ev, ui) {
        var origEvent;
        var $this = $(this);
        var widgetName = $this.data('autocomplete-widget-name');
        var ctl = $this.data(widgetName).options.controller;

        if (ui.item) {
          $this.trigger('autocomplete:select', [ui]);
          if (ctl) {
            if (ctl.scope && ctl.scope.autocomplete_select) {
              return ctl.scope.autocomplete_select($this, ev, ui);
            } else if (ctl.autocomplete_select) {
              return ctl.autocomplete_select($this, ev, ui);
            }
          }
        } else {
          origEvent = ev;
          $(document.body)
            .off('.autocomplete')
            .one('modal:success.autocomplete', function (_ev, newObj) {
              if (ctl) {
                if (ctl.scope && ctl.scope.autocomplete_select) {
                  return ctl.scope.autocomplete_select(
                    $this, origEvent, {item: newObj});
                } else if (ctl.autocomplete_select) {
                  return ctl.autocomplete_select(
                    $this, origEvent, {item: newObj});
                }
              }
              $this.trigger('autocomplete:select', [{
                item: newObj
              }]);
              $this.trigger('modal:success', newObj);
            })
            .one('hidden', function () {
              setTimeout(function () {
                $(this).off('.autocomplete');
              }, 100);
            });

          while ((origEvent = origEvent.originalEvent)) {
            if (origEvent.type === 'keydown') {
              // This selection event was generated from a keydown, so click
              // the add new link.
              // FIXME: el is not defined, this would result in an error
              widgetName = el.data('autocompleteWidgetName');
              el.data(widgetName).menu.active.find('a').click();
              break;
            }
          }
          return false;
        }
      },

      close: function () {
        this.scroll_op_in_progress = undefined;
      }
    },
    _create: function () {
      var that = this;
      var $that = $(this.element);
      var baseSearch = $that.data('lookup');
      var fromList = $that.data('from-list');
      var searchParams = $that.data('params');
      var permission = $that.data('permission-type');
      var searchtypes;
      var typeNames;

      this._super.apply(this, arguments);
      this.options.search_params = {
        extra_params: searchParams
      };
      if (permission) {
        this.options.search_params.__permission_type = permission;
      }

      $that.data('autocomplete-widget-name', this.widgetFullName);

      $that.focus(function () {
        $(this).data(that.widgetFullName).search($(this).val());
      });

      if (fromList) {
        this.options.searchlist = $.when.apply(
          this,
          $.map(fromList.list, function (item) {
            var props = baseSearch.trim().split('.');
            return item.instance.refresh_all.apply(item.instance, props);
          })
        );
      } else if (baseSearch) {
        baseSearch = baseSearch.trim();
        if (
          baseSearch.indexOf('__mappable') === 0 ||
          baseSearch.indexOf('__all') === 0
        ) {
          searchtypes = GGRC.Mappings.get_canonical_mappings_for(
            this.options.parent_instance.constructor.shortName
          );
          if (baseSearch.indexOf('__mappable') === 0) {
            searchtypes = can.map(searchtypes, function (mapping) {
              return (mapping instanceof GGRC.ListLoaders.ProxyListLoader) ?
                     mapping : undefined;
            });
          }
          if (baseSearch.indexOf('_except:')) {
            typeNames = baseSearch.substr(
              baseSearch.indexOf('_except:') + 8
            ).split(',');

            can.each(typeNames, function (remove) {
              delete searchtypes[remove];
            });
          }
          searchtypes = Object.keys(searchtypes);
        } else {
          searchtypes = baseSearch.split(',');
        }

        this.options.searchtypes = can.map(searchtypes, function (typeName) {
          return CMS.Models[typeName].model_singular;
        });
      }
    },

    _setup_menu_context: function (items) {
      var modelClass = this.element.data('lookup');
      var dataModel = this.element.data('model');
      var model = CMS.Models[modelClass || dataModel] ||
                  GGRC.Models[modelClass || dataModel];

      return {
        model_class: modelClass,
        model: model,
        // Reverse the enveloping we did 25 lines up
        items: can.map(items, function (item) {
          return item.item;
        })
      };
    },

    _renderMenu: function (ul, items) {
      var template = this.element.data('template');
      var context = new can.Observe(this._setup_menu_context(items));
      var model = context.model;
      var $ul = $(ul);

      if (!template) {
        if (
          model &&
          GGRC.Templates[model.table_plural + '/autocomplete_result']
        ) {
          template = '/' + model.table_plural + '/autocomplete_result.mustache';
        } else {
          template = '/base_objects/autocomplete_result.mustache';
        }
      }

      context.attr('disableCreate', this.options.disableCreate);

      $ul.unbind('scrollNext')
        .bind('scrollNext', function (ev, data) {
          var listItems;
          if (context.attr('scroll_op_in_progress') ||
              context.attr('oldLen') === context.attr('items').length) {
            return;
          }

          this.last_request = this.last_request || {};
          this.last_request.start = this.last_request.start || 0;
          this.last_request.start += MAX_RESULTS;
          context.attr('scroll_op_in_progress', true);
          context.attr('items_loading', true);
          this.source(this.last_request, function (items) {
            try {
              listItems = context.attr('items');
              listItems.push.apply(listItems, can.map(items, function (item) {
                return item.item;
              }));
              context.attr('oldLen', listItems.length);
            } catch (error) {
              // Really ugly way to hide canjs exception during scrolling.
              // Please note that it occurs in really rear cases.
              // Better solution is needed.
              console.warn(error);
            }

            context.removeAttr('items_loading');
            _.defer(function () {
              context.attr('scroll_op_in_progress', false);
            });
          });
        }.bind(this));

      can.view.render(GGRC.mustache_path + template,
        context, function (frag) {
          $ul.html(frag);
          $ul.cms_controllers_lhn_tooltips().cms_controllers_infinite_scroll();
          can.view.hookup(ul);
        });
    }
  });

  $.widget.bridge('ggrc_autocomplete', $.ggrc.autocomplete);
  $.widget('ggrc.mapping_autocomplete', $.ggrc.autocomplete, {
    options: {
      source_for_refreshable_objects: function (request) {
        var mapping = this.options.controller.options;

        if (mapping.scope) {
          mapping = mapping.scope.source_mapping;
        }

        return $.when(can.map(mapping || [], function (binding) {
          return binding.instance;
        }));
      },
      apply_filter: function (objects, request) {
        return can.map(objects, function (object) {
          if (
            !request.term ||
            object.title && _.includes(object.title, request.term)
          ) {
            return object;
          }
          return undefined;
        });
      }
    },
    _setup_menu_context: function (items) {
      return $.extend(this._super(items), {
        mapping: _.isUndefined(this.options.mapping) ?
                this.element.data('mapping') : this.options.mapping
      });
    }
  });

  $.widget.bridge('ggrc_mapping_autocomplete', $.ggrc.mapping_autocomplete);

  /**
   * Convert an input element to an autocomplete field.
   *
   * If an element is not given, it tries to use the first suitable element
   * within the current DOM context (i.e. a DOM node containing form elements),
   * if such context exists.
   *
   * @param {DOM.Element} el - the element to convert
   */
  $.cms_autocomplete = function (el) {
    var ctl = this;
    // Add autocomplete to the owner field
    if (!el) {
      if (!this.element) {
        // It can happen that this.element is already null when we want to init
        // autocomplete on it, e.g. when its containing modal form is already
        // being destroyed. In such cases we simply don't do anything.
        return;
      }
      el = this.element.find('input[data-lookup]');
    } else {
      el = $(el);
    }
    el.filter("[name][name!='']")
      .ggrc_autocomplete({
        controller: ctl
      });
  };
})(jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function(root, $, can) {

  // Set up all PUT requests to the server to respect ETags, to ensure that
  // we are not overwriting more recent data than was viewed by the user.
  var etags = {},
      doc = root.document,
      body = doc.body,
      $win = $(root),
      $doc = $(doc),
      $body = $(body);

  $.ajaxPrefilter(function(options, originalOptions, jqXHR) {
    var data = originalOptions.data;

    function attach_provisional_id(prop) {
      jqXHR.done(function(obj) {
        obj[prop].provisional_id = data[prop].provisional_id;
      });
    }

    if (/^\/api\//.test(options.url) && /PUT|POST|DELETE/.test(options.type.toUpperCase())) {
      options.dataType = "json";
      options.contentType = "application/json";
      jqXHR.setRequestHeader("If-Match", (etags[originalOptions.url] || [])[0]);
      jqXHR.setRequestHeader("If-Unmodified-Since", (etags[originalOptions.url] || [])[1]);
      options.data = options.type.toUpperCase() === "DELETE" ? "" : JSON.stringify(data);
      for (var i in data) {
        if (data.hasOwnProperty(i) && data[i] && data[i].provisional_id) {
          attach_provisional_id(i);
        }
      }
    }
    if (/^\/api\//.test(options.url) && (options.type.toUpperCase() === "GET")) {
      options.cache = false;
    }
    if (/^\/api\/\w+/.test(options.url)) {
      jqXHR.setRequestHeader("X-Requested-By", "gGRC");
      jqXHR.done(function(data, status, xhr) {
        if (!/^\/api\/\w+\/\d+/.test(options.url) && options.type.toUpperCase() === "GET") {
          return;
        }
        switch (options.type.toUpperCase()) {
          case "GET":
          case "PUT":
            etags[originalOptions.url] = [xhr.getResponseHeader("ETag"), xhr.getResponseHeader("Last-Modified")];
            break;
          case "POST":
            for (var d in data) {
              if (data.hasOwnProperty(d) && data[d].selfLink) {
                etags[data[d].selfLink] = [xhr.getResponseHeader("ETag"), xhr.getResponseHeader("Last-Modified")];
              }
            }
            break;
          case "DELETE":
            delete etags[originalOptions.url];
            break;
        }
      });
    }
  });

  // Set up default failure callbacks if nonesuch exist.
  var _old_ajax = $.ajax;

  // Here we break the deferred pattern a bit by piping back to original AJAX deferreds when we
  // set up a failure handler on a later transformation of that deferred.  Why?  The reason is that
  //  we have a default failure handler that should only be called if no other one is registered,
  //  unless it's also explicitly asked for.  If it's registered in a transformed one, though (after
  //  then() or pipe()), then the original one won't normally be notified of failure.
  can.ajax = $.ajax = function (options) {
    var _ajax = _old_ajax.apply($, arguments);

    function setup(_new_ajax, _old_ajax) {
      var _old_then = _new_ajax.then;
      var _old_fail = _new_ajax.fail;
      var _old_pipe = _new_ajax.pipe;
      _old_ajax && (_new_ajax.hasFailCallback = _old_ajax.hasFailCallback);
      _new_ajax.then = function() {
        var _new_ajax = _old_then.apply(this, arguments);
        if (arguments.length > 1) {
          this.hasFailCallback = true;
          if (_old_ajax) {
            _old_ajax.fail(function() {});
          }
        }
        setup(_new_ajax, this);
        return _new_ajax;
      };
      _new_ajax.fail = function() {
        this.hasFailCallback = true;
        if (_old_ajax) {
          _old_ajax.fail(function() {});
        }
        return _old_fail.apply(this, arguments);
      };
      _new_ajax.pipe = function() {
        var _new_ajax = _old_pipe.apply(this, arguments);
        setup(_new_ajax, this);
        return _new_ajax;
      };
    }

    setup(_ajax);
    return _ajax;
  };

  $doc.ajaxError(function (event, jqxhr, settings, exception) {
    var message;
    if (!jqxhr.hasFailCallback || settings.flashOnFail ||
      (!settings.flashOnFail && jqxhr.flashOnFail)) {
      // TODO: Import produced 'canceled' ajax flash message that needed handling. Will refactor once better method works.
      if (settings.url.indexOf('import') === -1 || exception !== 'canceled') {
        message = jqxhr.getResponseHeader('X-Flash-Error') ||
          GGRC.Errors.messages[jqxhr.status] || exception.message || exception;

        if (message) {
          GGRC.Errors.notifier('error', message);
        } else {
          GGRC.Errors.notifierXHR('error')(jqxhr);
        }
      }
    }
  });
})(this, jQuery, can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function ($, can) {
  // a few core CanJS extensions below.
  // Core validation for fields not being "blank", i.e.
  // having no content when outside spaces are trimmed away.
  can.Model.validationMessages.non_blank =
    can.Map.validationMessages.non_blank = 'cannot be blank';

  can.Model.validateNonBlank =
    can.Map.validateNonBlank = function (attrNames, options) {
      this.validate(attrNames, options, function (value) {
        if (_.isUndefined(value) ||
            _.isNull(value) ||
            _.isFunction(value.trim) && value.trim() === '') {
          return this.constructor.validationMessages.non_blank;
        }
      });
    };
  can.Model.validateContact =
    can.Map.validateContact = function (attrNames, options) {
      this.validate(attrNames, options, function (newVal, prop) {
        var reifiedContact = newVal && newVal.reify ? newVal.reify() : false;
        var hasEmail = reifiedContact ? reifiedContact.email : false;
        options = options || {};

        // This check will not work until the bug introduced with commit 8a5f600c65b7b45fd34bf8a7631961a6d5a19638
        // is resolved.
        if (!hasEmail) {
          return options.message ||
            'No valid contact selected for assignee';
        }
      });
    };

  /**
   * Validate an autocomplete list field to be not blank.
   *
   * It checks in the field contains either a false-value, or a
   * non-constructor, or a constructor that builds an empty object and if so,
   * returns a non_blank error message.
   *
   * @param {String} listFieldName - the name of the field with the
   * autocomplete list
   * @param {Function} condition - a zero-parameter function; the validation
   * will be fired only if condition returns true or is undefined
   * @param {Object} options - a CanJS options argument passed to CanJS
   * validate function
   *
   */
  can.Model.validateListNonBlank =
    can.Map.validateListNonBlank = function (listFieldName, condition,
                                             options) {
      this.validate(listFieldName, options, function (newVal, prop) {
        if (_.isUndefined(condition) || condition.call(this)) {
          if (!newVal ||
              !_.isFunction(newVal.attr) ||
              _.isEmpty(newVal.attr())) {
            return this.constructor.validationMessages.non_blank;
          }
        }
      });
    };

  // Adding reduce, a generally useful array comprehension.
  //  Bitovi decided against including it in core CanJS, but
  //  adding it here for easy universal use across can.List
  //  as well as arrays.
  if (!can.reduce) {
    can.reduce = function (a, f, i) {
      if (_.isNull(a)) {
        return null;
      }
      return [].reduce.apply(a, arguments.length < 3 ? [f] : [f, i]);
    };
  }

  // Turn camelCase or snake-case strings into Camel Space strings
  can.spaceCamelCase = function (string) {
    if (!_.isString(string)) {
      throw new TypeError('Invalid type, string required.');
    }

    return can.underscore(string)
      .split('_')
      .map(can.capitalize)
      .join(' ');
  };
  can.camelCaseToUnderscore = function (string) {
    if (!_.isString(string)) {
      throw new TypeError('Invalid type, string required.');
    }
    return _.snakeCase(string);
  };
  can.camelCaseToDashCase = function (string) {
    if (!_.isString(string)) {
      return '';
    }
    return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  };
})(jQuery, can);


/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can, _) {
  'use strict';

  if (_.isFunction(GGRC.Components)) {
    return;  // no need to create the component registry again
  }

  // make the registry publicly available
  GGRC.Components = Components;

  /**
   * An object representing the CanJS component registry.
   *
   * If invoked directly as a function, it creates a new component by
   * delegating the work to can.Component.extend(), and registers the resulting
   * constructor function under the given name.
   *
   * The name must be a nonempty string, and an error is thrown if the name has
   * already been taken.
   *
   * @param {String} name - the name under which to register the component
   * @param {Object} config - the component configuration object as expected
   *   by the underlying can.Component.extend() method
   *
   * @return {Function} - the created component constructor
   */
  function Components(name, config) {
    var constructor;
    var definitions;

    if (!name || !_.isString(name)) {
      throw new Error('Component name must be a nonempty string.');
    }

    if (Components._registry[name]) {
      throw new Error('Component already exists: ' + name);
    }

    if (config.scope && _.isObject(config.scope.define)) {
      definitions = config.scope.define;
      delete config.scope.define;
    }

    if (definitions) {
      config.scope = Components._extendScope(config.scope, definitions);
    }

    constructor = can.Component.extend(config);
    Components._registry[name] = constructor;

    return constructor;
  }

  /**
   * Wrap component scope function
   *
   * @param {Function} originalScope - Component original scope
   * @param {Object} definitions - Type definitions and their defaults
   *
   * @return {Function} - Scope wrapped init function
   */
  Components._extendScope = function (originalScope, definitions) {
    return function (scope, parentScope, element) {
      var val;
      scope = scope || {};
      parentScope = parentScope || {};
      element = element instanceof jQuery ? element : $(element);

      _.each(originalScope, function (obj, key) {
        if (originalScope[key] === '@') {
          scope[key] = element.attr(can.camelCaseToDashCase(key));
        }
      });
      _.each(definitions, function (obj, key) {
        var prefix = '';
        if (obj.type === 'function') {
          prefix = 'can-';
        }
        val = element.attr(prefix + can.camelCaseToDashCase(key));
        val = Components._castValue(val, obj.type, parentScope);
        if (_.isUndefined(val) && _.has(obj, 'default')) {
          val = obj.default;
        }
        scope[key] = val;
      });

      return _.extend({}, originalScope, scope);
    };
  };

  /**
   * Cast scope values for default types
   *
   * @param {String} val - Value we get from element attribute
   * @param {String} type - Type for the value we need to get
   * @param {object} parentScope - Parent scope
   *
   * @return {Any} - Returns casted types
   */
  Components._castValue = function (val, type, parentScope) {
    var types = {
      'boolean': function (bool) {
        if (_.isBoolean(bool)) {
          return bool;
        }
        return bool === 'true';
      },
      string: function (str) {
        if (_.isString(str)) {
          return str;
        }
        if (_.isEmpty(str)) {
          return;
        }
        return String(str);
      },
      number: function (num) {
        if (_.isNumber(num)) {
          return num;
        }
        num = parseInt(num, 10);
        if (_.isNaN(num)) {
          return;
        }
        return num;
      },
      'function': function (fn) {
        if (!fn || !parentScope.attr(fn)) {
          return;
        }
        return parentScope.attr(fn);
      }
    };
    if (!types[type]) {
      console.warn('Cast value for `' + type + '` is not defined');
      return undefined;
    }

    if (val &&
        type !== 'function' &&
        parentScope.attr(val)) {
      val = parentScope.attr(val);
    }
    return types[type](val);
  };

  // the internal storage of the registered components
  Components._registry = {};

  /**
   * Remove a registered component from the registry.
   *
   * If the component already does not exist, the function silently does
   * nothing.
   *
   * @param {String} name - the name of the component to deregister
   */
  Components.unregister = function (name) {
    delete Components._registry[name];
  };

  /**
   * Checks whether a component exists in the registry.
   *
   * @param {String} name - the name of the component
   * @return {Boolean} - true if the component exists, false false otherwise
   */
  Components.isRegistered = function (name) {
    return !_.isUndefined(Components._registry[name]);
  };

  /**
   * Retrieve a component from the registry.
   *
   * If the component is not found, an error is thrown.
   *
   * @param {String} name - the name of the component to retrieve
   * @return {Function} - the component's constructor function
   */
  Components.get = function (name) {
    var component = Components._registry[name];

    if (!component) {
      throw new Error('Component not found: ' + name);
    }

    return Components._registry[name];
  };
})(window.GGRC = window.GGRC || {}, can, _);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function ($) {
  function openclose(command) {
    var $that = $(this);
    var useSlide = $that.length < 100;

    $that.each(function () {
      var $this = $(this);
      var $main = $this.closest('.item-main');
      var $li = $main.closest('li');
      var $content = $li.children('.item-content');
      var $icon = $main.find('.openclose');
      var $parentTree = $this.closest('ul.new-tree');
      var cmd = command;

      if (typeof cmd !== 'string' || cmd === 'toggle') {
        cmd = $icon.hasClass('active') ? 'close' : 'open';
      }

      if (cmd === 'close') {
        if (useSlide) {
          $content.slideUp('fast');
        } else {
          $content.css('display', 'none');
        }
        $icon.removeClass('active');
        $li.removeClass('item-open');
        // Only remove tree open if there are no open siblings
        if (!$li.siblings('.item-open').length) {
          $parentTree.removeClass('tree-open');
        }
        $content.removeClass('content-open');
      } else if (cmd === 'open') {
        if (useSlide) {
          $content.slideDown('fast');
        } else {
          $content.css('display', 'block');
        }
        $icon.addClass('active');
        $li.addClass('item-open');
        $parentTree.addClass('tree-open');
        $content.addClass('content-open');
      }
    });

    return this;
  }
  $.fn.openclose = openclose;
})(jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function($) {
  // Fix positioning of bootstrap tooltips when on left/right edge of screen
  // Possibly remove this when upgrade to Bootstrap 2.3.0 (which has edge detection)
  var _tooltip_show = $.fn.tooltip.Constructor.prototype.show;
  $.fn.tooltip.Constructor.prototype.show = function() {
    var margin = 10,
      container_width = document.width,
      tip_pos, $arrow, offset, return_value;

    if (!this.hasContent() || !this.enabled) {
      return; // because _tooltip_show will do this too
    }

    _tooltip_show.apply(this);

    return_value = this.$tip.css({
      'white-space': 'normal'
    });

    tip_pos = this.$tip.position();
    tip_pos.width = this.$tip.width();
    tip_pos.height = this.$tip.height();
    $arrow = this.$tip.find('.tooltip-arrow');

    offset = tip_pos.left + tip_pos.width - container_width + margin;
    if (offset > 0) {
      this.$tip.css({
        left: tip_pos.left - offset
      });
      $arrow.css({
        left: parseInt($arrow.css('left')) + offset
      });
    } else if (tip_pos.left < margin) {
      this.$tip.css({
        left: margin
      });
      $arrow.css({
        left: parseInt($arrow.css('left')) + tip_pos.left - margin
      });
    }

    return return_value;
  };

  // Monitor Bootstrap Tooltips to remove the tooltip if the triggering element
  // becomes hidden or removed.
  //
  // * $currentTip needed because tooltips don't fire events until Bootstrap
  //   2.3.0 and $currentTarget.tooltip('hide') doesn't seem to work when it's
  //   not in the DOM
  // * $currentTarget.data('tooltip-monitor') is a flag to ensure only one
  //   monitor per element
  function monitorTooltip($currentTarget) {
    var monitorFn,
      monitorPeriod = 500,
      monitorTimeoutId = null,
      $currentTip,
      dataTooltip;

    if (!$currentTarget.data('tooltip-monitor')) {
      dataTooltip = $currentTarget.data('tooltip');
      $currentTip = dataTooltip && dataTooltip.$tip;

      monitorFn = function() {
        dataTooltip = dataTooltip || $currentTarget.data('tooltip');
        $currentTip = $currentTip || (dataTooltip && dataTooltip.$tip);

        if (!$currentTarget.is(':visible')) {
          $currentTip && $currentTip.remove();
          $currentTarget.data('tooltip-monitor', false);
        } else if ($currentTip && $currentTip.is(':visible')) {
          monitorTimeoutId = setTimeout(monitorFn, monitorPeriod);
        } else {
          $currentTarget.data('tooltip-monitor', false);
        }
      };

      monitorTimeoutId = setTimeout(monitorFn, monitorPeriod);
      $currentTarget.data('tooltip-monitor', true);
    }
  }
  ;

  $('body').on('shown', '.modal', function() {
    $('.tooltip').hide();
  });

  // Listeners for initial tooltip mouseovers
  $('body').on('mouseover', '[data-toggle="tooltip"], [rel=tooltip]', function(e) {
    var $currentTarget = $(e.currentTarget);

    if (!$currentTarget.data('tooltip')) {
      $currentTarget
        .tooltip({
          delay: {
            show: 500,
            hide: 0
          }
        })
        .triggerHandler(e);
    }

    monitorTooltip($currentTarget);
  });
})(jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function ($) {
  var defaults = {
    delay: {
      show: 500,
      hide: 100
    },
    placement: 'left',
    content: function (trigger) {
      var $el = $(new Spinner().spin().el);
      $el.css({
        width: '100px',
        height: '100px',
        left: '50px',
        top: '50px',
        zIndex: calculate_spinner_z_index
      });
      return $el[0];
    }
  };

  // Listeners for initial mouseovers for stick-hover
  $('body').on('mouseover', '[data-popover-trigger="sticky-hover"]', function (e) {
    // If popover instance doesn't exist already, create it and
    // force the 'enter' event.
    if (!$(e.currentTarget).data('sticky_popover')) {
      $(e.currentTarget)
        .sticky_popover($.extend({}, defaults, {
          trigger: 'sticky-hover',
          placement: function () {
            var $el = this.$element;
            var spaceLeft = $(document).width() - ($el.offset().left + $el.width());
            var spaceRight = $el.offset().left;
            var popover_size = 620;
            // Display on right if there is enough space
            if ($el.closest('.widget-area:first-child').length && spaceLeft > popover_size) {
              return 'right';
            } else if (spaceRight > popover_size) {
              return 'left';
            }
            return 'top';
          }
        }))
        .triggerHandler(e);
    }
  });

  // Listeners for initial clicks for popovers
  $('body').on('click', 'a[data-popover-trigger="click"]', function (e) {
    e.preventDefault();
    if (!$(e.currentTarget).data('sticky_popover')) {
      $(e.currentTarget)
        .sticky_popover($.extend({}, defaults, {
          trigger: 'click'
        }))
        .triggerHandler(e);
    }
  });

  function showhide(upsel, downsel) {
    return function (command) {
      $(this).each(function () {
        var $this = $(this);
        var $content = $this.closest(upsel).find(downsel);
        var cmd = command;

        if (typeof cmd !== 'string' || cmd === 'toggle') {
          cmd = $this.hasClass('active') ? 'hide' : 'show';
        }
        if (cmd === 'hide') {
          $content.slideUp();
          $this.removeClass('active');
        } else if (cmd === 'show') {
          $content.slideDown();
          $this.addClass('active');
        }
      });

      return this;
    };
  }

  $.fn.showhide = showhide('.widget', '.content', '.filter');
  $.fn.modal_showhide = showhide('.modal', '.hidden-fields-area');
  $.fn.widget_showhide = showhide('.info', '.hidden-fields-area');
  $.fn.widget_showhide_custom = showhide('.info', '.hidden-fields-area-custom');
  $.fn.widget_showhide_mapped = showhide('.custom-attr-wrap', '.hidden-fields-area');

  $('body').on('click', '.expand-link a', $.fn.modal_showhide);
  $('body').on('click', '.info-expand a', $.fn.widget_showhide);
  $('body').on('click', '.info-expand-custom a', $.fn.widget_showhide_custom);
  $('body').on('click', '.info-expand-mapped a', $.fn.widget_showhide_mapped);

  // Show/hide tree leaf content
  $('body').on('click', '.tree-structure .oneline, .tree-structure .description, .tree-structure .view-more', oneline);

  function oneline(command) {
    $(this).each(function () {
      var $this = $(this);
      var $leaf = $this.closest('[class*=span]').parent().children('[class*=span]:first');
      var $title = $leaf.find('.oneline');
      var $description = $leaf.find('.description');
      var $view = $leaf.closest('.row-fluid').find('.view-more');
      var cmd = command;

      if ($description.length > 0) {
        if (typeof cmd !== 'string') {
          cmd = $description.hasClass('in') ? 'hide' : 'view';
        }

        if (cmd === 'view') {
          $description.addClass('in');
          $title.find('.description-inline').addClass('out');
          if ($title.is('.description-only')) {
            $title.addClass('out');
          }
          $view.text('hide');
        } else if (cmd === 'hide') {
          $description.removeClass('in');
          $title.find('.description-inline').removeClass('out');
          if ($title.is('.description-only')) {
            $title.removeClass('out');
          }
          $view.text('view');
        }
      }
    });

    return this;
  }

  $.fn.oneline = oneline;

  // Close other popovers when one is shown
  $('body').on('show.popover', function (e) {
    $('[data-sticky_popover]').each(function () {
      var popover = $(this).data('sticky_popover');
      // popover && popover.hide();
      popover.hide();
    });
  });

  // Close all popovers on custom event
  $('body').on('kill-all-popovers', function (e) {
    // FIXME: This may be incompatible with bootstrap popover assumptions...
    // This is when the triggering element has been removed from the DOM
    // so we have to kill the popover elements themselves.
    $('.popover').remove();
  });
})(jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function(root, $, GGRC) {
  'use strict';

  function Popover(element) {
    this.el = element;
    this.$el = $(element);
    this.$body = $('body');
    this.file = this.$el.data('get-template');
    this.template = $(this.get_template());
    this._isShown = false;

    if (!this.template || !this.template.length) {
      return;
    }
    this.init();
    this.bindEvents();
  }
  Popover.prototype.get_template = function () {
    return $.parseHTML(GGRC.Templates[this.file]);
  };
  Popover.prototype.bindEvents = function () {
    this.$el.on('click', $.proxy(this.displayToggle, this));
    this.$body.on('click', $.proxy(this.clickOutside, this));
  };
  Popover.prototype.close = function (evnt) {
    if (evnt) {
      evnt.preventDefault();
    }
    this.popover.hide();
    this._isShown = false;
  };
  Popover.prototype.inElement = function (target, elements) {
    return $.map(elements, function (element) {
        return target.closest(element).length || target.is(element);
      }).some(function (val) {
        return val;
      });
  };
  Popover.prototype.clickOutside = function (evnt) {
    var $target = $(evnt.target);

    if (!this.inElement($target, [this.popover.tip(), this.$el])) {
      this.close();
    }
  };
  Popover.prototype.displayToggle = function (evnt) {
    evnt.preventDefault();

    this.popover[this._isShown ? 'hide' : 'show']();

    if (!this._isShown) {
      this.popover.tip().on('click', '.btn-success', $.proxy(this.close, this));
    }
    this._isShown = !this._isShown;
  };
  Popover.prototype.init = function () {
    this.popover = this.$el.popover({
      trigger: 'manual',
      html: true,
      placement: function (el, src) {
        $(el).addClass('popover-help-wrap');
        return 'bottom';
      }.bind(this),
      title: function () {
        return this.template.find('.popup__title').text();
      }.bind(this),
      content: function () {
        return this.template.find('.popup__content').html();
      }.bind(this)
    }).data('popover');
  };

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this),
          data = $this.data('popover-template');

      if (!data) {
        $this.data('popover-template', new Popover(this));
      }
    });
  }
  $.fn.popover_template = Plugin;
  $.fn.popover_template.Constructor = Popover;

  $('body').on('mouseover.popover-template', '.popover-template', function (evnt) {
    $(evnt.currentTarget).popover_template();
  });
})(window, jQuery, GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, _) {
  'use strict';
  /**
   * Tree View Widgets Configuration module
   */
  var allTypes = [
    'AccessGroup', 'Audit', 'Clause', 'Contract', 'Control', 'Assessment',
    'DataAsset', 'Facility', 'Issue', 'Market', 'Objective', 'OrgGroup',
    'Person', 'Policy', 'Process', 'Product', 'Program', 'Project',
    'Regulation', 'Request', 'Section', 'Standard', 'System', 'Vendor'
  ];
  // Items allowed for mapping via snapshot.
  var snapshotWidgetsConfig = GGRC.config.snapshotable_objects || [];
  // Items allowed for relationship mapping
  var excludeMappingConfig = [
    'Assessment',
    'AssessmentTemplate',
    'Request',
    'Issue'
  ];
  // Extra Tree View Widgets require to be rendered on Audit View
  var auditInclusion = [
    'Person',
    'Program'
  ];
  var baseWidgetsByType;

  var filteredTypes = _.difference(allTypes, excludeMappingConfig);
  // Audit is excluded and created a separate logic for it
  baseWidgetsByType = {
    AccessGroup: _.difference(filteredTypes, ['AccessGroup']),
    Audit: [].concat(snapshotWidgetsConfig, excludeMappingConfig,
      auditInclusion).sort(),
    Clause: _.difference(filteredTypes, ['Clause']),
    Contract: _.difference(filteredTypes,
      ['Contract', 'Policy', 'Regulation', 'Standard']),
    Control: filteredTypes,
    Assessment: _.difference(filteredTypes, ['Assessment']),
    DataAsset: filteredTypes,
    Facility: filteredTypes,
    Issue: filteredTypes,
    Market: filteredTypes,
    Objective: filteredTypes,
    OrgGroup: filteredTypes,
    Person: _.difference(filteredTypes, ['Person']),
    Policy: _.difference(filteredTypes,
      ['Contract', 'Policy', 'Regulation', 'Standard']),
    Process: filteredTypes,
    Product: filteredTypes,
    Program: _.difference(filteredTypes, ['Program']),
    Project: filteredTypes,
    Regulation: _.difference(filteredTypes,
      ['Contract', 'Policy', 'Regulation', 'Standard']),
    Section: filteredTypes,
    Standard: _.difference(filteredTypes,
      ['Contract', 'Policy', 'Regulation', 'Standard']),
    System: filteredTypes,
    Vendor: filteredTypes
  };

  GGRC.tree_view = GGRC.tree_view || new can.Map();
  GGRC.tree_view.attr('base_widgets_by_type', baseWidgetsByType);
})(this.GGRC, this._);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/


(function (root, GGRC, $, can) {
  var doc = root.document,
    body = doc.body,
    $win = $(root),
    $doc = $(doc),
    $body = $(body);


  $win.on('hashchange', function () {
    GGRC.current_url_compute(window.location);
  });
  $.migrateMute = true; // turn off console warnings for jQuery-migrate

  function ModelError(message, data) {
    this.name = "ModelError";
    this.message = message || "Invalid Model encountered";
    this.data = data;
  }
  ModelError.prototype = Error.prototype;
  root.cms_singularize = function (type) {
    type = type.trim();
    var _type = type.toLowerCase();
    switch (_type) {
      case "facilities":
        type = type[0] + "acility"; break;
      case "people":
        type = type[0] + "erson"; break;
      case "processes":
        type = type[0] + "rocess"; break;
      case "policies":
        type = type[0] + "olicy"; break;
      case "systems_processes":
        type = type[0] + "ystem_" + type[8] + "rocess";
        break;
      default:
        type = type.replace(/s$/, "");
    }
    return type;
  };
  root.calculate_spinner_z_index = function () {
    var zindex = 0;
    $(this).parents().each(function () {
      var z = parseInt($(this).css("z-index"), 10);
      if (z) {
        zindex = z;
        return false;
      }
    });
    return zindex + 10;
  };

  $doc.ready(function () {
    // monitor target, where flash messages are added
    var AUTOHIDE_TIMEOUT = 10000;
    var target = $('section.content div.flash')[0];
    var observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        // check for new nodes
        if (mutation.addedNodes !== null) {
          // remove the success message from non-expandable
          // flash success messages after timeout
          setTimeout(function () {
            $('.flash .alert-autohide').remove();
          }, AUTOHIDE_TIMEOUT);
        }
      });
    });

    var config = {
      attributes: true,
      childList: true,
      characterData: true
    };

    if (target) {
      observer.observe(target, config);
    }

    setTimeout(function () {
      $('.flash .alert-success').not(':has(ul.flash-expandable)').remove();
    }, 5000);

    // TODO: Not AJAX friendly
    $('.bar[data-percentage]').each(function () {
      $(this).css({
        width: $(this).data('percentage') + '%'
      });
    });


    // tree
    $body.on('click', 'ul.tree .item-title', function (e) {
      var $this = $(this),
        $content = $this.closest('li').find('.item-content');

      if ($this.hasClass("active")) {
        $content.slideUp('fast');
        $this.removeClass("active");
      } else {
        $content.slideDown('fast');
        $this.addClass("active");
      }

    });
    $body.on("change", ".rotate_assessment", function (ev) {
      ev.currentTarget.click(function () {
        ev.currentTarget.toggle();
      });
    });
    setTimeout(function () {
      GGRC.queue_event(
        can.map(GGRC.Templates, function (template, id) {
          var key = can.view.toId(GGRC.mustache_path + "/" + id + ".mustache");
          if (!can.view.cachedRenderers[key]) {
            return function () {
              can.view.mustache(key, template);
            };
          }
        })
      );
    }, 2000);
  });

  $win.load(function () {
    // affix setup
    $win.scroll(function () {
      if ($('.header-content').hasClass('affix')) {
        $('.header-content').next('.content').addClass('affixed');
      } else {
        $('.header-content').next('.content').removeClass('affixed');
      }
    });
    $body.on('click', 'ul.tree-structure .item-main .grcobject, ul.tree-structure .item-main .openclose', function (evnt) {
      evnt.stopPropagation();
      $(this).openclose();
    });
    // Google Circle CTA Button
    $body.on('mouseenter', '.square-trigger', function () {
      var $this = $(this),
        $popover = $this.closest('.circle-holder').find('.square-popover');

      $popover.slideDown('fast');
      $this.addClass("active");
      return false;
    });
    $body.on('mouseleave', '.square-popover', function () {
      var $this = $(this),
        $trigger = $this.closest('.circle-holder').find('.square-trigger');

      $this.slideUp('fast');
      $trigger.removeClass('active');
      $this.removeClass("active");
      return false;
    });
    // References popup preview
    $body.on('mouseenter', '.new-tree .tree-info a.reference', function () {
      if ($(this).width() > $('.new-tree .tree-info').width()) {
        $(this).addClass('shrink-it');
      }
    });

    // Popover trigger for person tooltip in styleguide
    // The popover disappears if the show/hide isn't controlled manually
    var last_popover;
    $body.on('mouseenter', '.person-tooltip-trigger', function (ev) {
      var target = $(ev.currentTarget),
        content = target.closest('.person-holder').find('.custom-popover-content').html();

      if (!content) {
        // Don't show tooltip if there is no content
        return;
      }
      if (!target.data('popover')) {
        target.popover({
          html: true,
          delay: {
            show: 400,
            hide: 200
          },
          trigger: 'manual',
          content: function () {
            return content;
          }
        });
        target.data('popover').tip().addClass('person-tooltip').css("z-index", 2000);
      }
      var popover = target.data('popover');
      if (last_popover && last_popover !== popover) {
        last_popover.hide();
      }

      // If the popover is active, just refresh the timeout
      if (popover.tip().is(':visible') && popover.timeout) {
        clearTimeout(popover.timeout);
        popover.hoverState = 'in';
      }
      // Otherwise show popover
      else {
        clearTimeout(popover.timeout);
        popover.enter(ev);
      }

      last_popover = popover;
    });
    $body.on('mouseenter', '.popover', function (ev) {
      // Refresh the popover
      if (last_popover && last_popover.tip().is(':visible')) {
        ev.currentTarget = last_popover.$element[0];
        clearTimeout(last_popover.timeout);
        last_popover.hoverState = 'in';
      }
    });
    $body.on('mouseleave', '.person-holder, .person-tooltip-trigger, .popover, .popover .square-popover', function (ev) {
      var target = $(ev.currentTarget),
        popover
      ;

      if (target.is('.person-tooltip-trigger')) {
        target = target.closest('.person-holder');
      } else if (target.is('.square-popover')) {
        target = target.closest('.popover');
      }

      // Hide the popover if we left for good
      if (target.is('.person-holder') && (target = target.find('.person-tooltip-trigger')) && (popover = target.data('popover'))) {
        ev.currentTarget = target[0];
        popover.leave(ev);
      }
      // Check if this popover originated from the last person popover
      else if (last_popover && target.is('.popover') && last_popover.tip()[0] === target[0]) {
        ev.currentTarget = last_popover.$element[0];
        last_popover.leave(ev);
      }
    });

    // Tab indexing form fields in modal
    $body.on('focus', '.modal', function () {
      $('.wysiwyg-area').each(function () {
        var $this = $(this),
          $textarea = $this.find('textarea.wysihtml5').attr('tabindex'),
          $descriptionField = $this.find('iframe.wysihtml5-sandbox');

        function addingTabindex() {
          $descriptionField.attr('tabindex', $textarea);
        }
        setTimeout(addingTabindex, 100);
      });
    });

    // Prevent link popup in code mode
    $body.on('click', 'a[data-wysihtml5-command=popupCreateLink]', function (e) {
      var $this = $(this);
      if ($this.hasClass('disabled')) {
        // The button is disabled, close the modal immediately
        $('body').find('.bootstrap-wysihtml5-insert-link-modal').modal('hide');
        $this.closest('.wysiwyg-area').find('textarea').focus();
      }
    });

    // Watermark trigger
    $body.on('click', '.watermark-trigger', function () {
      var $this = $(this),
        $showWatermark = $this.closest('.tree-item').find('.watermark-icon');

      $showWatermark.fadeIn('fast');
      $this.addClass("active");
      $this.html('<span class="utility-link"><i class="fa fa-check-square-o"></i> Watermarked</span>');

      return false;
    });

    // top nav dropdown position
    function dropdownPosition() {
      var $this = $(this),
        $dropdown = $this.closest(".hidden-widgets-list").find(".dropdown-menu"),
        $menu_item = $dropdown.find(".inner-nav-item").find("a"),
        offset = $this.offset(),
        win = $(window),
        win_width = win.width();

      if (win_width - offset.left < 322) {
        $dropdown.addClass("right-pos");
      } else {
        $dropdown.removeClass("right-pos");
      }
      if ($menu_item.length === 1) {
        $dropdown.addClass("one-item");
      } else {
        $dropdown.removeClass("one-item");
      }
    }
    $(".dropdown-toggle").on("click", dropdownPosition);
  });
  root.getPageToken = function getPageToken() {
    return $(document.body).data("page-subtype")
      || $(document.body).data("page-type")
      || window.location.pathname.substring(1, (window.location.pathname + "/").indexOf("/", 1));
  };
  // Make sure GGRC.config is defined (needed to run Karma tests)
  GGRC.config = GGRC.config || {};
})(window, GGRC, jQuery, can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function($) {

/**
 * GGRC.RequestStore caches GGRC API requests in session or local storage.  It
 * is mostly used for generating ad-hoc fixtures to distinguish latency due to
 * service requests from latency due to UI.
 *
 * To start recording:
 *    GGRC.RequestStore.set_record(true)
 * To start replaying:
 *    GGRC.RequestStore.set_replay(true)
 * To reset (stop recording, stop replaying):
 *    GGRC.RequestStore.pause()
 * To clear all data:
 *    GGRC.RequestStore.clear()
 */
GGRC.RequestStore = function() {
  // From https://www.artandlogic.com/blog/2013/06/ajax-caching-transports-compatible-with-jquery-deferred/
  var storage = (typeof sessionStorage === 'undefined') ?
      (typeof localStorage === 'undefined') ? {
          getItem: function(key){
              return this.store[key];
          },
          setItem: function(key, value){
              this.store[key] = value;
          },
          removeItem: function(key){
              delete this.store[key];
          },
          clear: function(){
              for (var key in this.store)
              {
                  if (this.store.hasOwnProperty(key)) delete this.store[key];
              }
          },
          store:{}
      } : localStorage : sessionStorage;

  // Transport layer for saving responses from API requests and short-
  // circuiting later, duplicate requests
  var record_replay_transport = function(options, _originalOptions, _jqXHR) {
    var recording = storage.getItem("RequestStore.record"),
        replaying = storage.getItem("RequestStore.replay");

    if (_originalOptions._canonical_url) {
      //console.debug("Found re-entrant request: " + _originalOptions._canonical_url);
      return;
    }

    if (options.type !== "GET") {
      return;
    }

    var url = options.url,
        match = url.match(/^(.*)([?&])_=\d+(?:([?&])(.*))?$/);

    if (match) {
      if (match[4]) {
        url = match[1] + match[2] + match[4];
      }
      else {
        url = match[1];
      }
    }

    _originalOptions._canonical_url = url;

    return {
      send: function(headers, completeCallback) {
        var data = null;
        if (replaying) {
          data = storage.getItem("RequestStore:" + url);
          if (data) {
            console.debug('Using cache: ', url);
            setTimeout(function() {
              completeCallback(200, 'success', { json: JSON.parse(data) });
            }, 1);
          }
          else {
            console.debug('Missed cache: ', url);
          }
        }

        if (!data && (!replaying || recording)) {
          //console.debug('Using server: ', url);
          jQuery.ajax(_originalOptions).done(function(data, statusText, jqXHR) {
            if (recording) {
              console.debug('Recording: ', url);
              storage.setItem("RequestStore:" + url, JSON.stringify(data));
            }
            completeCallback(jqXHR.status, statusText, { json: data });
          }).fail(function() {
            console.debug('fail', arguments);
          });
        }
      },
      abort: function() {
        console.debug("Aborted ajax");
      }
    };
  };

  // Only apply Ajax Transport when requested
  var enabled = false;
  var enable_record_replay_transport = function() {
    if (!enabled) {
      $.ajaxTransport("json", record_replay_transport);
      enabled = true;
    }
  };

  // Initialize Ajax Transport if storage record or replay is enabled
  var recording = storage.getItem("RequestStore.record"),
      replaying = storage.getItem("RequestStore.replay");
  if (recording || replaying) {
    enable_record_replay_transport();
  }

  return {
    set_record: function(state) {
      if (state) {
        enable_record_replay_transport();
        storage.setItem("RequestStore.record", true);
      } else {
        storage.removeItem("RequestStore.record");
      }
    },

    set_replay: function(state) {
      if (state) {
        enable_record_replay_transport();
        storage.setItem("RequestStore.replay", true);
      } else {
        storage.removeItem("RequestStore.replay");
      }
    },

    clear: function() {
      storage.clear();
    },

    pause: function() {
      this.set_record(false);
      this.set_replay(false);
    }
  };
}();

})(jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (namespace, $, can) {

//chrome likes to cache AJAX requests for Mustaches.
var mustache_urls = {};
$.ajaxPrefilter(function ( options, originalOptions, jqXHR ) {
  if ( /\.mustache$/.test(options.url) ) {
    if (mustache_urls[options.url]) {
      options.url = mustache_urls[options.url];
    } else {
      mustache_urls[options.url] = options.url += "?r=" + Math.random();
    }
  }
});

function get_template_path(url) {
  var match;
  match = url.match(/\/static\/(mustache|mockups)\/(.*)\.mustache/);
  return match && match[2];
}

// Check if the template is available in "GGRC.Templates", and if so,
//   short-circuit the request.

$.ajaxTransport('text', function (options, _originalOptions, _jqXHR) {
  var template_path = get_template_path(options.url);
  var template = template_path && GGRC.Templates[template_path];
  if (template) {
    return {
      send: function (headers, completeCallback) {
        function done() {
          if (template) {
            completeCallback(200, 'success', {text: template});
          }
        }
        if (options.async) {
          // Use requestAnimationFrame where possible because we want
          // these to run as quickly as possible but still release
          // the thread.
          (window.requestAnimationFrame || window.setTimeout)(done, 0);
        } else {
          done();
        }
      },

      abort: function () {
        template = null;
      }
    };
  }
});

var quickHash = function (str, seed) {
  var bitval = seed || 1;
  str = str || '';
  for (var i = 0; i < str.length; i++)
  {
    bitval *= str.charCodeAt(i);
    bitval = Math.pow(bitval, 7);
    bitval %= Math.pow(7, 37);
  }
  return bitval;
};


var getParentNode = function (el, defaultParentNode) {
  return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
};


function isExtendedFalsy(obj) {
  return !obj
    || (typeof obj === "object" && can.isEmptyObject(obj))
    || (obj.length != null && obj.length === 0)
    || (obj.serialize && can.isEmptyObject(obj.serialize()));
}

function preprocessClassString(str) {
  var ret = []
  , src = str.split(" ");

  for (var i = 0; i < src.length; i++) {
    var expr = src[i].trim();
    if (expr.charAt(0) === "=") {
      ret.push({ attr : src[i].trim().substr(1) });
    } else if (expr.indexOf(":") > -1) {
      var spl = expr.split(":");
      var arr = [];
      for (var j = 0; j < spl.length - 1; j ++) {
        var inverse = spl[j].trim()[0] === "!"
        , attr_name = spl[j].trim().substr(inverse ? 1 : 0);

        arr.push({attr : attr_name, inverse : inverse});
      }
      arr.value = spl[spl.length - 1];
      ret.push(arr);
    } else {
      ret.push(expr);
    }
  }
  return ret;
}

function buildClassString(arr, context) {
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (typeof arr[i] === "string") {
      ret.push(arr[i]);
    } else if (typeof arr[i] === "object" && arr[i].attr) {
      ret.push(can.getObject(arr[i].attr, context));
    } else if (can.isArray(arr[i]) && arr[i].value) {
      var p = true;
      for (var j = 0; j < arr[i].length; j ++) {
        var attr = can.getObject(arr[i][j].attr, context);
        if (arr[i][j].inverse ? !isExtendedFalsy(attr) : isExtendedFalsy(attr)) {
          p = false;
          break;
        }
      }
      if (p) {
        ret.push(arr[i].value);
      }
    } else {
      throw "Unsupported class building expression: " + JSON.stringify(arr[i]);
    }
  }

  return ret.join(" ");
}

Mustache.registerHelper("addclass", function (prefix, compute, options) {
  prefix = resolve_computed(prefix);
  var separator = 'separator' in (options.hash || {}) ? options.hash.separator : '-';
  return function (el) {
    var curClass = null
      , wasAttached = false
      , callback
      ;

    callback = function (_ev, newVal, _oldVal) {
      var nowAttached = $(el).closest('body').length > 0
        , newClass = null
        ;

      //  If we were once attached and now are not, unbind this callback.
      if (wasAttached && !nowAttached) {
        compute.unbind('change', callback);
        return;
      } else if (nowAttached && !wasAttached) {
        wasAttached = true;
      }
      if (newVal && newVal.toLowerCase) {
        newClass = prefix + newVal.toLowerCase().replace(/[\s\t]+/g, separator);
      }
      if (curClass) {
        $(el).removeClass(curClass);
        curClass = null;
      }
      if (newClass) {
        $(el).addClass(newClass);
        curClass = newClass;
      }
    };

    compute.bind('change', callback);
    callback(null, resolve_computed(compute));
  };
});

/**
  Add a live bound attribute to an element, avoiding buggy CanJS attribute interpolations.
  Usage:
  {{#withattr attrname attrvalue attrname attrvalue...}}<element/>{{/withattr}} to apply to the child element
  {{{withattr attrname attrvalue attrname attrvalue...}}} to apply to the parent element a la XSLT <xsl:attribute>. Note the triple braces!
  attrvalue can take mustache tokens, but they should be backslash escaped.
*/
Mustache.registerHelper("withattr", function () {
  var args = can.makeArray(arguments).slice(0, arguments.length - 1)
  , options = arguments[arguments.length - 1]
  , attribs = []
  , that = this.___st4ck ? this[this.length-1] : this
  , data = can.extend({}, that)
  , hash = quickHash(args.join("-"), quickHash(that._cid)).toString(36)
  , attr_count = 0;

  var hook = can.view.hook(function (el, parent, view_id) {
    var content = options.fn(that);

    if (content) {
      var frag = can.view.frag(content, parent);
      var $newel = $(frag.querySelector("*"));
      var newel = $newel[0];

      el.parentNode ? el.parentNode.replaceChild(newel, el) : $(parent).append($newel);
      el = newel;
    } else {
      //we are inside the element we want to add attrs to.
      var p = el.parentNode;
      p.removeChild(el);
      el = p;
    }

    function sub_all(el, ev, newVal, oldVal) {
      var $el = $(el);
      can.each(attribs, function (attrib) {
        $el.attr(attrib.name, $("<div>").html(can.view.render(attrib.value, data)).html());
      });
    }

    for (var i = 0; i < args.length - 1; i += 2) {
      var attr_name = args[i];
      var attr_tmpl = args[i + 1];
      //set up bindings where appropriate
      attr_tmpl = attr_tmpl.replace(/\{[^\}]*\}/g, function (match, offset, string) {
        var token = match.substring(1, match.length - 1);
        if (typeof data[token] === "function") {
          data[token].bind && data[token].bind("change." + hash, $.proxy(sub_all, that, el));
          data[token] = data[token].call(that);
        }

        that.bind && that.bind(token + "." + hash, $.proxy(sub_all, that, el));

        return "{" + match + "}";
      });
      can.view.mustache("withattr_" + hash + "_" + (++attr_count), attr_tmpl);
      attribs.push({name : attr_name, value : "withattr_" + hash + "_" + attr_count });
    }

    sub_all(el);

  });

  return "<div"
  + hook
  + " data-replace='true'/>";
});

Mustache.registerHelper("if_equals", function (val1, val2, options) {
  var that = this, _val1, _val2;
  function exec() {
    if (_val1 && val2 && options.hash && options.hash.insensitive) {
      _val1 = _val1.toLowerCase();
      _val2 = _val2.toLowerCase();
    }
    if (_val1 == _val2) return options.fn(options.contexts);
    else return options.inverse(options.contexts);
  }
    if (typeof val1 === "function") {
      if (val1.isComputed) {
        val1.bind("change", function (ev, newVal, oldVal) {
          _val1 = newVal;
          return exec();
        });
      }
      _val1 = val1.call(this);
    } else {
      _val1 = val1;
    }
    if (typeof val2 === "function") {
      if (val2.isComputed) {
        val2.bind("change", function (ev, newVal, oldVal) {
          _val2 = newVal;
          exec();
        });
      }
      _val2 = val2.call(this);
    } else {
      _val2 = val2;
    }

  return exec();
});

Mustache.registerHelper("if_match", function (val1, val2, options) {
  var that = this
  , _val1 = resolve_computed(val1)
  , _val2 = resolve_computed(val2);
  function exec() {
    var re = new RegExp(_val2);
    if (re.test(_val1)) return options.fn(options.contexts);
    else return options.inverse(options.contexts);
  }
  return exec();
});

Mustache.registerHelper("in_array", function (needle, haystack, options) {
  needle = resolve_computed(needle);
  haystack = resolve_computed(haystack);

  return options[~can.inArray(needle, haystack) ? "fn" : "inverse"](options.contexts);
});

Mustache.registerHelper("if_null", function (val1, options) {
  var that = this, _val1;
  function exec() {
    if (_val1 == null) return options.fn(that);
    else return options.inverse(that);
  }
    if (typeof val1 === "function") {
      if (val1.isComputed) {
        val1.bind("change", function (ev, newVal, oldVal) {
          _val1 = newVal;
          return exec();
        });
      }
      _val1 = val1.call(this);
    } else {
      _val1 = val1;
    }
  return exec();
});

  /**
   * Check if the given argument is a string and render the corresponding
   * block in the template.
   *
   * Example usage:
   *
   *   {{#if_string someValue}}
   *      {{someValue}} is a string
   *   {{else}}
   *     {{someValue}} is NOT a string
   *   {{/if_string}}
   *
   * @param {*} thing - the argument to check
   * @param {Object} options - a CanJS options argument passed to every helper
   *
   */
  Mustache.registerHelper('if_string', function (thing, options) {
    var resolved;

    if (arguments.length !== 2) {
      throw new Error(
        'Invalid number of arguments (' +
        (arguments.length - 1) +  // do not count the auto-provided options arg
        '), expected 1.');
    }

    resolved = Mustache.resolve(thing);

    if (_.isString(resolved)) {
      return options.fn(options.context);
    }

    return options.inverse(options.context);
  });

  /**
   * Return the value of the given object's property.
   *
   * If the first argument is not an object, an error is raised.
   *
   * @param {Object | Function} object - the object itself
   * @param {String | Function} key - the name of the property to retrieve
   * @param {Object} options - the Mustache options object
   *
   * @return {*} - the value of the property object[key]
   */
  Mustache.registerHelper('get_item', function (object, key, options) {
    if (arguments.length !== 3) {
      throw new Error(
        'Invalid number of arguments (' +
        (arguments.length - 1) +  // do not count the auto-provided options arg
        '), expected 2.');
    }

    object = Mustache.resolve(object);

    if (!_.isObject(object)) {
      throw new Error('First argument must be an object.');
    }

    key = Mustache.resolve(key);
    return object[key];
  });

// Resolve and return the first computed value from a list
Mustache.registerHelper("firstexist", function () {
  var args = can.makeArray(arguments).slice(0, arguments.length - 1);  // ignore the last argument (some Can object)
  for (var i = 0; i < args.length; i++) {
    var v = resolve_computed(args[i]);
    if (v && v.length) {
      return v.toString();
    }
  }
  return "";
});

// Return the first value from a list that computes to a non-empty string
Mustache.registerHelper("firstnonempty", function () {
  var args = can.makeArray(arguments).slice(0, arguments.length - 1);  // ignore the last argument (some Can object)
  for (var i = 0; i < args.length; i++) {
    var v = resolve_computed(args[i]);
    if (v != null && !!v.toString().trim().replace(/&nbsp;|\s|<br *\/?>/g, "")) return v.toString();
  }
  return "";
});

Mustache.registerHelper("pack", function () {
  var options = arguments[arguments.length - 1];
  var objects = can.makeArray(arguments).slice(0, arguments.length - 1);
  var pack = {};
  can.each(objects, function (obj, i) {
      if (typeof obj === "function") {
        objects[i] = obj = obj();
      }

    if (obj._data) {
      obj = obj._data;
    }
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        pack[k] = obj[k];
      }
    }
  });
  if (options.hash) {
    for (var k in options.hash) {
      if (options.hash.hasOwnProperty(k)) {
        pack[k] = options.hash[k];
      }
    }
  }
  pack = new can.Observe(pack);
  return options.fn(pack);
});


Mustache.registerHelper("is_beta", function () {
  var options = arguments[arguments.length - 1];
  if ($(document.body).hasClass('BETA')) return options.fn(this);
  else return options.inverse(this);
});

Mustache.registerHelper("if_page_type", function (page_type, options) {
  var options = arguments[arguments.length - 1];
  if (window.location.pathname.split('/')[1] == page_type)
    return options.fn(this);
  else
    return options.inverse(this);
});

// Render a named template with the specified context, serialized and
// augmented by 'options.hash'
Mustache.registerHelper("render", function (template, context, options) {
  if (!options) {
    options = context;
    context = this;
  }

  if (typeof context === "function") {
    context = context();
  }

  if (typeof template === "function") {
    template = template();
  }

  context = $.extend({}, context.serialize ? context.serialize() : context);

  if (options.hash) {
    for (var k in options.hash) {
      if (options.hash.hasOwnProperty(k)) {
        context[k] = options.hash[k];
        if (typeof context[k] == "function")
          context[k] = context[k]();
      }
    }
  }

  var ret = can.view.render(template, context instanceof can.view.Scope ? context : new can.view.Scope(context));
  //can.view.hookup(ret);
  return ret;
});

// Like 'render', but doesn't serialize the 'context' object, and doesn't
// apply options.hash
Mustache.registerHelper("renderLive", function (template, context, options) {
  if (!options) {
    options = context;
    context = this;
  } else {
    options.contexts = options.contexts.add(context);
  }

  if (typeof context === "function") {
    context = context();
  }

  if (typeof template === "function") {
    template = template();
  }

  if (options.hash) {
    options.contexts = options.contexts.add(options.hash);
  }

  return can.view.render(template, options.contexts);
});

// Renders one or more "hooks", which are templates registered under a
//  particular key using GGRC.register_hook(), using the current context.
//  Hook keys can be composed with dot separators by passing in multiple
//  positional parameters.
//
// Example: {{{render_hooks 'Audit' 'test_info'}}}  renders all hooks registered
//  with GGRC.register_hook("Audit.test_info", <template path>)
Mustache.registerHelper("render_hooks", function () {
  var args = can.makeArray(arguments),
      options = args.splice(args.length - 1, 1)[0],
      hook = can.map(args, Mustache.resolve).join(".");

  return can.map(can.getObject(hook, GGRC.hooks) || [], function (hook_tmpl) {
    return can.Mustache.getHelper("renderLive", options.contexts).fn(hook_tmpl, options.contexts, options);
  }).join("\n");
});

// Checks whether any hooks are registered for a particular key
Mustache.registerHelper("if_hooks", function () {
  var args = can.makeArray(arguments),
      options = args.splice(args.length - 1, 1)[0],
      hook = can.map(args, Mustache.resolve).join(".");

  if ((can.getObject(hook, GGRC.hooks) || []).length > 0) {
    return options.fn(options.contexts);
  } else {
    return options.inverse(options.contexts);
  }
});

var defer_render = Mustache.defer_render = function defer_render(tag_prefix, funcs, deferred) {
  var hook
    , tag_name = tag_prefix.split(" ")[0]
    ;

  tag_name = tag_name || "span";

  if (typeof funcs === "function") {
    funcs = { done : funcs };
  }

  function hookup(element, parent, view_id) {
    var $element = $(element)
    , f = function () {
      var g = deferred && deferred.state() === "rejected" ? funcs.fail : funcs.done
        , args = arguments
        , term = element.nextSibling
        , compute = can.compute(function () { return g.apply(this, args) || ""; }, this)
        ;

      if (element.parentNode) {
        can.view.live.html(element, compute, parent);
      } else {
        $element.after(compute());
        if ($element.next().get(0)) {
          can.view.nodeLists.update($element.get(), $element.nextAll().get());
          $element.remove();
        }
      }
    };
    if (deferred) {
      deferred.done(f);
      if (funcs.fail) {
        deferred.fail(f);
      }
    }
    else
      setTimeout(f, 13);

    if (funcs.progress) {
      // You would think that we could just do $element.append(funcs.progress()) here
      //  but for some reason we have to hookup our own fragment.
      $element.append(can.view.hookup($("<div>").html(funcs.progress())).html());
    }
  }

  hook = can.view.hook(hookup);
  return ["<", tag_prefix, " ", hook, ">", "</", tag_name, ">"].join("");
};

Mustache.registerHelper("defer", function (prop, deferred, options) {
  var context = this;
  var tag_name;
  if (!options) {
    options = prop;
    prop = "result";
  }

  tag_name = (options.hash || {}).tag_name || "span";
  allow_fail = (options.hash || {}).allow_fail || false;

  deferred = resolve_computed(deferred);
  if (typeof deferred === "function") deferred = deferred();
  function finish(items) {
    var ctx = {};
    ctx[prop] = items;
    return options.fn(options.contexts.add(ctx));
  }
  function progress() {
    return options.inverse(options.contexts);
  }

  return defer_render(tag_name, { done: finish, fail: allow_fail ? finish : null, progress: progress }, deferred);
});

Mustache.registerHelper("allow_help_edit", function () {
  var options = arguments[arguments.length - 1];
  var instance = this && this.instance ? this.instance : options.context.instance;
  if (instance) {
    var action = instance.isNew() ? "create" : "update";
    if (Permission.is_allowed(action, "Help", null)) {
      return options.fn(this);
    } else {
      return options.inverse(this);
    }
  }
  return options.inverse(this);
});

Mustache.registerHelper("all", function (type, params, options) {
  var model = CMS.Models[type] || GGRC.Models[type]
  , $dummy_content = $(options.fn({}).trim()).first()
  , tag_name = $dummy_content.prop("tagName")
  , context = this.instance ? this.instance : this instanceof can.Model.Cacheable ? this : null
  , require_permission = ""
  , items_dfd, hook;

  if (!options) {
    options = params;
    params = {};
  } else {
    params = JSON.parse(resolve_computed(params));
  }
  if ("require_permission" in params) {
    require_permission = params.require_permission;
    delete params.require_permission;
  }

  function hookup(element, parent, view_id) {
    items_dfd.done(function (items) {
      var val
      , $parent = $(element.parentNode)
      , $el = $(element);
      items = can.map(items, function (item) {
        if (require_permission === "" || Permission.is_allowed(require_permission, type, item.context.id)) {
          return item;
        }
      });
      can.each(items, function (item) {
        $(can.view.frag(options.fn(item), parent)).appendTo(element.parentNode);
      });
      if ($parent.is("select")
        && $parent.attr("name")
        && context
      ) {
        val = context.attr($parent.attr("name"));
        if (val) {
          $parent.find("option[value=" + val + "]").attr("selected", true);
        } else {
          context.attr($parent.attr("name").substr(0, $parent.attr("name").lastIndexOf(".")), items[0] || null);
        }
      }
      $parent.parent().find(":data(spinner)").each(function (i, el) {
        var spinner = $(el).data("spinner");
        if (spinner) spinner.stop();
      });
      $el.remove();
      //since we are removing the original live bound element, replace the
      // live binding reference to it, with a reference to the new
      // child nodes. We assume that at least one new node exists.
      can.view.nodeLists.update($el.get(), $parent.children().get());
    });
    return element.parentNode;
  }

  if ($dummy_content.attr("data-view-id")) {
    can.view.hookups[$dummy_content.attr("data-view-id")] = hookup;
  } else {
    hook = can.view.hook(hookup);
    $dummy_content.attr.apply($dummy_content, can.map(hook.split('='), function (s) { return s.replace(/'|"| /, "");}));
  }

  items_dfd = model.findAll(params);
  return "<" + tag_name + " data-view-id='" + $dummy_content.attr("data-view-id") + "'></" + tag_name + ">";
});

can.each(["with_page_object_as", "with_current_user_as"], function (fname) {
  Mustache.registerHelper(fname, function (name, options) {
    if (!options) {
      options = name;
      name = fname.replace(/with_(.*)_as/, "$1");
    }
    var page_object = (fname === "with_current_user_as"
                       ? (CMS.Models.Person.findInCacheById(GGRC.current_user.id)
                          || CMS.Models.Person.model(GGRC.current_user))
                       : GGRC.page_instance()
                       );
    if (page_object) {
      var p = {};
      p[name] = page_object;
      options.contexts = options.contexts.add(p);
      return options.fn(options.contexts);
    } else {
      return options.inverse(options.contexts);
    }
  });
});

Mustache.registerHelper("iterate", function () {
  var i = 0, j = 0
  , args = can.makeArray(arguments).slice(0, arguments.length - 1)
  , options = arguments[arguments.length - 1]
  , step = options.hash && options.hash.step || 1
  , ctx = {}
  , ret = [];

  options.hash && options.hash.listen && Mustache.resolve(options.hash.listen);

  for (; i < args.length; i += step) {
    ctx.iterator = typeof args[i] === "string" ? new String(args[i]) : args[i];
    for (j = 0; j < step; j++) {
      ctx["iterator_" + j] = typeof args[i + j] === "string" ? new String(args[i + j]) : args[i + j];
    }
    ret.push(options.fn(options.contexts.add(ctx)));
  }

  return ret.join("");
});

// Iterate over a string by spliting it by a separator
Mustache.registerHelper("iterate_string", function (str, separator, options) {
  var i = 0, args, ctx = {}, ret = [];

  str = Mustache.resolve(str);
  separator = Mustache.resolve(separator);
  args = str.split(separator);
  for (; i < args.length; i += 1) {
    ctx.iterator = typeof args[i] === "string" ? new String(args[i]) : args[i];
    ret.push(options.fn(options.contexts.add(ctx)));
  }

  return ret.join("");
});

Mustache.registerHelper("option_select", function (object, attr_name, role, options) {
  var selected_option = object.attr(attr_name)
    , selected_id = selected_option ? selected_option.id : null
    , options_dfd = CMS.Models.Option.for_role(role)
    , tabindex = options.hash && options.hash.tabindex
    , tag_prefix = 'select class="span12"'
    ;

  function get_select_html(options) {
    return [
        '<select class="span12" model="Option" name="' + attr_name + '"'
      ,   tabindex ? ' tabindex=' + tabindex : ''
      , '>'
      , '<option value=""'
      ,   !selected_id ? ' selected=selected' : ''
      , '>---</option>'
      , can.map(options, function (option) {
          return [
            '<option value="', option.id, '"'
          ,   selected_id == option.id ? ' selected=selected' : ''
          , '>'
          ,   option.title
          , '</option>'
          ].join('');
        }).join('\n')
      , '</select>'
    ].join('');
  }

  return defer_render(tag_prefix, get_select_html, options_dfd);
});

Mustache.registerHelper("category_select", function (object, attr_name, category_type, options) {
  var selected_options = object[attr_name] || [] //object.attr(attr_name) || []
    , selected_ids = can.map(selected_options, function (selected_option) {
        return selected_option.id;
      })
    , options_dfd = CMS.Models[category_type].findAll()
    , tab_index = options.hash && options.hash.tabindex
    , tag_prefix = 'select class="span12" multiple="multiple"'
    ;

  tab_index = typeof tab_index !== 'undefined' ? ' tabindex="' + tab_index + '"' : '';
  function get_select_html(options) {
    return [
        '<select class="span12" multiple="multiple"'
      ,   ' model="' + category_type + '"'
      ,   ' name="' + attr_name + '"'
      ,   tab_index
      , '>'
      , can.map(options, function (option) {
          return [
            '<option value="', option.id, '"'
          ,   selected_ids.indexOf(option.id) > -1 ? ' selected=selected' : ''
          , '>'
          ,   option.name
          , '</option>'
          ].join('');
        }).join('\n')
      , '</select>'
    ].join('');
  }

  return defer_render(tag_prefix, get_select_html, options_dfd);
});

Mustache.registerHelper("get_permalink_url", function () {
  return window.location.href;
});

Mustache.registerHelper("get_permalink_for_object", function (instance, options) {
  instance = resolve_computed(instance);
  if (!instance.viewLink) {
    return "";
  }
  return window.location.origin + instance.viewLink;
});

  /**
   * Generate an anchor element that opens the instance's view page in a
   * new browser tab/window.
   *
   * If the instance does not have such a page, an empty string is returned.
   * The inner content of the tag is used as the text for the link.
   *
   * Example usage:
   *
   *   {{{#view_object_link instance}}}
   *     Open {{firstexist instance.name instance.title}}
   *   {{{/view_object_link}}}
   *
   * NOTE: Since an HTML snippet is generated, the helper should be used with
   * an unescaping block (tripple braces).
   *
   * @param {can.Model} instance - the object to generate the link for
   * @param {Object} options - a CanJS options argument passed to every helper
   * @return {String} - the link HTML snippet
   */
  Mustache.registerHelper('view_object_link', function (instance, options) {
    var linkText;

    function onRenderComplete(link) {
      var html = [
        '<a ',
        '  href="' + link + '"',
        '  target="_blank"',
        '  class="view-link">',
        linkText,
        '</a>'
      ].join('');
      return html;
    }

    instance = resolve_computed(instance);
    if (!instance.viewLink && !instance.get_permalink) {
      return '';
    }

    linkText = options.fn(options.contexts);

    return defer_render('a', onRenderComplete, instance.get_permalink());
  });

Mustache.registerHelper("schemed_url", function (url) {
  var domain, max_label, url_split;

  url = Mustache.resolve(url);
  if (!url) {
    return;
  }

  if (!url.match(/^[a-zA-Z]+:/)) {
    url = (window.location.protocol === "https:" ? 'https://' : 'http://') + url;
  }

  // Make sure we can find the domain part of the url:
  url_split = url.split('/');
  if (url_split.length < 3) {
    return 'javascript://';
  }

  domain = url_split[2];
  max_label = _.max(domain.split('.').map(function(u) { return u.length; }));
  if (max_label > 63 || domain.length > 253) {
    // The url is invalid and might crash user's chrome tab
    return "javascript://";
  }
  return url;
});

function when_attached_to_dom(el, cb) {
  // Trigger the "more" toggle if the height is the same as the scrollable area
  el = $(el);
  return !function poll() {
    if (el.closest(document.documentElement).length) {
      cb();
    }
    else {
      setTimeout(poll, 100);
    }
  }();
}

Mustache.registerHelper("open_on_create", function (style) {
  return function (el) {
    when_attached_to_dom(el, function () {
      $(el).openclose("open");
    });
  };
});

Mustache.registerHelper("trigger_created", function () {
  return function (el) {
    when_attached_to_dom(el, function () {
      $(el).trigger("contentAttached");
    });
  };
});

Mustache.registerHelper("show_long", function () {
  return  [
      '<a href="javascript://" class="show-long"'
    , can.view.hook(function (el, parent, view_id) {
        el = $(el);

        var content = el.prevAll('.short');
        if (content.length) {
          return !function hide() {
            // Trigger the "more" toggle if the height is the same as the scrollable area
            if (el[0].offsetHeight) {
              if (content[0].offsetHeight === content[0].scrollHeight) {
                el.trigger('click');
              }
            }
            else {
              // If there is an open/close toggle, wait until "that" is triggered
              var root = el.closest('.tree-item')
                , toggle;
              if (root.length && !root.hasClass('item-open') && (toggle = root.find('.openclose')) && toggle.length) {
                // Listen for the toggle instead of timeouts
                toggle.one('click', function () {
                  // Delay to ensure all event handlers have fired
                  setTimeout(hide, 0);
                });
              }
              // Otherwise just detect visibility
              else {
                setTimeout(hide, 100);
              }
            }
          }();
        }
      })
    , ">...more</a>"
  ].join('');
});

Mustache.registerHelper('expose', function (options) {
  var frame = new can.Observe();
  if (options.hash) {
    can.each(options.hash, function (val, prop) {
      frame.attr(prop, Mustache.resolve(val));
    });
  }
  return options.fn(options.contexts.add(frame));
});

Mustache.registerHelper("using", function (options) {
  var refresh_queue = new RefreshQueue()
    , context
    , frame = new can.Observe()
    , args = can.makeArray(arguments)
    , i, arg;

  options = args.pop();
  context = options.contexts || this;

  if (options.hash) {
    for (i in options.hash) {
      if (options.hash.hasOwnProperty(i)) {
        arg = options.hash[i];
        arg = Mustache.resolve(arg);
        if (arg && arg.reify) {
          refresh_queue.enqueue(arg.reify());
          frame.attr(i, arg.reify());
        } else {
          frame.attr(i, arg);
        }
      }
    }
  }

  function finish() {
    return options.fn(options.contexts.add(frame));
  }

  return defer_render('span', finish, refresh_queue.trigger());
});

Mustache.registerHelper("with_mapping", function (binding, options) {
  var context = arguments.length > 2 ? resolve_computed(options) : this
    , frame = new can.Observe()
    , loader
    , stack;

  if (!context) // can't find an object to map to.  Do nothing;
    return;
  binding = Mustache.resolve(binding);
  loader = context.get_binding(binding);
  if (!loader)
    return;
  frame.attr(binding, loader.list);

  options = arguments[2] || options;

  function finish(list) {
    return options.fn(options.contexts.add(_.extend({}, frame, {results: list})));
  }
  function fail(error) {
    return options.inverse(options.contexts.add({error : error}));
  }

  return defer_render('span', { done : finish, fail : fail }, loader.refresh_instances());
});


Mustache.registerHelper("person_roles", function (person, scope, options) {
  var roles_deferred = new $.Deferred()
    , refresh_queue = new RefreshQueue()
    ;

  if (!options) {
    options = scope;
    scope = null;
  }

  person = Mustache.resolve(person);
  person = person.reify();
  refresh_queue.enqueue(person);
  // Force monitoring of changes to `person.user_roles`
  person.attr("user_roles");
  refresh_queue.trigger().then(function () {
    var user_roles = person.user_roles.reify()
      , user_roles_refresh_queue = new RefreshQueue()
      ;
    user_roles_refresh_queue.enqueue(user_roles);
    user_roles_refresh_queue.trigger().then(function () {
      var roles = can.map(
        can.makeArray(user_roles),
        function (user_role) {
          if (user_role.role) {
            return user_role.role.reify();
          }
        })
        , roles_refresh_queue = new RefreshQueue()
        ;
      roles_refresh_queue.enqueue(roles.splice());
      roles_refresh_queue.trigger().then(function () {
        roles = can.map(can.makeArray(roles), function (role) {
          if (!scope || new RegExp(scope).test(role.scope)) {
            return role;
          }
        });

        //  "Superuser" roles are determined from config
        //  FIXME: Abstraction violation
        if ((!scope || new RegExp(scope).test("System"))
            && GGRC.config.BOOTSTRAP_ADMIN_USERS
            && ~GGRC.config.BOOTSTRAP_ADMIN_USERS.indexOf(person.email)) {
          roles.unshift({
            permission_summary: "Superuser",
            name: "Superuser"
          });
        }
        roles_deferred.resolve(roles);
      });
    });
  });

  function finish(roles) {
    return options.fn({ roles: roles });
  }

  return defer_render('span', finish, roles_deferred);
});

Mustache.registerHelper("unmap_or_delete", function (instance, mappings) {
    instance = resolve_computed(instance);
    mappings = resolve_computed(mappings);
  if (mappings.indexOf(instance) > -1) {
    if (mappings.length == 1) {
      if (mappings[0] instanceof CMS.Models.Control)
        return "Unmap";
      else
        return "Delete";
    }
    else
      return "Unmap";// "Unmap and Delete"
  } else
    return "Unmap";
});

Mustache.registerHelper("with_direct_mappings_as",
    function (var_name, parent_instance, instance, options) {
  // Finds the mapping, if any, between `parent_object` and `instance`, then
  // renders the block with those mappings available in the scope as `var_name`

  parent_instance = Mustache.resolve(parent_instance);
  instance = Mustache.resolve(instance);

  if (!instance) {
      instance = [];
  } else if (typeof instance.length === "number") {
      instance = can.map(instance, function (inst) {
        return inst.instance ? inst.instance : inst;
      });
  } else if (instance.instance) {
      instance = [instance.instance];
  } else {
      instance = [instance];
  }

  var frame = new can.Observe();
  frame.attr(var_name, []);
  GGRC.all_local_results(parent_instance).then(function (results) {
    var instance_only = options.hash && options.hash.instances_only;
    can.each(results, function (result) {
      if (~can.inArray(result.instance, instance)) {
        frame.attr(var_name).push(instance_only ? result.instance : result);
      }
    });
  });

  return options.fn(options.contexts.add(frame));
});

Mustache.registerHelper("has_mapped_objects", function (selected, instance, options) {
  selected = resolve_computed(selected);
  instance = resolve_computed(instance);
  if (!selected.objects) {
    options.inverse(options.contexts);
  }
  var isMapped = _.some(selected.objects, function (el) {
        return el.id === instance.id && el.type === instance.type;
      });
  return options[isMapped ? "fn" : "inverse"](options.contexts);
});

Mustache.registerHelper("result_direct_mappings", function (bindings, parent_instance, options) {
  bindings = Mustache.resolve(bindings);
  bindings = resolve_computed(bindings);
  parent_instance = Mustache.resolve(parent_instance);
  var has_direct_mappings = false
    , has_external_mappings = false
    , mappings_type = ""
    , i
    ;

  if (bindings && bindings.length > 0) {
    for (i=0; i<bindings.length; i++) {
      if (bindings[i].instance && parent_instance
          && bindings[i].instance.reify() === parent_instance.reify())
        has_direct_mappings = true;
      else {
        has_external_mappings = true;
      }
    }
  }

  mappings_type = has_direct_mappings ?
      (has_external_mappings ? "Dir & Ext" : "Dir") : "Ext";
  options.context.mappings_type = mappings_type;

  return options.fn(options.contexts);
});

Mustache.registerHelper("if_result_has_extended_mappings", function (
    bindings, parent_instance, options) {
  //  Render the `true` / `fn` block if the `result` exists (in this list)
  //  due to mappings other than directly to the `parent_instance`.  Otherwise
  //  Render the `false` / `inverse` block.
  bindings = Mustache.resolve(bindings);
  bindings = resolve_computed(bindings);
  parent_instance = Mustache.resolve(parent_instance);
  var has_extended_mappings = false
    , i
    ;

  if (bindings && bindings.length > 0) {
    for (i=0; i<bindings.length; i++) {
      if (bindings[i].instance && parent_instance
          && bindings[i].instance.reify() !== parent_instance.reify())
        has_extended_mappings = true;
    }
  }

  if (has_extended_mappings)
    return options.fn(options.contexts);
  else
    return options.inverse(options.contexts);
});

Mustache.registerHelper("each_with_extras_as", function (name, list, options) {
  //  Iterate over `list` and render the provided block with additional
  //  variables available in the context, specifically to enable joining with
  //  commas and using "and" in the right place.
  //
  //  * `<name>`: Instead of rendering with the item as the current context,
  //      make the item available at the specified `name`
  //  * index
  //  * length
  //  * isFirst
  //  * isLast
  name = Mustache.resolve(name);
  list = Mustache.resolve(list);
  list = resolve_computed(list);
  var i
    , output = []
    , frame
    , length = list.length
    ;
  for (i=0; i<length; i++) {
    frame = {
      index : i
      , isFirst : i === 0
      , isLast : i === length - 1
      , isSecondToLast : i === length - 2
      , length : length
    };
    frame[name] = list[i];
    output.push(options.fn(new can.Observe(frame)));

    //  FIXME: Is this legit?  It seems necessary in some cases.
    //context = $.extend([], options.contexts, options.contexts.concat([frame]));
    //output.push(options.fn(context));
    // ...or...
    //contexts = options.contexts.concat([frame]);
    //contexts.___st4ck3d = true;
    //output.push(options.fn(contexts));
  }
  return output.join("");
});

Mustache.registerHelper("link_to_tree", function () {
  var args = [].slice.apply(arguments)
    , options = args.pop()
    , link = []
    ;

  args = can.map(args, Mustache.resolve);
  args = can.map(args, function (stub) { return stub.reify(); });
  link.push("#" + args[0].constructor.table_singular + "_widget");
  //  FIXME: Add this back when extended-tree-routing is enabled
  //for (i=0; i<args.length; i++)
  //  link.push(args[i].constructor.table_singular + "-" + args[i].id);
  return link.join("/");
});

/**
 *  Helper for rendering date or datetime values in current local time
 *
 *  @param {boolean} hideTime - if set to true, render date only
 *  @return {String} - date or datetime string in the following format:
 *    * date: MM/DD/YYYY),
 *    * datetime (MM/DD/YYYY hh:mm:ss [PM|AM] [local timezone])
 */
Mustache.registerHelper('date', function (date, hideTime) {
  return GGRC.Utils.formatDate(date, hideTime);
});

/**
 * Checks permissions.
 * Usage:
 *  {{#is_allowed ACTION [ACTION2 ACTION3...] RESOURCE_TYPE_STRING context=CONTEXT_ID}} content {{/is_allowed}}
 *  {{#is_allowed ACTION RESOURCE_INSTANCE}} content {{/is_allowed}}
 */
var allowed_actions = ["create", "read", "update", "delete", "view_object_page", "__GGRC_ADMIN__"];
Mustache.registerHelper("is_allowed", function () {
  var args = Array.prototype.slice.call(arguments, 0)
    , actions = []
    , resource
    , resource_type
    , context_unset = {}
    , context_id = context_unset
    , context_override
    , options = args[args.length-1]
    , passed = true
    ;

  // Resolve arguments
  can.each(args, function (arg, i) {
    while (typeof arg === 'function' && arg.isComputed) {
      arg = arg();
    }

    if (typeof arg === 'string' && can.inArray(arg, allowed_actions) > -1) {
      actions.push(arg);
    }
    else if (typeof arg === 'string') {
      resource_type = arg;
    }
    else if (typeof arg === 'object' && arg instanceof can.Model) {
      resource = arg;
    }
  });
  if (options.hash && options.hash.hasOwnProperty("context")) {
    context_id = options.hash.context;
    if (typeof context_id === 'function' && context_id.isComputed) {
      context_id = context_id();
    }
    if (context_id && typeof context_id === "object" && context_id.id) {
      // Passed in the context object instead of the context ID, so use the ID
      context_id = context_id.id;
    }
    //  Using `context=null` in Mustache templates, when `null` is not defined,
    //  causes `context_id` to be `""`.
    if (context_id === "" || context_id === undefined) {
      context_id = null;
    } else if (context_id === 'for' || context_id === 'any') {
      context_override = context_id;
      context_id = undefined;
    }
  }

  if (resource_type && context_id === context_unset) {
    throw new Error(
        "If `resource_type` is a string, `context` must be explicit");
  }
  if (actions.length === 0) {
    throw new Error(
        "Must specify at least one action");
  }

  if (resource) {
    resource_type = resource.constructor.shortName;
    context_id = resource.context ? resource.context.id : null;
  }

  // Check permissions
  can.each(actions, function (action) {
    if (resource && Permission.is_allowed_for(action, resource)) {
      passed = true;
      return;
    }
    if (context_id !== undefined) {
      passed = passed && Permission.is_allowed(action, resource_type, context_id);
    }
    if (passed && context_override === 'for' && resource) {
      passed = passed && Permission.is_allowed_for(action, resource);
    }
    else if (passed && context_override === 'any' && resource_type) {
      passed = passed && Permission.is_allowed_any(action, resource_type);
    }
  });

  return passed
    ? options.fn(options.contexts || this)
    : options.inverse(options.contexts || this)
    ;
});

Mustache.registerHelper('any_allowed', function (action, data, options) {
  var passed = [],
      hasPassed;
  data = resolve_computed(data);

  data.forEach(function (item) {
    passed.push(Permission.is_allowed_any(action, item.model_name));
  });
  hasPassed = passed.some(function (val) {
    return val;
  });
  return options[hasPassed ? 'fn' : 'inverse'](options.contexts || this);
});

Mustache.registerHelper('system_role', function (role, options) {
  role = role.toLowerCase();
  // If there is no user, it's same as No Role
  var user_role = (GGRC.current_user ? GGRC.current_user.system_wide_role : 'no access').toLowerCase();
      isValid = role === user_role;

  return options[isValid ? 'fn' : 'inverse'](options.contexts || this);
});

Mustache.registerHelper("is_allowed_all", function (action, instances, options) {
  var passed = true;

  action = resolve_computed(action);
  instances = resolve_computed(instances);

  can.each(instances, function (instance) {
    var resource_type
      , context_id
      , base_mappings = []
      ;

    if (instance instanceof GGRC.ListLoaders.MappingResult) {
      instance.walk_instances(function (inst, mapping) {
        if (can.reduce(mapping.mappings, function (a, b) { return a || (b.instance === true); }, false)) {
          base_mappings.push(inst);
        }
      });
    } else {
      base_mappings.push(instance);
    }

    can.each(base_mappings, function (instance) {
      resource_type = instance.constructor.shortName;
      context_id = instance.context ? instance.context.id : null;
      passed = passed && Permission.is_allowed(action, resource_type, context_id);
    });
  });

  if (passed)
    return options.fn(options.contexts || this);
  else
    return options.inverse(options.contexts || this);
});

Mustache.registerHelper("is_allowed_to_map", function (source, target, options) {
  //  For creating mappings, we only care if the user has update permission on
  //  source and/or target.
  //  - `source` must be a model instance
  //  - `target` can be the name of the target model or the target instance
  var target_type, resource_type, context_id, can_map;

  source = resolve_computed(source);
  target = resolve_computed(target);
  can_map = GGRC.Utils.allowed_to_map(source, target, options);

  if (can_map) {
    return options.fn(options.contexts || this);
  }
  return options.inverse(options.contexts || this);
});

function resolve_computed(maybe_computed, always_resolve) {
  return (typeof maybe_computed === "function"
    && (maybe_computed.isComputed || always_resolve)) ? resolve_computed(maybe_computed(), always_resolve) : maybe_computed;
}

Mustache.registerHelper("attach_spinner", function (spin_opts, styles) {
  spin_opts = Mustache.resolve(spin_opts);
  styles = Mustache.resolve(styles);
  spin_opts = typeof spin_opts === "string" ? JSON.parse(spin_opts) : {};
  styles = typeof styles === "string" ? styles : "";
  return function (el) {
    var spinner = new Spinner(spin_opts).spin();
    $(el).append($(spinner.el).attr("style", $(spinner.el).attr("style") + ";" + styles)).data("spinner", spinner);
  };
});

Mustache.registerHelper("determine_context", function (page_object, target) {
  if (page_object.constructor.shortName == "Program") {
    return page_object.context ? page_object.context.id : null;
  } else if (target.constructor.shortName == "Program") {
    return target.context ? target.context.id : null;
  }
  return page_object.context ? page_object.context.id : null;
});

Mustache.registerHelper("json_escape", function (obj, options) {
  var s = JSON.stringify("" + (resolve_computed(obj) || ""));
  return s.substr(1, s.length - 2);
  /*return (""+(resolve_computed(obj) || ""))
    .replace(/\\/g, '\\')
    .replace(/"/g, '\\"')
    //  FUNFACT: JSON does not allow wrapping strings with single quotes, and
    //    thus does not allow backslash-escaped single quotes within strings.
    //    E.g., make sure attributes use double quotes, or use character
    //    entities instead -- but these aren't replaced by the JSON parser, so
    //    the output is not identical to input (hence, not using them now.)
    //.replace(/'/g, "\\'")
    //.replace(/"/g, '&#34;').replace(/'/g, "&#39;")
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\u2028/g, "\\u2028") // Line separator
    .replace(/\u2029/g, "\\u2029") // Paragraph separator
    .replace(/\t/g, "\\t")
    .replace(/[\b]/g, "\\b")
    .replace(/\f/g, "\\f")
    .replace(/\v/g, "\\v");
  */
});

function localizeDate(date, options, tmpl) {
  if (!options) {
    date = new Date();
  } else {
    date = resolve_computed(date);
  }
  return date ? moment(date).format(tmpl) : '';
}

can.each({
  localize_date: 'MM/DD/YYYY',
  localize_datetime: 'MM/DD/YYYY hh:mm:ss A'
}, function (tmpl, fn) {
  Mustache.registerHelper(fn, function (date, options) {
    return localizeDate(date, options, tmpl);
  });
});

/**
 *  Helper for rendering date or 'Today' string.
 *
 *  @param {Date} value - the date object; if it's falsey the current (local) date is used
 *  @return {String} - 'Today' or date string in the following format: MM/DD/YYYY
 */
Mustache.registerHelper('localize_date_today', function (value) {
  var date = resolve_computed(value);
  var today = moment().startOf('day');
  var startOfDate = moment(date).startOf('day');
  // TODO: [Overdue] Move this logic to helper.
  if (!value || (date && today.diff(startOfDate, 'days') === 0)) {
    return 'Today';
  }
  return localizeDate(value, value, 'MM/DD/YYYY');
});

Mustache.registerHelper("capitalize", function (value, options) {
  value = resolve_computed(value) || "";
  return can.capitalize(value);
});

Mustache.registerHelper("lowercase", function (value, options) {
  value = resolve_computed(value) || "";
  return value.toLowerCase();
});

  Mustache.registerHelper('assignee_types', function (value, options) {
    function capitalizeFirst(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    value = resolve_computed(value) || '';
    value = _.first(_.map(value.split(','), function (type) {
      return _.trim(type).toLowerCase();
    }));
    return _.isEmpty(value) ? '' : '(' + capitalizeFirst(value) + ')';
  });

Mustache.registerHelper("local_time_range", function (value, start, end, options) {
  var tokens = [];
  var sod;
  value = resolve_computed(value) || undefined;
  //  Calculate "start of day" in UTC and offsets in local timezone
  sod = moment(value).startOf("day").utc();
  start = moment(value).startOf("day").add(moment(start, "HH:mm").diff(moment("0", "Y")));
  end = moment(value).startOf("day").add(moment(end, "HH:mm").diff(moment("0", "Y")));

  function selected(time) {
    if (time
      && value
      && time.hours() === value.getHours()
      && time.minutes() === value.getMinutes()
    ) {
      return " selected='true'";
    } else {
      return "";
    }
  }

  while(start.isBefore(end) || start.isSame(end)) {
    tokens.push("<option value='", start.diff(sod), "'", selected(start), ">", start.format("hh:mm A"), "</option>\n");
    start.add(1, "hour");
  }
  return new Mustache.safeString(tokens.join(""));
});

Mustache.registerHelper("mapping_count", function (instance) {
  var args = can.makeArray(arguments)
    , mappings = args.slice(1, args.length - 1)
    , options = args[args.length-1]
    , root = options.contexts.attr('__mapping_count')
    , refresh_queue = new RefreshQueue()
    , mapping
    , dfd
    ;
  instance = resolve_computed(args[0]);

  // Find the most appropriate mapping
  for (var i = 0; i < mappings.length; i++) {
    if (instance.get_binding(mappings[i])) {
      mapping = mappings[i];
      break;
    }
  }

  if (!root) {
    root = new can.Observe();
    get_observe_context(options.contexts).attr("__mapping_count", root);
  }

  function update() {
    return options.fn(''+root.attr(mapping).attr('length'));
  }

  if (!mapping) {
    return "";
  }

  if (!root[mapping]) {
    root.attr(mapping, new can.Observe.List());
    root.attr(mapping).attr('loading', true);
    refresh_queue.enqueue(instance);
    dfd = refresh_queue.trigger()
      .then(function (instances) { return instances[0]; })
      .done(function (refreshed_instance) {
        if (refreshed_instance && refreshed_instance.get_binding(mapping)) {
          refreshed_instance.get_list_loader(mapping).done(function (list) {
            root.attr(mapping, list);
          });
        }
        else
          root.attr(mapping).attr('loading', false);
    });
  }

  var ret = defer_render('span', { done : update, progress : function () { return options.inverse(options.contexts); } }, dfd);
  return ret;
});

Mustache.registerHelper("visibility_delay", function (delay, options) {
  delay = resolve_computed(delay);

  return function (el) {
    setTimeout(function () {
      if ($(el.parentNode).is(':visible')) {
        $(el).append(options.fn(options.contexts));
      }
        can.view.hookup($(el).children());  // FIXME dubious indentation - was this intended to be in the 'if'?
    }, delay);
    return el;
  };
});


Mustache.registerHelper("with_program_roles_as", function (
      var_name, result, options) {
  var dfd = $.when()
    , frame = new can.Observe()
    , user_roles = []
    , mappings
    , refresh_queue = new RefreshQueue()
    ;

  result = resolve_computed(result);
  mappings = resolve_computed(result.get_mappings_compute());

  frame.attr("roles", []);

  can.each(mappings, function (mapping) {
    if (mapping instanceof CMS.Models.UserRole) {
      refresh_queue.enqueue(mapping.role);
    }
  });

  dfd = refresh_queue.trigger().then(function (roles) {
    can.each(mappings, function (mapping) {
      if (mapping instanceof CMS.Models.UserRole) {
        frame.attr("roles").push({
          user_role: mapping,
          role: mapping.role.reify()
        });
      } else {
        frame.attr("roles").push({
          role: {
            "permission_summary": "Mapped"
          }
        });
      }
    });
  });

  function finish(list) {
    return options.fn(options.contexts.add(frame));
  }
  function fail(error) {
    return options.inverse(options.contexts.add({error : error}));
  }

  return defer_render('span', { done : finish, fail : fail }, dfd);
});


  var programRoles;  // needed for the infer_roles helper

  /**
   * Determine and serialize the roles for a user.
   *
   * @param {can.Model} instance - the object to infer the current user's
   *   roles for
   * @param {Object} options - a CanJS options argument passed to every helper
   */
  Mustache.registerHelper('infer_roles', function (instance, options) {
    var pageInstance;
    var person;
    var refreshQueue;
    var requests;
    var state;

    function initState() {
      if (!state.roles) {
        state.attr({
          status: 'loading',
          count: 0,
          roles: new can.Observe.List()
        });
      }
    }

    instance = resolve_computed(instance);

    state = options.contexts.attr('__infer_roles');
    pageInstance = GGRC.page_instance();
    person = pageInstance instanceof CMS.Models.Person ? pageInstance : null;

    if (!state) {
      state = new can.Observe();
      options.context.attr('__infer_roles', state);
    }

    if (!state.attr('status')) {
      if (person) {
        initState();

        // Check whether current user is audit lead (for audits) or contact (for everything else)
        if (instance.contact && instance.contact.id === person.id) {
          if (instance instanceof CMS.Models.Audit) {
            state.attr('roles').push('Audit Lead');
          } else {
            state.attr('roles').push('Contact');
          }
        }

        // Check for Audit roles
        if (instance instanceof CMS.Models.Audit) {
          requests = instance.requests || new can.Observe.List();
          refreshQueue = new RefreshQueue();

          refreshQueue.enqueue(requests.reify());
          refreshQueue.trigger().then(function (requests) {
            can.each(requests, function (request) {
              if (
                request.assignee &&
                request.assignee.id === person.id &&
                !_.includes(state.attr('roles'), 'Request Assignee')
              ) {
                state.attr('roles').push('Request Assignee');
              }
            });
          });
        }

        // Check for assessor roles
        if (
          instance.attr('principal_assessor') &&
          instance.principal_assessor.id === person.id
        ) {
          state.attr('roles').push('Principal Assessor');
        }

        if (
          instance.attr('secondary_assessor') &&
          instance.secondary_assessor.id === person.id
        ) {
          state.attr('roles').push('Secondary Assessor');
        }

        // Check for people
        if (
          instance.people &&
          _.contains(_.map(instance.people, 'id'), person.id)
        ) {
          state.attr('roles').push('Mapped');
        }

        if (instance instanceof CMS.Models.Audit) {
          $.when(
            instance.reify().get_binding('authorizations').refresh_list(),
            instance.findAuditors()
          ).then(function (authorizations, auditors) {
            if (_.includes(_.map(auditors, 'person.id'), person.id)) {
              state.attr('roles').push('Auditor');
            }

            function changeHandler() {
              var roleList = can.map(state.attr('roles'), function (role) {
                if (role !== 'Auditor') {
                  return role;
                }
              });
              state.attr('roles', roleList);

              instance.findAuditors().then(function (auds) {
                if (_.includes(_.map(auds, 'person.id'), person.id)) {
                  state.attr('roles').push('Auditor');
                }
              });
            }

            authorizations.bind('change', changeHandler);
          });
        }

        // Check for ownership
        if (
          instance.owners &&
          _.includes(_.map(instance.owners, 'id'), person.id)
        ) {
          state.attr('roles').push('Owner');
        }

        // Check for authorizations
        if (
          instance instanceof CMS.Models.Program &&
          instance.context &&
          instance.context.id
        ) {
          person.get_list_loader('authorizations')
            .done(function (authorizations) {
              authorizations = can.map(authorizations, function (auth) {
                if (
                  auth.instance.context &&
                  auth.instance.context.id === instance.context.id
                ) {
                  return auth.instance;
                }
              });

              if (!programRoles) {
                programRoles = CMS.Models.Role.findAll(
                  {scope__in: 'Private Program,Audit'}
                );
              }

              programRoles.done(function (roles) {
                can.each(authorizations, function (auth) {
                  var role = CMS.Models.Role.findInCacheById(auth.role.id);
                  var roleName;
                  if (role) {
                    roleName = (role.name === 'ProgramOwner') ?
                               'Program Manager' : role.name;
                    state.attr('roles').push(roleName);
                  }
                });
              });
            }
          );  // end person.get_list_loader()
        }
      } else if (  // When we're not on a profile page, check for ownership
        instance.owners &&
        _.includes(_.map(instance.owners, 'id'), GGRC.current_user.id)
      ) {
        initState();
        state.attr('roles').push('Yours');
      }
    }

    // Return the result
    if (!state.attr('roles') || state.attr('status') === 'failed') {
      return '';
    } else if (
      state.attr('roles').attr('length') === 0 &&
      state.attr('status') === 'loading'
    ) {
      return options.inverse(options.contexts);
    } else if (state.attr('roles').attr('length')) {
      return options.fn(options.contexts.add(state.attr('roles').join(', ')));
    }
  });

function get_observe_context(scope) {
  if (!scope) return null;
  if (scope._context instanceof can.Observe) return scope._context;
  return get_observe_context(scope._parent);
}

// Uses search to find the counts for a model type
Mustache.registerHelper("global_count", function (model_type, options) {
  model_type = resolve_computed(model_type);
  var state = options.contexts.attr("__global_count")
    ;

  if (!state) {
    state = new can.Observe();
    get_observe_context(options.contexts).attr("__global_count", state);
  }

  if (!state.attr('status')) {
    state.attr('status', 'loading');

    if (!GGRC._search_cache_deferred) {
      //  TODO: This should really be RefreshQueue-style
      var models = [
          "Program", "Regulation", "Contract", "Policy", "Standard"
        , "Section", "Objective", "Control"
        , "System", "Process"
        , "DataAsset", "Product", "Project", "Facility", "OrgGroup"
        , "Audit", "AccessGroup"
        ];
      GGRC._search_cache_deferred = GGRC.Models.Search.counts_for_types(null, models);
    }

    var model = CMS.Models[model_type]
      , update_count = function (ev, instance) {
          if (!instance || instance instanceof model) {
            GGRC._search_cache_deferred.then(function (result) {
              if (!result.counts.hasOwnProperty(model_type)) {
                return GGRC.Models.Search.counts_for_types(null, [model_type]);
              }
              else {
                return result;
              }
            }).then(function (result) {
              state.attr({
                  status: 'loaded'
                , count: result.counts[model_type]
              });
            });
          }
        }
      ;

    update_count();
    if (model) {
      model.bind('created', update_count);
      model.bind('destroyed', update_count);
    }
  }

  // Return the result
  if (state.attr('status') === 'failed') {
    return '';
  }
  else if (state.attr('status') === 'loading' || state.attr('count') === undefined) {
    return options.inverse(options.contexts);
  }
  else {
    return options.fn(state.attr('count'));
  }
});

Mustache.registerHelper("is_dashboard", function (options) {
  if (/dashboard/.test(window.location))
    return options.fn(options.contexts);
  else
    return options.inverse(options.contexts);
});

Mustache.registerHelper("is_allobjectview", function (options) {
  if (/objectBrowser/.test(window.location))
    return options.fn(options.contexts);
  else
    return options.inverse(options.contexts);
});

Mustache.registerHelper("is_dashboard_or_all", function (options) {
  if (/dashboard/.test(window.location) || /objectBrowser/.test(window.location))
    return options.fn(options.contexts);
  else
    return options.inverse(options.contexts);
});

Mustache.registerHelper("is_profile", function (parent_instance, options) {
  var instance;
  if (options)
    instance = resolve_computed(parent_instance);
  else
    options = parent_instance;

  if (GGRC.page_instance() instanceof CMS.Models.Person)
    return options.fn(options.contexts);
  else
    return options.inverse(options.contexts);
});

Mustache.registerHelper("is_parent_of_type", function (type_options, options) {
  /*
  Determines if parent instance is of specified type.
  Input:   type_options = 'TypeA,TypeB,TypeC'
  Returns: Boolean
  */
  var types = type_options.split(","),
      parent = GGRC.page_instance(),
      parent_type = parent.type;

  if ($.inArray(parent_type, types) !== -1) {
    return options.fn(options.contexts);
  }
  return options.inverse(options.contexts);
});

Mustache.registerHelper("current_user_is_admin", function (options) {
  if (Permission.is_allowed("__GGRC_ADMIN__")) {
  return options.fn(options.contexts);
  }
  return options.inverse(options.contexts);
});

Mustache.registerHelper("owned_by_current_user", function (instance, options) {
  var current_user_id = GGRC.current_user.id;
  instance = Mustache.resolve(instance);
  owners = instance.attr('owners');
  if (owners) {
    for (var i = 0; i < owners.length; i++) {
      if (current_user_id == owners[i].id) {
        return options.fn(options.contexts);
      }
    }
  }
  return options.inverse(options.contexts);
});

Mustache.registerHelper("current_user_is_contact", function (instance, options) {
  var current_user_id = GGRC.current_user.id;
  instance = Mustache.resolve(instance);
  var contact = instance.contact;
  if (current_user_id == contact.id) {
    return options.fn(options.contexts);
  } else {
    return options.inverse(options.contexts);
  }
});

Mustache.registerHelper("last_approved", function (instance, options) {
  var loader, frame = new can.Observe();
  instance = Mustache.resolve(instance);
  loader = instance.get_binding("approval_tasks");

  frame.attr(instance, loader.list);
  function finish(list) {
    var item;
    list = list.serialize();
    if (list.length > 1) {
      var biggest = Math.max.apply(Math, list.map(function (item) {
            return item.instance.id;
          }));
      item = list.filter(function (item) {
        return item.instance.id === biggest;
      });
    }
    item = item ? item[0] : list[0];
    return options.fn(item ? item : options.contexts);
  }
  function fail(error) {
    return options.inverse(options.contexts.add({error: error}));
  }

  return defer_render("span", {done: finish, fail: fail}, loader.refresh_instances());
});

Mustache.registerHelper("with_is_reviewer", function (review_task, options) {
  review_task = Mustache.resolve(review_task);
  var current_user_id = GGRC.current_user.id;
  var is_reviewer = review_task &&
      (current_user_id == review_task.contact.id ||
      Permission.is_allowed("__GGRC_ADMIN__"));
  return options.fn(options.contexts.add({is_reviewer: is_reviewer}));
});

Mustache.registerHelper("with_review_task", function (options) {
  var tasks = options.contexts.attr('approval_tasks');
  tasks = Mustache.resolve(tasks);
  if (tasks) {
    for (var i = 0; i < tasks.length; i++) {
      return options.fn(options.contexts.add({review_task: tasks[i].instance}));
    }
  }
  return options.fn(options.contexts.add({review_task: undefined}));
});

Mustache.registerHelper('default_audit_title', function (instance, options) {
  var index;
  var program;
  var title;

  instance = Mustache.resolve(instance);
  program = instance.attr('program');

  if (!instance._transient) {
    instance.attr('_transient', new can.Map());
  }

  if (!program) {
    // Mark the title to be populated when computed_program is defined,
    // returning an empty string here would disable the save button.
    instance.attr('title', '');
    instance.attr('_transient.default_title', instance.title);
    return;
  }
  if (instance._transient.default_title !== instance.title) {
    return;
  }

  program = program.reify();
  new RefreshQueue().enqueue(program).trigger().then(function () {
    title = (new Date()).getFullYear() + ': ' + program.title + ' - Audit';

    GGRC.Models.Search.counts_for_types(title, ['Audit'])
      .then(function (result) {
        // Next audit index should be bigger by one than previous, we have unique name policy
        index = result.getCountFor('Audit') + 1;
        title = title + ' ' + index;
        instance.attr('title', title);
        // this needs to be different than above, otherwise CanJS throws a strange error
        if (instance._transient) {
          instance.attr('_transient.default_title',
            instance.title);
        }
      });
  });
});

Mustache.registerHelper('param_current_location', function () {
  return GGRC.current_url_compute();
});

  Mustache.registerHelper('urlPath', function () {
    return window.location.pathname;
  });

Mustache.registerHelper("sum", function () {
  var sum = 0;
  for (var i = 0; i < arguments.length - 1; i++) {
    sum += parseInt(resolve_computed(arguments[i]), 10);
  }
  return ''+sum;
});

Mustache.registerHelper("to_class", function (prop, delimiter, options) {
  prop = resolve_computed(prop) || "";
  delimiter = (arguments.length > 2 && resolve_computed(delimiter)) || '-';
  return prop.toLowerCase().replace(/[\s\t]+/g, delimiter);
});

/*
  Evaluates multiple helpers as if they were a single condition

  Each new statement is begun with a newline-prefixed string. The type of logic
  to apply as well as whether it should be a truthy or falsy evaluation may also
  be included with the statement in addition to the helper name.

  Currently, if_helpers only supports Disjunctive Normal Form. All "and" statements are grouped,
  groups are split by "or" statements.

  All hash arguments (some_val=37) must go in the last line and should be prefixed by the
  zero-based index of the corresponding helper. This is necessary because all hash arguments
  are required to be the final arguments for a helper. Here's an example:
    _0_some_val=37 would pass some_val=37 to the first helper.

  Statement syntax:
    '\
    [LOGIC] [TRUTHY_FALSY]HELPER_NAME' arg1 arg2 argN

  Defaults:
    LOGIC = and (accepts: and or)
    TRUTHY_FALSEY = # (accepts: # ^)
    HELPER_NAME = some_helper_name

  Example:
    {{#if_helpers '\
      #if_match' page_object.constructor.shortName 'Project' '\
      and ^if_match' page_object.constructor.shortName 'Audit|Program|Person' '\
    ' _1_hash_arg_for_second_statement=something}}
      matched all conditions
    {{else}}
      failed
    {{/if_helpers}}

  FIXME: Only synchronous helpers (those which call options.fn() or options.inverse()
    without yielding the thread through defer_render or otherwise) can currently be used
    with if_helpers.  if_helpers should support all helpers by changing the walk through
    conjunctions and disjunctions to one using a can.reduce(Array, function (Deferred, item) {}, $.when())
    pattern instead of can.reduce(Array, function (Boolean, item) {}, Boolean) pattern. --BM 8/29/2014
*/
Mustache.registerHelper("if_helpers", function () {
  var args = arguments
    , options = arguments[arguments.length - 1]
    , helper_result
    , helper_options = can.extend({}, options, {
        fn: function () { helper_result = 'fn'; }
      , inverse: function () { helper_result = 'inverse'; }
      })
    ;

  // Parse statements
  var statements = []
    , statement
    , match
    , disjunctions = []
    , index = 0
    ;
  can.each(args, function (arg, i) {
    if (i < args.length - 1) {
      if (typeof arg === 'string' && arg.match(/^\n\s*/)) {
        if (statement) {
          if (statement.logic === "or") {
            disjunctions.push(statements);
            statements = [];
          }
          statements.push(statement);
          index = index + 1;
        }
        if (match = arg.match(/^\n\s*((and|or) )?([#^])?(\S+?)$/)) {
          statement = {
              fn_name: match[3] === '^' ? 'inverse' : 'fn'
            , helper: Mustache.getHelper(match[4], options.contexts)
            , args: []
            , logic: match[2] === 'or' ? 'or' : 'and'
          };

          // Add hash arguments
          if (options.hash) {
            var hash = {}
              , prefix = '_' + index + '_'
              , prop
              ;
            for (prop in options.hash) {
              if (prop.indexOf(prefix) === 0) {
                hash[prop.substr(prefix.length)] = options.hash[prop];
              }
            }
            for (prop in hash) {
              statement.hash = hash;
              break;
            }
          }
        }
        else
          statement = null;
      }
      else if (statement) {
        statement.args.push(arg);
      }
    }
  });
  if (statement) {
    if (statement.logic === "or") {
      disjunctions.push(statements);
      statements = [];
    }
    statements.push(statement);
  }
  disjunctions.push(statements);

  if (disjunctions.length) {
    // Evaluate statements
    var result = can.reduce(disjunctions, function (disjunctive_result, conjunctions) {
      if (disjunctive_result)
        return true;

      var conjunctive_result = can.reduce(conjunctions, function (current_result, stmt) {
        if (!current_result)
          return false; //short circuit

        helper_result = null;
        stmt.helper.fn.apply(stmt.helper, stmt.args.concat([
          can.extend({}, helper_options, { hash: stmt.hash || helper_options.hash })
        ]));
        helper_result = helper_result === stmt.fn_name;
        return current_result && helper_result;
      }, true);
      return disjunctive_result || conjunctive_result;
    }, false);

    // Execute based on the result
    if (result) {
      return options.fn(options.contexts);
    }
    else {
      return options.inverse(options.contexts);
    }
  }
});

Mustache.registerHelper("with_model_as", function (var_name, model_name, options) {
  var frame = {};
  model_name = resolve_computed(Mustache.resolve(model_name));
  frame[var_name] = CMS.Models[model_name];
  return options.fn(options.contexts.add(frame));
});

Mustache.registerHelper("private_program_owner", function (instance, modal_title, options) {
  var state = options.contexts.attr('__private_program_owner');
  if (resolve_computed(modal_title).indexOf('New ') === 0) {
    return GGRC.current_user.email;
  }
  else {
    var loader = resolve_computed(instance).get_binding('authorizations');
    return $.map(loader.list, function (binding) {
      if (binding.instance.role && binding.instance.role.reify().attr('name') === 'ProgramOwner') {
        return binding.instance.person.reify().attr('email');
      }
    }).join(', ');
  }
});

// Verify if the Program has multiple owners
// Usage: {{#if_multi_owner instance modal_title}}
Mustache.registerHelper("if_multi_owner", function (instance, modal_title, options) {
  var owner_count = 0;

  if (resolve_computed(modal_title).indexOf('New ') === 0) {
    return options.inverse(options.contexts);
  }

  var loader = resolve_computed(instance).get_binding('authorizations');
  can.each(loader.list, function(binding){
    if (binding.instance.role && binding.instance.role.reify().attr('name') === 'ProgramOwner') {
      owner_count += 1;
    }
  });

  if (owner_count > 1) {
    return options.fn(options.contexts);
  } else {
    return options.inverse(options.contexts);
  }
});

// Determines whether the value matches one in the $.map'd list
// {{#if_in_map roles 'role.permission_summary' 'Mapped'}}
Mustache.registerHelper("if_in_map", function (list, path, value, options) {
  list = resolve_computed(list);

  if (!list.attr || list.attr('length')) {
    path = path.split('.');
    var map = $.map(list, function (obj) {
      can.each(path, function (prop) {
        obj = (obj && obj[prop]) || null;
      });
      return obj;
    });

    if (map.indexOf(value) > -1)
      return options.fn(options.contexts);
  }
  return options.inverse(options.contexts);
});

Mustache.registerHelper("if_in", function (needle, haystack, options) {
  needle = resolve_computed(needle);
  haystack = resolve_computed(haystack).split(",");

  var found = haystack.some(function (h) {
    return h.trim() === needle;
  });
  return options[found ? "fn" : "inverse"](options.contexts);
});

Mustache.registerHelper("with_auditors", function (instance, options) {
  var auditors, auditors_dfd
    , decoy
    ;

  instance = resolve_computed(instance);
  if (options.hash && options.hash.decoy) {
    decoy = Mustache.resolve(options.hash.decoy);
    decoy.attr();
  }

  if (!instance)
    return "";

  auditors_dfd = Mustache.resolve(instance).findAuditors().done(function (aud) {
    auditors = aud;
  });
  return defer_render("span", function () {
    if (auditors && auditors.attr("length") > 0) {
      return options.fn(options.contexts.add({"auditors": auditors}));
    }
    else{
      return options.inverse(options.contexts);
    }
  }, auditors_dfd);
});

Mustache.registerHelper("if_instance_of", function (inst, cls, options) {
  var result;
  cls = resolve_computed(cls);
  inst = resolve_computed(inst);

  if (typeof cls === "string") {
    cls = cls.split("|").map(function (c) {
      return CMS.Models[c];
    });
  } else if (typeof cls !== "function") {
    cls = [cls.constructor];
  } else {
    cls = [cls];
  }

  result = can.reduce(cls, function (res, c) {
    return res || inst instanceof c;
  }, false);

  return options[result ? "fn" : "inverse"](options.contexts);
});

Mustache.registerHelper("prune_context", function (options) {
  return options.fn(new can.view.Scope(options.context));
});

Mustache.registerHelper("mixed_content_check", function (url, options) {
  url = Mustache.getHelper("schemed_url", options.contexts).fn(url);
  if (window.location.protocol === "https:" && !/^https:/.test(url)) {
    return options.inverse(options.contexts);
  } else {
    return options.fn(options.contexts);
  }
});

/**
  scriptwrap - create live-bound content contained within a <script> tag as CDATA
  to prevent, e.g. iframes being rendered in hidden fields, or temporary storage
  of markup being found by $().

  Usage
  -----
  To render a section of markup in a script tag:
  {{#scriptwrap}}<section content>{{/scriptwrap}}

  To render the output of another helper in a script tag:
  {{scriptwrap "name_of_other_helper" helper_arg helper_arg... hashkey=hashval}}

  Hash keys starting with "attr_" will be treated as attributes to place on the script tag itself.
  e.g. {{#scriptwrap attr_class="data-popover-content" attr_aria_
*/
Mustache.registerHelper("scriptwrap", function (helper) {
  var extra_attrs = ""
  , args = can.makeArray(arguments).slice(1, arguments.length)
  , options = args[args.length - 1] || helper
  , ret = "<script type='text/html'" + can.view.hook(function (el, parent, view_id) {
    var c = can.compute(function () {
      var $d = $("<div>").html(
        helper === options
        ? options.fn(options.contexts)  //not calling a separate helper case
        : Mustache.getHelper(helper, options.contexts).fn.apply(options.context, args));
      can.view.hookup($d);
      return "<script type='text/html'" + extra_attrs + ">" + $d.html() + "</script>";
    });

    can.view.live.html(el, c, parent);
  });

  if (options.hash) {
    can.each(Object.keys(options.hash), function (key) {
      if (/^attr_/.test(key)) {
        extra_attrs += " " + key.substr(5).replace("_", "-") + "='" + resolve_computed(options.hash[key]) + "'";
        delete options.hash[key];
      }
    });
  }

  ret += "></script>";
  return new Mustache.safeString(ret);
});

Mustache.registerHelper("ggrc_config_value", function (key, default_, options) {
  key = resolve_computed(key);
  if (!options) {
    options = default_;
    default_ = null;
  }
  default_ = resolve_computed(default_);
  default_ = default_ || "";
  return can.getObject(key, [GGRC.config]) || default_;
});

Mustache.registerHelper("is_page_instance", function (instance, options) {
  var instance = resolve_computed(instance)  // FIXME duplicate declaration
    , page_instance = GGRC.page_instance()
    ;

  if (instance && instance.type === page_instance.type && instance.id === page_instance.id) {
    return options.fn(options.contexts);
  }
  else{
    return options.inverse(options.contexts);
  }
});

Mustache.registerHelper("remove_space", function (str, options) {
  return resolve_computed(str, true).replace(' ', '');
});

Mustache.registerHelper("if_auditor", function (instance, options) {
  var audit, auditors_dfd, auditors
    , admin = Permission.is_allowed("__GGRC_ADMIN__")
    , editor = GGRC.current_user.system_wide_role === "Editor"
    , include_admin = !options.hash || options.hash.include_admin !== false;

  instance = Mustache.resolve(instance);
  instance = (!instance || instance instanceof CMS.Models.Request) ? instance : instance.reify();

  if (!instance) {
    return '';
  }

  audit = instance instanceof CMS.Models.Request ? instance.attr("audit") : instance;

  if (!audit) {
    return '';  // take no action until audit is available
  }

  audit = audit instanceof CMS.Models.Audit ? audit : audit.reify();
  auditors = audit.findAuditors(true); // immediate-mode findAuditors

  if ((include_admin && (admin|| editor)) ||
      can.map(
          auditors,
          function (auditor) {
            if (auditor.person.id === GGRC.current_user.id) {
              return auditor;
            }
        }).length) {
    return options.fn(options.contexts);
  }
  return options.inverse(options.contexts);
});

Mustache.registerHelper("if_verifiers_defined", function (instance, options) {
  var verifiers;

  instance = Mustache.resolve(instance);
  instance = (!instance || instance instanceof CMS.Models.Request) ? instance : instance.reify();

  if (!instance) {
    return '';
  }

  verifiers = instance.get_binding('related_verifiers');

  return defer_render('span', function(list) {
    if (list.length) {
      return options.fn(options.contexts);
    }
    return options.inverse(options.contexts);
  }, verifiers.refresh_instances());
});

Mustache.registerHelper("if_verifier", function (instance, options) {
  var user = GGRC.current_user,
      verifiers;

  instance = Mustache.resolve(instance);
  instance = (!instance || instance instanceof CMS.Models.Request) ? instance : instance.reify();

  if (!instance) {
    return '';
  }

  verifiers = instance.get_binding('related_verifiers');

  return defer_render('span', function(list) {
    var llist = _.filter(list, function(item) {
      if (item.instance.email == user.email) {
        return true;
      }
      return false;
    });

    if (llist.length) {
      return options.fn(options.contexts);
    }
    return options.inverse(options.contexts);
  }, verifiers.refresh_instances());
});

can.each({
  "if_can_edit_request": {
    assignee_states: ["Requested", "Amended Request"],
    auditor_states: ["Draft", "Responded", "Updated Response"],
    program_editor_states: ["Requested", "Amended Request"],
    predicate: function(options) {
      return options.admin
          || options.editor
          || options.can_assignee_edit
          || options.can_program_editor_edit
          || options.can_auditor_edit
          || (!options.accepted
              && (options.update
                  || options.map
                  || options.create
                  || options.program_owner));
    }
  },
  "if_can_reassign_request": {
    auditor_states: ["Responded", "Updated Response"],
    assignee_states: ["Requested", "Amended Request", "Responded", "Updated Response"],
    program_editor_states: ["Requested", "Amended Request"],
    predicate: function(options) {
      return options.admin
          || options.editor
          || options.can_auditor_edit
          || options.can_assignee_edit
          || options.can_program_editor_edit
          || (!options.accepted
              && (options.update
                || options.map
                || options.create));
    }
  }
}, function(fn_opts, name) {

  Mustache.registerHelper(name, function(instance, options){

      var audit, auditors_dfd, accepted, prog_roles_dfd,
          admin = Permission.is_allowed("__GGRC_ADMIN__"),
          editor = GGRC.current_user.system_wide_role === "Editor";

      instance = resolve_computed(instance);
      instance = (!instance || instance instanceof CMS.Models.Request) ? instance : instance.reify();

      if(!instance)
        return "";

      audit = instance.attr("audit");

      if(!audit)
        return "";  //take no action until audit is available

      audit = audit.reify();
      auditors_dfd = audit.findAuditors();
      prog_roles_dfd = audit.refresh_all('program').then(function(program) {
                         //debugger;
                         return program.get_binding("program_authorizations").refresh_instances();
                       }).then(function(user_role_bindings) {
                          var rq = new RefreshQueue();
                          can.each(user_role_bindings, function(urb) {
                            if(urb.instance.person && urb.instance.person.id === GGRC.current_user.id) {
                              rq.enqueue(urb.instance.role.reify());
                            }
                          });
                          return rq.trigger();
                       });

      return defer_render("span", function(auditors, program_roles) {
        var accepted = instance.status === "Accepted",
            draft = instance.status === "Draft",
            update = Permission.is_allowed("update", instance), //All-context allowance
            map = Permission.is_allowed("mapping", instance),   //All-context allowance
            create = Permission.is_allowed("creating", instance), //All-context allowance
            assignee = !!instance.assignee && instance.assignee.id === GGRC.current_user.id, // User is request assignee
            audit_lead = !!audit.contact && audit.contact.id === GGRC.current_user.id,  // User is audit lead
            auditor = can.map(  // User has auditor role in audit
                        auditors || [],
                        function(auditor) {
                          if(auditor.person.id === GGRC.current_user.id) {
                            return auditor;
                          }
                      }).length > 0,
            program_owner = can.reduce(  //user is owner of the audit's parent program
                              program_roles,
                              function(cur, role) { return cur || role.name === "ProgramOwner"; },
                              false
                              ),
            program_editor = can.reduce(  //user is editor of the audit's parent program
                              program_roles,
                              function(cur, role) { return cur || role.name === "ProgramEditor"; },
                              false
                              ),
            auditor_states = fn_opts.auditor_states || [], // States in which an auditor can edit a request
            assignee_states = fn_opts.assignee_states || [], // " for assignee of request
            program_editor_states = fn_opts.program_editor_states || [], // " for program editor
            // Program owner currently has nearly the same state allowances as Admin --BM 2014-12-16
            can_auditor_edit = auditor && ~can.inArray(instance.attr("status"), auditor_states),
            can_assignee_edit = (audit_lead || assignee) && ~can.inArray(instance.attr("status"), assignee_states),
            can_program_editor_edit = (program_editor || program_owner) && ~can.inArray(instance.attr("status"), program_editor_states)
            ;

        if(fn_opts.predicate({
          admin: admin,
          editor: editor,
          can_auditor_edit: can_auditor_edit,
          can_assignee_edit: can_assignee_edit,
          can_program_editor_edit: can_program_editor_edit,
          accepted: accepted,
          draft: draft,
          update: update,
          map: map,
          create: create,
          program_owner: program_owner,
          auditor: auditor,
          audit_lead: audit_lead
        })) {
          return options.fn(options.contexts);
        }
        else{
          return options.inverse(options.contexts);
        }
      }, $.when(auditors_dfd, prog_roles_dfd));
  });
});

Mustache.registerHelper("strip_html_tags", function (str) {
  return resolve_computed(str).replace(/<(?:.|\n)*?>/gm, '');
});

Mustache.registerHelper("truncate", function (len, str) {
  // find a good source
  str = can.makeArray(arguments).reduce(function (res, arg, i) {
      var s = resolve_computed(arg);
      if (typeof s === "string") {
          return s;
      }else{
          return res;
      }
  }, "");

  if (typeof len === "number") {
      // max len characters
      if (str.length > len) {
          str = str.substr(0, str.lastIndexOf(len, ' '));
          str += " &hellip;";
      }
  }else{
      // first line of input
      var strs = str.split(/<br[^>]*>|\n/gm);
      if (strs.length > 1) {
          str = strs[0];
          str += " &hellip;";
      }
  }

  return str;
});

Mustache.registerHelper("switch", function (value, options) {
  var frame = new can.Observe({});
  value = resolve_computed(value);
  frame.attr(value || "default", true);
  frame.attr("default", true);
  return options.fn(options.contexts.add(frame), {
    helpers : {
      case : function (val, options) {
        val = resolve_computed(val);
        if (options.context[val]) {
          options.context.attr ? options.context.attr("default", false) : (options.context.default = false);
          return options.fn(options.contexts);
        }
      }
    }
  });
});


Mustache.registerHelper("fadein", function (delay, prop, options) {
  switch(arguments.length) {
    case 1:
    options = delay;
    delay = 500;
    break;
    case 2:
    options = prop;
    prop = null;
    break;
  }
  resolve_computed(prop);
  return function (el) {
    var $el = $(el);
    $el.css("display", "none");
    if (!prop || resolve_computed(prop)) {
      setTimeout(function () {
        $el.fadeIn({
          duration : (options.hash && options.hash.duration) || 500
          , complete : function () {
            return typeof prop === "function" && prop(true);
          }
        });
      }, delay);
    }
  };
});

Mustache.registerHelper("fadeout", function (delay, prop, options) {
  switch(arguments.length) {
    case 1:
    options = delay;
    delay = 500;
    break;
    case 2:
    options = prop;
    prop = null;
    break;
  }
  if (resolve_computed(prop)) {
    return function (el) {
      var $el = $(el);
      setTimeout(function () {
        $el.fadeOut({
          duration : (options.hash && options.hash.duration) || 500
          , complete : function () {
            return typeof prop === "function" && prop(null);
          }
        });
      }, delay);
    };
  }
});

  Mustache.registerHelper('current_cycle_assignee',
    function (instance, options) {
      var mapping;
      var approvalCycle;
      var binding;
      var finish;
      var progress;

      instance = Mustache.resolve(instance);
      mapping = instance.get_mapping('current_approval_cycles');

      if (!mapping || !mapping.length) {
        return options.inverse();
      }
      approvalCycle = mapping[0].instance;
      binding = approvalCycle.get_binding('cycle_task_groups');

      finish = function (tasks) {
        return options.fn(options.contexts.add({
          person: tasks[0].instance.contact
        }));
      };
      progress = function () {
        return options.inverse(options.contexts);
      };

      return defer_render('span', {
        done: finish, progress: progress
      }, binding.refresh_instances());
    });

  Mustache.registerHelper('with_mapping_count',
    function (instance, mappingNames, options) {
      var args = can.makeArray(arguments);
      var mappingName;
      var i;

      options = args[args.length - 1];  // FIXME duplicate declaration

      mappingNames = args.slice(1, args.length - 1);

      instance = Mustache.resolve(instance);

      // Find the most appropriate mapping
      for (i = 0; i < mappingNames.length; i++) {
        mappingName = Mustache.resolve(mappingNames[i]);
        if (instance.has_binding(mappingName)) {
          break;
        }
      }

      return defer_render('span', {
        done: function (count) {
          return options.fn(options.contexts.add({count: count}));
        },
        progress: function () {
          return options.inverse(options.contexts);
        }
      },
        instance.get_list_counter(mappingName)
      );
    });

Mustache.registerHelper("is_overdue", function (_date, status, options) {
  var date = moment(resolve_computed(_date));
  var today = moment().startOf('day');
  var startOfDate = moment(date).startOf('day');
  var isBefore = date && today.diff(startOfDate, 'days') > 0;
  options = arguments.length === 2 ? arguments[1] : options;
  status = arguments.length === 2 ? "" : resolve_computed(status);
  // TODO: [Overdue] Move this logic to helper.
  if (status !== 'Verified' && isBefore) {
    return options.fn(options.contexts);
  }
  else {
    return options.inverse(options.contexts);
  }
});

Mustache.registerHelper("with_mappable_instances_as", function (name, list, options) {
  var ctx = new can.Observe()
    , page_inst = GGRC.page_instance()
    , page_context = page_inst.context ? page_inst.context.id : null
    ;

  list = Mustache.resolve(list);

  if (list) {
    list.attr("length"); //setup live.
    list = can.map(list, function (item, key) {
      var inst = item.instance || item;
      var jds = GGRC.Mappings.join_model_name_for (page_inst.constructor.shortName, inst.constructor.shortName);
      if (inst !== page_inst
         && jds
         && Permission.is_allowed("create", jds, page_context)
      ) {
        return inst;
      }
    });
  }

  ctx.attr(name, list);

  return options.fn(options.contexts.add(ctx));
});

Mustache.registerHelper("with_subtracted_list_as", function (name, haystack, needles, options) {
  var ctx = new can.Observe();

  haystack = Mustache.resolve(haystack);
  needles = Mustache.resolve(needles);

  if (haystack) {
    haystack.attr("length"); //setup live.
    needles.attr("length");
    haystack = can.map(haystack, function (item, key) {
      return ~can.inArray(item, needles) ? undefined : item;
    });
  }

  ctx.attr(name, haystack);

  return options.fn(options.contexts.add(ctx));
});

Mustache.registerHelper("with_mapping_instances_as", function (name, mappings, options) {
  var ctx = new can.Observe();

  mappings = Mustache.resolve(mappings);

  if (!(mappings instanceof can.List || can.isArray(mappings))) {
    mappings = [mappings];
  }

  if (mappings) {
    //  Setup decoy for live binding
    mappings.attr && mappings.attr("length");
    mappings = can.map(mappings, function (item, key) {
      return item.instance;
    });
  }
  ctx.attr(name, mappings);

  return options.fn(options.contexts.add(ctx));
});


Mustache.registerHelper("with_allowed_as", function (name, action, mappings, options) {
  var ctx = new can.Observe();

  mappings = Mustache.resolve(mappings);

  if (!(mappings instanceof can.List || can.isArray(mappings))) {
    mappings = [mappings];
  }

  if (mappings) {
    //  Setup decoy for live binding
    mappings.attr && mappings.attr("length");
    mappings = can.map(mappings, function (item, key) {
      var mp = item.get_mappings()[0]
        , context_id = mp.context ? mp.context.id : null
        ;
      if (Permission.is_allowed(action, mp.constructor.shortName, context_id)) {
        return item;
      }
    });
  }
  ctx.attr(name, mappings);

  return options.fn(options.contexts.add(ctx));
});

Mustache.registerHelper("log", function () {
  var args = can.makeArray(arguments).slice(0, arguments.length - 1);
  console.log.apply(console, ["Mustache log"].concat(_.map(args, function (arg) {
    return resolve_computed(arg);
  })));
});

Mustache.registerHelper('autocomplete_select', function (disableCreate, opt) {
  var cls;
  var options = arguments[arguments.length - 1];
  var _disableCreate = Mustache.resolve(disableCreate);

  if (typeof (_disableCreate) !== 'boolean') {
    _disableCreate = false;
  }
  if (options.hash && options.hash.controller) {
    cls = Mustache.resolve(cls);
    if (typeof cls === 'string') {
      cls = can.getObject(cls);
    }
  }
  return function (el) {
    $(el).bind('inserted', function () {
      var $ctl = $(this).parents(':data(controls)');
      $(this).ggrc_autocomplete($.extend({}, options.hash, {
        controller: cls ? $ctl.control(cls) : $ctl.control(),
        disableCreate: _disableCreate
      }));
    });
  };
});

Mustache.registerHelper("find_template", function (base_name, instance, options) {
  var tmpl;

  base_name = Mustache.resolve(base_name);
  if (!options) {
    options = instance;
    instance = options.context;
  }
  instance = Mustache.resolve(instance);
  if (instance.instance) {
    //binding result case
    instance = instance.instance;
  }
  if (GGRC.Templates[instance.constructor.table_plural + "/" + base_name]) {
    tmpl = "/static/mustache/" + instance.constructor.table_plural + "/" + base_name + ".mustache";
  } else if (GGRC.Templates["base_objects/" + base_name]) {
    tmpl = "/static/mustache/base_objects/" + base_name + ".mustache";
  } else {
    tmpl = null;
  }

  if (tmpl) {
    return options.fn(options.contexts.add({ template : tmpl }));
  } else {
    return options.inverse(options.contexts);
  }
});

// Append string to source if the string isn't already present,
//   remove the string from source if it is present.
Mustache.registerHelper("toggle_string", function (source, str) {
  source = Mustache.resolve(source);
  str = Mustache.resolve(str);
  var re = new RegExp('.*' + str);
  if (re.test(source)) {
    return source.replace(str, '');
  }

  return source + str;
});

Mustache.registerHelper("grdive_msg_to_id", function (message) {
  var msg = Mustache.resolve(message);

  if (!msg) {
    return;
  }

  msg = msg.split(' ');
  return msg[msg.length-1];
});

Mustache.registerHelper("disable_if_errors", function (instance) {
  var ins,
      res;
  ins = Mustache.resolve(instance);
  res = ins.computed_unsuppressed_errors();
  if (res == null ) {
    return "";
  }
  else {
    return "disabled" ;
  }
});

/*
  toggle mustache helper

  An extended "if" that sets up a "toggle_button" trigger, which can
  be applied to any button rendered within the section bounded by the
  toggle call.  toggle_buttons set the value of the toggle value to its
  boolean opposite.  Note that external forces can also set this value
  and thereby flip the toggle -- this helper is friendly to those cases.

  @helper_type section -- use outside of element tags.

  @param compute some computed value to flip between true and false
*/
Mustache.registerHelper("toggle", function (compute, options) {
  function toggle(trigger) {
    if (typeof trigger === "function") {
      trigger = Mustache.resolve(trigger);
    }
    if (typeof trigger !== "string") {
      trigger = "click";
    }
    return function (el) {
      $(el).bind(trigger, function () {
        compute(compute() ? false : true);
      });
    };
  }

  if (compute()) {
    return options.fn(
      options.contexts, { helpers: { toggle_button: toggle }});
  } else {
    return options.inverse(
      options.contexts, { helpers: { toggle_button: toggle }});
  }
});

can.each({
  "has_pending_addition": "add",
  "has_pending_removal": "remove"
}, function (how, fname) {
  Mustache.registerHelper(fname, function (object, option_instance, options) {
    if (!options) {
      options = option_instance;
      option_instance = object;
      object = options.context;
    }
    option_instance = Mustache.resolve(option_instance);
    object = Mustache.resolve(object);

    if (object._pending_joins && can.map(
      object._pending_joins,
      function (pj) {
        return pj.how === how && pj.what === option_instance ? option_instance : undefined;
      }).length > 0) {
      return options.fn(options.contexts);
    } else {
      return options.inverse(options.contexts);
    }
  });
});

Mustache.registerHelper("iterate_by_two", function (list, options) {
  var i, arr, output = [];
  list = Mustache.resolve(list);

  for (i = 0; i < list.length; i+=2) {
    if ((i + 1) === list.length) {
      arr = [list[i]];
    } else {
      arr = [list[i], list[i+1]];
    }
    output.push(options.fn(
      options.contexts.add({list: arr})));
  }
  return output.join("");
});

/**
 * Helper method for determining the file type of a Document object from its
 * file name extension.
 *
 * @param {Object} instance - an instance of a model object of type "Document"
 * @return {String} - determined file type or "default" for unknown/missing
 *   file name extensions.
 *
 * @throws {String} If the type of the `instance` is not "Document" or if its
 *   "title" attribute is empty.
 */
Mustache.registerHelper("file_type", function (instance) {
  var extension,
      filename,
      parts,
      DEFAULT_VALUE = "default",
      FILE_EXTENSION_TYPES,
      FILE_TYPES;

  FILE_TYPES = Object.freeze({
    PLAIN_TXT: "txt",
    IMAGE: "img",
    PDF: "pdf",
    OFFICE_DOC: "doc",
    OFFICE_SHEET: "xls",
    ARCHIVE: "zip"
  });

  FILE_EXTENSION_TYPES = Object.freeze({
    // plain text files
    txt: FILE_TYPES.PLAIN_TXT,

    // image files
    jpg: FILE_TYPES.IMAGE,
    jpeg: FILE_TYPES.IMAGE,
    png: FILE_TYPES.IMAGE,
    gif: FILE_TYPES.IMAGE,
    bmp: FILE_TYPES.IMAGE,
    tiff: FILE_TYPES.IMAGE,

    // PDF documents
    pdf: FILE_TYPES.PDF,

    // Office-like text documents
    doc: FILE_TYPES.OFFICE_DOC,
    docx: FILE_TYPES.OFFICE_DOC,
    odt: FILE_TYPES.OFFICE_DOC,

    // Office-like spreadsheet documents
    xls: FILE_TYPES.OFFICE_SHEET,
    xlsx: FILE_TYPES.OFFICE_SHEET,
    ods: FILE_TYPES.OFFICE_SHEET,

    // archive files
    zip: FILE_TYPES.ARCHIVE,
    rar: FILE_TYPES.ARCHIVE,
    "7z": FILE_TYPES.ARCHIVE,
    gz: FILE_TYPES.ARCHIVE,
    tar: FILE_TYPES.ARCHIVE
  });

  if (instance.type !== "Document") {
    throw "Cannot determine file type for a non-document object";
  }

  filename = instance.title || "";
  if (!filename) {
    throw "Cannot determine the object's file name";
  }

  parts = filename.split(".");
  extension = (parts.length === 1) ? "" : parts[parts.length - 1];
  extension = extension.toLowerCase();

  return FILE_EXTENSION_TYPES[extension] || DEFAULT_VALUE;
});

Mustache.registerHelper("debugger", function () {
  // This just gives you a helper that you can wrap around some code in a
  // template to see what's in the context. Dev tools need to be open for this
  // to work (in Chrome at least).
  debugger;

  var options = arguments[arguments.length - 1];
  return options.fn(options.contexts);
});

Mustache.registerHelper("update_link", function(instance, options) {

  instance = Mustache.resolve(instance);
  if (instance.viewLink) {
    var link = window.location.host + instance.viewLink;
    instance.attr('link', link);
  }
  return options.fn(options.contexts);
});

Mustache.registerHelper("with_most_recent_declining_task_entry", function (review_task, options) {
  var entries = review_task.get_mapping("declining_cycle_task_entries");
  var most_recent_entry;

  if(entries) {
    for (var i = entries.length - 1; i >= 0; i--) {
      var entry = entries[i];
      if ('undefined' !== typeof most_recent_entry) {
        if (moment(most_recent_entry.created_at).isBefore(moment(entry.created_at))) {
          most_recent_entry = entry;
        }
      } else {
        most_recent_entry = entry;
      }
    }
  }

  if(most_recent_entry) {
    return options.fn(options.contexts.add({'most_recent_declining_task_entry': most_recent_entry}));
  }
  return options.fn(options.contexts.add({'most_recent_declining_task_entry': {}}));
});
Mustache.registerHelper("inject_parent_instance", function(instance, options) {
  return options.fn(options.contexts.add($.extend({parent_instance: Mustache.resolve(instance)}, options.contexts._context)));
});

Mustache.registerHelper("if_less", function (a, b, options) {
  a = Mustache.resolve(a);
  b = Mustache.resolve(b);

  if (a < b) {
    return options.fn(options.contexts);
  } else {
    return options.inverse(options.contexts);
  }
});

Mustache.registerHelper("add_index", function(index, increment, options) {
  index = Mustache.resolve(index);
  increment = Mustache.resolve(increment);

  return (index + increment);
});

function get_proper_url (url) {
  var domain, max_label, url_split;

  if (!url) {
    return '';
  }

  if (!url.match(/^[a-zA-Z]+:/)) {
    url = (window.location.protocol === "https:" ? 'https://' : 'http://') + url;
  }

  // Make sure we can find the domain part of the url:
  url_split = url.split('/');
  if (url_split.length < 3) {
    return 'javascript://';
  }

  domain = url_split[2];
  max_label = _.max(domain.split('.').map(function(u) { return u.length; }));
  if (max_label > 63 || domain.length > 253) {
    // The url is invalid and might crash user's chrome tab
    return "javascript://";
  }
  return url;
}

Mustache.registerHelper('get_url_value', function (attr_name, instance) {
  instance = Mustache.resolve(instance);
  attr_name = Mustache.resolve(attr_name);

  if (instance[attr_name]) {
    if(['url', 'reference_url'].indexOf(attr_name) !== -1) {
      return get_proper_url(instance[attr_name]);
    }
  }
  return '';
});

  /**
   * Retrieve the string value of an attribute of the given instance.
   *
   * The method only supports instance attributes categorized as "default",
   * and does not support (read: not work for) nested object references.
   *
   * If the attribute does not exist, has a falsy value, or is not considered
   * to be a "default" attribute, an empty string is returned.
   *
   * If the attribute represents a date information, it is returned in the
   * MM/DD/YYYY format.
   *
   * @param {String} attrName - the name of the attribute to retrieve
   * @param {Object} instance - an instance of a model object
   * @return {String} - the retrieved attribute's value
   */
  Mustache.registerHelper('get_default_attr_value',
    function (attrName, instance) {
      // attribute names considered "default" and representing a date
      var DATE_ATTRS = Object.freeze({
        due_on: 1,
        end_date: 1,
        finished_date: 1,
        start_date: 1,
        updated_at: 1,
        verified_date: 1
      });

      // attribute names considered "default" and not representing a date
      var NON_DATE_ATTRS = Object.freeze({
        kind: 1,
        reference_url: 1,
        request_type: 1,
        slug: 1,
        status: 1,
        url: 1,
        verified: 1
      });

      var res;

      instance = Mustache.resolve(instance);
      attrName = Mustache.resolve(attrName);

      res = instance.attr(attrName);

      if (res !== undefined && res !== null) {
        if (attrName in NON_DATE_ATTRS) {
          if ($.type(res) === 'boolean') {
            res = String(res);
          }
          return res;
        }
        if (attrName in DATE_ATTRS) {
          // convert to a localized date
          return moment(res).format('MM/DD/YYYY');
        }
      }

      return '';
    }
  );

/*
  Used to get the string value for custom attributes
*/
  Mustache.registerHelper('get_custom_attr_value',
    function (attr, instance, options) {
      var value = '';
      var definition;

      attr = Mustache.resolve(attr);
      instance = Mustache.resolve(instance);

      can.each(GGRC.custom_attr_defs, function (item) {
        if (item.definition_type === instance.class.table_singular &&
          item.title === attr.attr_name) {
          definition = item;
        }
      });

      if (definition) {
        can.each(instance.custom_attribute_values, function (item) {
          if (!(instance instanceof CMS.Models.Assessment)) {
            // reify all models with the exception of the Assessment,
            // because it has a different logic of work with the CA
            item = item.reify();
          }
          if (item.custom_attribute_id === definition.id) {
            if (definition.attribute_type.startsWith('Map:')) {
              value = options.fn(options.contexts.add({
                object: item.attribute_object ?
                  item.attribute_object.reify() : null
              }));
            } else {
              value = item.attribute_value;
            }
          }
        });
      }

      return value;
    });

Mustache.registerHelper('with_create_issue_json', function (instance, options) {
  var audits;
  var audit;
  var programs;
  var program;
  var control;
  var json;
  var relatedControls;
  var canMap;

  instance = Mustache.resolve(instance);
  audits = instance.get_mapping('related_audits');
  if (!audits.length) {
    return options.inverse(options.contexts);
  }

  audit = audits[0].instance.reify();
  programs = audit.get_mapping('_program');
  program = programs.length ? programs[0].instance.reify() : {};
  control = instance.control ? instance.control.reify() : {};
  relatedControls = instance.get_mapping('related_controls');

  if (!control.id && relatedControls.length) {
    control = relatedControls[0].instance;
  }
  json = {
    audit: {title: audit.title, id: audit.id, type: audit.type},
    program: {title: program.title, id: program.id, type: program.type},
    control: {title: control.title, id: control.id, type: control.type},
    context: {type: audit.context.type, id: audit.context.id},
    assessment: {
      title: instance.title,
      id: instance.id,
      type: instance.type,
      title_singular: instance.class.title_singular,
      table_singular: instance.class.table_singular
    }
  };
  // Check permissions
  canMap = [audit, program, control, instance].every(function (obj) {
    if (_.isEmpty(obj)) {
      return true;
    }
    return Permission.is_allowed_for('update', obj);
  });
  if (canMap) {
    return options.fn(options.contexts.add(
        {create_issue_json: JSON.stringify(json)}));
  }
  return options.inverse(options.contexts);
});

Mustache.registerHelper("pretty_role_name", function (name) {
  name = Mustache.resolve(name);
  var ROLE_LIST = {
    "ProgramOwner": "Program Manager",
    "ProgramEditor": "Program Editor",
    "ProgramReader": "Program Reader",
    "WorkflowOwner": "Workflow Manager",
    "WorkflowMember": "Workflow Member",
    "Mapped": "No Role",
    "Owner": "Manager",
  };
  if (ROLE_LIST[name]) {
    return ROLE_LIST[name];
  }
  return name;
});

  Mustache.registerHelper('role_scope', function (scope) {
    scope = Mustache.resolve(scope);

    if (scope === 'Private Program') {
      return 'Program';
    }
    return scope;
  });

   /**
   * Check if provided user is current user
   *
   * Example usage:
   *
   *   {{#if_current_user person}}
   *     ...
   *   {{/if_current_user}}
   *
   * or:
   *
   *   {{#if_current_user email}}
   *     ...
   *   {{/if_current_user}}
   *
   * @param {Object|String} person - Person object or email
   * @param {Object} options - a CanJS options argument passed to every helper
   *
   */
  Mustache.registerHelper('if_current_user', function (person, options) {
    var email;
    person = Mustache.resolve(person);

    if (_.isString(person)) {
      email = person;
    } else if (person && person.email) {
      email = person.email;
    } else {
      console.warn('You should pass in either email or person object');
    }

    if (GGRC.current_user.email === email) {
      return options.fn(options.context);
    }
    return options.inverse();
  });

/*
Add new variables to current scope. This is useful for passing variables
to initialize a tree view.

Example:
  {{#add_to_current_scope example1="a" example2="b"}}
    {{log .}} // {example1: "a", example2: "b"}
  {{/add_to_current_scope}}
*/
Mustache.registerHelper("add_to_current_scope", function (options) {
  return options.fn(options.contexts.add(_.extend({}, options.context, options.hash)));
});

  /**
   * Return a value of a CMS.Model constructor's property.
   *
   * If a Model is not found, an error is raised. If a property does not exist
   * on the model, undefined is returned.
   *
   * @param {String} modelName - the name of the Model to inspect
   * @param {String} attr - the name of a modelName's property
   *
   * @return {*} - the value of the modelName[attr]
   */
  Mustache.registerHelper('model_info', function (modelName, attr, options) {
    var model;

    if (arguments.length !== 3) {
      throw new Error(
        'Invalid number of arguments (' +
        (arguments.length - 1) +  // do not count the auto-provided options arg
        '), expected 2.');
    }

    model = CMS.Models[modelName];

    if (typeof model === 'undefined') {
      throw new Error('Model not found (' + modelName + ').');
    }

    return model[attr];
  });

/*
Add spaces to a CamelCase string.

Example:
{{un_camel_case "InProgress"}} becomes "In Progress"
*/
  Mustache.registerHelper('un_camel_case', function (str, toLowerCase) {
    var value = Mustache.resolve(str);
    toLowerCase = typeof toLowerCase !== 'object';
    if (!value) {
      return value;
    }
    value = value.replace(/([A-Z]+)/g, ' $1').replace(/([A-Z][a-z])/g, ' $1');
    return toLowerCase ? value.toLowerCase() : value;
  });

  /**
   * Check if the current user is allowed to edit a comment, and render the
   * corresponding block in the template.
   *
   * Example usage:
   *
   *   {{#canEditComment commentInstance parentIntance}}
   *     ... (display e.g. an edit button) ...
   *   {{else}}
   *     ... (no edit button) ...
   *   {{/canEditComment}}
   *
   * @param {can.Model} comment - the Comment instance to check
   * @param {can.Model} parentInstance - the object the comment was posted
   *    under, e.g. an Assessment or a Request instance
   * @param {Object} options - a CanJS options argument passed to every helper
   *
   */
  Mustache.registerHelper('canEditComment',
    function (comment, parentInstance, options) {
      var END_STATES = Object.freeze({
        Verified: true,
        Completed: true
      });

      var canEdit = true;
      var isAdmin = Permission.is_allowed('__GGRC_ADMIN__');

      comment = Mustache.resolve(comment);
      parentInstance = Mustache.resolve(parentInstance);

      if (!Permission.is_allowed_for('update', comment)) {
        canEdit = false;
      } else if (!isAdmin && parentInstance.status in END_STATES) {
        // non-administrators cannot edit comments if the underlying object is
        // in final or verfiied state
        canEdit = false;
      }

      if (canEdit) {
        return options.fn(options.context);
      }

      return options.inverse(options.context);
    }
  );

  /**
   * Checks if two object types are mappable
   *
   * @param {String} source - Source type
   * @param {String} target - Target type
   * @param {Object} options - a CanJS options argument passed to every helper
   */
  Mustache.registerHelper('is_mappable_type',
    function (source, target, options) {
      target = Mustache.resolve(target);
      source = Mustache.resolve(source);
      if (GGRC.Utils.isMappableType(source, target)) {
        return options.fn(options.contexts);
      }
      return options.inverse(options.contexts);
    }
  );

  /**
   * Check if Custom Atttribute's value did not pass validation, and render the
   * corresponding block in the template. The error messages, if any, are
   * available in the "error" variable within the "truthy" block.
   *
   * Example usage:
   *
   *   {{#ca_validation_error validationErrors customAttrId}}
   *     Invalid value for the Custom Attribute {{customAttrId}}: {{errors.0}}
   *   {{else}}
   *     Hooray, no errors, a correct value is set!
   *   {{/ca_validation_error}}
   *
   * @param {Object} validationErrors - an object containing validation results
   *   of a can.Model instance
   * @param {Number} customAttrId - ID of the Custom Attribute to check for
   *   validation errors
   * @param {Object} options - a CanJS options argument passed to every helper
   */
  Mustache.registerHelper(
    'ca_validation_error',
    function (validationErrors, customAttrId, options) {
      var errors;
      var contextStack;
      var property;

      validationErrors = Mustache.resolve(validationErrors) || {};
      customAttrId = Mustache.resolve(customAttrId);

      property = 'custom_attributes.' + customAttrId;
      errors = validationErrors[property] || [];

      if (errors.length > 0) {
        contextStack = options.contexts.add({errors: errors});
        return options.fn(contextStack);
      }
      return options.inverse(options.contexts);
    }
  );
})(this, jQuery, can);

/*
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

/*
DO NOT EDIT - this is an auto generated file.

The file was generated by peg.js from src/parser/parsec.pegjs 
see: src/parser/generate_parser.js

*/

GGRC.query_parser = {
  parse: function parse(query) {
    try {
      return this.generated.parse(query);
    } catch (e) {
      // force texst search if anything goes wrong
      return this.generated.parse("~" + query);
    }
  },
  join_queries: function(left, right, op_key) {
    var expression = null,
        op = {},
        keys = jQuery.unique(left.keys.concat(right.keys));
    if (!left.expression.op){
      return right;
    }
    if (!right.expression.op){
      return left;
    }
    if (op_key && op_key == "OR") {
      op = {
        name: "OR",
        evaluate: function(val1, val2) { return val1 || val2; }
      };
    } else {
      op = {
        name: "AND",
        evaluate: function(val1, val2) { return val1 && val2; }
      };
    }
    expression = {
      left: left.expression,
      op: op,
      right: right.expression,
      evaluate: function(values) {
        return op.evaluate(left.expression.evaluate(values), right.expression.evaluate(values));
      }
    }
    return {
      expression: expression,
      keys: keys,
      order_by: right.order_by,
      evaluate: function(values, keys) {
        try {
          return expression.evaluate(values, keys)
        } catch (e) {
          return false;
        }
      }
    }
  },
  generated: (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = [],
        peg$c2 = function(only_order_by) {
              return {
                expression: {},
                keys: [],
                order_by: only_order_by,
                evaluate: function(values, keys) {
                  // functions evaluates the current expresion tree, with the given
                  // values
                  //
                  // * values, Object with all the keys as in the keys array, and their
                  //   coresponding values
                  return true;
                }
              };
            },
        peg$c3 = function(or_exp, order_by) {
              var keys = jQuery.unique(or_exp.keys.sort());
              delete or_exp.keys;
              return {
                expression: or_exp,
                keys: keys,
                order_by: order_by,
                evaluate: function(values, keys) {
                  // functions evaluates the current expresion tree, with the given
                  // values
                  //
                  // * values, Object with all the keys as in the keys array, and their
                  //   coresponding values
                  try {
                    return or_exp.evaluate(values, keys);
                  } catch (e) {
                    return false;
                  }
                }
              };
            },
        peg$c4 = function() {
              return {
                expression: {},
                keys: [],
                order_by: {
                  keys: [],
                  order: '',
                  compare: null
                },
                evaluate: function(values, keys) {
                  return true;
                }
              };
            },
        peg$c5 = { type: "any", description: "any character" },
        peg$c6 = function() {
              return false;
            },
        peg$c7 = " ",
        peg$c8 = { type: "literal", value: " ", description: "\" \"" },
        peg$c9 = function(only_order_by) {
              return only_order_by;
            },
        peg$c10 = function() {
              return {
                keys: [],
                order: '',
                compare: null
              };
            },
        peg$c11 = "order by",
        peg$c12 = { type: "literal", value: "order by", description: "\"order by\"" },
        peg$c13 = function(word_list, order) {
              return {
                keys: word_list,
                order: order,
                compare: function(val1, val2){
                  for (var i=0 ; i < word_list.length; i++){
                    var key = word_list[i];
                    if (val1[key] !== val2[key]){
                      var a = parseFloat(val1[key]) || val1[key],
                          b = parseFloat(val2[key]) || val2[key];
                      return (a < b) ^ (order !== 'asc')
                    }
                  }
                  return false;
                }
              };
            },
        peg$c14 = ",",
        peg$c15 = { type: "literal", value: ",", description: "\",\"" },
        peg$c16 = function(word, word_list) {
              return [word].concat(word_list);
            },
        peg$c17 = function(word) {
              return [word];
            },
        peg$c18 = "desc",
        peg$c19 = { type: "literal", value: "desc", description: "\"desc\"" },
        peg$c20 = function() {
              return 'desc';
            },
        peg$c21 = "asc",
        peg$c22 = { type: "literal", value: "asc", description: "\"asc\"" },
        peg$c23 = function() {
              return 'asc';
            },
        peg$c24 = function(left, op, right) {
              var keys = left.keys.concat(right.keys);
              delete right.keys;
              delete left.keys;
              return {
                left: left,
                op: op,
                right: right,
                keys: keys,
                evaluate: function(values) {
                  return op.evaluate(left.evaluate(values), right.evaluate(values));
                }
              };
            },
        peg$c25 = function(left, op, right) {
              var keys = left.keys.concat(right.keys);
              delete right.keys;
              delete left.keys;
              return {
                left:left,
                op: op,
                right: right,
                keys: keys,
                evaluate: function(values) {
                  return op.evaluate(left.evaluate(values), right.evaluate(values));
                }
              };
            },
        peg$c26 = function(left, op, right) {
              var lleft = left.toLowerCase();
              return {
                left: lleft,
                op: op,
                right: right,
                keys: [lleft],
                evaluate: function(values){
                  if (op.name != "~" && op.name != "!~" &&
                      (moment(right, "M/D/YYYY", true).isValid() ||
                      moment(right, "YYYY-M-D", true).isValid())) {
                    right = moment(right).format("YYYY-MM-DD");
                  }
                  return op.evaluate(values[lleft], right);
                }
              };
            },
        peg$c27 = "#",
        peg$c28 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c29 = function(relevant) {
              return {
                object_name: relevant[0],
                op: {name: "relevant"},
                ids: relevant.slice(1),
                keys: [],
                evaluate: function(values, keys){
                  return true;
                }
              };
            },
        peg$c30 = "~",
        peg$c31 = { type: "literal", value: "~", description: "\"~\"" },
        peg$c32 = function(characters) {
              return {
                text: characters.join("").trim(),
                op: {name:'text_search'},
                keys: [],
                evaluate: function(values, keys){
                   keys = keys || Object.keys(values);

                  function comparator(a, b){
                    return a.toUpperCase().indexOf(b.toUpperCase()) > -1
                  }

                  return keys.reduce(function(result, key){
                    if (result) return result;
                    if (values.hasOwnProperty(key)){
                      var value = values[key];
                      if (jQuery.type(value) === "string" ){
                        return comparator(value, this.text);
                      } else if (jQuery.type(value) === "array") {
                        return value.reduce(function(result, val){
                          return result || this.evaluate(val);
                        }.bind(this), false);
                      } else if (jQuery.type(value) === "object"){
                        return this.evaluate(value);
                      }
                    }
                    return result;
                  }.bind(this), false);
                }
              };
            },
        peg$c33 = "!~",
        peg$c34 = { type: "literal", value: "!~", description: "\"!~\"" },
        peg$c35 = function(characters) {
              return {
                text: characters.join("").trim(),
                op: {name: 'exclude_text_search'},
                keys: [],
                evaluate: function(values, keys){
                   keys = keys || Object.keys(values);

                  function comparator(a, b){
                    return a.toUpperCase().indexOf(b.toUpperCase()) == -1
                  }

                  return keys.reduce(function(result, key){
                    if (!result) return result;
                    if (values.hasOwnProperty(key)){
                      var value = values[key];
                      if (jQuery.type(value) === "string" ){
                        return comparator(value, this.text);
                      } else if (jQuery.type(value) === "array") {
                        return value.reduce(function(result, val){
                          return result || this.evaluate(val);
                        }.bind(this), false);
                      } else if (jQuery.type(value) === "object"){
                        return this.evaluate(value);
                      }
                    }
                    return result;
                  }.bind(this), true);
                }
              };
            },
        peg$c36 = function(or_exp) {
              return or_exp;
            },
        peg$c37 = function(word) {
              return word.join('');
            },
        peg$c38 = "\"",
        peg$c39 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c40 = /^[a-zA-Z0-9_\-.\/]/,
        peg$c41 = { type: "class", value: "[a-zA-Z0-9_\\-.\\/]", description: "[a-zA-Z0-9_\\-.\\/]" },
        peg$c42 = "\\\"",
        peg$c43 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
        peg$c44 = function() {
              return '"';
            },
        peg$c45 = /^[^"]/,
        peg$c46 = { type: "class", value: "[^\"]", description: "[^\"]" },
        peg$c47 = "and",
        peg$c48 = { type: "literal", value: "AND", description: "\"AND\"" },
        peg$c49 = function() {
              return {
                name: 'AND',
                evaluate: function(val1, val2) { return val1 && val2; }
              };
            },
        peg$c50 = "&&",
        peg$c51 = { type: "literal", value: "&&", description: "\"&&\"" },
        peg$c52 = "or",
        peg$c53 = { type: "literal", value: "OR", description: "\"OR\"" },
        peg$c54 = function() {
              return {
                name: 'OR',
                evaluate: function(val1, val2) { return val1 || val2;}
              };
            },
        peg$c55 = "||",
        peg$c56 = { type: "literal", value: "||", description: "\"||\"" },
        peg$c57 = function() {
              return {
                name: 'OR',
                evaluate: function(val1, val2) { return val1 || val2; }
              };
            },
        peg$c58 = "=",
        peg$c59 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c60 = function(op) {
              return {
                name: op,
                evaluate: function(val1, val2) {

                  if (jQuery.type(val1) === "array") {
                    return val1.reduce(function(result, value) {
                      return result || this.evaluate(value, val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "object") {
                    return Object.keys(val1).reduce(function(result, key) {
                      return result || this.evaluate(val1[key], val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "string") {
                    return val1.toUpperCase() == val2.toUpperCase();
                  } else {
                    return val1 == val2;
                  }
                }
              };
            },
        peg$c61 = "!=",
        peg$c62 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c63 = function(op) {
              return {
                name: op,
                evaluate: function(val1, val2) {

                  if (jQuery.type(val1) === "array") {
                    return val1.reduce(function(result, value) {
                      return result || this.evaluate(value, val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "object") {
                    return Object.keys(val1).reduce(function(result, key) {
                      return result || this.evaluate(val1[key], val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "string") {
                    return val1.toUpperCase() != val2.toUpperCase();
                  } else {
                    return val1 != val2;
                  }
                }
              };
            },
        peg$c64 = "<",
        peg$c65 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c66 = function(op) {
              return {
                name: op,
                evaluate: function(val1, val2) {
                  return val1 < val2;
                }
              };
            },
        peg$c67 = ">",
        peg$c68 = { type: "literal", value: ">", description: "\">\"" },
        peg$c69 = function(op) {
              return {
                name: op,
                evaluate: function(val1, val2) {
                  return val1 > val2;
                }
              };
            },
        peg$c70 = function(op) {
              return {
                name: op,
                evaluate: function(val1, val2) {

                  if (jQuery.type(val1) === "array") {
                    return val1.reduce(function(result, value) {
                      return result || this.evaluate(value, val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "object") {
                    return Object.keys(val1).reduce(function(result, key) {
                      return result || this.evaluate(val1[key], val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "string") {
                    return val1.toUpperCase().indexOf(val2.toUpperCase()) > -1 ;
                  } else {
                    return false;
                  }
                }
              };
            },
        peg$c71 = function(op) {
              return {
                name: op,
                evaluate: function(val1, val2) {
                  if (jQuery.type(val1) === "array") {
                    return val1.reduce(function(result, value) {
                      return result || this.evaluate(value, val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "object") {
                    return Object.keys(val1).reduce(function(result, key) {
                      return result || this.evaluate(val1[key], val2);
                    }.bind(this), false);
                  } else if (jQuery.type(val1) === "string") {
                    // the comparison is done here
                    return val1.toUpperCase().indexOf(val2.toUpperCase()) == -1 ;
                  } else {
                    return false;
                  }
                }
              };
            },
        peg$c72 = "(",
        peg$c73 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c74 = ")",
        peg$c75 = { type: "literal", value: ")", description: "\")\"" },
        peg$c76 = /^[ \t\r\n\f]/,
        peg$c77 = { type: "class", value: "[ \\t\\r\\n\\f]", description: "[ \\t\\r\\n\\f]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseonly_order_by();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c2(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseor_exp();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseorder_by();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parse_();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parse_();
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c3(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c4();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c6();
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parseorder_by() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseonly_order_by();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c9(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c10();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseonly_order_by() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c11) {
          s2 = input.substr(peg$currPos, 8);
          peg$currPos += 8;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseword_list();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseorder();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13(s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseword_list() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseword();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c14;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c15); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseword_list();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c16(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseword();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c17(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseorder() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c18) {
          s2 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c19); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c20();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
        } else {
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c21) {
            s2 = input.substr(peg$currPos, 3);
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c22); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c23();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c23();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseor_exp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseand_exp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOR();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseor_exp();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseand_exp();
      }

      return s0;
    }

    function peg$parseand_exp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsesimple_exp();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseAND();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseand_exp();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c25(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsesimple_exp();
      }

      return s0;
    }

    function peg$parsesimple_exp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseword();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseword();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c26(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parserelevant_exp();
        if (s0 === peg$FAILED) {
          s0 = peg$parseparen_exp();
          if (s0 === peg$FAILED) {
            s0 = peg$parsetext_exp();
          }
        }
      }

      return s0;
    }

    function peg$parserelevant_exp() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 35) {
          s2 = peg$c27;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseword_list();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 35) {
              s4 = peg$c27;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c28); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c29(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsetext_exp() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 126) {
          s2 = peg$c30;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c31); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c32(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c33) {
            s2 = peg$c33;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c35(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseparen_exp() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseLEFT_P();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseor_exp();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseRIGHT_P();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c36(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseword() {
      var s0;

      s0 = peg$parseunquoted_word();
      if (s0 === peg$FAILED) {
        s0 = peg$parsequoted_word();
      }

      return s0;
    }

    function peg$parseunquoted_word() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseunqoted_char();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseunqoted_char();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c37(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsequoted_word() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c38;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c39); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsequoted_char();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsequoted_char();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c38;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c37(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseunqoted_char() {
      var s0;

      if (peg$c40.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }

      return s0;
    }

    function peg$parsequoted_char() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c42) {
        s1 = peg$c42;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c44();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
      }

      return s0;
    }

    function peg$parseAND() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c47) {
          s2 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c49();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c50) {
            s2 = peg$c50;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c49();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseOR() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c52) {
          s2 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c53); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c54();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c55) {
            s2 = peg$c55;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseOP() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c58;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c59); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c60(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parse_();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c61) {
            s2 = peg$c61;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parse_();
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c63(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parse_();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parse_();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 60) {
              s2 = peg$c64;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c65); }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parse_();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parse_();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c66(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parse_();
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s2 = peg$c67;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c68); }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parse_();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parse_();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c69(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parse_();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parse_();
              }
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 126) {
                  s2 = peg$c30;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c31); }
                }
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parse_();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parse_();
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c70(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parse_();
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parse_();
                }
                if (s1 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c33) {
                    s2 = peg$c33;
                    peg$currPos += 2;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c34); }
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parse_();
                    while (s4 !== peg$FAILED) {
                      s3.push(s4);
                      s4 = peg$parse_();
                    }
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c71(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseLEFT_P() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c72;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseRIGHT_P() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s2 = peg$c74;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c75); }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      if (peg$c76.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c76.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c77); }
          }
        }
      } else {
        s0 = peg$c0;
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})()
};

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  /*  GGRC.ListLoaders.MappingResult
   *
   *  - `instance`: The resulting item itself
   *  - `mappings`: Essentially, the reason(s) the instance appears in the
   *      list.  This may be an instance of can.Model or a pair containing
   *      (binding, result) in the case of a chained ListLoader.
   *
   *  For FilteredListLoader, the mappings are (`result`, `binding`), where
   *    `binding` is the binding in which the result appears, and thus,
   *    `binding.loader` contains information about the filter.
   *    `binding.instance`, then, is the instance on which the original,
   *    unfiltered list is specified.
   *  For CrossListLoader, the mappings are (`result`, `binding`), where
   *    `binding` is the "remote binding" which
   */
  can.Construct('GGRC.ListLoaders.MappingResult', {}, {
    init: function (instance, mappings, binding) {
      if (!mappings) {
        // Assume item was passed in as an object
        mappings = instance.mappings;
        binding = instance.binding;
        instance = instance.instance;
      }

      this.instance = instance;
      this.mappings = this._make_mappings(mappings);
      this.binding = binding;
    },

    //  `_make_mappings`
    //  - Ensures that every instance in `mappings` is an instance of
    //    `MappingResult`.
    _make_mappings: function (mappings) {
      var i;
      var mapping;

      if (!mappings)
        mappings = [];

      for (i = 0; i < mappings.length; i++) {
        mapping = mappings[i];
        if (!(mapping instanceof GGRC.ListLoaders.MappingResult))
          mapping = new GGRC.ListLoaders.MappingResult(mapping);
        mappings[i] = mapping;
      }

      return mappings;
    },

    //  `observe_trigger`, `watch_observe_trigger`, `trigger_observe_trigger`
    //  - These exist solely to support dynamic updating of `*_compute`.
    //    Basically, these fake dependencies for those computes so each is
    //    updated any time a mapping is inserted or removed beyond a
    //    "virtual" level, which would otherwise obscure changes in the
    //    "first-level mappings" which both `bindings_compute` and
    //    `mappings_compute` depend on.
    observe_trigger: function () {
      if (!this._observe_trigger)
        this._observe_trigger = new can.Observe({change_count: 1});
      return this._observe_trigger;
    },

    watch_observe_trigger: function () {
      this.observe_trigger().attr('change_count');
      can.each(this.mappings, function (mapping) {
        if (mapping.watch_observe_trigger)
          mapping.watch_observe_trigger();
      });
    },

    trigger_observe_trigger: function () {
      var observeTrigger = this.observe_trigger();
      observeTrigger.attr('change_count', observeTrigger.change_count + 1);
    },

    //  `insert_mapping` and `remove_mapping`
    //  - These exist solely to trigger an `observe_trigger` change event
    insert_mapping: function (mapping) {
      this.mappings.push(mapping);
      // Trigger change event
      this.trigger_observe_trigger();
    },

    remove_mapping: function (mapping) {
      var ret;
      var mappingIndex = this.mappings.indexOf(mapping);
      if (mappingIndex > -1) {
        ret = this.mappings.splice(mappingIndex, 1);
        //  Trigger change event
        this.trigger_observe_trigger();
        return ret;
      }
    },

    //  `get_bindings`, `bindings_compute`, `get_bindings_compute`
    //  - Returns a list of the `ListBinding` instances which are the source
    //    of 'first-level mappings'.
    get_bindings: function () {
      var bindings = [];

      this.walk_instances(function (instance, result, depth) {
        if (depth === 1)
          bindings.push(result.binding);
      });
      return bindings;
    },

    bindings_compute: function () {
      if (!this._bindings_compute)
        this._bindings_compute = this.get_bindings_compute();
      return this._bindings_compute;
    },

    get_bindings_compute: function () {
      var self = this;

      return can.compute(function () {
        // Unnecessarily access observe_trigger to be able to trigger change
        self.watch_observe_trigger();
        return self.get_bindings();
      });
    },

    //  `get_mappings`, `mappings_compute`, and `get_mappings_compute`
    //  - Returns a list of first-level mapping instances, even if they're
    //    several levels down due to virtual mappers like Multi or Cross
    //  - "First-level mappings" are the objects whose existence causes the
    //    `binding.instance` to be in the current `binding.list`.  (E.g.,
    //    if any of the "first-level mappings" exist, the instance will
    //    appear in the list.
    get_mappings: function () {
      var self = this;
      var mappings = [];

      this.walk_instances(function (instance, result, depth) {
        if (depth === 1) {
          if (instance === true)
            mappings.push(self.instance);
          else
            mappings.push(instance);
        }
      });
      return mappings;
    },

    mappings_compute: function () {
      if (!this._mappings_compute)
        this._mappings_compute = this.get_mappings_compute();
      return this._mappings_compute;
    },

    get_mappings_compute: function () {
      var self = this;

      return can.compute(function () {
        // Unnecessarily access _observe_trigger to be able to trigger change
        self.watch_observe_trigger();
        return self.get_mappings();
      });
    },

    //  `walk_instances`
    //  - `binding.mappings` can have several "virtual" levels due to mappers
    //    like `Multi`, `Cross`, and `Filter` -- e.g., mappers which just
    //    aggregate or filter results of other mappers.  `walk_instances`
    //    iterates over these "virtual" levels to emit instances only once
    //    per time they appear in a traversal path of `binding.mappings`.
    walk_instances: function (fn, lastInstance, depth) {
      var i;
      if (!depth)
        depth = 0;
      if (this.instance !== lastInstance) {
        fn(this.instance, this, depth);
        depth++;
      }
      for (i = 0; i < this.mappings.length; i++) {
        this.mappings[i].walk_instances(fn, this.instance, depth);
      }
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  /*  GGRC.ListLoaders.ListBinding
   */
  can.Construct('GGRC.ListLoaders.ListBinding', {}, {
    init: function (instance, loader) {
      this.instance = instance;
      this.loader = loader;

      this.list = new can.Observe.List();
    },

    refresh_stubs: function () {
      return this.loader.refresh_stubs(this);
    },

    refresh_instances: function (force) {
      return this.loader.refresh_instances(this, force);
    },

    //  `refresh_count`
    //  - Returns a `can.compute`, which in turn returns the length of
    //    `this.list`
    //  - Attempts to do the minimal work (e.g., loading only stubs, not full
    //    instances) to return an accurate length
    refresh_count: function () {
      var self = this;
      return this.refresh_stubs().then(function () {
        return can.compute(function () {
          return self.list.attr('length');
        });
      });
    },

    //  `refresh_list`
    //  - Returns a list which will *only* ever contain fully loaded / reified
    //    instances
    refresh_list: function () {
      var loader = new GGRC.ListLoaders.ReifyingListLoader(this);
      var binding = loader.attach(this.instance);
      var self = this;

      binding.name = this.name + '_instances';
      //  FIXME: `refresh_instances` should not need to be called twice, but
      //  it fixes pre-mature resolution of mapping deferreds in some cases
      return binding.refresh_instances(this).then(function () {
        return self.refresh_instances();
      });
    },

    refresh_instance: function () {
      var refreshQueue = new RefreshQueue();
      refreshQueue.enqueue(this.instance);
      return refreshQueue.trigger();
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  can.Construct('GGRC.ListLoaders.BaseListLoader', {
    binding_factory: function (instance, loader) {
      return new GGRC.ListLoaders.ListBinding(instance, loader);
    }
  }, {
    init: function () {
    },

    attach: function (instance) {
      var binding = this.constructor.binding_factory(instance, this);
      this.init_listeners(binding);
      return binding;
    },

    make_result: function (instance, mappings, binding) {
      return new GGRC.ListLoaders.MappingResult(instance, mappings, binding);
    },

    find_result_by_instance: function (result, list) {
      var i;
      var foundResult = null;
      var oldResult;

      for (i = 0; !foundResult && i < list.length; i++) {
        oldResult = list[i];
        if (oldResult.instance.id === result.instance.id &&
          oldResult.instance.constructor.shortName ===
          result.instance.constructor.shortName) {
          foundResult = oldResult;
        }
      }

      return foundResult;
    },

    is_duplicate_result: function (oldResult, newResult) {
      var old = oldResult;
      var new_ = newResult;

      if (old.instance === new_.instance) {// && o.binding  === n.binding) {
        if (old.mappings === new_.mappings) {
          return true;
        }
        old = old.mappings;
        new_ = new_.mappings;
        if (old && new_ && old.length === 1 && new_.length === 1) {
          old = old[0];
          new_ = new_[0];
          if (old.binding === new_.binding) {
            if (old.instance === new_.instance &&
              (old.mappings.length > 0 || new_.mappings.length > 0)) {
              old = old.mappings;
              new_ = new_.mappings;
              if (old && new_ && old.length === 1 && new_.length === 1) {
                old = old[0];
                new_ = new_[0];
              }
            }

            if (old.binding === new_.binding && old.instance === true &&
              new_.instance === true && old.mappings &&
              old.mappings.length === 0 && new_.mappings &&
              new_.mappings.length === 0) {
              return true;
            }
          }
        }
      }

      return false;
    },

    insert_results: function (binding, results) {
      var self = this;
      var allBindingResults = [];
      var newInstanceResults = [];
      var instancesToRefresh = [];

      can.each(results, function (newResult) {
        var foundResult = null;
        var mappingAttr;

        foundResult = self.find_result_by_instance(newResult, binding.list);

        if (!foundResult && binding.pending_list) {
          foundResult =
            self.find_result_by_instance(newResult, binding.pending_list);
        }

        if (!foundResult) {
          foundResult =
            self.find_result_by_instance(newResult, newInstanceResults);
        }

        if (foundResult) {
          if (self.is_duplicate_result(foundResult, newResult)) {
            return;
          }

          mappingAttr = foundResult.mappings;
          // Since we're adding the result as its own mapping, use
          // new_result as the mapping instead of new_result.mappings?

          can.each(newResult.mappings, function (mapping) {
            // TODO: Examine when this will be false -- is it a sign of
            //   duplicate work?
            if (mappingAttr.indexOf && mappingAttr.indexOf(mapping) === -1) {
              foundResult.insert_mapping(mapping);
              instancesToRefresh.push(newResult.instance);
            }
          });

          allBindingResults.push(foundResult);
        } else {
          //  FIXME: Loaders should be passing in newly instantiated results,
          //    so this line should be:
          //      found_result = new_result;
          //    but it's not a big deal
          foundResult =
            self.make_result(newResult.instance, newResult.mappings, binding);
          newInstanceResults.push(foundResult);
          instancesToRefresh.push(newResult.instance);
          // FIXME: Also queue mappings to refresh?

          allBindingResults.push(foundResult);
        }
      });

      if (newInstanceResults.length > 0) {
        binding.list.push.apply(binding.list, newInstanceResults);

        //  TODO: Examine whether deferring this list insertion avoids
        //    causing client-side freezes
        /* if (!binding.pending_list)
         binding.pending_list = [];
         binding.pending_list.push.apply(binding.pending_list, new_instance_results);

         if (!binding.pending_timeout) {
         binding.pending_deferred = new $.Deferred();
         binding.pending_timeout = setTimeout(function() {
         binding.list.push.apply(binding.list, binding.pending_list);
         delete binding.pending_list;
         delete binding.pending_timeout;
         binding.pending_deferred.resolve();
         delete binding.pending_deferred;
         }, 100);
         }*/
      }

      return allBindingResults;
    },

    remove_instance: function (binding, instance, mappings) {
      var indexesToRemove = [];

      if (!(can.isArray(mappings) || mappings instanceof can.Observe.List))
        mappings = [mappings];

      can.each(binding.list, function (data, instanceIndex) {
        var mappingAttr = binding.list[instanceIndex].mappings;

        if (data.instance.id === instance.id &&
          data.instance.constructor.shortName ===
          instance.constructor.shortName) {
          if (mappingAttr.length === 0) {
            indexesToRemove.push(instanceIndex);
          } else {
            can.each(mappings, function (mapping) {
              var wasRemoved = data.remove_mapping(mapping);
              if (wasRemoved) {
                if (mappingAttr.length === 0)
                  indexesToRemove.push(instanceIndex);
              }
            });
          }
        }
      });
      can.each(indexesToRemove.sort(), function (indexToRemove, count) {
        binding.list.splice(indexToRemove - count, 1);
      });
    },

    refresh_stubs: function (binding) {
      if (!binding._refresh_stubs_deferred) {
        binding._refresh_stubs_deferred = $.when(this._refresh_stubs(binding));
      }
      return binding._refresh_stubs_deferred
        .then(function () {
          return binding.list;
        });
    },

    refresh_instances: function (binding, force) {
      if (force || !binding._refresh_instances_deferred) {
        binding._refresh_instances_deferred =
          $.when(this._refresh_instances(binding, force));
      }
      return binding._refresh_instances_deferred
        .then(
          function () {
            return binding.list;
          },
          function () {
            setTimeout(function () {
              delete binding._refresh_instances_deferred;
            }, 10);
            return this;
          });
    },

    _refresh_instances: function (binding, force) {
      return this.refresh_stubs(binding)
        .then(function () {
          var refreshQueue = new RefreshQueue();
          can.each(binding.list, function (result) {
            refreshQueue.enqueue(result.instance, force);
          });
          return refreshQueue.trigger();
        });
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.StubFilteredListLoader', {},
    {
      init: function (source, filterFn) {
        this._super();

        this.source = source;
        this.filter_fn = filterFn;
      },
      init_listeners: function (binding) {
        var self = this;
        var matchingResults;

        if (typeof this.source === 'string') {
          binding.source_binding = binding.instance.get_binding(this.source);
        } else {
          binding.source_binding = this.source;
        }
        binding.source_binding.list.bind('add', function (ev, results) {
          if (binding._refresh_stubs_deferred &&
            binding._refresh_stubs_deferred.state() !== 'pending') {
            matchingResults = can.map(can.makeArray(results), function (res) {
              if (self.filter_fn(res)) {
                return self.make_result(res.instance, [res], binding);
              }
            });
            self.insert_results(binding, matchingResults);
          }
        });

        binding.source_binding.list.bind('remove', function (ev, results) {
          can.each(results, function (result) {
            self.remove_instance(binding, result.instance, result);
          });
        });
      },
      _refresh_stubs: function (binding) {
        return binding.source_binding.refresh_stubs()
          .then(function (results) {
            var matchingResults = can.map(can.makeArray(results),
              function (result) {
                if (this.filter_fn(result)) {
                  return this.make_result(result.instance, [result], binding);
                }
              }.bind(this));
            this.insert_results(binding, matchingResults);
          }.bind(this));
      }
    });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.CrossListLoader', {}, {
    init: function (localMapping, remoteMapping) {
      this._super();

      this.local_mapping = localMapping;
      this.remote_mapping = remoteMapping;
    },
    init_listeners: function (binding) {
      if (!binding.bound_insert_from_source_binding) {
        binding.bound_insert_from_source_binding =
          this.proxy('insert_from_source_binding', binding);
        binding.bound_remove_from_source_binding =
          this.proxy('remove_from_source_binding', binding);
      }

      binding.source_binding = binding.instance.get_binding(this.local_mapping);

      binding.source_binding.list.bind(
        'add', binding.bound_insert_from_source_binding);
      binding.source_binding.list.bind(
        'remove', binding.bound_remove_from_source_binding);
    },
    insert_from_source_binding: function (binding, ev, localResults, index) {
      var self = this;
      can.each(localResults, function (localResult) {
        // FIXME: This is identical to code in _refresh_stubs
        var remoteBinding = self.insert_local_result(binding, localResult);
        remoteBinding.refresh_instance().then(function () {
          remoteBinding.refresh_stubs();
        });
      });
    },
    remove_from_source_binding: function (binding, ev, localResults, index) {
      var self = this;
      can.each(localResults, function (localResult) {
        self.remove_local_result(binding, localResult);
      });
    },
    insert_local_result: function (binding, localResult) {
      var self = this;
      var i;
      var localResults;
      var remoteBinding;

      if (!binding.remote_bindings)
        binding.remote_bindings = [];

      for (i = 0; i < binding.remote_bindings.length; i++) {
        if (binding.remote_bindings[i].instance === localResult.instance)
          return binding.remote_bindings[i];
      }

      remoteBinding =
        localResult.instance.get_binding(self.remote_mapping);
      remoteBinding.bound_insert_from_remote_binding =
        this.proxy('insert_from_remote_binding', binding, remoteBinding);
      remoteBinding.bound_remove_from_remote_binding =
        this.proxy('remove_from_remote_binding', binding, remoteBinding);

      binding.remote_bindings.push(remoteBinding);

      remoteBinding.list.bind(
        'add', remoteBinding.bound_insert_from_remote_binding);
      remoteBinding.list.bind(
        'remove', remoteBinding.bound_remove_from_remote_binding);

      localResults = can.map(remoteBinding.list, function (result) {
        return self.make_result(result.instance, [result], binding);
      });
      self.insert_results(binding, localResults);

      return remoteBinding;
    },
    remove_local_result: function (binding, localResult) {
      var self = this;
      var remoteBinding;
      var i;
      var remoteBindingIndex;

      if (!binding.remote_bindings)
        binding.remote_bindings = [];

      for (i = 0; i < binding.remote_bindings.length; i++) {
        if (binding.remote_bindings[i].instance === localResult.instance)
          remoteBinding = binding.remote_bindings[i];
      }

      if (!remoteBinding) {
        console.debug('Removed binding not found:', localResult, binding);
        return;
      }

      remoteBinding.list.unbind(
        'add', remoteBinding.bound_insert_from_remote_binding);
      remoteBinding.list.unbind(
        'remove', remoteBinding.bound_remove_from_remote_binding);

      can.each(remoteBinding.list, function (result) {
        self.remove_instance(binding, result.instance, result);
      });

      remoteBindingIndex = binding.remote_bindings.indexOf(remoteBinding);
      binding.remote_bindings.splice(remoteBindingIndex, 1);
    },
    insert_from_remote_binding: function (binding, remoteBinding, ev, results) {
      var self = this;
      var newResults = can.map(results, function (result) {
        return self.make_result(result.instance, [result], binding);
      });
      this.insert_results(binding, newResults);
    },
    remove_from_remote_binding: function (binding, remoteBinding, ev, results) {
      var self = this;
      can.each(results, function (result) {
        self.remove_instance(binding, result.instance, result);
      });
    },
    _refresh_stubs: function (binding) {
      var self = this;

      return binding.source_binding.refresh_stubs()
        .then(function (localResults) {
          var deferreds = [];

          can.each(localResults, function (localResult) {
            var remoteBinding = self.insert_local_result(binding, localResult);
            var deferred = remoteBinding.refresh_instance().then(function () {
              return remoteBinding.refresh_stubs();
            });

            deferreds.push(deferred);
          });

          return $.when.apply($, deferreds);
        })
        .then(function () {
          return binding.list;
        });
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.StubFilteredListLoader(
    'GGRC.ListLoaders.TypeFilteredListLoader', {}, {
      init: function (source, modelNames) {
        var filterFn = function (result) {
          var i;
          var modelName;
          for (i = 0; i < modelNames.length; i++) {
            modelName = modelNames[i];
            if (typeof modelName !== 'string')
              modelName = modelName.shortName;
            if (result.instance.constructor &&
              result.instance.constructor.shortName === modelName)
              return true;
          }
          return false;
        };

        this._super(source, filterFn);
      }
    });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.StubFilteredListLoader(
    'GGRC.ListLoaders.AttrFilteredListLoader', {}, {
      init: function (source, prop, value, type) {
        var filterFn = function (binding) {
          // TODO: We should filter by type as well
          if (!binding.mappings) {
            return;
          }
          return _.any(binding.mappings, function (mapping) {
            var instance = mapping.instance;
            if (instance instanceof CMS.Models.Relationship) {
              if (_.exists(instance, 'attrs') &&
                  instance.attrs[prop] && (!value ||
                _.contains(instance.attrs[prop].split(','), value))) {
                return true;
              }
            }
            return filterFn(mapping);
          });
        };
        this.prop_name = prop;
        this.keyword = value;
        this.object_type = type;
        this._super(source, filterFn);
      },
      init_listeners: function (binding) {
        this._super(binding);
        function itemFromList(list, id) {
          return _.first(can.makeArray(list).filter(function (item) {
            return item.instance.id === id;
          }));
        }

        CMS.Models.Relationship.bind('updated', function (ev, model) {
          var value;
          var needle;
          var active;
          var activeInList;
          var contains;
          if (!(model instanceof CMS.Models.Relationship)) {
            return;
          }
          value = can.getObject('attrs.' + this.prop_name, model);

          if (model.source.type === this.object_type) {
            needle = model.source;
          } else if (model.destination.type === this.object_type) {
            needle = model.destination;
          }
          if (!needle || !value) {
            return;
          }
          active = itemFromList(binding.source_binding.list, needle.id);
          activeInList = itemFromList(binding.list, needle.id);

          if (!active) {
            return;
          }
          contains = _.contains(value.split(','), this.keyword);
          if (!contains && activeInList) {
            binding.list.splice(
                _.map(binding.list, function (e) {
                  return e.instance.id;
                }).indexOf(active.instance.id),
                1
            );
          }
          if (contains && !activeInList) {
            this.insert_results(binding, [active]);
          }
        }.bind(this));
      }
    });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.FirstElementLoader', {}, {
    init_listeners: function (binding) {
      var self = this;

      binding.source_binding = binding.instance.get_binding(this.source);

      binding.source_binding.list.bind('add', function (ev, results) {
        var matchingResults = results[0];
        if (self.list.length < 1)
          self.insert_results(binding, [matchingResults]);
      });

      binding.source_binding.list.bind('remove', function (ev, results) {
        can.each(results, function (result) {
          self.remove_instance(binding, result.instance, result);
        });
        if (self.list.length < 1)
          self.insert_results(binding, [binding.source_binding.list[0]]);
      });
    },
    _refresh_stubs: function (binding) {
      var self = this;

      return binding.source_binding.refresh_stubs()
        .then(function (results) {
          var matchingResults = results[0];
          self.insert_results(binding, matchingResults);
        });
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  /*
   CustomFilteredListLoader allows any sort of filter to be applied on instances
   to create a new set of filtered items.  This depends on refresh_instances from
   the source list loader and a filter function applied to each MappingResult.

   The signature of the filter function is (MappingResult) -> truthy | falsy | Deferred

   if the filter function returns a Deferred, inclusion of the instance in the new
   ListBinding will be contingent on the Deferred resolving to a truthy value.

   Rejected Deferreds are treated as false.
   */
  GGRC.ListLoaders.StubFilteredListLoader(
    'GGRC.ListLoaders.CustomFilteredListLoader', {}, {
      process_result: function (binding, result, newResult, include) {
        var self = this;
        if (include) {
          if (typeof include.then === 'function') {
            // return nothing yet. push in later if it is needed.
            include.then(function (realInclude) {
              if (realInclude) {
                self.insert_results(binding, [newResult]);
              } else {
                self.remove_instance(binding, result.instance, result);
              }
            }, function () {
              // remove instance (if it exists) if the deferred rejects
              self.remove_instance(binding, result.instance, result);
            });
          } else {
            self.insert_results(binding, [newResult]);
          }
        } else {
          self.remove_instance(binding, result.instance, result);
        }
      },

      init_listeners: function (binding) {
        var self = this;
        function resultCompute(result) {
          return can.compute(function () {
            return self.filter_fn(result);
          });
        }

        if (typeof this.source === 'string') {
          binding.source_binding = binding.instance.get_binding(this.source);
        } else {
          binding.source_binding = this.source;
        }

        binding.source_binding.list.bind('add', function (ev, results) {
          binding.refresh_instances().done(function () {
            new RefreshQueue().enqueue(
              can.map(results, function (res) {
                return res.instance;
              })
            ).trigger().done(function () {
              can.map(can.makeArray(results), function (result) {
                var newResult =
                  self.make_result(result.instance, [result], binding);
                newResult.compute = resultCompute(result);
                newResult.compute.bind('change',
                  $.proxy(self, 'process_result', binding, result, newResult));
                self.process_result(binding, result, newResult,
                  newResult.compute());
              });
            });
          });
        });

        binding.source_binding.list.bind('remove', function (ev, results) {
          can.each(results, function (result) {
            self.remove_instance(binding, result.instance, result);
          });
        });
      },

      _refresh_stubs: function (binding) {
        var self = this;

        return binding.source_binding.refresh_instances()
          .then(function (results) {
            new RefreshQueue().enqueue(
              can.map(results, function (res) {
                return res.instance;
              })
            ).trigger().done(function () {
              can.map(can.makeArray(results), function (result) {
                var newResult =
                  self.make_result(result.instance, [result], binding);
                newResult.compute = can.compute(function () {
                  return self.filter_fn(result);
                });
                newResult.compute.bind('change',
                  $.proxy(self, 'process_result', binding, result, newResult));
                self.process_result(binding, result, newResult,
                  newResult.compute());
              });
            });
          });
      }
    });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.MultiListLoader', {}, {
    init: function (sources) {
      this._super();

      this.sources = sources || [];
    },
    init_listeners: function (binding) {
      var self = this;

      if (!binding.source_bindings)
        binding.source_bindings = [];

      can.each(this.sources, function (source) {
        var sourceBinding = binding.instance.get_binding(source);
        if (source) {
          binding.source_bindings.push(sourceBinding);
          self.init_source_listeners(binding, sourceBinding);
        }
      });
    },
    insert_from_source_binding: function (binding, results, index) {
      var self = this;
      var newResults;

      newResults = can.map(results, function (result) {
        return self.make_result(result.instance, [result], binding);
      });
      self.insert_results(binding, newResults);
    },
    init_source_listeners: function (binding, sourceBinding) {
      var self = this;

      self.insert_from_source_binding(binding, sourceBinding.list);

      sourceBinding.list.bind('add', function (ev, results) {
        self.insert_from_source_binding(binding, results);
      });

      sourceBinding.list.bind('remove', function (ev, results) {
        can.each(results, function (result) {
          self.remove_instance(binding, result.instance, result);
        });
      });
    },
    _refresh_stubs: function (binding) {
      var deferreds = [];

      can.each(binding.source_bindings, function (sourceBinding) {
        deferreds.push(sourceBinding.refresh_stubs());
      });

      return $.when.apply($, deferreds);
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.IntersectingListLoader', {},
    {
      init: function (sources) {
        this._super();

        this.sources = sources || [];
      },
      init_listeners: function (binding) {
        var self = this;

        if (!binding.source_bindings)
          binding.source_bindings = [];

        can.each(this.sources, function (source) {
          var sourceBinding = null;
          // Here is a deviation from the norm, since we want to
          //  allow source bindings from possibly several disparate
          //  instances.  Pass them in as already created objects
          //  and we won't try to find them on the binding instance.
          if (typeof source === 'string') {
            sourceBinding = binding.instance.get_binding(source);
          } else {
            sourceBinding = source;
          }
          if (source) {
            binding.source_bindings.push(sourceBinding);
          }
        });
        self.init_source_listeners(binding, binding.source_bindings);
      },
      insert_from_source_binding: function (binding, results, index) {
        var self = this;
        var newResults;
        var lists = can.map(
          binding.source_bindings,
          function (source) {
            return [can.map(
              source.list,
              function (result) {
                return result.instance;
              })];
          });

        newResults = can.map(results, function (result) {
          // only the results that have membership in all lists will be added.
          if (can.reduce(lists, function (found, list) {
            return found && !!~can.inArray(result.instance, list);
          }, true)) {
            return self.make_result(result.instance, [result], binding);
          }
        });
        self.insert_results(binding, newResults);
      },
      init_source_listeners: function (binding, sourceBindings) {
        var self = this;

        can.each(sourceBindings, function (sourceBinding) {
          self.insert_from_source_binding(binding, sourceBinding.list);

          sourceBinding.list.bind('add', function (ev, results) {
            self.insert_from_source_binding(binding, results);
          });

          sourceBinding.list.bind('remove', function (ev, results) {
            can.each(results, function (result) {
              self.remove_instance(binding, result.instance, result);
            });
          });
        });
      },
      _refresh_stubs: function (binding) {
        var deferreds = [];

        can.each(binding.source_bindings, function (sourceBinding) {
          deferreds.push(sourceBinding.refresh_stubs());
        });

        return $.when.apply($, deferreds);
      }
    });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  /*  ProxyListLoader
   *  - handles relationships across join tables
   *
   *  - listens to:
   *      - join_model.created
   *      - join_model.destroyed
   *      - not implemented:
   *        - join_instance.change(object_attr)
   *        - join_instance.change(option_attr)
   */
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.ProxyListLoader', {}, {
    init: function (modelName, objectAttr, optionAttr, objectJoinAttr,
                    optionModelName) {
      this._super();

      this.model_name = modelName;
      this.object_attr = objectAttr;
      this.option_attr = optionAttr;
      this.object_join_attr = objectJoinAttr;
      this.option_model_name = optionModelName;
    },
    init_listeners: function (binding) {
      var self = this;
      var model = CMS.Models[this.model_name];
      var objectJoinValue = binding.instance[this.object_join_attr];

      binding.instance.bind(this.object_join_attr, function (ev, _new, _old) {
        if (binding._refresh_stubs_deferred &&
          binding._refresh_stubs_deferred.state() !== 'pending') {
          self._refresh_stubs(binding);
        }
      });

      if (objectJoinValue) {
        objectJoinValue.bind('length', function (ev, _new, _old) {
          self._refresh_stubs(binding);
        });
      }

      model.bind('created', function (ev, mapping) {
        if (mapping instanceof model)
          self.filter_and_insert_instances_from_mappings(binding, [mapping]);
      });

      model.bind('destroyed', function (ev, mapping) {
        if (mapping instanceof model)
          self.remove_instance_from_mapping(binding, mapping);
      });

      //  FIXME: This is only needed in DirectListLoader, right?
      model.bind('orphaned', function (ev, mapping) {
        if (mapping instanceof model)
          self.remove_instance_from_mapping(binding, mapping);
      });
    },
    is_valid_mapping: function (binding, mapping) {
      var model = CMS.Models[this.model_name];
      var objectModel = binding.instance.constructor;
      var optionModel = CMS.Models[this.option_model_name];

      return (mapping.constructor === model && mapping[this.object_attr] &&
      (mapping[this.object_attr].reify() === binding.instance ||
      (mapping[this.object_attr].reify().constructor === objectModel &&
      mapping[this.object_attr].id === binding.instance.id)) &&
      (!optionModel || (mapping[this.option_attr] &&
      mapping[this.option_attr].reify() instanceof optionModel)));
    },
    filter_and_insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var matchingMappings;

      matchingMappings = can.map(can.makeArray(mappings), function (mapping) {
        if (self.is_valid_mapping(binding, mapping))
          return mapping;
      });
      return this.insert_instances_from_mappings(binding, matchingMappings);
    },
    insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var newResults;

      newResults = can.map(can.makeArray(mappings), function (mapping) {
        return self.get_result_from_mapping(binding, mapping);
      });
      this.insert_results(binding, newResults);
    },
    remove_instance_from_mapping: function (binding, mapping) {
      var instance;
      var result;
      if (this.is_valid_mapping(binding, mapping)) {
        instance = this.get_instance_from_mapping(binding, mapping);
        result = this.find_result_from_mapping(binding, mapping);
        if (instance)
          this.remove_instance(binding, instance, result);
      }
    },
    get_result_from_mapping: function (binding, mapping) {
      return this.make_result({
        instance: mapping[this.option_attr].reify(),
        mappings: [{
          instance: mapping,
          mappings: [{
            instance: true,
            mappings: [],
            binding: binding
          }],
          binding: binding
        }]
      });
    },
    get_instance_from_mapping: function (binding, mapping) {
      return mapping[this.option_attr] && mapping[this.option_attr].reify();
    },
    find_result_from_mapping: function (binding, mapping) {
      var mapInd;
      var result;
      var resultInd;
      var mappingResult;

      for (resultInd = 0; resultInd < binding.list.length; resultInd++) {
        result = binding.list[resultInd];
        for (mapInd = 0; mapInd < result.mappings.length; mapInd++) {
          mappingResult = result.mappings[mapInd];
          if (mappingResult.instance === mapping)
            return mappingResult;
        }
      }
    },
    _refresh_stubs: function (binding) {
      var model = CMS.Models[this.model_name];
      var refreshQueue = new RefreshQueue();
      var objectJoinAttr = this.object_join_attr || model.table_plural;

      // These properties only exist if the user has read access
      if (binding.instance[objectJoinAttr]) {
        can.each(binding.instance[objectJoinAttr].reify(), function (mapping) {
          refreshQueue.enqueue(mapping);
        });
      }

      return refreshQueue.trigger()
        .then(this.proxy('filter_for_valid_mappings', binding))
        .then(this.proxy('insert_instances_from_mappings', binding));
    },
    filter_for_valid_mappings: function (binding, mappings) {
      // Remove incomplete mappings, including those not in our context
      //   (which the server refused to provide).
      var i;
      var validMappings = [];

      for (i = 0; i < mappings.length; i++) {
        if (mappings[i][this.option_attr])
          validMappings.push(mappings[i]);
      }
      return validMappings;
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  /*  DirectListLoader
   *  - handles direct relationships / one-to-many relationships
   *
   *  - listens to:
   *      - model.created
   *      - model.destroyed
   *      - not implemented:
   *        - instance.change(object_attr)
   */
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.DirectListLoader', {}, {
    init: function (modelName, objectAttr, objectJoinAttr) {
      this._super();

      this.model_name = modelName;
      this.object_attr = objectAttr;
      this.object_join_attr = objectJoinAttr;
    },
    init_listeners: function (binding) {
      var self = this;
      var model = CMS.Models[this.model_name] || can.Model.Cacheable;

      binding.instance.bind(this.object_join_attr, function (ev, _new, _old) {
        if (binding._refresh_stubs_deferred &&
          binding._refresh_stubs_deferred.state() !== 'pending') {
          self._refresh_stubs(binding);
        }
      });

      model.bind('created', function (ev, mapping) {
        if (mapping instanceof model)
          self.filter_and_insert_instances_from_mappings(binding, [mapping]);
      });

      model.bind('destroyed', function (ev, mapping) {
        if (mapping instanceof model)
          self.remove_instance_from_mapping(binding, mapping);
      });

      model.bind('orphaned', function (ev, mapping) {
        if (mapping instanceof model)
          self.remove_instance_from_mapping(binding, mapping);
      });
    },
    is_valid_mapping: function (binding, mapping) {
      var model = CMS.Models[this.model_name] || can.Model.Cacheable;
      var objectModel = binding.instance.constructor;

      return (mapping instanceof model && mapping[this.object_attr] &&
      (mapping[this.object_attr].reify() === binding.instance ||
      (mapping[this.object_attr].reify().constructor === objectModel &&
      mapping[this.object_attr].id === binding.instance.id)));
    },
    filter_and_insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var matchingMappings;

      matchingMappings = can.map(can.makeArray(mappings), function (mapping) {
        if (self.is_valid_mapping(binding, mapping))
          return mapping;
      });
      return this.insert_instances_from_mappings(binding, matchingMappings);
    },
    insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var newResults;

      newResults = can.map(can.makeArray(mappings), function (mapping) {
        return self.get_result_from_mapping(binding, mapping);
      });
      this.insert_results(binding, newResults);
    },
    remove_instance_from_mapping: function (binding, mapping) {
      var instance;
      var result;
      if (this.is_valid_mapping(binding, mapping)) {
        instance = this.get_instance_from_mapping(binding, mapping);
        result = this.find_result_from_mapping(binding, mapping);
        if (instance)
          this.remove_instance(binding, instance, result);
      }
    },
    get_result_from_mapping: function (binding, mapping) {
      return this.make_result({
        instance: mapping,
        mappings: [{
          instance: true,
          mappings: [],
          binding: binding
        }],
        binding: binding
      });
    },
    get_instance_from_mapping: function (binding, mapping) {
      return mapping;
    },
    find_result_from_mapping: function (binding, mapping) {
      var result;
      var resultInd;

      for (resultInd = 0; resultInd < binding.list.length; resultInd++) {
        result = binding.list[resultInd];
        if (result.instance === mapping)
        // DirectListLoader can't have multiple mappings
          return result.mappings[0];
      }
    },
    _refresh_stubs: function (binding) {
      var that = this;
      var refreshQueue = new RefreshQueue();

      refreshQueue.enqueue(binding.instance);

      return refreshQueue.trigger().then(function () {
        var objectJoinAttr = that.object_join_attr;
        var mappings = binding.instance[objectJoinAttr] &&
          binding.instance[objectJoinAttr].reify();

        that.insert_instances_from_mappings(binding, mappings);
      });
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  /*  IndirectListLoader
   *  - handles indirect relationships
   *  (zero-to-many, no local join but has a direct mapping in another object)
   *
   *  - listens to:
   *      - model.created
   *      - model.destroyed
   *      - not implemented:
   *        - instance.change(object_attr)
   */
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.IndirectListLoader', {}, {
    init: function (modelName, objectAttr) {
      this._super();

      this.model_name = modelName;
      this.object_attr = objectAttr;
    },
    init_listeners: function (binding) {
      var self = this;
      var model = CMS.Models[this.model_name];

      model.bind('created', function (ev, mapping) {
        if (mapping instanceof model)
          self.filter_and_insert_instances_from_mappings(binding, [mapping]);
      });

      model.bind('destroyed', function (ev, mapping) {
        if (mapping instanceof model)
          self.remove_instance_from_mapping(binding, mapping);
      });

      model.bind('orphaned', function (ev, mapping) {
        if (mapping instanceof model)
          self.remove_instance_from_mapping(binding, mapping);
      });
    },
    is_valid_mapping: function (binding, mapping) {
      var model = CMS.Models[this.model_name];
      var objectModel = binding.instance.constructor;

      return (mapping instanceof model && mapping[this.object_attr] &&
      (mapping[this.object_attr].reify() === binding.instance ||
      (mapping[this.object_attr].type === 'Context' ||
      (mapping[this.object_attr].reify() &&
      mapping[this.object_attr].reify().constructor === objectModel) &&
      mapping[this.object_attr].id === binding.instance.id)));
    },
    filter_and_insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var matchingMappings;

      matchingMappings = can.map(can.makeArray(mappings), function (mapping) {
        if (self.is_valid_mapping(binding, mapping))
          return mapping;
      });
      return this.insert_instances_from_mappings(binding, matchingMappings);
    },
    insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var newResults;

      newResults = can.map(can.makeArray(mappings), function (mapping) {
        return self.get_result_from_mapping(binding, mapping);
      });
      this.insert_results(binding, newResults);
    },
    remove_instance_from_mapping: function (binding, mapping) {
      var instance;
      var result;
      if (this.is_valid_mapping(binding, mapping)) {
        instance = this.get_instance_from_mapping(binding, mapping);
        result = this.find_result_from_mapping(binding, mapping);
        if (instance)
          this.remove_instance(binding, instance, result);
      }
    },
    get_result_from_mapping: function (binding, mapping) {
      return this.make_result({
        instance: mapping,
        mappings: [{
          instance: true,
          mappings: [],
          binding: binding
        }],
        binding: binding
      });
    },
    get_instance_from_mapping: function (binding, mapping) {
      return mapping;
    },
    find_result_from_mapping: function (binding, mapping) {
      var result;
      var resultInd;

      for (resultInd = 0; resultInd < binding.list.length; resultInd++) {
        result = binding.list[resultInd];
        if (result.instance === mapping)
        // DirectListLoader can't have multiple mappings
          return result.mappings[0];
      }
    },
    _refresh_stubs: function (binding) {
      var model = CMS.Models[this.model_name];
      var objectJoinAttr =
        ('indirect_' + (this.object_join_attr || model.table_plural));
      var mappings = binding.instance[objectJoinAttr] &&
        binding.instance[objectJoinAttr].reify();
      var params = {};
      var objectAttr = this.object_attr +
        (this.object_attr !== 'context' &&
        model.attributes[this.object_attr].indexOf('stubs') > -1 ?
          '.id' : '_id');
      var result;
      var self = this;

      params[objectAttr] =
        this.object_attr === 'context' ?
        binding.instance.context && binding.instance.context.id :
          binding.instance.id;

      if (mappings || !params[objectAttr]) {
        this.insert_instances_from_mappings(binding, mappings);
        result = new $.Deferred().resolve(mappings);
      } else {
        result = model.findAll(params).done(function (mappings) {
          // binding.instance.attr(object_join_attr, mappings);
          self.insert_instances_from_mappings(binding, mappings.reify());
        });
      }
      return result;
    },
    refresh_list: function () {
      return this._refresh_stubs();
    }
  });
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  /*  SearchListLoader
   *  - handles search relationships
   *
   *  - listens to:
   *      - model.created
   *      - model.destroyed
   *      - not implemented:
   *        - instance.change(object_attr)
   */
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.SearchListLoader', {}, {
    init: function (queryFunction, observeTypes) {
      this._super();
      this.observe_types = observeTypes && observeTypes.split(',');
      this.query_function = queryFunction;
    },
    init_listeners: function (binding) {
      var model = can.Model.Cacheable;
      var that = this;

      model.bind('created', function (ev, mapping) {
        if (mapping instanceof model) {
          if (_.includes(that.observe_types, mapping.type)) {
            that._refresh_stubs(binding);
          }
        }
      });

      model.bind('destroyed', function (ev, mapping) {
        if (mapping instanceof model)
          that.remove_instance_from_mapping(binding, mapping);
      });

      // FIXME: This is only needed in DirectListLoader, right?
      model.bind('orphaned', function (ev, mapping) {
        if (mapping instanceof model)
          that.remove_instance_from_mapping(binding, mapping);
      });
    },
    is_valid_mapping: function (binding, mapping) {
      return true;
    },
    filter_and_insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var matchingMappings;

      matchingMappings = can.map(can.makeArray(mappings), function (mapping) {
        if (self.is_valid_mapping(binding, mapping))
          return mapping;
      });
      return this.insert_instances_from_mappings(binding, matchingMappings);
    },
    insert_instances_from_mappings: function (binding, mappings) {
      var self = this;
      var newResults;

      newResults = can.map(can.makeArray(mappings), function (mapping) {
        return self.get_result_from_mapping(binding, mapping);
      });
      this.insert_results(binding, newResults);
    },
    remove_instance_from_mapping: function (binding, mapping) {
      var instance;
      var result;
      if (this.is_valid_mapping(binding, mapping)) {
        instance = this.get_instance_from_mapping(binding, mapping);
        result = this.find_result_from_mapping(binding, mapping);
        if (instance)
          this.remove_instance(binding, instance, result);
      }
    },
    get_result_from_mapping: function (binding, mapping) {
      return this.make_result({
        instance: mapping,
        mappings: [{
          instance: true,
          mappings: [],
          binding: binding
        }],
        binding: binding
      });
    },
    get_instance_from_mapping: function (binding, mapping) {
      return mapping;
    },
    find_result_from_mapping: function (binding, mapping) {
      var result;
      var resultInd;

      for (resultInd = 0; resultInd < binding.list.length; resultInd++) {
        result = binding.list[resultInd];
        if (result.instance === mapping)
          // DirectListLoader can't have multiple mappings
          return result.mappings[0];
      }
    },
    _refresh_stubs: function (binding) {
      var objectJoinAttr = ('search_' + (this.object_join_attr ||
      binding.instance.constructor.table_plural));
      var mappings = binding.instance[objectJoinAttr] &&
        binding.instance[objectJoinAttr].reify();
      var self = this;
      var result;

      if (mappings) {
        this.insert_instances_from_mappings(binding, mappings);
        result = new $.Deferred().resolve(mappings);
      } else {
        result = this.query_function(binding);
        result.pipe(function (mappings) {
          can.each(mappings, function (entry, i) {
            var _class = (can.getObject('CMS.Models.' + entry.type) ||
            can.getObject('GGRC.Models.' + entry.type));
            mappings[i] = new _class({id: entry.id});
          });

          // binding.instance.attr(object_join_attr, mappings);
          self.insert_instances_from_mappings(binding, mappings.reify());
          return mappings;
        });
      }
      return result;
    },
    refresh_list: function (binding) {
      return this._refresh_stubs(binding);
    }
  });
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.ReifyingListLoader', {}, {
    init: function (source) {
      this._super();

      if (source instanceof GGRC.ListLoaders.ListBinding)
        this.source_binding = source;
      else
        this.source = source;
    },
    insert_from_source_binding: function (binding, results, index) {
      var self = this;
      var refreshQueue = new RefreshQueue();
      var newResults = [];

      can.each(results, function (result) {
        refreshQueue.enqueue(result.instance);
        newResults.push(self.make_result(result.instance, [result], binding));
      });
      refreshQueue.trigger().then(function () {
        self.insert_results(binding, newResults);
      });
    },
    init_listeners: function (binding) {
      var self = this;

      if (this.source_binding)
        binding.source_binding = this.source_binding;
      else
        binding.source_binding = binding.instance.get_binding(this.source);

      this.insert_from_source_binding(binding, binding.source_binding.list, 0);

      binding.source_binding.list.bind('add', function (ev, results, index) {
        self.insert_from_source_binding(binding, results, index);
      });

      binding.source_binding.list.bind('remove', function (ev, results, index) {
        can.each(results, function (result) {
          self.remove_instance(binding, result.instance, result);
        });
      });
    },
    _refresh_stubs: function (binding) {
      return binding.source_binding.refresh_stubs(binding);
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  'use strict';

  GGRC.ListLoaders.BaseListLoader('GGRC.ListLoaders.TreePageLoader', {}, {
    init: function (model, instance, mapping) {
      this.model = model;
      this.binding = instance.get_binding(mapping);
    },
    load: function (params) {
      var snapshots = GGRC.Utils.Snapshots;
      var queryParams = params;
      var result;
      if (snapshots.isSnapshotScope(this.binding.instance) &&
        snapshots.isSnapshotModel(params.data[0].object_name)) {
        queryParams = snapshots.transformQuery(params);
      }
      return this.model.query(queryParams)
        .then(function (data) {
          result = data;
          return this.insertInstancesFromMappings(data.values);
        }.bind(this))
        .then(function (values) {
          result.values = values;
          return result;
        });
    },
    insertInstancesFromMappings: function (mappings) {
      var self = this;
      var result;

      result = can.map(can.makeArray(mappings), function (mapping) {
        return self.getResultFromMapping(mapping);
      });
      return $.when.apply($, result).then(function () {
        return new can.List(Array.prototype.slice.call(arguments));
      });
    },
    getResultFromMapping: function (mapping) {
      var binding = this.binding;
      return this.makeResult(mapping.reify(), binding);
    },
    makeResult: function (instance, binding) {
      var result;
      if (instance instanceof CMS.Models.Person) {
        if (binding.instance.workflow_people) {
          result = CMS.Models.Person
            .getPersonMappings(binding.instance, instance, 'workflow_people');
        } else if (binding.instance.object_people.length) {
          result = CMS.Models.Person
            .getPersonMappings(binding.instance, instance, 'object_people');
        } else {
          result = CMS.Models.Person
            .getUserRoles(binding.instance, instance);
        }
      } else {
        result = CMS.Models.Relationship
          .getRelationshipBetweenInstances(binding.instance, instance, true);
      }
      return result
        .then(function (relationships) {
          return new GGRC.ListLoaders.MappingResult(
            instance, can.map(relationships, function (relationship) {
              return {
                binding: binding,
                instance: relationship,
                mappings: [{
                  instance: true,
                  mappings: [],
                  binding: binding
                }]
              };
            }), binding);
        });
    }
  });
})(GGRC, can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  GGRC.MapperHelpers = {};

  GGRC.MapperHelpers.Proxy = function Proxy(
    optionModelName, joinOptionAttr, joinModelName, joinObjectAttr,
    instanceJoinAttr) {
    return new GGRC.ListLoaders.ProxyListLoader(
        joinModelName, joinObjectAttr, joinOptionAttr,
        instanceJoinAttr, optionModelName);
  };

  GGRC.MapperHelpers.Direct = function Direct(
      optionModelName, instanceJoinAttr, remoteJoinAttr) {
    return new GGRC.ListLoaders.DirectListLoader(
      optionModelName, instanceJoinAttr, remoteJoinAttr);
  };

  GGRC.MapperHelpers.Indirect = function Indirect(instModelName, joinAttr) {
    return new GGRC.ListLoaders.IndirectListLoader(instModelName, joinAttr);
  };

  GGRC.MapperHelpers.Search = function Search(queryFunction, observeTypes) {
    return new GGRC.ListLoaders.SearchListLoader(queryFunction, observeTypes);
  };

  GGRC.MapperHelpers.Multi = function Multi(sources) {
    return new GGRC.ListLoaders.MultiListLoader(sources);
  };

  GGRC.MapperHelpers.TypeFilter = function TypeFilter(source, modelName) {
    return new GGRC.ListLoaders.TypeFilteredListLoader(source, [modelName]);
  };

  GGRC.MapperHelpers.AttrFilter = function AttrFilter(source, filterName,
                                                      keyword, type) {
    return new GGRC.ListLoaders.AttrFilteredListLoader(source, filterName,
      keyword, type);
  };

  GGRC.MapperHelpers.CustomFilter = function CustomFilter(source, filterFn) {
    return new GGRC.ListLoaders.CustomFilteredListLoader(source, filterFn);
  };

  GGRC.MapperHelpers.Reify = function Reify(source) {
    return new GGRC.ListLoaders.ReifyingListLoader(source);
  };

  GGRC.MapperHelpers.Cross = function Cross(localMapping, remoteMapping) {
    return new GGRC.ListLoaders.CrossListLoader(localMapping, remoteMapping);
  };

  GGRC.all_local_results = function (instance) {
    // Returns directly-linked objects
    var loaders;
    var multiLoader;
    var localLoaders = [];

    if (instance._all_local_results_binding)
      return instance._all_local_results_binding.refresh_stubs();

    loaders = GGRC.Mappings.get_mappings_for(instance.constructor.shortName);
    can.each(loaders, function (loader, name) {
      if (loader instanceof GGRC.ListLoaders.DirectListLoader ||
        loader instanceof GGRC.ListLoaders.ProxyListLoader) {
        localLoaders.push(name);
      }
    });

    multiLoader = new GGRC.ListLoaders.MultiListLoader(localLoaders);
    instance._all_local_results_binding = multiLoader.attach(instance);
    return instance._all_local_results_binding.refresh_stubs();
  };
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  var Proxy = GGRC.MapperHelpers.Proxy;
  var Direct = GGRC.MapperHelpers.Direct;
  var Indirect = GGRC.MapperHelpers.Indirect;
  var Search = GGRC.MapperHelpers.Search;
  var Multi = GGRC.MapperHelpers.Multi;
  var TypeFilter = GGRC.MapperHelpers.TypeFilter;
  var AttrFilter = GGRC.MapperHelpers.AttrFilter;
  var CustomFilter = GGRC.MapperHelpers.CustomFilter;
  var Cross = GGRC.MapperHelpers.Cross;
  /*
    class GGRC.Mappings
    represents everything known about how GGRC objects connect to each other.

    a Mappings instance contains the set of known mappings for a module, such as "ggrc_core"
    or "ggrc_gdrive_integration".  The set of all Mappings instances is used throughout the
    system to build widgets, map and unmap objects, etc.

    To configure a new Mappings instance, use the following format :
    { <mixin name or source object type> : {
        _mixins : [ <mixin name>, ... ],
        _canonical : { <option type> : <name of mapping in parent object>, ... }
        <mapping name> : GGRC.Mappings.Proxy(...) | GGRC.Mappings.Direct(...) | GGRC.Mappings.Indirect(...)
                        | GGRC.Mappings.Multi(...) | GGRC.Mappings.TypeFilter(...) | GGRC.Mappings.Cross(...)
                        | GGRC.Mappings.CustomFilter(...),
        ...
      }
    }
  */
  can.Construct.extend('GGRC.Mappings', {
    // Convenience properties for building mappings types.
    Proxy: Proxy,
    Direct: Direct,
    Indirect: Indirect,
    Search: Search,
    Multi: Multi,
    TypeFilter: TypeFilter,
    AttrFilter: AttrFilter,
    CustomFilter: CustomFilter,
    Cross: Cross,
    modules: {},

    /**
     * Return list of allowed for mapping models.
     * Performs checks for
     * @param {String} type - base model type
     * @param {Array} include - array of included models
     * @param {Array} exclude - array of excluded models
     * @return {Array} - list of allowed for mapping Models
     */
    getMappingList: function (type, include, exclude) {
      var baseModel = GGRC.Utils.getModelByType(type);
      if (!baseModel) {
        return [];
      }

      if (can.isFunction(baseModel.getAllowedMappings)) {
        return baseModel.getAllowedMappings() || [];
      }
      return GGRC.Utils
        .getMappableTypes(type, {
          whitelist: include,
          forbidden: exclude
        })
        // Temporary Code to unify output formatting
        .map(function (item) {
          return {modelName: item, mappingType: 'relation'};
        });
    },
    /**
     * Perform a check to identify mapping type of {source} and {destination}.
     * In case mapping type is "snapshot" - should return {false}.
     * @param {String} source - model name of selected for mapping object
     * @param {String} destination - destination model name
     * @return {boolean} - is mapped directly or via parent object
     */
    canBeMappedDirectly: function (source, destination) {
      var allowedMappingList;
      var canBe;
      if (!source || !destination) {
        console.debug('No arguments are provided or ' +
          'has incorrect format.', arguments);
        return true;
      }
      // AllObjects has no mapping configuration as it's fake instance
      if (source === 'AllObject' &&
        !GGRC.Utils.Snapshots.isSnapshotParent(destination)) {
        return true;
      }
      allowedMappingList = this.getMappingList(destination);
      canBe = allowedMappingList
        .some(function (item) {
          return item.mappingType !== 'snapshot' && item.modelName === source;
        });
      return canBe;
    },
    /*
      return all mappings from all modules for an object type.
      object - a string representing the object type's shortName

      return: a keyed object of all mappings (instances of GGRC.ListLoaders.BaseListLoader) by mapping name
      Example: GGRC.Mappings.get_mappings_for('Program')
    */
    get_mappings_for: function (object) {
      var mappings = {};
      can.each(this.modules, function (mod, name) {
        if (mod[object]) {
          can.each(mod[object], function (mapping, mappingName) {
            if (mappingName === '_canonical')
              return;
            mappings[mappingName] = mapping;
          });
        }
      });
      return mappings;
    },
    /*
      return the canonical mapping (suitable for joining) between two objects.
      object - the string type (shortName) of the "from" object's class
      option - the string type (shortName) of the "to" object's class

      return: an instance of GGRC.ListLoaders.BaseListLoader (mappings are implemented as ListLoaders)
    */
    get_canonical_mapping: function (object, option) {
      var mapping = null;
      can.each(this.modules, function (mod, name) {
        if (mod._canonical_mappings && mod._canonical_mappings[object] &&
          mod._canonical_mappings[object][option]) {
          mapping =
            CMS.Models[object]
              .get_mapper(mod._canonical_mappings[object][option]);
          return false;
        }
      });
      return mapping;
    },
    /*
      return the defined name of the canonical mapping between two objects.
      object - the string type (shortName) of the "from" object's class
      option - the string type (shortName) of the "to" object's class

      return: an instance of GGRC.ListLoaders.BaseListLoader (mappings are implemented as ListLoaders)
    */
    get_canonical_mapping_name: function (object, option) {
      var mappingName = null;
      can.each(this.modules, function (mod, name) {
        if (mod._canonical_mappings && mod._canonical_mappings[object] &&
          mod._canonical_mappings[object][option]) {
          mappingName = mod._canonical_mappings[object][option];
          return false;
        }
      });
      return mappingName;
    },
    /*
      return all canonical mappings (suitable for joining) from all modules for an object type.
      object - a string representing the object type's shortName

      return: a keyed object of all mappings (instances of GGRC.ListLoaders.BaseListLoader) by option type
    */
    get_canonical_mappings_for: function (object) {
      var mappings = {};
      can.each(this.modules, function (mod, name) {
        if (mod._canonical_mappings && mod._canonical_mappings[object]) {
          can.each(mod._canonical_mappings[object],
            function (mappingName, option) {
              mappings[option] = CMS.Models[object].get_mapper(mappingName);
            });
        }
      });
      return mappings;
    },
    /*
      return the join model for the canonical mapping between two objects if and only if the canonical mapping is a Proxy.
      model_name_a - the string type (shortName) of the "from" object's class
      model_name_b - the string type (shortName) of the "to" object's class

      return: a string of the shortName of the join model (subclass of can.Model.Join) or null
    */
    join_model_name_for: function (modelNameA, modelNameB) {
      var joinDescriptor = this.get_canonical_mapping(modelNameA, modelNameB);
      var result;
      if (joinDescriptor instanceof GGRC.ListLoaders.ProxyListLoader) {
        result = joinDescriptor.model_name;
      } else {
        result = null;
      }
      return result;
    },
    /*
      make a new instance of the join model for the canonical mapping between two objects
       if and only if the canonical mapping is a Proxy.
      object - the string type (shortName) of the "from" object's class
      option - the string type (shortName) of the "to" object's class
      join_attrs - any other attributes to add to the new instance

      return: an instance of the join model (subclass of can.Model.Join) or null
    */
    make_join_object: function (object, option, joinAttrs) {
      var joinModel;
      var joinMapping = this.get_canonical_mapping(object.constructor.shortName,
        option.constructor.shortName);
      var objectAttrs = {
        id: object.id,
        type: object.constructor.shortName
      };
      var optionAttrs = {
        id: option.id,
        type: option.constructor.shortName
      };
      var result;

      if (joinMapping && joinMapping.model_name) {
        joinModel = CMS.Models[joinMapping.model_name];
        joinAttrs = $.extend({}, joinAttrs || {});
        joinAttrs[joinMapping.option_attr] = optionAttrs;
        joinAttrs[joinMapping.object_attr] = objectAttrs;

        result = new joinModel(joinAttrs);
      } else {
        result = null;
      }
      return result;
    }
  }, {
    /*
      On init:
      kick off the application of mixins to the mappings and resolve canonical mappings
    */
    init: function (name, opts) {
      var createdMappings;
      var that = this;
      this.constructor.modules[name] = this;
      this._canonical_mappings = {};
      if (this.groups) {
        can.each(this.groups, function (group, name) {
          if (typeof group === 'function') {
            that.groups[name] = $.proxy(group, that.groups);
          }
        });
      }
      createdMappings = this.create_mappings(opts);
      can.each(createdMappings, function (mappings, objectType) {
        if (mappings._canonical) {
          if (!that._canonical_mappings[objectType]) {
            that._canonical_mappings[objectType] = {};
          }
          can.each(mappings._canonical || [],
            function (optionTypes, mappingName) {
              if (!can.isArray(optionTypes)) {
                optionTypes = [optionTypes];
              }
              can.each(optionTypes, function (optionType) {
                that._canonical_mappings[objectType][optionType] = mappingName;
              });
            });
        }
      });
      $.extend(this, createdMappings);
    },
    // Recursively handle mixins -- this function should not be called directly.
    reify_mixins: function (definition, definitions) {
      var that = this;
      var finalDefinition = {};
      if (definition._mixins) {
        can.each(definition._mixins, function (mixin) {
          if (typeof (mixin) === 'string') {
            // If string, recursive lookup
            if (!definitions[mixin]) {
              console.debug('Undefined mixin: ' + mixin, definitions);
            } else {
              can.extend(true, finalDefinition,
                that.reify_mixins(definitions[mixin], definitions));
            }
          } else if (can.isFunction(mixin)) {
            // If function, call with current definition state
            mixin(finalDefinition);
          } else {
            // Otherwise, assume object and extend
            if (finalDefinition._canonical && mixin._canonical) {
              mixin = can.extend({}, mixin);

              can.each(mixin._canonical, function (types, mapping) {
                if (finalDefinition._canonical[mapping]) {
                  if (!can.isArray(finalDefinition._canonical[mapping])) {
                    finalDefinition._canonical[mapping] =
                      [finalDefinition._canonical[mapping]];
                  }
                  finalDefinition._canonical[mapping] =
                    can.unique(finalDefinition._canonical[mapping]
                      .concat(types));
                } else {
                  finalDefinition._canonical[mapping] = types;
                }
              });
              finalDefinition._canonical = can.extend({}, mixin._canonical,
                finalDefinition._canonical);
              delete mixin._canonical;
            }
            can.extend(finalDefinition, mixin);
          }
        });
      }
      can.extend(true, finalDefinition, definition);
      delete finalDefinition._mixins;
      return finalDefinition;
    },

    // create mappings for definitions -- this function should not be called directly/
    create_mappings: function (definitions) {
      var mappings = {};

      can.each(definitions, function (definition, name) {
        // Only output the mappings if it's a model, e.g., uppercase first letter
        if (name[0] === name[0].toUpperCase())
          mappings[name] = this.reify_mixins(definition, definitions);
      }, this);
      return mappings;
    }
  });
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  var Proxy = GGRC.MapperHelpers.Proxy;
  var Direct = GGRC.MapperHelpers.Direct;
  var Indirect = GGRC.MapperHelpers.Indirect;
  var Search = GGRC.MapperHelpers.Search;
  var Multi = GGRC.MapperHelpers.Multi;
  var TypeFilter = GGRC.MapperHelpers.TypeFilter;
  var AttrFilter = GGRC.MapperHelpers.AttrFilter;
  var CustomFilter = GGRC.MapperHelpers.CustomFilter;
  var Cross = GGRC.MapperHelpers.Cross;

  new GGRC.Mappings('ggrc_core', {
    base: {},

    // Governance
    Control: {
      _mixins: ['related_object', 'personable', 'ownable'],
      related_business_objects: Multi([
        'related_data_assets', 'related_facilities', 'related_markets',
        'related_org_groups', 'related_vendors', 'related_processes',
        'related_products', 'related_projects', 'related_systems'
      ]),
      related_and_able_objects: Multi([
        'objectives', 'related_business_objects',
        'people', 'programs', 'clauses'
      ]),
      audits: Proxy(
        'Audit', 'audit', 'AuditObject', 'auditable', 'audit_objects'),
      orphaned_objects: Multi([
        'related_objects', 'clauses', 'controls', 'programs', 'objectives',
        'people'
      ])
    },
    Objective: {
      _mixins: ['related_object', 'personable', 'ownable'],
      related_and_able_objects: Multi([
        'controls', 'objectives', 'related_objects', 'people',
        'sections', 'clauses'
      ]),
      orphaned_objects: Multi([
        'related_objects', 'clauses', 'contracts', 'controls', 'objectives',
        'people', 'policies', 'programs', 'regulations', 'sections', 'standards'
      ])
    },
    Section: {
      _mixins: ['related_object', 'personable', 'ownable']
    },
    Clause: {
      _mixins: ['related_object', 'personable', 'ownable']
    },
    personable: {
      _canonical: {
        people: 'Person'
      },
      people: Proxy(
        'Person', 'person', 'ObjectPerson', 'personable', 'object_people')
    },
    ownable: {
      owners: Proxy(
        'Person', 'person', 'ObjectOwner', 'ownable', 'object_owners')
    },
    documentable: {
      _canonical: {
        documents: 'Document'
      },
      documents: Proxy(
        'Document', 'document', 'ObjectDocument', 'documentable',
        'object_documents')
    },
    assignable: {
      urls: TypeFilter('related_objects', 'Document'),
      info_related_objects: CustomFilter('related_objects',
        function (relatedObjects) {
          return !_.includes(['Comment', 'Document', 'Person'],
            relatedObjects.instance.type);
        }),
      comments: TypeFilter('related_objects', 'Comment'),
      documents_from_comments: Cross('comments', 'documents'),
      urls_from_comments: Cross('comments', 'urls'),
      all_documents: Multi(['documents', 'documents_from_comments']),
      all_urls: Multi(['urls', 'urls_from_comments'])
    },
    related_object: {
      _canonical: {
        related_objects_as_source: [
          'DataAsset', 'Facility', 'Market', 'OrgGroup', 'Vendor', 'Process',
          'Product', 'Project', 'System', 'Regulation', 'Policy', 'Contract',
          'Standard', 'Program', 'Issue', 'Control', 'Section', 'Clause',
          'Objective', 'Audit', 'Assessment', 'AssessmentTemplate',
          'AccessGroup', 'Request', 'Document'
        ]
      },
      related_objects_as_source: Proxy(
        null, 'destination', 'Relationship', 'source', 'related_destinations'),
      related_objects_as_destination: Proxy(
        null, 'source', 'Relationship', 'destination', 'related_sources'),
      related_objects:
        Multi(['related_objects_as_source', 'related_objects_as_destination']),
      destinations: Direct('Relationship', 'source', 'related_destinations'),
      sources: Direct('Relationship', 'destination', 'related_sources'),
      relationships: Multi(['sources', 'destinations']),
      related_access_groups: TypeFilter('related_objects', 'AccessGroup'),
      related_data_assets: TypeFilter('related_objects', 'DataAsset'),
      related_facilities: TypeFilter('related_objects', 'Facility'),
      related_markets: TypeFilter('related_objects', 'Market'),
      related_org_groups: TypeFilter('related_objects', 'OrgGroup'),
      related_vendors: TypeFilter('related_objects', 'Vendor'),
      related_processes: TypeFilter('related_objects', 'Process'),
      related_products: TypeFilter('related_objects', 'Product'),
      related_projects: TypeFilter('related_objects', 'Project'),
      related_systems: TypeFilter('related_objects', 'System'),
      related_issues: TypeFilter('related_objects', 'Issue'),
      related_audits: TypeFilter('related_objects', 'Audit'),
      related_controls: TypeFilter('related_objects', 'Control'),
      related_assessments: TypeFilter('related_objects', 'Assessment'),
      related_requests: TypeFilter('related_objects', 'Request'),
      regulations: TypeFilter('related_objects', 'Regulation'),
      contracts: TypeFilter('related_objects', 'Contract'),
      policies: TypeFilter('related_objects', 'Policy'),
      standards: TypeFilter('related_objects', 'Standard'),
      programs: TypeFilter('related_objects', 'Program'),
      controls: TypeFilter('related_objects', 'Control'),
      sections: TypeFilter('related_objects', 'Section'),
      clauses: TypeFilter('related_objects', 'Clause'),
      objectives: TypeFilter('related_objects', 'Objective')
    },
    // Program
    Program: {
      _mixins: [
        'related_object', 'personable'
      ],
      _canonical: {
        audits: 'Audit',
        context: 'Context'
      },
      related_issues: TypeFilter('related_objects', 'Issue'),
      audits: Direct('Audit', 'program', 'audits'),
      related_people_via_audits:
        TypeFilter('related_objects_via_audits', 'Person'),
      authorizations_via_audits: Cross('audits', 'authorizations'),
      context: Direct('Context', 'related_object', 'context'),
      contexts_via_audits: Cross('audits', 'context'),
      program_authorized_people: Cross('context', 'authorized_people'),
      program_authorizations: Cross('context', 'user_roles'),
      authorization_contexts: Multi(['context', 'contexts_via_audits']),
      authorizations_via_contexts:
        Cross('authorization_contexts', 'user_roles'),
      authorizations: Cross('authorization_contexts', 'user_roles'),
      authorized_people: Cross('authorization_contexts', 'authorized_people'),
      mapped_and_or_authorized_people: Multi([
        'people', 'authorized_people'
      ]),
      owner_authorizations: CustomFilter('program_authorizations',
        function (authBinding) {
          return new RefreshQueue()
            .enqueue(authBinding.instance.role.reify())
            .trigger()
            .then(function (roles) {
              return roles[0].name === 'ProgramOwner';
            });
        }),
      program_owners: Cross('owner_authorizations', 'person'),
      owners_via_object_owners: Proxy(
        'Person', 'person', 'ObjectOwner', 'ownable', 'object_owners'),
      owners: Multi(['program_owners', 'owners_via_object_owners']),
      orphaned_objects: Multi([
        'related_objects', 'people'
      ])
    },
    directive_object: {
      _mixins: [
        'related_object', 'personable', 'ownable'
      ],
      orphaned_objects: Multi([
        'people', 'controls', 'objectives', 'related_objects'
      ])
    },

    // Directives
    Regulation: {
      _mixins: ['directive_object']
    },
    Contract: {
      _mixins: ['directive_object']
    },
    Standard: {
      _mixins: ['directive_object']
    },
    Policy: {
      _mixins: ['directive_object']
    },

    // Business objects
    business_object: {
      _mixins: [
        'related_object', 'personable',
        'ownable'
      ],
      orphaned_objects: Multi([
        'related_objects', 'people', 'controls', 'objectives', 'sections',
        'clauses'
      ])
    },
    AccessGroup: {
      _mixins: ['business_object']
    },
    DataAsset: {
      _mixins: ['business_object']
    },
    Facility: {
      _mixins: ['business_object']
    },
    Market: {
      _mixins: ['business_object']
    },
    OrgGroup: {
      _mixins: ['business_object']
    },
    Vendor: {
      _mixins: ['business_object']
    },
    Product: {
      _mixins: ['business_object']
    },
    Project: {
      _mixins: ['business_object']
    },
    System: {
      _mixins: ['business_object']
    },
    Process: {
      _mixins: ['business_object']
    },
    Person: {
      _canonical: {
        related_objects: [
          'Program', 'Regulation', 'Contract', 'Policy', 'Standard',
          'AccessGroup', 'Objective', 'Control', 'Section', 'Clause',
          'DataAsset', 'Facility', 'Market', 'OrgGroup', 'Vendor', 'Process',
          'Product', 'Project', 'System', 'Issue',
          'Request'
        ],
        authorizations: 'UserRole'
      },
      owned_programs: Indirect('Program', 'contact'),
      owned_regulations: Indirect('Regulation', 'contact'),
      owned_contracts: Indirect('Contract', 'contact'),
      owned_policies: Indirect('Policy', 'contact'),
      owned_standards: Indirect('Standard', 'contact'),
      owned_objectives: Indirect('Objective', 'contact'),
      owned_controls: Indirect('Control', 'contact'),
      owned_sections: Indirect('Section', 'contact'),
      owned_clauses: Indirect('Clause', 'contact'),
      owned_access_groups: Indirect('AccessGroup', 'contact'),
      owned_data_assets: Indirect('DataAsset', 'contact'),
      owned_facilities: Indirect('Facility', 'contact'),
      owned_markets: Indirect('Market', 'contact'),
      owned_org_groups: Indirect('OrgGroup', 'contact'),
      owned_vendors: Indirect('Vendor', 'contact'),
      owned_processes: Indirect('Process', 'contact'),
      owned_products: Indirect('Product', 'contact'),
      owned_projects: Indirect('Project', 'contact'),
      owned_systems: Indirect('System', 'contact'),
      related_objects: Proxy(
        null, 'personable', 'ObjectPerson', 'person', 'object_people'),
      related_programs: TypeFilter('related_objects', 'Program'),
      related_regulations: TypeFilter('related_objects', 'Regulation'),
      related_contracts: TypeFilter('related_objects', 'Contract'),
      related_policies: TypeFilter('related_objects', 'Policy'),
      related_standards: TypeFilter('related_objects', 'Standard'),
      related_objectives: TypeFilter('related_objects', 'Objective'),
      related_controls: TypeFilter('related_objects', 'Control'),
      related_sections: TypeFilter('related_objects', 'Section'),
      related_clauses: TypeFilter('related_objects', 'Clause'),
      related_access_groups: TypeFilter('related_objects', 'AccessGroup'),
      related_data_assets: TypeFilter('related_objects', 'DataAsset'),
      related_facilities: TypeFilter('related_objects', 'Facility'),
      related_markets: TypeFilter('related_objects', 'Market'),
      related_org_groups: TypeFilter('related_objects', 'OrgGroup'),
      related_vendors: TypeFilter('related_objects', 'Vendor'),
      related_processes: TypeFilter('related_objects', 'Process'),
      related_products: TypeFilter('related_objects', 'Product'),
      related_projects: TypeFilter('related_objects', 'Project'),
      related_systems: TypeFilter('related_objects', 'System'),
      related_issues: TypeFilter('related_objects', 'Issue'),
      authorizations: Direct('UserRole', 'person', 'user_roles'),
      programs_via_authorizations:
        Cross('authorizations', 'program_via_context'),
      extended_related_programs: Multi(['related_programs', 'owned_programs',
          'programs_via_authorizations']),
      extended_related_regulations:
        Multi(['related_regulations', 'owned_regulations']),
      extended_related_contracts:
        Multi(['related_contracts', 'owned_contracts']),
      extended_related_policies: Multi(['related_policies', 'owned_policies']),
      extended_related_objectives:
        Multi(['related_objectives', 'owned_objectives']),
      extended_related_controls: Multi(['related_controls', 'owned_controls']),
      extended_related_sections: Multi(['related_sections', 'owned_sections']),
      extended_related_clauses: Multi(['related_clauses', 'owned_clauses']),
      extended_related_data_assets:
        Multi(['related_data_assets', 'owned_data_assets']),
      extended_related_facilities:
        Multi(['related_facilities', 'owned_facilities']),
      extended_related_markets: Multi(['related_markets', 'owned_markets']),
      extended_related_org_groups:
        Multi(['related_org_groups', 'owned_org_groups']),
      extended_related_vendors: Multi(['related_vendors', 'owned_vendors']),
      extended_related_processes:
        Multi(['related_processes', 'owned_processes']),
      extended_related_products: Multi(['related_products', 'owned_products']),
      extended_related_projects: Multi(['related_projects', 'owned_projects']),
      extended_related_systems: Multi(['related_systems', 'owned_systems']),
      related_objects_via_search: Search(function (binding) {
        var types = this.observe_types;

        // checkfor window.location
        if (/^\/objectBrowser\/?$/.test(window.location.pathname)) {
          return GGRC.Models.Search.search_for_types('', types, {})
            .pipe(function (mappings) {
              return mappings.entries;
            });
        }
        return GGRC.Models.Search.search_for_types('', types, {
          contact_id: binding.instance.id
        }).pipe(function (mappings) {
          return mappings.entries;
        });
      }, 'Program,Regulation,Contract,Policy,Standard,Section,Clause,' +
        'Objective,Control,System,Process,DataAsset,AccessGroup,Product,' +
        'Project,Facility,Market,OrgGroup,Vendor,Audit,Assessment,Request,' +
        'Issue'),
      extended_related_programs_via_search:
        TypeFilter('related_objects_via_search', 'Program'),
      extended_related_regulations_via_search:
        TypeFilter('related_objects_via_search', 'Regulation'),
      extended_related_contracts_via_search:
        TypeFilter('related_objects_via_search', 'Contract'),
      extended_related_policies_via_search:
        TypeFilter('related_objects_via_search', 'Policy'),
      extended_related_standards_via_search:
        TypeFilter('related_objects_via_search', 'Standard'),
      extended_related_objectives_via_search:
        TypeFilter('related_objects_via_search', 'Objective'),
      extended_related_controls_via_search:
        TypeFilter('related_objects_via_search', 'Control'),
      extended_related_sections_via_search:
        TypeFilter('related_objects_via_search', 'Section'),
      extended_related_clauses_via_search:
        TypeFilter('related_objects_via_search', 'Clause'),
      extended_related_access_groups_via_search:
        TypeFilter('related_objects_via_search', 'AccessGroup'),
      extended_related_data_assets_via_search:
        TypeFilter('related_objects_via_search', 'DataAsset'),
      extended_related_facilities_via_search:
        TypeFilter('related_objects_via_search', 'Facility'),
      extended_related_markets_via_search:
        TypeFilter('related_objects_via_search', 'Market'),
      extended_related_org_groups_via_search:
        TypeFilter('related_objects_via_search', 'OrgGroup'),
      extended_related_vendors_via_search:
        TypeFilter('related_objects_via_search', 'Vendor'),
      extended_related_processes_via_search:
        TypeFilter('related_objects_via_search', 'Process'),
      extended_related_products_via_search:
        TypeFilter('related_objects_via_search', 'Product'),
      extended_related_projects_via_search:
        TypeFilter('related_objects_via_search', 'Project'),
      extended_related_systems_via_search:
        TypeFilter('related_objects_via_search', 'System'),
      extended_related_audits_via_search:
        TypeFilter('related_objects_via_search', 'Audit'),
      extended_related_issues_via_search:
        TypeFilter('related_objects_via_search', 'Issue'),
      extended_related_assessment_via_search:
        TypeFilter('related_objects_via_search', 'Assessment'),
      extended_related_request_via_search:
        TypeFilter('related_objects_via_search', 'Request'),
      open_audit_requests: CustomFilter('extended_related_request_via_search',
        function (result) {
          return result.instance.status !== 'Accepted';
        }),
      all_audit_requests: Search(function (binding) {
        return CMS.Models.Request.findAll({});
      }),
      all_open_audit_requests: CustomFilter('all_audit_requests',
        function (result) {
          return result.instance.status !== 'Accepted';
        })
    },
    Context: {
      _canonical: {
        user_roles: 'UserRole',
        authorized_people: 'Person'
      },
      user_roles: Direct('UserRole', 'context', 'user_roles'),
      authorized_people: Proxy('Person', 'person', 'UserRole', 'context',
        'user_roles')
    },
    UserRole: {
      // FIXME: These should not need to be `Indirect` --
      //   `context.related_object` *should* point to the right object.
      program_via_context: Indirect('Program', 'context'),
      audit_via_context: Indirect('Audit', 'context'),
      person: Direct('Person', 'user_roles', 'person'),
      role: Direct('Role', 'user_roles', 'role')
    },
    Audit: {
      _canonical: {
        requests: 'Request',
        _program: 'Program',
        context: 'Context'

      },
      _mixins: [
        'related_object'
      ],
      requests: Direct('Request', 'audit', 'requests'),
      active_requests: CustomFilter('requests', function (result) {
        return result.instance.status !== 'Accepted';
      }),
      history: CustomFilter('requests', function (result) {
        return result.instance.status === 'Accepted';
      }),
      _program: Direct('Program', 'audits', 'program'),
      program_controls: Cross('_program', 'controls'),
      program_requests: Cross('_program', 'related_requests'),
      program_issues: Cross('_program', 'related_issues'),
      program_assessments: Cross('_program', 'related_assessments'),
      objects:
        Proxy(null, 'auditable', 'AuditObject', 'audit', 'audit_objects'),
      responses_via_requests: Cross('requests', 'related_objects'),
      related_objects_via_requests:
        Multi(['requests', 'responses_via_requests']),
      context: Direct('Context', 'related_object', 'context'),
      authorizations: Cross('context', 'user_roles'),
      authorized_program_people: Cross('_program', 'authorized_people'),
      authorized_audit_people: Cross('authorizations', 'person'),
      authorized_people:
        Multi(['authorized_audit_people', 'authorized_program_people']),
      auditor_authorizations: CustomFilter('authorizations', function (result) {
        return new RefreshQueue()
          .enqueue(result.instance.role.reify())
          .trigger()
          .then(function (roles) {
            return roles[0].name === 'Auditor';
          });
      }),
      auditors: Cross('auditor_authorizations', 'person'),
      related_owned_objects:
        CustomFilter('related_objects_via_requests', function (result) {
          var person = GGRC.page_instance() instanceof CMS.Models.Person &&
            GGRC.page_instance();
          var instance = result.instance;
          return !person ||
            (instance.attr('contact') && instance.contact.id === person.id) ||
            (instance.attr('assignee') && instance.assignee.id === person.id) ||
            (instance.attr('requestor') && instance.requestor.id === person.id);
        }),
      related_owned_requests: TypeFilter('related_owned_objects', 'Request'),
      related_mapped_objects: CustomFilter('related_objects_via_requests',
        function (result) {
          var pageInstance = GGRC.page_instance();
          var instance = result.instance;
          var res;
          var isMapped = function (responses) {
            var i;
            var j;
            var response;
            var relationships;
            var relationship;

            for (i = 0, response = responses[i]; ;i++) {
              //  FIXME: This avoids script errors due to stubs, but causes
              //    incorrect results.  `CustomFilter.filter_fn` should be
              //    refactored to return a deferred, and then this function
              //    should be cleaned up.
              if (!('related_sources' in response)) continue;
              relationships = new can.Observe.List()
                .concat(response.related_sources.reify(),
                  response.related_destinations.reify());
              for (j = 0, relationship = relationships[j]; ; j++) {
                if (relationship.source && relationship.source.reify &&
                  relationship.source.reify() === pageInstance ||
                  relationship.destination &&
                  relationship.destination.reify() === pageInstance) {
                  return true;
                }
              }
            }
          };

          if (instance instanceof CMS.Models.Request && instance.responses) {
            res = isMapped(instance.responses.reify());
          } else {
            res = false;
          }
          return res;
        }),
      extended_related_objects: Cross('requests', 'extended_related_objects'),
      related_assessment_templates: TypeFilter(
        'related_objects', 'AssessmentTemplate')
    },
    Assessment: {
      _mixins: [
        'related_object', 'personable', 'ownable', 'documentable', 'assignable'
      ],
      audits: TypeFilter('related_objects', 'Audit'),
      related_controls: TypeFilter('related_objects', 'Control'),
      related_regulations: TypeFilter('related_objects', 'Regulation'),
      related_creators:
        AttrFilter('related_objects', 'AssigneeType', 'Creator', 'Person'),
      related_assessors:
        AttrFilter('related_objects', 'AssigneeType', 'Assessor', 'Person'),
      related_verifiers:
        AttrFilter('related_objects', 'AssigneeType', 'Verifier', 'Person'),
      people: AttrFilter('related_objects', 'AssigneeType', null, 'Person')
    },
    AssessmentTemplate: {
      _mixins: ['related_object']
    },
    Issue: {
      _mixins: [
        'related_object', 'personable', 'ownable'
      ]
    },
    Request: {
      _mixins: ['related_object', 'personable', 'ownable', 'business_object',
        'documentable', 'assignable'],
      business_objects: Multi(['related_objects', 'controls', 'documents',
        'people', 'sections', 'clauses']),
      audits: Direct('Audit', 'requests', 'audit'),
      related_controls: TypeFilter('related_objects', 'Control'),
      related_regulations:
        TypeFilter('related_objects', 'Regulation'),
      related_assignees:
        AttrFilter('related_objects', 'AssigneeType', 'Assignee', 'Person'),
      related_requesters:
        AttrFilter('related_objects', 'AssigneeType', 'Requester', 'Person'),
      related_verifiers:
        AttrFilter('related_objects', 'AssigneeType', 'Verifier', 'Person'),
      people: AttrFilter('related_objects', 'AssigneeType', null, 'Person'),
      related_objects_via_search: Search(function (binding) {
        var types = [
          'Program', 'Regulation', 'Contract', 'Policy', 'Standard',
          'Section', 'Clause', 'Objective', 'Control', 'AccessGroup',
          'System', 'Process', 'DataAsset', 'Product', 'Project', 'Facility',
          'Market', 'OrgGroup', 'Vendor', 'Audit', 'Issue', 'Assessment',
          'Request'
        ];

        // checkfor window.location
        if (/^\/objectBrowser\/?$/.test(window.location.pathname)) {
          return GGRC.Models.Search.search_for_types('', types, {})
              .pipe(function (mappings) {
                return mappings.entries;
              });
        }
        return GGRC.Models.Search.search_for_types(
            '', types, {
              contact_id: binding.instance.id
            }).pipe(function (mappings) {
              return mappings.entries;
            });
      }, 'Program,Regulation,Contract,Policy,Standard,Section,Clause,' +
        'Objective,Control,System,Process,DataAsset,AccessGroup,Product,' +
        'Project,Facility,Market,OrgGroup,Vendor,Audit,Assessment,Request')
    },
    Comment: {
      _mixins: ['related_object', 'documentable', 'ownable'],
      urls: TypeFilter('related_objects', 'Document'),
      documents_and_urls: Multi(['documents', 'urls'])
    },
    Meeting: {
      _mixins: ['personable']
    },
    MultitypeSearch: {
      _mixins: ['directive_object'],
      _canonical: {
        audits: 'Audit',
        workflows: 'Workflow'
      },
      audits: Proxy(
        'Audit', 'audit', 'MultitypeSearchJoin'),
      workflows: Proxy(
        'Workflow', 'workflow', 'MultitypeSearchJoin'),
      sections: Proxy(
        'Section', 'section', 'MultitypeSearchJoin')
    },
    AuditObject: {
      _auditable: Direct(null, null, 'auditable')
    },
    // Used by Custom Attributes widget
    CustomAttributable: {
      custom_attribute_definitions: Search(function (binding) {
        return CMS.Models.CustomAttributeDefinition.findAll({
          definition_type: binding.instance.root_object,
          definition_id: null
        });
      }, 'CustomAttributeDefinition')
    }
  });
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  can.Construct('can.Model.Mixin', {
    extend: function (fullName, klass, proto) {
      var tempname;
      var mixinName;
      var parts;
      var shortName;
      var Constructor;

      if (typeof fullName === 'string') {
        // Mixins do not go into the global namespace.
        tempname = fullName;
        fullName = '';
      }
      Constructor = this._super(fullName, klass, proto);

      // instead mixins sit under CMS.Models.Mixins
      if (tempname) {
        parts = tempname.split('.');
        shortName = parts.pop();
        Constructor.fullName = tempname;
      } else {
        Constructor.fullName = shortName =
          'Mixin_' + Math.floor(Math.random() * Math.pow(36, 8)).toString(36);
        parts = [];
      }
      mixinName = 'CMS.Models.Mixins' + (parts.length ?
        '.' + parts.join('.') :
          '');
      can.getObject(mixinName, window, true)[shortName] = Constructor;
      return Constructor;
    },
    newInstance: function () {
      throw new Error('Mixins cannot be directly instantiated');
    },
    add_to: function (cls) {
      var setupfns;
      if (this === can.Model.Mixin) {
        throw new Error('Must only add a subclass of Mixin to an object,' +
          ' not Mixin itself');
      }
      setupfns = function (obj) {
        return function (fn, key) {
          var blockedKeys = ['fullName', 'defaults', '_super', 'constructor'];
          var aspect = ~key.indexOf(':') ?
            key.substr(0, key.indexOf(':')) :
            'after';
          var oldfn;

          key = ~key.indexOf(':') ? key.substr(key.indexOf(':') + 1) : key;
          if (fn !== can.Model.Mixin[key] && !~can.inArray(key, blockedKeys)) {
            oldfn = obj[key];
            // TODO support other ways of adding functions.
            //  E.g. "override" (doesn't call super fn at all)
            //       "sub" (sets this._super for mixin function)
            //       "chain" (pushes result of oldfn onto args)
            //       "before"/"after" (overridden function)
            // TODO support extension for objects.
            //   Necessary for "attributes"/"serialize"/"convert"
            // Defaults will always be "after" for functions
            //  and "override" for non-function values
            if (oldfn && typeof oldfn === 'function') {
              switch (aspect) {
                case 'before':
                  obj[key] = function () {
                    fn.apply(this, arguments);
                    return oldfn.apply(this, arguments);
                  };
                  break;
                case 'after':
                  obj[key] = function () {
                    oldfn.apply(this, arguments);
                    return fn.apply(this, arguments);
                  };
                  break;
                default:
                  break;
              }
            } else if (aspect === 'extend') {
              obj[key] = $.extend(obj[key], fn);
            } else {
              obj[key] = fn;
            }
          }
        };
      };
      if (!~can.inArray(this.fullName, cls._mixins)) {
        cls._mixins = cls._mixins || [];
        cls._mixins.push(this.fullName);

        can.each(this, setupfns(cls));
        can.each(this.prototype, setupfns(cls.prototype));
      }
    }
  }, {
  });

  can.Model.Mixin('ownable', {
    'after:init': function () {
      if (!this.owners) {
        this.attr('owners', []);
      }
    }
  });

  can.Model.Mixin('contactable', {
    // NB : Because the attributes object
    //  isn't automatically cloned into subclasses by CanJS (this is an intentional
    //  exception), when subclassing a class that uses this mixin, be sure to pull in the
    //  parent class's attributes using `can.extend(this.attributes, <parent_class>.attributes);`
    //  in the child class's static init function.
    'extend:attributes': {
      contact: 'CMS.Models.Person.stub',
      secondary_contact: 'CMS.Models.Person.stub'
    }
  }, {
    before_create: function () {
      var person = {
        id: GGRC.current_user.id,
        type: 'Person'
      };
      if (!this.contact) {
        this.attr('contact', person);
      }
    },
    form_preload: function (newObjectForm) {
      var person = {
        id: GGRC.current_user.id,
        type: 'Person'
      };
      if (newObjectForm && !this.contact) {
        this.attr('contact', person);
        this.attr('_transient.contact', person);
      } else if (this.contact) {
        this.attr('_transient.contact', this.contact);
      }
    }
  });

  can.Model.Mixin('ca_update', {}, {
    after_save: function () {
      this.attr('isReadyForRender', true);
    },
    info_pane_preload: function () {
      this.refresh();
    }
  });

  /**
   * A mixin to use for objects that can have their status automatically
   * changed when they are edited.
   *
   * @class CMS.Models.Mixins.autoStatusChangeable
   */
  can.Model.Mixin('autoStatusChangeable', {}, {

    /**
     * Display a confirmation dialog before starting to edit the instance.
     *
     * The dialog is not shown if the instance is either in the "Not Started",
     * or the "In Progress" state - in that case an already resolved promise is
     * returned.
     *
     * @return {Promise} A promise resolved/rejected if the user chooses to
     *   confirm/reject the dialog.
     */
    confirmBeginEdit: function () {
      var STATUS_NOT_STARTED = 'Not Started';
      var STATUS_IN_PROGRESS = 'In Progress';
      var IGNORED_STATES = [STATUS_NOT_STARTED, STATUS_IN_PROGRESS];

      var TITLE = [
        'Confirm moving ', this.type, ' to "', STATUS_IN_PROGRESS, '"'
      ].join('');

      var DESCRIPTION = [
        'If you modify a value, the status of the ', this.type,
        ' will move from "', this.status, '" to "',
        STATUS_IN_PROGRESS, '" - are you sure about that?'
      ].join('');

      var confirmation = $.Deferred();

      if (_.includes(IGNORED_STATES, this.status)) {
        confirmation.resolve();
      } else {
        GGRC.Controllers.Modals.confirm({
          modal_description: DESCRIPTION,
          modal_title: TITLE,
          button_view: GGRC.mustache_path + '/gdrive/confirm_buttons.mustache'
        }, confirmation.resolve, confirmation.reject);
      }

      return confirmation.promise();
    }
  });

  can.Model.Mixin('unique_title', {
    'after:init': function () {
      this.validate(['title', '_transient.title'], function (newVal, prop) {
        if (prop === 'title') {
          return this.attr('_transient.title');
        } else if (prop === '_transient.title') {
          return newVal; // the title error is the error
        }
      });
    }
  }, {
    save_error: function (val) {
      if (/title values must be unique\.$/.test(val)) {
        this.attr('_transient.title', val);
      }
    },
    after_save: function () {
      this.removeAttr('_transient.title');
    },
    'before:attr': function (key, val) {
      if (key === 'title' &&
          arguments.length > 1 &&
          this._transient) {
        this.attr('_transient.title', null);
      }
    }
  });
  // TODO: remove this mixin and all related logic from Front-end part
  can.Model.Mixin('relatable', {
  }, {
    related_self: function () {
      var model = CMS.Models[this.type];
      return this._related(
        model.relatable_options.relevantTypes,
        model.relatable_options.threshold
      );
    },
    /**
     * Return objects of single type above threshold that are
     * mapped to specified mapped objects.
     *
     * @param {Object} relevantTypes - object with specified first degree
     *   binding (objectBinding), second degree binding (relatableBinding) and
     *   weights that individual second degree bindings are carrying.
     *
     *   relevantTypes = {
     *     @ObjectType: {
     *       objectBinding: @first-degree-mapping,
     *       relatableBinding: @second-degree-mapping,
     *       weight: @weight-of-objects
     *     },
     *     Audit: {
     *       objectBinding: 'audits',
     *       relatableBinding: 'program_requests',
     *       weight: 5
     *     },
     *     Regulation: {
     *       objectBinding: 'related_regulations',
     *       relatableBinding: 'related_requests',
     *       weight: 3
     *     }, ...
     *   }
     * @param {Number} threshold - minimum weight required to render related
     *   object
     *
     */
    _related: function (relevantTypes, threshold) {
      var that = this;
      var relatable = $.Deferred();
      var connectionsCount = {};
      var relatedObjectsDeferreds = [];
      var mappedObjectDeferreds = _.map(relevantTypes, function (rtype) {
        return this.get_binding(rtype.objectBinding).refresh_instances();
      }.bind(this));

      $.when.apply($, mappedObjectDeferreds).done(function () {
        _.each(_.toArray(arguments), function (mappedObjectInstances) {
          if (!mappedObjectInstances.length) {
            return;
          }
          relatedObjectsDeferreds = relatedObjectsDeferreds.concat(
            _.map(mappedObjectInstances, function (mappedObj) {
              var insttype = mappedObj.instance.type;
              var binding = relevantTypes[insttype].relatableBinding;
              return mappedObj.instance.get_binding(
                binding).refresh_instances();
            }));
        });
        $.when.apply($, relatedObjectsDeferreds).done(function () {
          _.each(_.toArray(arguments), function (relatedObjects) {
            _.each(relatedObjects, function (relObj) {
              var type = relObj.binding.instance.type;
              var weight = relevantTypes[type].weight;
              if (relObj.instance.id !== that.id) {
                if (connectionsCount[relObj.instance.id] === undefined) {
                  connectionsCount[relObj.instance.id] = {
                    count: weight,
                    object: relObj
                  };
                } else {
                  connectionsCount[relObj.instance.id].count += weight;
                }
              }
            });
          });
          relatable.resolve(
            _.map(_.sortBy(_.filter(connectionsCount, function (item) {
              if (item.count >= threshold) {
                return item;
              }
            }), 'count').reverse(),
              function (item) {
                return item.object;
              }));
        });
      });
      return relatable;
    }
  });

  can.Model.Mixin('timeboxed', {
    'extend:attributes': {
      start_date: 'date',
      end_date: 'date'
    }
  }, {
  });
})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

// = require can.jquery-all

(function (can) {
  var _oldAttr;
  function makeFindRelated(thistype, othertype) {
    return function (params) {
      if (!params[thistype + '_type']) {
        params[thistype + '_type'] = this.shortName;
      }
      return CMS.Models.Relationship.findAll(params).then(
        function (relationships) {
          var dfds = [];
          var things = new can.Model.List();
          can.each(relationships, function (rel, idx) {
            var dfd;
            if (rel[othertype].selfLink) {
              things.push(rel[othertype]);
            } else {
              dfd = rel[othertype].refresh().then(function (dest) {
                things.splice(idx, 1, dest);
              });
              dfds.push(dfd);
              things.push(dfd);
            }
          });
          return $.when.apply($, dfds).then(function () {
            return things;
          });
        });
    };
  }

  function dateConverter(date, oldValue, fn, key) {
    var conversion = 'YYYY-MM-DD\\THH:mm:ss\\Z';
    var ret;
    if (typeof date === 'object' && date) {
      date = date.getTime();
    }
    if (typeof date === 'number') {
      date /= 1000;
      conversion = 'X';
    }
    if (typeof date === 'string' && ~date.indexOf('/')) {
      conversion = 'MM/DD/YYYY';
    }
    date = date ? date.toString() : null;
    ret = moment(date, conversion);
    if (!ret.unix()) {
      // invalid date computed. Result of unix() is NaN.
      return undefined;
    }

    if (typeof date === 'string' && ret &&
      //  Don't correct timezone for dates
        !/^\d+-\d+-\d+$/.test(date) && !/^\d+\/\d+\/\d+$/.test(date) &&
      //  Don't correct timezone if `moment.js` has already done it
        !/[-+]\d\d:?\d\d/.test(date)) {
      // Use the UTC offset that was active at the moment in time to correct
      // the date's timezone.
      ret.add(ret.utcOffset(), 'minute');
    }

    if (oldValue && oldValue.getTime &&
      ret && ret.toDate().getTime() === oldValue.getTime()) {
      // avoid changing to new Date object if the value is the same.
      return oldValue;
    }
    return ret ? ret.toDate() : undefined;
  }

  function makeDateUnpacker(keys) {
    return function (date, oldValue, fn, attr) {
      return can.reduce(keys, function (curr, key) {
        return curr || (date[key] && dateConverter(
            date[key], oldValue, fn, attr));
      }, null) || date;
    };
  }

  function makeDateSerializer(type, key) {
    var conversion = type === 'date' ?
      'YYYY-MM-DD' :
      'YYYY-MM-DD\\THH:mm:ss\\Z';
    return function (date) {
      var retstr;
      var retval;
      if (date === null || date === undefined) {
        return '';
      }
      if (typeof date !== 'number') {
        date = date.getTime();
      }
      retstr = moment((date / 1000).toString(), 'X');
      if (type !== 'date') {
        retstr = retstr.utc();
      }
      retstr = retstr.format(conversion);
      if (key) {
        retval = {};
        retval[key] = retstr;
      } else {
        retval = retstr;
      }
      return retval;
    };
  }

  can.Model('can.Model.Cacheable', {
    root_object: '',
    attr_list: [
    {attr_title: 'Title', attr_name: 'title'},
    {attr_title: 'Owner', attr_name: 'owner', attr_sort_field: 'contact.name|email'},
    {attr_title: 'Code', attr_name: 'slug'},
    {attr_title: 'State', attr_name: 'status'},
    {attr_title: 'Primary Contact', attr_name: 'contact', attr_sort_field: 'contact.name|email'},
    {attr_title: 'Secondary Contact', attr_name: 'secondary_contact', attr_sort_field: 'secondary_contact.name|email'},
    {attr_title: 'Last Updated', attr_name: 'updated_at'}
    ],

    root_collection: '',
    model_singular: '',
    model_plural: '',
    table_singular: '',
    table_plural: '',
    title_singular: '',
    title_plural: '',
    findOne: 'GET {href}',

    makeDestroy: function (destroy) {
      return function (id, instance) {
        return destroy(id).then(function (result) {
          if ('background_task' in result) {
            return CMS.Models.BackgroundTask.findOne(
            {id: result.background_task.id}
          ).then(function (task) {
            if (!task) {
              return;
            }
            return task.poll();
          }).then(function () {
            return instance;
          });
          } else {
            return instance;
          }
        });
      };
    },

    makeFindAll: function (finder) {
      return function (params, success, error) {
        var deferred = $.Deferred();
        var sourceDeferred = finder.call(this, params);
        var self = this;
        var tracker_stop = GGRC.Tracker.start('modelize', self.shortName);

        deferred.then(success, error);
        sourceDeferred.then(function (sourceData) {
          if (sourceData[self.root_collection + '_collection']) {
            sourceData = sourceData[self.root_collection + '_collection'];
          }
          if (sourceData[self.root_collection]) {
            sourceData = sourceData[self.root_collection];
          }

          if (!sourceData.splice) {
            sourceData = [sourceData];
          }

          self._modelize(sourceData, deferred);
        }, function () {
          deferred.reject.apply(deferred, arguments);
        });

        return deferred.done(tracker_stop);
      };
    },

    setup: function (construct, name, statics, prototypes) {
      var overrideFindAll = false;

      if (this.fullName === 'can.Model.Cacheable') {
        this.findAll = function () {
          throw 'No default findAll() exists for subclasses of Cacheable';
        };
        this.findPage = function () {
          throw 'No default findPage() exists for subclasses of Cacheable';
        };
      }
      else if ((!statics || !statics.findAll) && this.findAll === can.Model.Cacheable.findAll) {
        if (this.root_collection) {
          this.findAll = 'GET /api/' + this.root_collection;
        } else {
          overrideFindAll = true;
        }
      }
      if (this.root_collection) {
        this.model_plural = statics.model_plural || this.root_collection.replace(/(?:^|_)([a-z])/g, function (s, l) { return l.toUpperCase(); });
        this.title_plural = statics.title_plural || this.root_collection.replace(/(^|_)([a-z])/g, function (s, u, l) { return (u ? ' ' : '') + l.toUpperCase(); });
        this.table_plural = statics.table_plural || this.root_collection;
      }
      if (this.root_object) {
        this.model_singular = statics.model_singular || this.root_object.replace(/(?:^|_)([a-z])/g, function (s, l) { return l.toUpperCase(); });
        this.title_singular = statics.title_singular || this.root_object.replace(/(^|_)([a-z])/g, function (s, u, l) { return (u ? ' ' : '') + l.toUpperCase(); });
        this.table_singular = statics.table_singular || this.root_object;
      }

      if (!can.isFunction(this.findAll)) {
        this.findPage = this.makeFindPage(this.findAll);
      }

    // Prevent event "bleeding" from other members of the Cacheable tree.
    // This fix causes breakages in places where we're expecting model class
    //  events not to be isolated (like in the LHN controller).
    //  I've submitted a fix to CanJS for this but it remains to be seen
    //  whether it gets in and when.  --BM 3/4/14
    // this.__bindEvents = {};

      var that = this;
      if (statics.mixins) {
        can.each(statics.mixins, function (mixin) {
          var _mixin = mixin;
          if (typeof _mixin === 'string') {
            _mixin = can.getObject(_mixin, CMS.Models.Mixins);
          }
          if (_mixin) {
            _mixin.add_to(that);
          } else {
            throw new Error('Error: Cannot find mixin ' +
              mixin + ' for class ' + that.fullName);
          }
        });
        delete this.mixins;
      }

      var ret = this._super.apply(this, arguments);
      if (overrideFindAll)
        this.findAll = can.Model.Cacheable.findAll;

    // set up default attribute converters/serializers for all classes
      can.extend(this.attributes, {
        created_at: 'datetime',
        updated_at: 'datetime'
      });

      return ret;
    },

    init: function () {
      var id_key = this.id;
      var _update = this.update;
      var _create = this.create;
      this.bind('created', function (ev, new_obj) {
        var cache = can.getObject('cache', new_obj.constructor, true);
        if (new_obj[id_key] || new_obj[id_key] === 0) {
          if (!GGRC.Utils.Snapshots.isSnapshot(new_obj)) {
            cache[new_obj[id_key]] = new_obj;
          }
          if (cache[undefined] === new_obj)
            delete cache[undefined];
        }
      });
      this.bind('destroyed', function (ev, old_obj) {
        delete can.getObject('cache', old_obj.constructor, true)[old_obj[id_key]];
      });

    // FIXME:  This gets set up in a chain of multiple calls to the function defined
    //  below when the update endpoint isn't set in the model's static config.
    //  This leads to conflicts not actually rejecting because on the second go-round
    //  the local and remote objects look the same.  --BM 2015-02-06
      this.update = function (id, params) {
        var self = this;
        var ret = _update
        .call(this, id, this.process_args(params))
        .then(
          this.resolve_deferred_bindings.bind(this),
          function (xhr) {
            if (xhr.status === 409) {
              $(document.body).trigger('ajax:flash', {
                warning: 'There was a conflict while saving.' +
                'Your changes have not yet been saved.' +
                ' Please check any fields you were editing and try saving again'
              });
              // TODO: we should show modal window here
              return self.findInCacheById(id).refresh();
            }
            return xhr;
          }
        );
        delete ret.hasFailCallback;
        return ret;
      };
      this.create = function (params) {
        var ret = _create
        .call(this, this.process_args(params))
        .then(this.resolve_deferred_bindings.bind(this));
        delete ret.hasFailCallback;
        return ret;
      };

    // Register this type as a custom attributable type if it is one.
      if (this.is_custom_attributable) {
        if (!GGRC.custom_attributable_types) {
          GGRC.custom_attributable_types = [];
        }
        GGRC.custom_attributable_types.push(can.extend({}, this));
      }
    },

    resolve_deferred_bindings: function (obj) {
      var _pjs;
      var refresh_dfds = [];
      var dfds = [];
      var dfds_apply;
      if (obj._pending_joins && obj._pending_joins.length) {
        _pjs = obj._pending_joins.slice(0); // refresh of bindings later will muck up the pending joins on the object
        can.each(can.unique(can.map(_pjs, function (pj) {
          return pj.through;
        })), function (binding) {
          refresh_dfds.push(obj.get_binding(binding).refresh_stubs());
        });

        return $.when.apply($, refresh_dfds)
      .then(function () {
        can.each(obj._pending_joins, function (pj) {
          var inst;
          var binding = obj.get_binding(pj.through);
          var model = (CMS.Models[binding.loader.model_name] ||
                       GGRC.Models[binding.loader.model_name]);
          if (pj.how === 'add') {
            // Don't re-add -- if the object is already mapped (could be direct or through a proxy)
            // move on to the next one
            if (_.includes(_.map(binding.list, 'instance'), pj.what) ||
               (binding.loader.option_attr &&
                _.includes(_.map(binding.list, function (join_obj) {
                  return join_obj.instance[binding.loader.option_attr];
                }), pj.what))) {
              return;
            }
            inst = pj.what instanceof model
              ? pj.what
              : new model({
                context: obj.context
              });
            dfds.push(
              $.when(pj.what !== inst && pj.what.isNew() ? pj.what.save() : null)
               .then(function () {
                 if (binding.loader.object_attr) {
                   inst.attr(binding.loader.object_attr, obj.stub());
                 }
                 if (binding.loader.option_attr) {
                   inst.attr(binding.loader.option_attr, pj.what.stub());
                 }
                 if (pj.extra) {
                   inst.attr(pj.extra);
                 }
                 return inst.save();
               })
            );
          } else if (pj.how === 'update') {
            binding.list.forEach(function (bound_obj) {
              if (bound_obj.instance === pj.what ||
                  bound_obj.instance[binding.loader.option_attr] === pj.what) {
                bound_obj.get_mappings().forEach(function (mapping) {
                  dfds.push(mapping.refresh().then(function () {
                    if (pj.extra) {
                      mapping.attr(pj.extra);
                    }
                    return mapping.save();
                  }));
                });
              }
            });
          } else if (pj.how === 'remove') {
            can.map(binding.list, function (bound_obj) {
              if (bound_obj.instance === pj.what || bound_obj.instance[binding.loader.option_attr] === pj.what) {
                can.each(bound_obj.get_mappings(), function (mapping) {
                  dfds.push(mapping.refresh().then(function () {
                    mapping.destroy();
                  }));
                });
              }
            });
          }
        });

        dfds_apply = $.when.apply($, dfds);

        obj.attr('_pending_joins', []);
        obj.attr('_pending_joins_dfd', dfds_apply);

        return dfds_apply.then(function () {
          can.trigger(this, 'resolved');
          return obj.refresh();
        });
      });
      }
      return obj;
    },

    findInCacheById: function (id) {
      return can.getObject('cache', this, true)[id];
    },

    newInstance: function (args) {
      var cache = can.getObject('cache', this, true);
      var isKeyExists = args && args[this.id];
      var isObjectExists = isKeyExists && cache[args[this.id]];
      var notSnapshot = args && !GGRC.Utils.Snapshots.isSnapshot(args);
      if (isObjectExists && notSnapshot) {
        // cache[args.id].attr(args, false); //CanJS has bugs in recursive merging
        // (merging -- adding properties from an object without removing existing ones
        //  -- doesn't work in nested objects).  So we're just going to not merge properties.
        return cache[args[this.id]];
      }
      return this._super.apply(this, arguments);
    },
    process_args: function (args) {
      var pargs = {};
      var obj = pargs;
      var src;
      var go_names;
      if (this.root_object && !(this.root_object in args)) {
        obj = pargs[this.root_object] = {};
      }
      src = args.serialize ? args.serialize() : args;
      go_names = Object.keys(src)
      for (var i = 0; i < (go_names.length || 0); i++) {
        obj[go_names[i]] = src[go_names[i]];
      }
      return pargs;
    },

    findRelated: makeFindRelated('source', 'destination'),
    findRelatedSource: makeFindRelated('destination', 'source'),

    models: function (params) {
      var ms;
      if (params[this.root_collection + '_collection']) {
        params = params[this.root_collection + '_collection'];
      }
      if (params[this.root_collection]) {
        params = params[this.root_collection];
      }
      if (!params || params.length === 0)
        return new this.List();
      ms = this._super(params);
      if (params instanceof can.Map || params instanceof can.List) {
        params.replace(ms);
        return params;
      }
      return ms;
    },

    query: function (request) {
      var deferred = $.Deferred();
      var self = this;

      GGRC.Utils.QueryAPI.makeRequest(request)
        .then(function (sourceData) {
          var values = [];
          var listDfd = $.Deferred();
          if (sourceData.length) {
            sourceData = sourceData[0];
          } else {
            sourceData = {};
          }

          if (sourceData[self.shortName]) {
            sourceData = sourceData[self.shortName];
            values = sourceData.values;
          } else if (sourceData.Snapshot) {
            // This is response with snapshots - convert it to objects
            sourceData = sourceData.Snapshot;
            values = GGRC.Utils.Snapshots.toObjects(sourceData.values);
          }

          if (!values.splice) {
            values = [values];
          }
          self._modelize(values, listDfd);

          listDfd.then(function (list) {
            sourceData.values = list;
            deferred.resolve(sourceData);
          });
        }, function () {
          deferred.reject.apply(deferred, arguments);
        });

      return deferred;
    },

  _modelize: function (sourceData, deferred) {
    var obsList = new this.List([]);
    var index = 0;
    var self = this;
    function modelizeMS(ms) {
      var item;
      var start;
      var instances = [];

      start = Date.now();
      while (sourceData.length > index && (Date.now() - start) < ms) {
        can.Observe.startBatch();
        item = sourceData[index];
        index += 1;
        instances.push.apply(instances, self.models([item]));
        can.Observe.stopBatch();
      }
      can.Observe.startBatch();
      obsList.push.apply(obsList, instances);
      can.Observe.stopBatch();
    }

    // Trigger a setTimeout loop to modelize remaining objects
    (function cb() {
      modelizeMS(100);
      if (sourceData.length > index) {
        setTimeout(cb, 5);
      } else {
        deferred.resolve(obsList);
      }
    })();
  },

    object_from_resource: function (params) {
      var obj_name = this.root_object;
      if (!params) {
        return params;
      }
      if (typeof obj_name !== 'undefined' && params[obj_name]) {
        for (var i in params[obj_name]) {
          if (params[obj_name].hasOwnProperty(i)) {
            params.attr
            ? params.attr(i, params[obj_name][i])
            : (params[i] = params[obj_name][i]);
          }
        }
        if (params.removeAttr) {
          params.removeAttr(obj_name);
        } else {
          delete params[obj_name];
        }
      }
      return params;
    },

    stubs: function (params) {
      return new can.List(can.map(this.models(params), function (instance) {
        if (!instance) {
          return instance;
        }
        return instance.stub();
      }));
    },

    stub: function (params) {
      if (!params) {
        return params;
      }
      return this.model(params).stub();
    },
    model: function (params) {
      var model;
      params = this.object_from_resource(params);
      if (!params)
        return params;
      model = this.findInCacheById(params[this.id]) ||
        (params.provisional_id &&
        can.getObject('provisional_cache', can.Model.Cacheable, true)[params.provisional_id]);
      if (model && !GGRC.Utils.Snapshots.isSnapshot(params)) {
        if (model.provisional_id && params.id) {
          delete can.Model.Cacheable.provisional_cache[model.provisional_id];
          model.removeAttr('provisional_id');
          model.constructor.cache[params.id] = model;
          model.attr('id', params.id);
        }
        model.attr(params);
      } else {
        model = this._super(params);
      }
      return model;
    },

    convert: {
      date: dateConverter,
      datetime: dateConverter,
      packaged_datetime: makeDateUnpacker(['dateTime', 'date'])
    },
    serialize: {
      datetime: makeDateSerializer('datetime'),
      date: makeDateSerializer('date'),
      packaged_datetime: makeDateSerializer('datetime', 'dateTime')
    },
    tree_view_options: {
      display_attr_names: ['title', 'owner', 'status'],
      mandatory_attr_names: ['title']
    },
    obj_nav_options: {},
    list_view_options: {},
    getRootModelName: function () {
      return this.root_model || this.shortName;
    },

    makeFindPage: function (findAllSpec) {
    /* Create a findPage function that will return a paging object that will
     * provide access to the model items provided in a single page as well
     * as paging capability to retrieve the named pages provided in the
     * response.
     *
     * findPage returns an object with two properties:
     * {this.options.model.root_collection}_collection and paging. The models
     * property will be an array of all model instances in the page retrieved
     * for the collection. The paging property will be an object that can be
     * used to retrieve other named pages from the collection.  The names of
     * pages include first, prev, next, last. Named page properties will
     * either be functions or the null value in the case where there is no
     * link available in the collection under that name.  Paging functions
     * have the same type of return value as the findPage function.
     *
     * This method assumes that findAllSpec is a string like
     * "GET /api/programs". If this assumption is invalid, this function
     * WILL NOT work correctly.
     */
      var parts;
      var method;
      var collectionUrl;
      var baseParams;

      var that = this;

      function makePaginator(paging, baseParams, scope) {
        function getPage(pageName) {
          if (paging[pageName]) {
            return function () {
              // the paging ("next", "prev", etc. URLs already include query
              // string params, thus passing null for them
              return findPageFunc(paging[pageName], null, baseParams, scope);
            };
          }
          return null;
        }

        return {
          count: paging.count,
          total: paging.total,
          first: getPage('first'),
          prev: getPage('prev'),
          next: getPage('next'),
          last: getPage('last'),
          has_next: function () {
            return this.next !== null;
          },
          has_prev: function () {
            return this.prev !== null;
          }
        };
      }

      function findPageFunc(url, data, params, scope) {
        var ajaxOptions = can.extend({
          url: url,
          data: data
        }, params);

        return can.ajax(ajaxOptions).then(function (response) {
          var collection = response[that.root_collection + '_collection'];
          var paginator = makePaginator(collection.paging, params, scope);
          var ret = {
            paging: paginator
          };
          ret[scope.root_collection + '_collection'] =
            scope.models(collection[scope.root_collection]);
          return ret;
        });
      }

      if (typeof findAllSpec === 'string') {
        parts = findAllSpec.split(' ');
        method = parts.length === 2 ? parts[0] : 'GET';
        collectionUrl = parts.length === 2 ? parts[1] : parts[0];
      } else if (typeof findAllSpec === 'object') {
        method = findAllSpec.type || 'GET';
        collectionUrl = findAllSpec.url;
      } else {
        return; // TODO make a pager if findAllSpec is a function.
      }

      baseParams = {
        type: method,
        dataType: 'json'
      };

      return function (params) {
        params = params || {};
        if (!params.__page) {
          params.__page = 1;
        }
        if (!params.__page_size) {
          params.__page_size = 50;
        }
        return findPageFunc(collectionUrl, params, baseParams, that);
      };
    },

    get_mapper: function (name) {
      var mappers, mapper;
      mappers = GGRC.Mappings.get_mappings_for(this.shortName);
      if (mappers) {
        mapper = mappers[name];
        return mapper;
      }
    },

  // This this is the parsing part of the easy accessor for deep properties.
  // Use the result of this with instance.get_deep_property
  // owners.0.name -> this.owners[0].reify().name
  // owners.0.name|email ->
  // firstnonempty this.owners[0].reify().name this.owners[0].reify().email
  //
  // owners.GET_ALL.name ->
  // [this.owners[0].reify().name, this.owners[1].reify().name...]
    parse_deep_property_descriptor: function (deep_property_string) {
      return Object.freeze(_.map(deep_property_string.split('.'), function (part) {
        if (part === 'GET_ALL') {
          return part;
        }
        return Object.freeze(part.split('|'));
      }));
    }
  }, {
    init: function () {
      var cache = can.getObject('cache', this.constructor, true);
      var id_key = this.constructor.id;
      var that = this;
      GGRC.Utils.Snapshots.setAttrs(this);
      if ((this[id_key] || this[id_key] === 0) &&
        !GGRC.Utils.Snapshots.isSnapshot(this)) {
        cache[this[id_key]] = this;
      }
      this.attr('class', this.constructor);
      this.notifier = new PersistentNotifier({name: this.constructor.model_singular});

      if (!this._pending_joins) {
        this.attr('_pending_joins', []);
      }

    // Listen for `stub_destroyed` change events and nullify or remove the
    // corresponding property or list item.
      this.bind('change', function (ev, path, how, newVal, oldVal) {
        var m, n;
        m = path.match(/(.*?)\.stub_destroyed$/);
        if (m) {
          n = m[1].match(/^([^.]+)\.(\d+)$/);
          if (n) {
            that.attr(n[1]).splice(parseInt(n[2], 10), 1);
          } else {
            n = m[1].match(/^([^.]+)$/);
            if (n)
              that.removeAttr(n[1]);
          }
        }
      });
    },
    load_custom_attribute_definitions: function () {
      var definitions;
      if (this.attr('custom_attribute_definitions')) {
        return;
      }
      if (GGRC.custom_attr_defs === undefined) {
        GGRC.custom_attr_defs = {};
        console.warn('Missing injected custom attribute definitions');
      }
      definitions = can.map(GGRC.custom_attr_defs, function (def) {
        var idCheck = !def.definition_id || def.definition_id === this.id;
        if (idCheck && def.definition_type === this.constructor.table_singular) {
          return def;
        }
      }.bind(this));
      this.attr('custom_attribute_definitions', definitions);
    },

  /**
   * Setup the instance's custom attribute validations, and initialize their
   * values, if necessary.
   */
    setup_custom_attributes: function () {
      var self = this;
      var key;

    // Remove existing custom_attribute validations,
    // some of them might have changed
      for (key in this.class.validations) {
        if (key.indexOf('custom_attributes.') === 0) {
          delete this.class.validations[key];
        }
      }

    // setup validators for custom attributes based on their definitions
      can.each(this.custom_attribute_definitions, function (definition) {
        if (definition.mandatory && !this.ignore_ca_errors) {
          if (definition.attribute_type === 'Checkbox') {
            self.class.validate('custom_attributes.' + definition.id,
              function (val) {
                return val ? '' : 'must be checked';
              });
          } else {
            self.class.validateNonBlank('custom_attributes.' + definition.id);
          }
        }
      }.bind(this));

    // if necessary, initialize custom attributes' values on the instance
      if (!this.custom_attributes) {
        this.attr('custom_attributes', new can.Map());
        can.each(this.custom_attribute_values, function (value) {
          var def;
          var attributeValue;
          var object;
          value = value.isStub ? value : value.reify();
          def = _.find(this.custom_attribute_definitions, {
            id: value.custom_attribute_id
          });
          if (def) {
            if (def.attribute_type.startsWith('Map:')) {
              object = value.attribute_object;
              attributeValue = object.type + ':' + object.id;
            } else {
              attributeValue = value.attribute_value;
            }
            self.custom_attributes.attr(value.custom_attribute_id,
                                      attributeValue);
          }
        }.bind(this));
      }

    // Due to the current lack on any information on sort order, just use the
    // order the custom attributes were defined in.
      function sortById(a, b) {
        return a.id - b.id;
      }
      // Sort only if definitions were attached.
      if (this.attr('custom_attribute_definitions')) {
        this.attr('custom_attribute_definitions').sort(sortById);
      }
    },

    _custom_attribute_map: function (attrId, object) {
      var definition;
      attrId = Number(attrId); // coming from mustache this will be a string
      definition = _.find(this.custom_attribute_definitions, {id: attrId});

      if (!definition || !definition.attribute_type.startsWith('Map:')) {
        return;
      }
      if (typeof object === 'string' && object.length > 0) {
        return;
      }
      object = object.stub ? object.stub() : undefined;
      if (object) {
        this.custom_attributes.attr(attrId, object.type + ':' + object.id);
      } else {
        this.custom_attributes.attr(attrId, 'Person:None');
      }
    },
    computed_errors: can.compute(function () {
      var errors = this.errors();
      if (this.attr('_suppress_errors')) {
        return null;
      } else {
        return errors;
      }
    }),
    computed_unsuppressed_errors: can.compute(function () {
      return this.errors();
    }),
    get_list_counter: function (name) {
      var binding = this.get_binding(name);
      if (!binding) {
        return $.Deferred().reject();
      }
      return binding.refresh_count();
    },

    get_list_loader: function (name) {
      var binding = this.get_binding(name);
      return binding.refresh_list();
    },

    get_mapping: function (name) {
      var binding = this.get_binding(name);
      if (binding) {
        binding.refresh_list();
        return binding.list;
      }
      return [];
    },

    get_mapping_deferred: function (name) {
      return this.get_binding(name).refresh_list();
    },

  // This retrieves the potential orphan stats for a given instance
  // Example: "This may also delete 3 Sections, 2 Controls, and 4 object mappings."
    get_orphaned_count: function () {
      if (!this.get_binding('orphaned_objects')) {
        return new $.Deferred().reject();
      }
      return this.get_list_loader('orphaned_objects').then(function (list) {
        var objects = [], mappings = []
        , counts = {}
        , result = []
        , parts = 0;

        function is_join(mapping) {
          if (mapping.mappings.length > 0) {
            for (var i = 0, child; child = mapping.mappings[i]; i++) {
              if (child = is_join(child)) {
                return child;
              }
            }
          }
          return mapping.instance && mapping.instance instanceof can.Model.Join && mapping.instance;
        }
        can.each(list, function (mapping) {
          var inst;
          if (inst = is_join(mapping))
            mappings.push(inst);
          else
          objects.push(mapping.instance);
        });

      // Generate the summary
        if (objects.length || mappings.length) {
          result.push('This may also delete');
        }
        if (objects.length) {
          can.each(objects, function (instance) {
            var title = instance.constructor.title_singular;
            counts[title] = counts[title] || {
              model: instance.constructor
            , count: 0
            };
            counts[title].count++;
          });
          can.each(counts, function (count, i) {
            parts++;
            result.push(count.count + ' ' + (count.count === 1 ? count.model.title_singular : count.model.title_plural) + ',');
          });
        }
        if (mappings.length) {
          parts++;
          result.push(mappings.length + ' object mapping' + (mappings.length !== 1 ? 's' : ''));
        }

      // Clean up commas, add an "and" if appropriate
        parts >= 1 && parts <= 2 && (result[result.length - 1] = result[result.length - 1].replace(',', ''));
        parts === 2 && (result[result.length - 2] = result[result.length - 2].replace(',', ''));
        parts >= 2 && result.splice(result.length - 1, 0, 'and');
        return result.join(' ') + (objects.length || mappings.length ? '.' : '');
      });
    },

    _get_binding_attr: function (mapper) {
      if (typeof (mapper) === 'string') {
        return '_' + mapper + '_binding';
      }
    },

  // checks if binding exists without throwing debug statements
  // modeled after what get_binding is doing
    has_binding: function (mapper) {
      var binding,
        mapping,
        binding_attr = this._get_binding_attr(mapper);

      if (binding_attr) {
        binding = this[binding_attr];
      }

      if (!binding) {
        if (typeof (mapper) === 'string') {
          mapping = this.constructor.get_mapper(mapper);
          if (!mapping) {
            return false;
          }
        } else if (!(mapper instanceof GGRC.ListLoaders.BaseListLoader)) {
          return false;
        }
      }

      return true;
    },

    get_binding: function (mapper) {
      var mappings;
      var mapping;
      var binding;
      var binding_attr = this._get_binding_attr(mapper);

      if (binding_attr) {
        binding = this[binding_attr];
      }

      if (!binding) {
        if (typeof (mapper) === 'string') {
        // Lookup and attach named mapper
          mapping = this.constructor.get_mapper(mapper);
          if (!mapping)
            console.debug('No such mapper:  ' + this.constructor.shortName + '.' + mapper);
          else
          binding = mapping.attach(this);
        } else if (mapper instanceof GGRC.ListLoaders.BaseListLoader) {
        // Loader directly provided, so just attach
          binding = mapper.attach(this);
        } else {
          console.debug('Invalid mapper specified:', mapper);
        }
        if (binding && binding_attr) {
          this[binding_attr] = binding;
          binding.name = this.constructor.shortName + '.' + mapper;
        }
      }
      return binding;
    },

    addElementToChildList: function (attrName, new_element) {
      this[attrName].push(new_element);
      this._triggerChange(attrName, 'set', this[attrName], this[attrName].slice(0, this[attrName].length - 1));
    },
    removeElementFromChildList: function (attrName, old_element, all_instances) {
      for (var i = this[attrName].length - 1; i >= 0; i--) {
        if (this[attrName][i] === old_element) {
          this[attrName].splice(i, 1);
          if (!all_instances) break;
        }
      }
      this._triggerChange(attrName, 'set', this[attrName], this[attrName].slice(0, this[attrName].length - 1));
    },
    refresh: function (params) {
      var dfd,
        href = this.selfLink || this.href,
        that = this;

      if (!href) {
        return (new can.Deferred()).reject();
      }
      if (!this._pending_refresh) {
        this._pending_refresh = {
          dfd: $.Deferred(),
          fn: _.throttle(function () {
            var dfd = that._pending_refresh.dfd;
            can.ajax({
              url: href,
              params: params,
              type: 'get',
              dataType: 'json'
            })
          .then(function (resources) {
            delete that._pending_refresh;
            return resources;
          })
          .then($.proxy(that.constructor, 'model'))
          .done(function (response) {
            response.backup();
            dfd.resolve.apply(dfd, arguments);
          })
          .fail(function () {
            dfd.reject.apply(dfd, arguments);
          });
          }, 1000, {trailing: false})
        };
      }
      dfd = this._pending_refresh.dfd;
      this._pending_refresh.fn();
      return dfd;
    },
  // TODO: should be refactored and sliced on multiple functions
    serialize: function () {
      var that = this;
      var serial = {};
      if (arguments.length) {
        return this._super.apply(this, arguments);
      }
      this.each(function (val, name) {
        var fnName;
        if (that.constructor.attributes && that.constructor.attributes[name]) {
          fnName = that.constructor.attributes[name];
          fnName = fnName.substr(fnName.lastIndexOf('.') + 1);
          if (fnName === 'stubs' || fnName === 'get_stubs' ||
          fnName === 'models' || fnName === 'get_instances') {
          // val can be null in some cases
            if (val) {
              serial[name] = val.stubs().serialize();
            }
          } else if (fnName === 'stub' || fnName === 'get_stub' ||
          fnName === 'model' || fnName === 'get_instance') {
            serial[name] = (val ? val.stub().serialize() : null);
          } else {
            serial[name] = that._super(name);
          }
        } else if (val && typeof val.save === 'function') {
          serial[name] = val.stub().serialize();
        } else if (typeof val === 'object' && val !== null && val.length) {
          serial[name] = can.map(val, function (v) {
            var isModel = v && typeof v.save === 'function';
            return isModel ?
            v.stub().serialize() :
            v.serialize ? v.serialize() : v;
          });
        } else if (typeof val !== 'function') {
          if (that[name] && that[name].isComputed) {
            serial[name] = val && val.serialize ? val.serialize() : val;
          } else {
            serial[name] = that[name] && that[name].serialize ?
            that[name].serialize() :
            that._super(name);
          }
        }
      });
      return serial;
    },
    display_name: function () {
      var displayName = this.title || this.name;

      if (_.isUndefined(displayName)) {
        return '"' + this.type + ' ID: ' + this.id + '" (DELETED)';
      }

      return displayName;
    },
    display_type: function () {
      return this.type;
    },
    autocomplete_label: function () {
      return this.title;
    },
    get_permalink: function () {
      var dfd = $.Deferred(),
        constructor = this.constructor;
      if (!constructor.permalink_options) {
        return dfd.resolve(this.viewLink);
      }
      $.when(this.refresh_all.apply(this, constructor.permalink_options.base.split(':'))).then(function (base) {
        return dfd.resolve(_.template(constructor.permalink_options.url)({base: base, instance: this}));
      }.bind(this));
      return dfd.promise();
    },

  /**
    * Set up a deferred join object update when this object is updated.
    */
    mark_for_update: function (join_attr, obj, extra_attrs, options) {
      obj = obj.reify ? obj.reify() : obj;
      extra_attrs = _.isEmpty(extra_attrs) ? undefined : extra_attrs;

      this.remove_duplicate_pending_joins(obj);
      this._pending_joins.push({
        how: 'update',
        what: obj,
        through: join_attr,
        extra: extra_attrs,
        opts: options
      });
    },
  /**
   Set up a deferred join object deletion when this object is updated.
  */
    mark_for_deletion: function (join_attr, obj, extra_attrs, options) {
      obj = obj.reify ? obj.reify() : obj;

      this.remove_duplicate_pending_joins(obj);
      this._pending_joins.push({how: 'remove', what: obj, through: join_attr, opts: options});
    },

  /**
   Set up a deferred join object creation when this object is updated.
  */
    mark_for_addition: function (joinAttr, obj, extraAttrs, options) {
      obj = obj.reify ? obj.reify() : obj;
      extraAttrs = _.isEmpty(extraAttrs) ? undefined : extraAttrs;

      this.remove_duplicate_pending_joins(obj);
      this._pending_joins.push({
        how: 'add',
        what: obj,
        through: joinAttr,
        extra: extraAttrs,
        opts: options
      });
    },

    remove_duplicate_pending_joins: function (obj) {
      var joins;
      var len;
      if (!this._pending_joins) {
        this.attr('_pending_joins', []);
      }
      len = this._pending_joins.length;
      joins = _.filter(this._pending_joins, function (val) {
        return val.what !== obj;
      });

      if (len !== joins.length) {
        this.attr('_pending_joins').replace(joins);
      }
    },

    delay_resolving_save_until: function (dfd) {
      return this.notifier.queue(dfd);
    },
    _save: function () {
      var that = this,
        _super = Array.prototype.pop.call(arguments),
        isNew = this.isNew(),
        xhr,
        dfd = this._dfd,
        pre_save_notifier = new PersistentNotifier({name: this.constructor.model_singular + ' (pre-save)'})
        ;

      this.before_save && this.before_save(pre_save_notifier);
      if (isNew) {
        this.attr('provisional_id', 'provisional_' + Math.floor(Math.random() * 10000000));
        can.getObject('provisional_cache', can.Model.Cacheable, true)[this.provisional_id] = this;
        this.before_create && this.before_create(pre_save_notifier);
      } else {
        this.before_update && this.before_update(pre_save_notifier);
      }

      pre_save_notifier.on_empty(function () {
        xhr = _super.apply(that, arguments)
      .then(function (result) {
        if (isNew) {
          that.after_create && that.after_create();
        } else {
          that.after_update && that.after_update();
        }
        that.after_save && that.after_save();
        return result;
      }, function (xhr, status, message) {
        that.save_error && that.save_error(xhr.responseText);
        return new can.Deferred().reject(xhr, status, message);
      })
      .fail(function (response) {
        that.notifier.on_empty(function () {
          dfd.reject(that, response);
        });
      })
      .done(function () {
        that.notifier.on_empty(function () {
          dfd.resolve(that);
        });
      });

        GGRC.delay_leaving_page_until(xhr);
        GGRC.delay_leaving_page_until(dfd);
      });
      return dfd;
    },
    save: function () {
      Array.prototype.push.call(arguments, this._super);
      this._dfd = new can.Deferred();
      GGRC.SaveQueue.enqueue(this, arguments);
      return this._dfd;
    },
    refresh_all: function () {
      var props = Array.prototype.slice.call(arguments, 0);

      return RefreshQueue.refresh_all(this, props);
    },
    refresh_all_force: function () {
      var props = Array.prototype.slice.call(arguments, 0);

      return RefreshQueue.refresh_all(this, props, true);
    },
    hash_fragment: function () {
      var type = can.spaceCamelCase(this.type || '')
            .toLowerCase()
            .replace(/ /g, '_');

      return [type, this.id].join('/');
    },
    get_custom_value: function (prop) {
      var attr = _.find(GGRC.custom_attr_defs, function (item) {
        return item.definition_type === this.type.toLowerCase() &&
        item.title === prop;
      }.bind(this));
      var result;
      if (!attr) {
        return undefined;
      }
      result = _.find(this.custom_attribute_values, function (item) {
        return item.reify().custom_attribute_id === attr.id;
      });
      if (result) {
        result = result.reify().attribute_value;
        if (attr.attribute_type.toLowerCase() === 'date') {
          result = moment(result, 'MM/DD/YYYY').format('YYYY-MM-DD');
        }
      }
      return result;
    },

  // Returns a deep property as specified in the descriptor built
  // by Cacheable.parse_deep_property_descriptor
    get_deep_property: function (property_descriptor) {
      var i;
      var j;
      var part;
      var field;
      var found;
      var tmp;
      var val = this;
      var rCustom = /^custom\:/i;
      var mapProp;

      function mapDeepProp(count) {
        count += 1;
        return function (element) {
          return element.get_deep_property(property_descriptor.slice(count));
        };
      }
      for (i = 0; i < property_descriptor.length; i++) {
        part = property_descriptor[i];
        if (val.instance) {
          val = val.instance;
        }
        found = false;
        if (part === 'GET_ALL') {
          mapProp = mapDeepProp(i);
          return _.map(val, mapProp);
        }
        for (j = 0; j < part.length; j++) {
          field = part[j];
          tmp = val[field];
          if (tmp !== undefined && tmp !== null) {
            val = tmp;
            if (typeof val.reify === 'function') {
              val = val.reify();
            }
            found = true;
            break;
          } else if (rCustom.test(field)) {
            field = field.split(':')[1];
            val = this.get_custom_value(field);
            found = true;
            break;
          }
        }
        if (!found) {
          return null;
        }
      }
      return val;
    }
  });
  /* TODO: hack on can.Observe should be removed or at least placed outside of Cacheable Model Class */
  _oldAttr = can.Observe.prototype.attr;
  can.Observe.prototype.attr = function (key, val) {
    if (key instanceof can.Observe) {
      if (arguments[0] === this) {
        return this;
      } else {
        return _oldAttr.apply(this, [key.serialize()]);
      }
    } else {
      return _oldAttr.apply(this, arguments);
    }
  };

  can.Observe.prototype.stub = function () {
    var type;
    var id;

    if (!(this instanceof can.Model || this instanceof can.Stub))
      console.debug('.stub() called on non-stub, non-instance object', this);

    if (this instanceof can.Stub) {
      return this;
    }

    if (this instanceof can.Model) {
      type = this.constructor.shortName;
    } else {
      type = this.type;
    }

    if (this.constructor.id) {
      id = this[this.constructor.id];
    } else {
      id = this.id;
    }

    if (!id && id !== 0) {
      return null;
    }

    return can.Stub.get_or_create({
      id: id,
      href: this.selfLink || this.href,
      type: type
    });
  };

  can.Observe('can.Stub', {
    get_or_create: function (obj) {
      var id = obj.id;
      var stub;
      var type = obj.type;

      CMS.Models.stub_cache = CMS.Models.stub_cache || {};
      CMS.Models.stub_cache[type] = CMS.Models.stub_cache[type] || {};
      if (!CMS.Models.stub_cache[type][id]) {
        stub = new can.Stub(obj);
        CMS.Models.stub_cache[type][id] = stub;
      }
      return CMS.Models.stub_cache[type][id];
    }
  }, {
    init: function () {
      var that = this;
      this._super.apply(this, arguments);
      this._instance().bind('destroyed', function (ev) {
        // Trigger propagating `change` event to convey `stub-destroyed` message
        can.trigger(
          that, 'change', ['stub_destroyed', 'stub_destroyed', that, null]);
        delete CMS.Models.stub_cache[that.type][that.id];
      });
    },

    _model: function () {
      return CMS.Models[this.type] || GGRC.Models[this.type];
    },

    _instance: function () {
      if (!this.__instance) {
        this.__instance = this._model().model(this);
      }
      return this.__instance;
    },

    getInstance: function () {
      return this._instance();
    }
  });

  can.Observe.List.prototype.stubs = function () {
    return new can.Observe.List(can.map(this, function (obj) {
      return obj.stub();
    }));
  };

  can.Observe.prototype.reify = function () {
    var type;
    var model;

    if (this instanceof can.Model) {
      return this;
    }
    if (!(this instanceof can.Stub)) {
      console.debug('`reify()` called on non-stub, non-instance object', this);
    }

    type = this.type;
    model = CMS.Models[type] || GGRC.Models[type];

    if (!model) {
      console.debug('`reify()` called with unrecognized type', this);
    } else {
      return model.model(this);
    }
  };

  can.Observe.List.prototype.reify = function () {
    return new can.Observe.List(can.map(this, function (obj) {
      return obj.reify();
    }));
  };
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all

// LocalStorage model, stubs AJAX requests to storage instead of going to the server.  Useful when a REST resource hasn't yet been implemented
// Adapted from an example in the CanJS documentation.  http://canjs.us/recipes.html

(function(can){

  // Base model to handle reading / writing to local storage
  can.Model("can.Model.LocalStorage", {
    makeFindOne : function( findOne ) {

      if(typeof findOne === "function" && this !== can.Model.LocalStorage) {
        return findOne;
      } else {
        return function( params, success, error ) {
          params = params || {};

            var def = new can.Deferred(),
                // Key to be used for local storage
                key = [this._shortName, params.id].join(":"),
                // Grab the current data, if any
                data = window.localStorage.getItem( key );

            // Bind success and error callbacks to the deferred
            def.then(success, error);

            // If we had existing local storage data...
            if ( data ) {

                // Create our model instance
                var instance = this.store[params.id] || this.model( JSON.parse( data ));

                // Resolve the deferred with our instance
                def.resolve( instance );

            // Otherwise hand off the deferred to the ajax request
            } else {
                def.reject({status : 404, responseText : "Object with id " + params.id + " was not found"});
            }
            return def;
        };
      }
    }
    , makeFindAll : function(findAll) {
      if(typeof findAll === "function" && this !== can.Model.LocalStorage) {
        return findAll;
      } else {
        return function(params, success, error) {
          var def = new can.Deferred()
          , key = [this._shortName, "ids"].join(":")
          , data = window.localStorage.getItem( key )
          , returns = new can.Model.List()
          , that = this;
          params = params || {};

          if(data) {
            can.each(JSON.parse(data), function(id) {
              if(params.id == null || params.id === id) {
                var k = [that._shortName, id].join(":")
                , d = window.localStorage.getItem( k );

                if(d) {
                  d = that.store[id] || JSON.parse(d);
                  var pkeys = Object.keys(params);
                  if(pkeys.length < 1 || can.filter(pkeys, function(k) {
                    return params[k] !== d[k];
                  }).length < 1) {
                    returns.push(that.model(d));
                  }
                }
              }
            });
          }

          def.resolve(returns);
          return def;
        };
      }
    }
    , makeCreate : function(create) {
      if(typeof create === "function" && this !== can.Model.LocalStorage) {
        return create;
      } else {
        return function(params) {
          var key = [this._shortName, "ids"].join(":")
            , data = window.localStorage.getItem( key )
            , newkey = 1
            , def = new can.Deferred()
            ;

            //add to list
          if(data) {
            data = JSON.parse(data);
            newkey = Math.max.apply(Math, data.concat([0])) + 1;
            data.push(newkey);
          } else {
            data = [newkey];
          }
          window.localStorage.setItem(key, JSON.stringify(data));

          //create new
          key = [this._shortName, newkey].join(":");
          var item = this.model(can.extend({id : newkey}, params));
          window.localStorage.setItem(key, JSON.stringify(item.serialize()));

          def.resolve(item);
          this.created && this.created(item);
          return def;
        };
      }
    }
    , makeUpdate : function(update) {
      if(typeof update === "function" && this !== can.Model.LocalStorage) {
        return update;
      } else {
        return function(id, params) {
          var key = [this._shortName, id].join(":")
            , data = window.localStorage.getItem( key )
            , def = new can.Deferred()
            ;

          if(data) {
            data = JSON.parse(data);
            params._removedKeys && can.each(params._removedKeys, function(key) {
              if(!params[key]) {
                delete data[key];
              }
            });
            delete params._removedKeys;
            can.extend(data, params);
            var item = this.model({}).attr(data);

            window.localStorage.setItem(key, JSON.stringify(item.serialize()));
            def.resolve(item);
            this.updated && this.updated(item);
          } else {
            def.reject({ status : 404, responseText : "The object with id " + id + " was not found."});
          }
          return def;
        };
      }
    }
    , makeDestroy : function(destroy) {
      if(typeof findAll === "function" && this !== can.Model.LocalStorage) {
        return findAll;
      } else {
        return function(id) {
          var def = new can.Deferred()
          , key = [this._shortName, id].join(":")
          , item = this.model({ id : id });

          if(window.localStorage.getItem(key)) {
            window.localStorage.removeItem(key);

            // remove from list
            key = [this._shortName, "ids"].join(":");
            data = window.localStorage.getItem( key );

            data = JSON.parse(data);
            data.splice(can.inArray(id, data), 1);
            window.localStorage.setItem(key, JSON.stringify(data));

            def.resolve(item);
            this.destroyed && this.destroyed(item);
          } else {
            def.reject({ status : 404, responseText : "Object with id " + id + " was not found"});
          }
          return def;
        };
      }
    }
    , clearAll : function() {
      window.localStorage.clear();
    }
  }, {
    removeAttr : function(attr) {
      this._super(attr);
      this._removedKeys || (this._data._removedKeys = this._removedKeys = []);
      this._removedKeys.push(attr);
      return this;
    }

  });

})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all
//= require models/local_storage

(function(can, $){

var COLLAPSE = "collapse"
, LHN_SIZE = "lhn_size"
, OBJ_SIZE = "obj_size"
, SORTS = "sorts"
, HEIGHTS = "heights"
, COLUMNS = "columns"
, PBC_LISTS = "pbc_lists"
, GLOBAL = "global"
, LHN_STATE = "lhn_state"
, TOP_NAV = "top_nav"
, FILTER_WIDGET = "filter_widget"
, TREE_VIEW_HEADERS = "tree_view_headers"
, TREE_VIEW = "tree_view"
, CHILD_TREE_DISPLAY_LIST = "child_tree_display_list"
, MODAL_STATE = "modal_state"
, path = window.location.pathname.replace(/\./g, "/");

can.Model.LocalStorage("CMS.Models.DisplayPrefs", {
  autoupdate : true
  , version : 20150129 // Last updated to add 2 accessors

  , findAll : function() {
    var that = this;
    var objs_dfd = this._super.apply(this, arguments)
    .then(function(objs) {
      var i;
      for(i = objs.length; i--;) {
        if(!objs[i].version || objs[i].version < that.version) {
          objs[i].destroy();
          objs.splice(i, 1);
        }
      }
      return objs;
    });
    return objs_dfd;
  }

  , findOne : function() {
    var that = this;
    var obj_dfd = this._super.apply(this, arguments)
    .then(function(obj) {
      var dfd, p;
      if(!obj.version || obj.version < that.version) {
        obj.destroy();
        dfd = new $.Deferred();
        p = dfd.promise();
        p.status = 404;
        return dfd.reject(p, "error", "Object expired");
      } else {
        return obj;
      }
    });
    return obj_dfd;
  }

  , create : function(opts) {
    opts.version = this.version;
    return this._super(opts);
  }

  , update : function(id, opts) {
    opts.version = this.version;
    return this._super(id, opts);
  }

  , getSingleton : function () {
    var deferred,
        prefs;
    if (this.cache) {
      return $.when(this.cache);
    }

    this.findAll().then(function (d) {
      if (d.length > 0) {
        prefs = d[0];
      } else {
        prefs = new CMS.Models.DisplayPrefs();
        prefs.save();
      }
    });
    this.cache = prefs;
    return $.when(prefs);
  }
}, {
  init : function() {
    this.autoupdate = this.constructor.autoupdate;
  }

  , makeObject : function() {
    var retval = this;
    var args = can.makeArray(arguments);
    can.each(args, function(arg) {
      var tval = can.getObject(arg, retval);
      if(!tval || !(tval instanceof can.Observe)) {
        tval = new can.Observe(tval);
        retval.attr(arg, tval);
      }
      retval = tval;
    });
    return retval;
  }

  , getObject : function() {
    var args = can.makeArray(arguments);
    args[0] === null && args.splice(0,1);
    return can.getObject(args.join("."), this);
  }

  // collapsed state
  // widgets on a page may be collapsed such that only the title bar is visible.
  // if page_id === null, this is a global value
  , setCollapsed : function(page_id, widget_id, is_collapsed) {
    this.makeObject(page_id === null ? page_id : path, COLLAPSE).attr(widget_id, is_collapsed);

    this.autoupdate && this.save();
    return this;
  }

  , getCollapsed : function(page_id, widget_id) {
    var collapsed = this.getObject(page_id === null ? page_id : path, COLLAPSE);
    if(!collapsed) {
      collapsed = this.makeObject(page_id === null ? page_id : path, COLLAPSE).attr(this.makeObject(COLLAPSE, page_id).serialize());
    }

    return widget_id ? collapsed.attr(widget_id) : collapsed;
  }

  , setTopNavHidden: function (page_id, is_hidden) {
    this.makeObject(page_id === null ? page_id : path, TOP_NAV).attr("is_hidden", !!is_hidden);

    this.autoupdate && this.save();
    return this;
  }

  , getTopNavHidden: function (page_id) {
    var value = this.getObject(page_id === null ? page_id : path, TOP_NAV);

    if (typeof value === "undefined") {
      this.setTopNavHidden("", false);
      return false;
    }

    return !!value.is_hidden;
  }

  , setTopNavWidgets: function (page_id, widget_list) {
    this.makeObject(page_id === null ? page_id : path, TOP_NAV).attr("widget_list", widget_list);

    this.autoupdate && this.save();
    return this;
  }

  , getTopNavWidgets: function (page_id) {
    var value = this.getObject(page_id === null ? page_id : path, TOP_NAV);

    if (typeof value === "undefined") {
      this.setTopNavWidgets(page_id, {});
      return this.getTopNavWidgets(page_id);
    }

    return value.widget_list && value.widget_list.serialize() || {};
  }

  , setFilterHidden: function (is_hidden) {
    this.makeObject(path, FILTER_WIDGET).attr("is_hidden", is_hidden);

    this.autoupdate && this.save();
    return this;
  }

  , getFilterHidden: function () {
    var value = this.getObject(path, FILTER_WIDGET);

    if (typeof value === "undefined") {
      this.setFilterHidden(false);
      return false;
    }

    return value.is_hidden;
  }

  , setTreeViewHeaders : function (model_name, display_list) {
    var hdr = this.getObject(path, TREE_VIEW_HEADERS), obj = {};
    if (!hdr) {
      hdr = this.makeObject(path, TREE_VIEW_HEADERS);
    }

    obj.display_list = display_list;
    hdr.attr(model_name, obj);

    this.autoupdate && this.save();
    return this;
  }

  , getTreeViewHeaders : function (model_name) {
    var value = this.getObject(path, TREE_VIEW_HEADERS);

    if (!value || !value[model_name]) {
      return [];
    }

    return value[model_name].display_list;
  }

  , setModalState : function (model_name, display_state) {
    var path = null, modal_state = this.getObject(path, MODAL_STATE), obj = {};

    if (!modal_state) {
      modal_state = this.makeObject(path, MODAL_STATE);
    }

    obj.display_state = display_state;
    modal_state.attr(model_name, obj);

    this.autoupdate && this.save();
    return this;
  }

  , getModalState : function (model_name) {
    var modal_state = this.getObject(null, MODAL_STATE);

    if (!modal_state || !modal_state[model_name]) {
      return null;
    }

    return modal_state[model_name].display_state;
  }

  , setChildTreeDisplayList : function (model_name, display_list) {
    var hdr = this.getObject(TREE_VIEW, CHILD_TREE_DISPLAY_LIST), obj = {};
    if (!hdr) {
      hdr = this.makeObject(TREE_VIEW, CHILD_TREE_DISPLAY_LIST);
    }

    obj.display_list = display_list;
    hdr.attr(model_name, obj);

    this.autoupdate && this.save();
    return this;
  }

  , getChildTreeDisplayList : function (model_name) {
    var value = this.getObject(TREE_VIEW, CHILD_TREE_DISPLAY_LIST);

    if (!value || !value[model_name]) {
      return null; //in this case user should use default list an empty list, [], is different  than null
    }

    return value[model_name].display_list;
  }

  , setLHNavSize : function(page_id, widget_id, size) {
    this.makeObject(page_id === null ? page_id : path, LHN_SIZE).attr(widget_id, size);
    this.autoupdate && this.save();
    return this;
  }

  , getLHNavSize : function(page_id, widget_id) {
    var size = this.getObject(page_id === null ? page_id : path, LHN_SIZE);
    if(!size) {
      size = this.makeObject(page_id === null ? page_id : path, LHN_SIZE).attr(this.makeObject(LHN_SIZE, page_id).serialize());
    }

    return widget_id ? size.attr(widget_id) : size;
  }
  , setGlobal : function(widget_id, attrs) {
    var global = this.getObject(null, GLOBAL) && this.getObject(null, GLOBAL).attr(widget_id);
    if (!global) {
      global = this.makeObject(null, GLOBAL).attr(widget_id, new can.Observe(attrs));
    }
    else {
      global.attr(attrs);
    }
    this.autoupdate && this.save();
    return this;
  }

  , getGlobal : function(widget_id) {
    return this.getObject(null, GLOBAL) && this.getObject(null, GLOBAL).attr(widget_id);
  }

  // sorts = position of widgets in each column on a page
  // This is also use at page load to determine which widgets need to be
  // generated client-side.
  , getSorts : function(page_id, column_id) {
    var sorts = this.getObject(path, SORTS);
    if(!sorts) {
      sorts = this.makeObject(path, SORTS).attr(this.makeObject(SORTS, page_id).serialize());
      this.autoupdate && this.save();
    }

    return column_id ? sorts.attr(column_id) : sorts;
  }

  , setSorts : function(page_id, widget_id, sorts) {
    if(typeof sorts === "undefined" && typeof widget_id === "object") {
      sorts = widget_id;
      widget_id = undefined;
    }
    var page_sorts = this.makeObject(path, SORTS);

    page_sorts.attr(widget_id ? widget_id : sorts, widget_id ? sorts : undefined);

    this.autoupdate && this.save();
    return this;
  }

  // heights : height of widgets to restore on page start.
  // Is set by jQuery-UI resize functions in ResizeWidgetsController
  , getWidgetHeights : function(page_id) {
    var heights = this.getObject(path, HEIGHTS);
    if(!heights) {
      heights = this.makeObject(path, HEIGHTS).attr(this.makeObject(HEIGHTS, page_id).serialize());
      this.autoupdate && this.save();
    }
    return heights;
  }

  , getWidgetHeight : function(page_id, widget_id) {
    return this.getWidgetHeights(page_id)[widget_id];
  }

  , setWidgetHeight : function(page_id, widget_id, height) {
    var page_heights = this.makeObject(path, HEIGHTS);

    page_heights.attr(widget_id, height);

    this.autoupdate && this.save();
    return this;
  }

  // columns : the relative width of columns on each page.
  //  should add up to 12 since we're using row-fluid from Bootstrap
  , getColumnWidths : function(page_id, content_id) {
    var widths = this.getObject(path, COLUMNS);
    if(!widths) {
      widths = this.makeObject(path, COLUMNS).attr(this.makeObject(COLUMNS, page_id).serialize());
      this.autoupdate && this.save();
    }
    return widths[content_id];
  }

  , getColumnWidthsForSelector : function(page_id, sel) {
    return this.getColumnWidths(page_id, $(sel).attr("id"));
  }

  , setColumnWidths : function(page_id, widget_id, widths) {
    var csp = this.makeObject(path, COLUMNS);
    csp.attr(widget_id, widths);
    this.autoupdate && this.save();
    return this;
  }

  // reset function currently resets all layout for a page type (first element in URL path)
  , resetPagePrefs : function() {
    this.removeAttr(path);
    return this.save();
  }

  , setPageAsDefault : function(page_id) {
    var that = this;
    can.each([COLLAPSE, LHN_SIZE, OBJ_SIZE, SORTS, HEIGHTS, COLUMNS], function(key) {
      that.makeObject(key).attr(page_id, new can.Observe(that.makeObject(path, key).serialize()));
    });
    this.save();
    return this;
  }

  , getPbcListPrefs : function(pbc_id) {
    return this.makeObject(PBC_LISTS, pbc_id);
  }

  , setPbcListPrefs : function(pbc_id, prefs) {
    this.makeObject(PBC_LISTS).attr(pbc_id, prefs instanceof can.Observe ? prefs : new can.Observe(prefs));
    this.autoupdate && this.save();
  }

  , getPbcResponseOpen : function(pbc_id, response_id) {
    return this.makeObject(PBC_LISTS, pbc_id, "responses").attr(response_id);
  }

  , getPbcRequestOpen : function(pbc_id, request_id) {
    return this.makeObject(PBC_LISTS, pbc_id, "requests").attr(request_id);
  }

  , setPbcResponseOpen : function(pbc_id, response_id, is_open) {
    var prefs = this.makeObject(PBC_LISTS, pbc_id, "responses").attr(response_id, is_open);

    this.autoupdate && this.save();
    return this;
  }

  , setPbcRequestOpen : function(pbc_id, request_id, is_open) {
    var prefs = this.makeObject(PBC_LISTS, pbc_id, "requests").attr(request_id, is_open);

    this.autoupdate && this.save();
    return this;
  }

  , getLHNState : function() {
    return this.makeObject(LHN_STATE);
  }

  , setLHNState : function(new_prefs, val) {
    var prefs = this.makeObject(LHN_STATE);
    can.each(
      ["open_category", "panel_scroll", "category_scroll", "search_text", "my_work", "filter_params", "is_open", "is_pinned"]
      , function(token) {
        if(typeof new_prefs[token] !== "undefined") {
          prefs.attr(token, new_prefs[token]);
        } else if(new_prefs === token && typeof val !== "undefined") {
          prefs.attr(token, val);
        }
      }
    );

    this.autoupdate && this.save();
    return this;
  }

});

if(typeof jasmine !== "undefined") {
  CMS.Models.DisplayPrefs.exports = {
    COLLAPSE : COLLAPSE
    , SORTS : SORTS
    , HEIGHTS : HEIGHTS
    , COLUMNS : COLUMNS
    , GLOBAL : GLOBAL
    , PBC_LISTS : PBC_LISTS
    , path : path
  };
}

})(this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
;(function(can) {

can.Model.LocalStorage("CMS.Models.LocalListCache", {
  attributes : {
    objects : "modelize"
  }
  , convert : {
    modelize : function(serial) {
      var ml = this.type ? this.type.List : can.List;
      var insts;
      can.batch.start();
      insts = new ml(can.map(serial, function(s) {
        var inst = CMS.Models.get_instance(s);
        if(!inst.selfLink) {
          inst.attr(s); // Add any other attributes in the serial form, like title
        }
        return inst;
      }));
      can.batch.stop();
      return insts;
    }
  }
  , init : function() {
    var that = this
    , _update = this.update;

    this.update = function(id, params) {
      return that.destroy({ id : id }).then(function() {
        return that.create(params);
      });
    };
  }
}, {
  save : function() {
    var that = this
    , ct = this.constructor;

    return ct.findAll({ name : this.name }).then(function(to_del) {
      return $.when.apply($, can.map(to_del, function(d) {
        return d.destroy();
      }));
    }).then(function() {
      return ct.create(that.serialize());
    });
  }
  , serialize : function() {
    var that = this;
    return {
      id : this.id
      , name : this.name
      , type : this.type
      , search_text : this.search_text
      , my_work : this.my_work
      , extra_params: this.extra_params
      , objects : can.map(this.objects || [], function(d) {
        if(that.type && d.constructor.shortName !== that.type)
          return;

        var obj = {
          id : d.id
          , type : that.type
          , href : d.href || d.selfLink || ("/api/" + that.type + "/" + d.id)
        };
        can.each(that.keys, function(key) {
          obj[key] = (d[key] && d[key].serialize) ? d[key].serialize() : d[key];
        });
        return obj;
      })
      , keys : this.keys.serialize ? this.keys.serialize() : this.keys
    };
  }
});

})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(ns, can) {

can.Model.Cacheable("CMS.Models.Document", {
    root_object : "document"
    , root_collection : "documents"
    , title_singular : "Reference"
    , title_plural : "References"
    , category : "business"
    , findAll : "GET /api/documents"
    , findOne : "GET /api/documents/{id}"
    , create : "POST /api/documents"
    , update : "PUT /api/documents/{id}"
    , destroy : "DELETE /api/documents/{id}"
    , search : function(request, response) {
        return $.ajax({
            type : "get"
            , url : "/api/documents"
            , dataType : "json"
            , data : {s : request.term}
            , success : function(data) {
                response($.map( data, function( item ) {
                  return can.extend({}, item.document, {
                    label: item.document.title
                          ? item.document.title
                          + (item.document.link_url
                            ? " (" + item.document.link_url + ")"
                            : "")
                          : item.document.link_url
                    , value: item.document.id
                  });
                }));
            }
        });
    }
    , attributes : {
        context : "CMS.Models.Context.stub"
      , object_documents : "CMS.Models.ObjectDocument.stubs"
      , owners : "CMS.Models.Person.stubs"
      , kind : "CMS.Models.Option.stub"
      , year : "CMS.Models.Option.stub"
    }
  , tree_view_options: {
    show_view: GGRC.mustache_path + "/documents/tree.mustache"
    , footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache"
    , add_item_view : GGRC.mustache_path + "/documents/tree_add_item.mustache"

  }
  , init : function() {
    this.validateNonBlank("link");
    this._super.apply(this, arguments);
  }

}, {
  display_type: function () {
    if (_.isEmpty(this.object_documents)) {
      return 'URL';
    }
    return 'Evidence';
  }
});

})(this, can);

CMS.Models.Document("CMS.Models.PopulationWorksheet", {}, {});
CMS.Models.PopulationWorksheet.title_singular = "Population Worksheet";

CMS.Models.Document("CMS.Models.SampleWorksheet", {}, {});
CMS.Models.SampleWorksheet.title_singular = "Sample Worksheet";

CMS.Models.Document("CMS.Models.SampleEvidence", {}, {});
CMS.Models.SampleEvidence.title_singular = "Sample Evidence";

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

// require can.jquery-all
// require models/cacheable

(function (ns, can) {
  can.Model.Cacheable('CMS.Models.Person', {
    root_object: 'person',
    root_collection: 'people',
    category: 'entities',
    findAll: 'GET /api/people',
    findOne: 'GET /api/people/{id}',
    create: 'POST /api/people',
    update: 'PUT /api/people/{id}',
    destroy: 'DELETE /api/people/{id}',
    search: function (request, response) {
      return can.ajax({
        type: 'get',
        url: '/api/people',
        dataType: 'json',
        data: {s: request.term},
        success: function (data) {
          response(can.$.map(data, function (item) {
            return can.extend({}, item.person, {
              label: item.person.email,
              value: item.person.id
            });
          }));
        }
      });
    },
    is_custom_attributable: true,
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      language: 'CMS.Models.Option.stub',
      user_roles: 'CMS.Models.UserRole.stubs',
      name: 'trimmed',
      email: 'trimmedLower',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    },
    mixins: ['ca_update'],
    defaults: {
      name: '',
      email: '',
      contact: null,
      owners: null
    },
    convert: {
      trimmed: function (val) {
        return (val && val.trim) ? val.trim() : val;
      },
      trimmedLower: function (val) {
        return ((val && val.trim) ? val.trim() : val).toLowerCase();
      }
    },
    serialize: {
      trimmed: function (val) {
        return (val && val.trim) ? val.trim() : val;
      },
      trimmedLower: function (val) {
        return ((val && val.trim) ? val.trim() : val).toLowerCase();
      }
    },
    findInCacheByEmail: function (email) {
      var result = null;
      var that = this;
      can.each(Object.keys(this.cache || {}), function (k) {
        if (that.cache[k].email === email) {
          result = that.cache[k];
          return false;
        }
      });
      return result;
    },
    tree_view_options: {
      show_view: GGRC.mustache_path + '/people/tree.mustache',
      header_view: GGRC.mustache_path + '/people/tree_header.mustache',
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      add_item_view: GGRC.mustache_path + '/people/tree_add_item.mustache'
    },
    list_view_options: {
      find_params: {__sort: 'name,email'}
    },
    init: function () {
      var rEmail =
        /^[-!#$%&*+\\.\/0-9=?A-Z^_`{|}~]+@([-0-9A-Z]+\.)+([0-9A-Z]){2,4}$/i;
      this._super.apply(this, arguments);

      this.validateNonBlank('email');
      this.validateFormatOf('email', rEmail);
    },
    getUserRoles: function (instance, person) {
      var result = $.Deferred();
      var refreshQueue = new RefreshQueue();
      var userRoles;

      can.each(person.user_roles, function (ur) {
        refreshQueue.enqueue(ur.getInstance());
      });

      refreshQueue.trigger().then(function (roles) {
        userRoles = _.filter(roles, function (role) {
          return instance.context && role.context &&
            role.context.id === instance.context.id;
        });
        result.resolve(userRoles);
      });
      return result.promise();
    },
    getPersonMappings: function (instance, person, specificOject) {
      var result = $.Deferred();
      var mappingObject = instance[specificOject];
      var refreshQueue = new RefreshQueue();

      can.each(mappingObject, function (obj) {
        refreshQueue.enqueue(obj);
      });

      refreshQueue.trigger().then(function (objects) {
        var userRoles;
        var objectPeopleFiltered = _.filter(objects, function (item) {
          return item.person && item.person.id === person.id;
        });

        userRoles = _.filter(person.user_roles, function (item) {
          item = item.getInstance();
          return instance.context && item.context_id === instance.context.id;
        }).map(function (item) {
          return item.reify();
        });

        userRoles = userRoles.concat(objectPeopleFiltered);

        result.resolve(userRoles);
      });
      return result.promise();
    }
  }, {
    display_name: function () {
      return this.email;
    },
    autocomplete_label: function () {
      return this.name ?
      this.name + '<span class="url-link">' + this.email + '</span>' :
        this.email;
    }
  });
})(window, can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//require can.jquery-all

(function(can) {

can.Model.Cacheable("CMS.Models.Context", {
    root_object : "context"
  , root_collection : "contexts"
  , category : "contexts"
  , findAll : "/api/contexts"
  , findOne : "/api/contexts/{id}"
  , create : "POST /api/contexts"
  , update : "PUT /api/contexts/{id}"
  , destroy : "DELETE /api/contexts/{id}"
  , attributes : {
      context : "CMS.Models.Context.stub"
    , related_object: "CMS.Models.get_stub"
    , user_roles: "CMS.Models.UserRole.stubs"
    }
}, {
});

can.Model.Cacheable("CMS.Models.Program", {
  root_object : "program"
  , root_collection : "programs"
  , category : "programs"
  , findAll : "/api/programs"
  , findOne : "/api/programs/{id}"
  , create : "POST /api/programs"
  , update : "PUT /api/programs/{id}"
  , destroy : "DELETE /api/programs/{id}"
  , mixins : ['contactable', 'unique_title', 'ca_update', 'timeboxed']
  , is_custom_attributable: true
  , attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      sections: 'CMS.Models.get_stubs',
      directives: 'CMS.Models.Directive.stubs',
      controls: 'CMS.Models.Control.stubs',
      audits: 'CMS.Models.Audit.stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  }
  , tree_view_options : {
      show_view : GGRC.mustache_path + "/programs/tree.mustache"
    , footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache"
    , attr_list : [
      {attr_title: 'Manager', attr_name: 'owner', attr_sort_field: 'authorizations.0.person.name|email'}
    ].concat(can.Model.Cacheable.attr_list.filter(function (d) {
      return d.attr_name != 'owner';
    })).concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ])
    , add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache"
    }
  , links_to : {
    "System" : {}
    , "Process" : {}
    , "Product" : {}
    , "Facility" : {}
    , "OrgGroup" : {}
    , "Vendor" : {}
    , "Project" : {}
    , "DataAsset" : {}
    , "AccessGroup" : {}
    , "Product" : {}
    , "Market" : {}
  },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    this.validateNonBlank("title");
    this._super.apply(this, arguments);
  }
}, {
});

can.Model.Cacheable("CMS.Models.Option", {
  root_object : "option"
  , findAll : "GET /api/options"
  , findOne : "GET /api/options/{id}"
  , create : "POST /api/options"
  , update : "PUT /api/options/{id}"
  , destroy : "DELETE /api/options/{id}"
  , root_collection : "options"
  , cache_by_role: {}
  , for_role: function(role) {
      var self = this;

      if (!this.cache_by_role[role])
        this.cache_by_role[role] =
          this.findAll({ role: role }).then(function(options) {
            self.cache_by_role[role] = options;
            return options;
          });
      return $.when(this.cache_by_role[role]);
    }
}, {});

can.Model.Cacheable("CMS.Models.Objective", {
  root_object : "objective"
  , root_collection : "objectives"
  , category : "objectives"
  , title_singular : "Objective"
  , title_plural : "Objectives"
  , findAll : "GET /api/objectives"
  , findOne : "GET /api/objectives/{id}"
  , create : "POST /api/objectives"
  , update : "PUT /api/objectives/{id}"
  , destroy : "DELETE /api/objectives/{id}"
  , mixins : ['ownable', 'contactable', 'unique_title', 'ca_update']
  , is_custom_attributable: true
  , attributes : {
      context : "CMS.Models.Context.stub"
    , owners : "CMS.Models.Person.stubs"
    , modified_by : "CMS.Models.Person.stub"
    , sections : "CMS.Models.get_stubs"
    , controls : "CMS.Models.Control.stubs"
    , object_people : "CMS.Models.ObjectPerson.stubs"
    , related_sources : "CMS.Models.Relationship.stubs"
    , related_destinations : "CMS.Models.Relationship.stubs"
    , objective_objects : "CMS.Models.ObjectObjective.stubs"
    , custom_attribute_values : "CMS.Models.CustomAttributeValue.stubs"
  }
  , tree_view_options : {
      show_view : GGRC.mustache_path + "/objectives/tree.mustache"
    , footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache"
    , attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'}
    ])
    , add_item_view : GGRC.mustache_path + "/objectives/tree_add_item.mustache"
    , create_link : true
    //, draw_children : true
    , start_expanded : false
    , child_options : [{
        model : can.Model.Cacheable
      , mapping : "related_objects" //"related_and_able_objects"
      , footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache"
      , add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache"
      , title_plural : "Business Objects"
      , draw_children : false
    }]
  },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    this.validateNonBlank("title");
    this._super.apply(this, arguments);
  }
}, {
});

can.Model.Cacheable("CMS.Models.Help", {
  root_object : "help"
  , root_collection : "helps"
  , findAll : "GET /api/help"
  , findOne : "GET /api/help/{id}"
  , update : "PUT /api/help/{id}"
  , destroy : "DELETE /api/help/{id}"
  , create : "POST /api/help"
}, {});

can.Model.Cacheable("CMS.Models.Event", {
  root_object : "event"
  , root_collection : "events"
  , findAll : "GET /api/events"
  , list_view_options : { find_params: { __include: "revisions" } }
  , attributes : {
      modified_by : "CMS.Models.Person.stub"
    }
}, {});

can.Model.Cacheable('CMS.Models.Role', {
  root_object: 'role',
  root_collection: 'roles',
  findAll: 'GET /api/roles',
  findOne: 'GET /api/roles/{id}',
  update: 'PUT /api/roles/{id}',
  destroy: 'DELETE /api/roles/{id}',
  create: 'POST /api/roles',
  scopes: [
    'Private Program',
    'Workflow',
    'System'
  ],
  defaults: {
    permissions: {
      read: [],
      update: [],
      create: [],
      delete: []
    }
  }
}, {

  allowed : function(operation, object_or_class) {
    var cls = typeof object_or_class === "function" ? object_or_class : object_or_class.constructor;
    return !!~can.inArray(cls.model_singular, this.permissions[operation]);
  }

  , not_system_role : function() {
    return this.attr('scope') !== "System";
  }

  , permission_summary : function() {
    if (this.name == "ProgramOwner") return "Owner";
    if (this.name == "ProgramEditor") return "Can Edit";
    if (this.name == "ProgramReader") return "View Only";
    return this.name;
  }

});

can.Model.Cacheable("CMS.Models.MultitypeSearch", {}, {});

can.Model.Cacheable("CMS.Models.BackgroundTask", {
  root_object : "background_task"
  , root_collection : "background_tasks"
  , findAll : "GET /api/background_tasks"
  , findOne : "GET /api/background_tasks/{id}"
  , update : "PUT /api/background_tasks/{id}"
  , destroy : "DELETE /api/background_tasks/{id}"
  , create : "POST /api/background_tasks"
  , scopes : []
  , defaults : {}
}, {
  poll: function() {
    var dfd = new $.Deferred(),
        self = this,
        wait = 2000,
        interval;

    function _poll(){
      self.refresh().then(function(task) {
        // Poll until we either get a success or a failure:
        if (['Success', 'Failure'].indexOf(task.status) < 0) {
          setTimeout(_poll, wait);
        } else {
          dfd.resolve(task);
        }
      });
    }
    _poll();
    return dfd;
  }
});

CMS.Models.get_instance = function(object_type, object_id, params_or_object) {
  var model, params = {}, instance = null, href;

  if(typeof object_type === "object" || object_type instanceof can.Stub) {
    //assume we only passed in params_or_object
    params_or_object = object_type;
    if (!params_or_object)
      return null;
    if (params_or_object instanceof can.Model)
      object_type = params_or_object.constructor.shortName;
    else if (params_or_object instanceof can.Stub)
      object_type = params_or_object.type;
    else if (!params_or_object.selfLink && params_or_object.type)
      object_type = params_or_object.type;
    else {
      href = params_or_object.selfLink || params_or_object.href;
      object_type = can.map(
          window.cms_singularize(/^\/api\/(\w+)\//.exec(href)[1]).split("_"),
          can.capitalize
        ).join("");
    }
    object_id = params_or_object.id;
  }

  model = CMS.Models[object_type];

  if (!model)
    return null;

  if (!object_id)
    return null;

  if (!!params_or_object) {
    if ($.isFunction(params_or_object.serialize))
      $.extend(params, params_or_object.serialize());
    else
      $.extend(params, params_or_object || {});
  }

  instance = model.findInCacheById(object_id);
  if (!instance) {
    if (params.selfLink) {
      params.id = object_id;
      instance = new model(params);
    } else
      instance = new model({
          id: object_id
        , href: (params_or_object || {}).href
        });
  }
  return instance;
};

CMS.Models.get_stub = function (object) {
  var instance = CMS.Models.get_instance(object);
  if (!instance) {
    return;
  }
  return instance.stub();
};

CMS.Models.get_stubs = function (objects) {
  return new can.Stub.List(can.map(CMS.Models.get_instances(objects), function (o) {
    if (!o || !o.stub) {
      console.warn("`Models.get_stubs` instance has no stubs ", arguments);
      return;
    }
    return o.stub();
  }));
};

CMS.Models.get_instances = function (objects) {
  var i, instances = [];
  if (!objects)
    return [];
  for (i=0; i<objects.length; i++) {
    instances[i] = CMS.Models.get_instance(objects[i]);
  }
  return instances;
};

CMS.Models.get_link_type = function(instance, attr) {
  var type
    , model
    ;

  type = instance[attr + "_type"];
  if (!type) {
    model = instance[attr] && instance[attr].constructor;
    if (model)
      type = model.shortName;
    else if (instance[attr])
      type = instance[attr].type;
  }
  return type;
};

})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can) {

can.Model.Cacheable("CMS.Models.OrgGroup", {
  root_object : "org_group",
  root_collection : "org_groups",
  category : "entities",
  findAll : "GET /api/org_groups",
  findOne : "GET /api/org_groups/{id}",
  create : "POST /api/org_groups",
  update : "PUT /api/org_groups/{id}",
  destroy : "DELETE /api/org_groups/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update',
            'timeboxed'],
  is_custom_attributable: true,
  attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections: 'CMS.Models.get_stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ]),
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "OrgGroup",
        relationship_type_id : "org_group_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }, {
      model : null,
      find_params : {
        "destination_type" : "OrgGroup",
        "source_type" : "OrgGroup",
        relationship_type_id: "org_group_relies_upon_org_group"
      },
      parent_find_param : "destination_id",
      draw_children : true,
      start_expanded : false,
      find_function : "findRelatedSource",
      related_side : "destination",
      single_object : false,
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });
    this.tree_view_options.child_options[1].model = this;

    this.validateNonBlank("title");
  }
}, {});

can.Model.Cacheable("CMS.Models.Project", {
  root_object : "project",
  root_collection : "projects",
  category : "business",
  findAll : "GET /api/projects",
  findOne : "GET /api/projects/{id}",
  create : "POST /api/projects",
  update : "PUT /api/projects/{id}",
  destroy : "DELETE /api/projects/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update', 'timeboxed'],
  is_custom_attributable: true,
  attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections: 'CMS.Models.get_stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ]),
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "Project",
        relationship_type_id : "project_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });

    this.validateNonBlank("title");
  }
}, {});

can.Model.Cacheable("CMS.Models.Facility", {
  root_object : "facility",
  root_collection : "facilities",
  category : "business",
  findAll : "GET /api/facilities",
  findOne : "GET /api/facilities/{id}",
  create : "POST /api/facilities",
  update : "PUT /api/facilities/{id}",
  destroy : "DELETE /api/facilities/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update', 'timeboxed'],
  is_custom_attributable: true,
  attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections: 'CMS.Models.get_stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ]),
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "Facility",
        relationship_type_id : "facility_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }, {
      model : null,
      find_params : {
        "destination_type" : "Facility",
        "source_type" : "Facility",
        relationship_type_id: "facility_relies_upon_facility"
      },
      parent_find_param : "destination_id",
      draw_children : true,
      start_expanded : false,
      find_function : "findRelatedSource",
      related_side : "destination",
      single_object : false,
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });
    this.tree_view_options.child_options[1].model = this;

    this.validateNonBlank("title");
  }
}, {});

can.Model.Cacheable("CMS.Models.Product", {
  root_object : "product",
  root_collection : "products",
  category : "business",
  findAll : "GET /api/products",
  findOne : "GET /api/products/{id}",
  create : "POST /api/products",
  update : "PUT /api/products/{id}",
  destroy : "DELETE /api/products/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update', 'timeboxed'],
  is_custom_attributable: true,
  attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections: 'CMS.Models.get_stubs',
      kind: 'CMS.Models.Option.stub',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  defaults : {
    kind : null
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'Type', attr_name: 'type'},
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'}
    ]),
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "Product",
        relationship_type_id : "product_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }, {
      model : null,
      find_params : {
        "destination_type" : "Product",
        "source_type" : "Product",
        relationship_type_id: "product_relies_upon_product"
      },
      parent_find_param : "destination_id",
      draw_children : true,
      start_expanded : false,
      find_function : "findRelatedSource",
      related_side : "destination",
      single_object : false,
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });
    this.tree_view_options.child_options[1].model = this;

    this.validateNonBlank("title");
  }
}, {
});

can.Model.Cacheable("CMS.Models.DataAsset", {
  root_object : "data_asset",
  root_collection : "data_assets",
  category : "business",
  findAll : "GET /api/data_assets",
  findOne : "GET /api/data_assets/{id}",
  create : "POST /api/data_assets",
  update : "PUT /api/data_assets/{id}",
  destroy : "DELETE /api/data_assets/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update', 'timeboxed'],
  is_custom_attributable: true,
  attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections:'CMS.Models.get_stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ]),
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "DataAsset",
        relationship_type_id : "data_asset_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }, {
      model : null,
      find_params : {
        "destination_type" : "DataAsset",
        "source_type" : "DataAsset",
        relationship_type_id: "data_asset_relies_upon_data_asset"
      },
      parent_find_param : "destination_id",
      draw_children : true,
      start_expanded : false,
      find_function : "findRelatedSource",
      related_side : "destination",
      single_object : false,
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });
    this.tree_view_options.child_options[1].model = this;

    this.validateNonBlank("title");
  }
}, {});

can.Model.Cacheable("CMS.Models.AccessGroup", {
  root_object : "access_group",
  root_collection : "access_groups",
  category : "entities",
  findAll : "GET /api/access_groups",
  findOne : "GET /api/access_groups/{id}",
  create : "POST /api/access_groups",
  update : "PUT /api/access_groups/{id}",
  destroy : "DELETE /api/access_groups/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update'],
  is_custom_attributable: true,
  attributes : {
    context : "CMS.Models.Context.stub",
    owners : "CMS.Models.Person.stubs",
    modified_by : "CMS.Models.Person.stub",
    object_people : "CMS.Models.ObjectPerson.stubs",
    people : "CMS.Models.Person.stubs",
    related_sources : "CMS.Models.Relationship.stubs",
    related_destinations : "CMS.Models.Relationship.stubs",
    objectives : "CMS.Models.Objective.stubs",
    controls : "CMS.Models.Control.stubs",
    sections : "CMS.Models.get_stubs",
    custom_attribute_values : "CMS.Models.CustomAttributeValue.stubs"
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ]),
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "AccessGroup",
        relationship_type_id : "access_group_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }, {
      model : null,
      find_params : {
        "destination_type" : "AccessGroup",
        "source_type" : "AccessGroup",
        relationship_type_id: "access_group_relies_upon_access_group"
      },
      parent_find_param : "destination_id",
      draw_children : true,
      start_expanded : false,
      find_function : "findRelatedSource",
      related_side : "destination",
      single_object : false,
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
    'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });
    this.tree_view_options.child_options[1].model = this;

    this.validateNonBlank("title");
  }
}, {});

  can.Model.Cacheable("CMS.Models.Market", {
    root_object: 'market',
    root_collection: 'markets',
    category: 'business',
    findAll: 'GET /api/markets',
    findOne: 'GET /api/markets/{id}',
    create: 'POST /api/markets',
    update: 'PUT /api/markets/{id}',
    destroy: 'DELETE /api/markets/{id}',
    mixins: ['ownable', 'contactable', 'unique_title', 'ca_update',
             'timeboxed'],
    is_custom_attributable: true,
    attributes: {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections: 'CMS.Models.get_stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    },
    tree_view_options: {
      show_view: GGRC.mustache_path + '/base_objects/tree.mustache',
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      attr_list: can.Model.Cacheable.attr_list.concat([
        {attr_title: 'URL', attr_name: 'url'},
        {attr_title: 'Reference URL', attr_name: 'reference_url'},
        {attr_title: 'Effective Date', attr_name: 'start_date'},
        {attr_title: 'Stop Date', attr_name: 'end_date'}
      ]),
      add_item_view: GGRC.mustache_path + '/base_objects/tree_add_item.mustache',
      child_options: [{
        model: null,
        find_params: {
          destination_type: 'Process',
          source_type: 'Market',
          relationship_type_id: 'market_has_process'
        },
        parent_find_param: 'source_id',
        draw_children: true,
        find_function: 'findRelated',
        related_side: 'source',
        create_link: true
      }]
    },
    links_to: {
      System: {},
      Process: {},
      Program: {},
      Product: {},
      Facility: {},
      OrgGroup: {},
      Vendor: {},
      Project: {},
      DataAsset: {},
      AccessGroup: {},
      Market: {}
    },
    defaults: {
      status: 'Draft'
    },
    statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
    init: function () {
      var that = this;
      if (this._super) {
        this._super.apply(this, arguments);
      }
      $(function () {
        that.tree_view_options.child_options[0].model = CMS.Models.Process;
      });

      this.validateNonBlank('title');
    }
  }, {});

can.Model.Cacheable("CMS.Models.Vendor", {
  root_object : "vendor",
  root_collection : "vendors",
  category : "entities",
  findAll : "GET /api/vendors",
  findOne : "GET /api/vendors/{id}",
  create : "POST /api/vendors",
  update : "PUT /api/vendors/{id}",
  destroy : "DELETE /api/vendors/{id}",
  mixins : ['ownable', 'contactable', 'unique_title', 'ca_update', 'timeboxed'],
  is_custom_attributable: true,
  attributes : {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      controls: 'CMS.Models.Control.stubs',
      sections: 'CMS.Models.get_stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options : {
    show_view : GGRC.mustache_path + "/base_objects/tree.mustache",
    footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache",
    attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ]),
    add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
    child_options : [{
      model : null,
      find_params : {
        "destination_type" : "Process",
        "source_type" : "Vendor",
        relationship_type_id : "vendor_has_process"
      },
      parent_find_param : "source_id",
      draw_children : true,
      find_function : "findRelated",
      related_side : "source",
      create_link : true
    }, {
      model : null,
      find_params : {
        "destination_type" : "Vendor",
        "source_type" : "Vendor",
        relationship_type_id: "vendor_relies_upon_vendor"
      },
      parent_find_param : "destination_id",
      draw_children : true,
      start_expanded : false,
      find_function : "findRelatedSource",
      related_side : "destination",
      single_object : false,
      create_link : true
    }]},
  links_to : {
    "System" : {},
    "Process" : {},
    "Program" : {},
    "Product" : {},
    "Facility" : {},
    "OrgGroup" : {},
    "Vendor" : {},
    "Project" : {},
    "DataAsset" : {},
    "AccessGroup" : {},
    "Market" : {}
    },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    var that = this;
    this._super && this._super.apply(this, arguments);
    $(function(){
      that.tree_view_options.child_options[0].model = CMS.Models.Process;
    });
    this.tree_view_options.child_options[1].model = this;

    this.validateNonBlank("title");
  }
}, {});

})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can) {

can.Model.Cacheable("CMS.Models.Directive", {
  root_object : "directive"
  , root_collection : "directives"
  , category : "governance"
  // `rootModel` overrides `model.shortName` when determining polymorphic types
  , root_model : "Directive"
  , findAll : "/api/directives"
  , findOne : "/api/directives/{id}"
  , mixins : ["ownable", "contactable", "unique_title", 'timeboxed']
  , tree_view_options : {
      list_view : GGRC.mustache_path + "/directives/tree.mustache"
    , footer_view : GGRC.mustache_path + "/base_objects/tree_footer.mustache"
    , attr_list : can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'}
    ])
    , add_item_view : GGRC.mustache_path + "/directives/tree_add_item.mustache"
    }

  , model : function(params) {
      if (this.shortName !== 'Directive')
        return this._super(params);
      if (!params)
        return params;
      params = this.object_from_resource(params);
      if (!params.selfLink) {
        if (params.type !== 'Directive')
          return CMS.Models[params.type].model(params);
      } else {
        if (CMS.Models.Contract.meta_kinds.indexOf(params.kind) > -1)
          return CMS.Models.Contract.model(params);
        else if (CMS.Models.Regulation.meta_kinds.indexOf(params.kind) > -1)
          return CMS.Models.Regulation.model(params);
        else if (CMS.Models.Policy.meta_kinds.indexOf(params.kind) > -1)
          return CMS.Models.Policy.model(params);
        else if (CMS.Models.Standard.meta_kinds.indexOf(params.kind) > -1)
          return CMS.Models.Standard.model(params);
      }
      console.debug("Invalid Directive:", params);
    },
    attributes : {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      programs: 'CMS.Models.Program.stubs',
      sections: 'CMS.Models.get_stubs',
      controls: 'CMS.Models.Control.stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    }
  , defaults : {
  }
  , init : function() {
    this.validateNonBlank("title");
    //this.validateInclusionOf("kind", this.meta_kinds);
    this._super.apply(this, arguments);
  }
  , meta_kinds : []
}, {
  init : function() {
    this._super && this._super.apply(this, arguments);
    var that = this;
  }
  , lowercase_kind : function() { return this.kind ? this.kind.toLowerCase() : undefined; }
});

CMS.Models.Directive("CMS.Models.Standard", {
  root_object : "standard"
  , root_collection : "standards"
  , model_plural : "Standards"
  , table_plural : "standards"
  , title_plural : "Standards"
  , model_singular : "Standard"
  , title_singular : "Standard"
  , table_singular : "standard"
  , findAll : "GET /api/standards"
  , findOne : "GET /api/standards/{id}"
  , create : "POST /api/standards"
  , update : "PUT /api/standards/{id}"
  , destroy : "DELETE /api/standards/{id}"
  , is_custom_attributable: true
  , attributes : {}
  , meta_kinds : [ "Standard" ]
  , cache : can.getObject("cache", CMS.Models.Directive, true),
  mixins: ['ca_update'],
  defaults: {
    status: 'Draft',
    kind: 'Standard'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    can.extend(this.attributes, CMS.Models.Directive.attributes);
    this._super.apply(this, arguments);
  }
}, {});

CMS.Models.Directive("CMS.Models.Regulation", {
  root_object : "regulation"
  , root_collection : "regulations"
  , model_plural : "Regulations"
  , table_plural : "regulations"
  , title_plural : "Regulations"
  , model_singular : "Regulation"
  , title_singular : "Regulation"
  , table_singular : "regulation"
  , findAll : "GET /api/regulations"
  , findOne : "GET /api/regulations/{id}"
  , create : "POST /api/regulations"
  , update : "PUT /api/regulations/{id}"
  , destroy : "DELETE /api/regulations/{id}"
  , is_custom_attributable: true
  , attributes : {}
  , meta_kinds : [ "Regulation" ]
  , cache : can.getObject("cache", CMS.Models.Directive, true),
  mixins: ['ca_update'],
  defaults: {
    status: 'Draft',
    kind: 'Regulation'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    can.extend(this.attributes, CMS.Models.Directive.attributes);
    this._super.apply(this, arguments);
  }
}, {});

CMS.Models.Directive("CMS.Models.Policy", {
  root_object : "policy"
  , root_collection : "policies"
  , model_plural : "Policies"
  , table_plural : "policies"
  , title_plural : "Policies"
  , model_singular : "Policy"
  , title_singular : "Policy"
  , table_singular : "policy"
  , findAll : "GET /api/policies"
  , findOne : "GET /api/policies/{id}"
  , create : "POST /api/policies"
  , update : "PUT /api/policies/{id}"
  , destroy : "DELETE /api/policies/{id}"
  , tree_view_options : {}
  , is_custom_attributable: true
  , attributes : {}
  , meta_kinds : [  "Company Policy", "Org Group Policy", "Data Asset Policy", "Product Policy", "Contract-Related Policy", "Company Controls Policy" ]
  , cache : can.getObject("cache", CMS.Models.Directive, true),
  mixins: ['ca_update'],
  defaults: {
    status: 'Draft',
    kind: null
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    can.extend(this.attributes, CMS.Models.Directive.attributes);
    can.extend(this.tree_view_options, CMS.Models.Directive.tree_view_options);
    this.tree_view_options.attr_list = can.Model.Cacheable.attr_list.concat([
      {attr_title: 'Type', attr_name: 'kind', attr_sort_field: 'kind.title'},
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'},
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'}
    ]);
    this._super.apply(this, arguments);
  }
}, {});

CMS.Models.Directive("CMS.Models.Contract", {
  root_object : "contract"
  , root_collection : "contracts"
  , model_plural : "Contracts"
  , table_plural : "contracts"
  , title_plural : "Contracts"
  , model_singular : "Contract"
  , title_singular : "Contract"
  , table_singular : "contract"
  , findAll : "GET /api/contracts"
  , findOne : "GET /api/contracts/{id}"
  , create : "POST /api/contracts"
  , update : "PUT /api/contracts/{id}"
  , destroy : "DELETE /api/contracts/{id}"
  , is_custom_attributable: true
  , attributes : {
  }
  , meta_kinds : [ "Contract" ]
  , cache : can.getObject("cache", CMS.Models.Directive, true),
  mixins: ['ca_update'],
  defaults: {
    status: 'Draft',
    kind: 'Contract'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    can.extend(this.attributes, CMS.Models.Directive.attributes);
    this._super.apply(this, arguments);
  }
}, {});

})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

can.Model.LocalStorage("GGRC.Models.RecentlyViewedObject", {

  newInstance : function(attrs) {
    if(attrs instanceof can.Model) {
      var title = (attrs.title && attrs.title.trim()) || (attrs.name && attrs.name.trim()) || (attrs.email && attrs.email.trim());
      return new this({
        type : attrs.constructor.shortName
        , model : attrs.constructor
        , viewLink : attrs.viewLink
        , title : title
      });
    } else {
      return this._super(attrs);
    }
  }

}, {

  init : function() {
    this.attr("model", GGRC.Models[this.type] || CMS.Models[this.type]);
  }

  , stub : function() {
    return can.extend(this._super(), { title : this.title, viewLink : this.viewLink });
  }
});

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

can.Model("GGRC.Models.Search", {

  findOne : "GET /search"
  , search : function(str, params) {
    return this.findOne($.extend({q : str}, params));
  }
  , search_for_types : function(str, types, params) {
    if ((!str || str.trim().length == 0) && (!params || params.length == 0))
      // Empty search, so actually hit normal endpoints instead of search
      // This returns a search instance which will search across all given types.
      return this.load_via_model_endpoints(types);
    else
      // This returns a Search instance, NOT a model instance.
      return this.findOne($.extend({q : str, types : types.join(",") }, params));
  }
  , counts : function(str, params) {
    return this.findOne($.extend({q : str, counts_only : true}, params));
  }
  , counts_for_types : function(str, types, params, extra_columns) {
    return this.findOne(
      $.extend({q: str,
        types: types.join(","),
        counts_only: true,
        extra_columns: extra_columns && extra_columns.join(',')
      }, params));
  }
  , load_via_model_endpoints: function(types) {
    var dfds;

    dfds = can.map(types, function(model_name) {
      // FIXME: This should use __stubs_only=true when paging is used
      return CMS.Models[model_name].findAll({ __stubs_only: true, __sort: 'title,email' });
    });

    return $.when.apply($, dfds).then(function() {
      var model_results = can.makeArray(arguments)
        , search_response = { entries: {}, selfLink: "Fake" }
        ;
      // Mock the search resource format
      can.each(types, function(model_name, index) {
        search_response.entries[model_name] = model_results[index];
      });

      return new GGRC.Models.Search(search_response);
    });
    }

  , init : function() {
    this._super && this._super.apply(this, arguments);
    var _findOne = this.findOne;
    this.findOne = function() {
      return _findOne.apply(this, arguments).then(function(data) {
        if (data.results.entries)
          data.attr("entries", data.results.entries);
        if (data.results.counts)
          data.attr("counts", data.results.counts);
        data.removeAttr("results");
        return data;
      });
    };
  }
}, {

  getResultsFor : function(type) {
    var _class = type.shortName
      ? type
      : (can.getObject("CMS.Models." + type) || can.getObject("GGRC.Models." + type));

    type = _class.shortName;
    return can.map(
      this.entries
      , function(v) {
        var inst;
        if(v.type === type) {
          inst = new _class({id : v.id});
          return inst;
        }
    });
  }

  , getResultsForType : function(model_name) {
      var model = CMS.Models[model_name]
        , entries;

      if (!(this.entries instanceof Array || this.entries instanceof can.Observe.List))
        entries = this.entries[model_name] || [];
      else
        entries = can.map(this.entries, function(v) {
          if (v.type == model_name)
            return v;
        });

      return can.map(entries, function(stub) {
        return CMS.Models.get_instance(model.shortName, stub.id);
      });
  }

  , getCountFor : function(type) {
      if (type && type.shortName)
        type = type.shortName;

      if (!this.counts[type])
        return 0;
      else
        return this.counts[type];
  }
});

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, CMS) {
  function update_program_authorizations(programs, person) {
    return can.when(
      programs[0],
      programs[0].get_binding('program_authorized_people').refresh_instances(),
      programs[0].get_binding('program_authorizations').refresh_instances(),
      CMS.Models.Role.findAll({
        name: 'ProgramReader'
      }),
      CMS.Models.Role.findAll({
        name: 'ProgramEditor'
      })
    ).then(function (program, peopleBindings, authBindings,
                     reader_roles, editor_roles) {
      // ignore readers.  Give users an editor role
      var readerAuthorizations = [];
      var deleteDfds;
      var editorAuthorizedPeople = can.map(authBindings, function (ab) {
        if (~can.inArray(ab.instance.role.reify(), reader_roles)) {
          readerAuthorizations.push(ab.instance);
        } else {
          return ab.instance.person.reify();
        }
      });

      if (Permission.is_allowed('create', 'UserRole', program.context.id) &&
        !~can.inArray(person.reify(), editorAuthorizedPeople)) {
        deleteDfds = can.map(readerAuthorizations, function (ra) {
          if (ra.person.reify() === person.reify()) {
            return ra.refresh().then(function () {
              return ra.destroy();
            });
          }
        });
        return $.when.apply($, deleteDfds).then(function () {
          return new CMS.Models.UserRole({
            person: person,
            role: editor_roles[0].stub(),
            context: program.context
          }).save();
        });
      }
    }).then(Permission.refresh());
  }

  can.Model.Cacheable('CMS.Models.Audit', {
    root_object: 'audit',
    root_collection: 'audits',
    category: 'programs',
    findAll: 'GET /api/audits',
    findOne: 'GET /api/audits/{id}',
    update: 'PUT /api/audits/{id}',
    destroy: 'DELETE /api/audits/{id}',
    create: 'POST /api/audits',
    mixins: ['contactable', 'unique_title', 'ca_update', 'timeboxed'],
    is_custom_attributable: true,
    is_clonable: true,
    attributes: {
      context: 'CMS.Models.Context.stub',
      program: 'CMS.Models.Program.stub',
      requests: 'CMS.Models.Request.stubs',
      modified_by: 'CMS.Models.Person.stub',
      report_start_date: 'date',
      report_end_date: 'date',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      audit_firm: 'CMS.Models.OrgGroup.stub',
      audit_objects: 'CMS.Models.AuditObject.stubs',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    },
    defaults: {
      status: 'Planned'
    },
    allowedMappings: [
      // Direct mapping to Audit
      {modelName: 'Assessment', mappingType: 'relation'},
      {modelName: 'AssessmentTemplate', mappingType: 'relation'},
      {modelName: 'Issue', mappingType: 'relation'},
      {modelName: 'Request', mappingType: 'relation'},
      // Mapping through Parent Object
      {modelName: 'AccessGroup', mappingType: 'snapshot'},
      {modelName: 'Clause', mappingType: 'snapshot'},
      {modelName: 'Contract', mappingType: 'snapshot'},
      {modelName: 'Control', mappingType: 'snapshot'},
      {modelName: 'DataAsset', mappingType: 'snapshot'},
      {modelName: 'Facility', mappingType: 'snapshot'},
      {modelName: 'Market', mappingType: 'snapshot'},
      {modelName: 'Objective', mappingType: 'snapshot'},
      {modelName: 'OrgGroup', mappingType: 'snapshot'},
      {modelName: 'Policy', mappingType: 'snapshot'},
      {modelName: 'Process', mappingType: 'snapshot'},
      {modelName: 'Product', mappingType: 'snapshot'},
      {modelName: 'Regulation', mappingType: 'snapshot'},
      {modelName: 'Section', mappingType: 'snapshot'},
      {modelName: 'Standard', mappingType: 'snapshot'},
      {modelName: 'System', mappingType: 'snapshot'},
      {modelName: 'Vendor', mappingType: 'snapshot'}
    ],
    getAllowedMappings: function () {
      return this.allowedMappings;
    },
    statuses: ['Planned', 'In Progress', 'Manager Review',
      'Ready for External Review', 'Completed'],
    obj_nav_options: {
      show_all_tabs: false,
      force_show_list: ['In Scope Controls', 'Assessment Templates',
        'Issues', 'Assessments']
    },
    tree_view_options: {
      header_view: GGRC.mustache_path + '/audits/tree_header.mustache',
      attr_list: [{
        attr_title: 'Title',
        attr_name: 'title'
      }, {
        attr_title: 'Audit Lead',
        attr_name: 'audit_lead',
        attr_sort_field: 'contact.name|email'
      }, {
        attr_title: 'Code',
        attr_name: 'slug'
      }, {
        attr_title: 'Status',
        attr_name: 'status'
      }, {
        attr_title: 'Last Updated',
        attr_name: 'updated_at'
      }, {
        attr_title: 'Start Date',
        attr_name: 'start_date'
      }, {
        attr_title: 'End Date',
        attr_name: 'end_date'
      }, {
        attr_title: 'Report Period',
        attr_name: 'report_period',
        attr_sort_field: 'report_end_date'
      }, {
        attr_title: 'Audit Firm',
        attr_name: 'audit_firm'
      }],
      draw_children: true,
      child_options: [{
        model: 'Request',
        mapping: 'requests',
        allow_creating: true,
        parent_find_param: 'audit.id'
      }, {
        model: 'Request',
        mapping: 'related_owned_requests',
        allow_creating: true,
        parent_find_param: 'audit.id'
      }]
    },
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validatePresenceOf('program');
      this.validateNonBlank('title');
      this.validateContact(['_transient.contact', 'contact'], {
        message: 'Internal audit lead cannot be empty'
      });
      this.validate(['_transient.audit_firm', 'audit_firm'],
        function () {
          var auditFirm = this.attr('audit_firm');
          var transientAuditFirm = this.attr('_transient.audit_firm');

          if (!auditFirm && transientAuditFirm) {
            if (_.isObject(transientAuditFirm) &&
              (auditFirm.reify().title !== transientAuditFirm.reify().title) ||
              (transientAuditFirm !== '' && transientAuditFirm !== null &&
              auditFirm !== null &&
              transientAuditFirm !== auditFirm.reify().title)) {
              return 'No valid org group selected for firm';
            }
          }
        }
      );
    }
  }, {
    object_model: can.compute(function () {
      return CMS.Models[this.attr('object_type')];
    }),
    clone: function (options) {
      var model = CMS.Models.Audit;
      return new model({
        operation: 'clone',
        cloneOptions: options.cloneOptions,
        program: this.program,
        title: this.title + new Date()
      });
    },
    save: function () {
      // Make sure the context is always set to the parent program
      var _super = this._super;
      var args = arguments;
      if (!this.context || !this.context.id) {
        return this.program.reify().refresh().then(function (program) {
          this.attr('context', program.context);
          return _super.apply(this, args);
        }.bind(this));
      }
      return _super.apply(this, args);
    },
    after_save: function () {
      var dfd;

      dfd = $.when(
        new RefreshQueue().enqueue(this.program.reify()).trigger(),
        this.contact
      ).then(update_program_authorizations);
      GGRC.delay_leaving_page_until(dfd);
    },
    findAuditors: function (returnList) {
      // If returnList is true, use findAuditors in the
      //  classical way, where the exact state of the list
      //  isn't needed immediately (as in a Mustache helper);
      //  if false, return a deferred that resolves to the list
      //  when the list is fully ready, for cases like permission
      //  checks for other modules.
      var loader = this.get_binding('authorizations');
      var auditorsList = new can.List();
      var dfds = [];

      if (returnList) {
        $.map(loader.list, function (binding) {
          // FIXME: This works for now, but is sad.
          var role;
          if (!binding.instance.selfLink) {
            return;
          }
          role = binding.instance.role.reify();

          function checkRole() {
            if (role.attr('name') === 'Auditor') {
              auditorsList.push({
                person: binding.instance.person.reify(),
                binding: binding.instance
              });
            }
          }

          if (role.selfLink) {
            checkRole();
          } else {
            role.refresh().then(checkRole);
          }
        });
        return auditorsList;
      }
      return loader.refresh_instances().then(function () {
        $.map(loader.list, function (binding) {
          // FIXME: This works for now, but is sad.
          dfds.push(new $.Deferred(function (dfd) {
            if (!binding.instance.selfLink) {
              binding.instance.refresh().then(function () {
                dfd.resolve(binding.instance);
              });
            } else {
              dfd.resolve(binding.instance);
            }
          }).then(function (instance) {
            var role = instance.role.reify();

            function checkRole() {
              if (role.attr('name') === 'Auditor') {
                auditorsList.push({
                  person: instance.person.reify(),
                  binding: instance
                });
              }
            }

            if (role.selfLink) {
              checkRole();
            } else {
              return role.refresh().then(checkRole);
            }
          }));
        });
        return $.when.apply($, dfds).then(function () {
          return auditorsList;
        });
      });
    }
  });

  can.Model.Mixin('requestorable', {
    before_create: function () {
      if (!this.requestor) {
        this.attr('requestor', {
          id: GGRC.current_user.id,
          type: 'Person'
        });
      }
    },
    form_preload: function (new_object_form) {
      if (new_object_form) {
        if (!this.requestor) {
          this.attr('requestor', {
            id: GGRC.current_user.id,
            type: 'Person'
          });
        }
      }
    }
  });

  can.Model.Cacheable('CMS.Models.Request', {
    root_object: 'request',
    root_collection: 'requests',
    findAll: 'GET /api/requests',
    findOne: 'GET /api/requests/{id}',
    create: 'POST /api/requests',
    update: 'PUT /api/requests/{id}',
    destroy: 'DELETE /api/requests/{id}',
    mixins: ['unique_title', 'relatable', 'ca_update', 'autoStatusChangeable',
      'timeboxed'],
    relatable_options: {
      relevantTypes: {
        Audit: {
          objectBinding: 'audits',
          relatableBinding: 'program_requests',
          weight: 5
        },
        Regulation: {
          objectBinding: 'related_regulations',
          relatableBinding: 'related_requests',
          weight: 3
        },
        Control: {
          objectBinding: 'related_controls',
          relatableBinding: 'related_requests',
          weight: 10
        }
      },
      threshold: 5
    },
    is_custom_attributable: true,
    attributes: {
      context: 'CMS.Models.Context.stub',
      assignee: 'CMS.Models.Person.stub',
      finished_date: 'date',
      verified_date: 'date',
      documents: 'CMS.Models.Document.stubs',
      audit: 'CMS.Models.Audit.stub',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    },
    defaults: {
      status: 'Not Started',
      start_date: moment().toDate(),
      end_date: GGRC.Utils.firstWorkingDay(moment().add(1, 'weeks'))
    },
    info_pane_options: {
      mapped_objects: {
        model: can.Model.Cacheable,
        mapping: 'info_related_objects',
        show_view: GGRC.mustache_path + '/base_templates/subtree.mustache'
      },
      evidence: {
        model: CMS.Models.Document,
        mapping: 'all_documents',
        show_view: GGRC.mustache_path + '/base_templates/attachment.mustache',
        sort_function: GGRC.Utils.sortingHelpers.commentSort
      },
      comments: {
        model: can.Model.Cacheable,
        mapping: 'comments',
        show_view: GGRC.mustache_path +
        '/base_templates/comment_subtree.mustache',
        sort_function: GGRC.Utils.sortingHelpers.commentSort
      },
      urls: {
        model: CMS.Models.Document,
        mapping: 'all_urls',
        show_view: GGRC.mustache_path + '/base_templates/urls.mustache'
      }
    },
    tree_view_options: {
      show_view: GGRC.mustache_path + '/requests/tree.mustache',
      header_view: GGRC.mustache_path + '/requests/tree_header.mustache',
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      add_item_view: GGRC.mustache_path + '/requests/tree_add_item.mustache',
      attr_list: [{
        attr_title: 'Title',
        attr_name: 'title'
      }, {
        attr_title: 'Status',
        attr_name: 'status'
      }, {
        attr_title: 'Verified',
        attr_name: 'verified',
        attr_sort_field: 'verified'
      }, {
        attr_title: 'Last Updated',
        attr_name: 'updated_at'
      }, {
        attr_title: 'Starts On',
        attr_name: 'start_date',
        attr_sort_field: 'start_date'
      }, {
        attr_title: 'Due On',
        attr_name: 'end_date',
        attr_sort_field: 'end_date'
      }, {
        attr_title: 'Verified Date',
        attr_name: 'verified_date',
        attr_sort_field: 'verified_date'
      }, {
        attr_title: 'Finished Date',
        attr_name: 'finished_date',
        attr_sort_field: 'finished_date'
      }, {
        attr_title: 'Request Type',
        attr_name: 'request_type'
      }, {
        attr_title: 'Code',
        attr_name: 'slug'
      }, {
        attr_title: 'Audit',
        attr_name: 'audit'
      }],
      display_attr_names: ['title', 'assignee', 'end_date',
        'status', 'request_type'],
      mandatory_attr_names: ['title'],
      draw_children: true,
      child_options: [{
        model: can.Model.Cacheable,
        mapping: 'info_related_objects',
        allow_creating: true
      }]
    },
    assignable_list: [{
      title: 'Requester(s)',
      type: 'requester',
      mapping: 'related_requesters',
      required: true
    }, {
      title: 'Assignee(s)',
      type: 'assignee',
      mapping: 'related_assignees',
      required: true
    }, {
      title: 'Verifier(s)',
      type: 'verifier',
      mapping: 'related_verifiers',
      required: false
    }],
    init: function () {
      this._super.apply(this, arguments);
      this.validateNonBlank('title');
      this.validateNonBlank('end_date');
      this.validateNonBlank('start_date');
      this.validatePresenceOf('audit');

      this.validate(['start_date', 'end_date'], function () {
        var datesAreValid;

        if (this.start_date && this.end_date) {
          datesAreValid = this.end_date >= this.start_date;
        }

        if (!datesAreValid) {
          return 'Start and/or Due date is invalid';
        }
      });

      this.validate(
        'validate_assignee',
        function () {
          if (!this.validate_assignee) {
            return 'You need to specify at least one assignee';
          }
        }
      );
      this.validate(
        'validate_requester',
        function () {
          if (!this.validate_requester) {
            return 'You need to specify at least one requester';
          }
        }
      );

      if (this === CMS.Models.Request) {
        this.bind('created', function (ev, instance) {
          if (instance.constructor === CMS.Models.Request) {
            instance.audit.reify().refresh();
          }
        });
      }
    }
  }, {
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
    },
    form_preload: function (new_object_form, object_params) {
      var audit;
      var auditId;
      var that = this;
      var assignees = {};
      var current_user = CMS.Models.get_instance('Person',
        GGRC.current_user.id);
      var contact;

      if (new_object_form) {
        // Current user should be Requester
        assignees[current_user.email] = 'Requester';

        // auditId = the audit info from the request creation button ||
        //           the audit from the current page if we are on audit page
        if (_.exists(object_params, 'audit.id')) {
          auditId = object_params.audit.id;
        } else if (_.exists(GGRC, 'page_model.type') === 'Audit') {
          auditId = GGRC.page_model.id;
        }

        if (auditId) {
          this.attr('audit', {
            id: auditId,
            type: 'Audit'
          });
        }

        if (this.audit) {
          audit = this.audit.reify();

          // Audit leads should be default assignees
          (audit.selfLink ? $.when(audit) : audit.refresh())
            .then(function (audit) {
              contact = audit.contact.reify();

              if (assignees[contact.email]) {
                assignees[contact.email] += ',Assignee';
              } else {
                assignees[contact.email] = 'Assignee';
              }
            });

          // Audit auditors should be default verifiers
          $.when(audit.findAuditors()).then(function (auditors) {
            auditors.each(function (elem) {
              elem.each(function (obj) {
                if (obj.type === 'Person') {
                  if (assignees[obj.email]) {
                    assignees[obj.email] += ',Verifier';
                  } else {
                    assignees[obj.email] = 'Verifier';
                  }
                }
              });
            });
          });
        }

        // Assign assignee roles
        can.each(assignees, function (value, key) {
          var person = CMS.Models.Person.findInCacheByEmail(key);
          that.mark_for_addition('related_objects_as_destination', person, {
            attrs: {
              AssigneeType: value
            }
          });
        });
      } // /new_object_form
    },
    save: function () {
      // Make sure the context is always set to the parent audit
      if (!this.context || !this.context.id) {
        this.attr('context', this.audit.reify().context);
      }
      return this._super.apply(this, arguments);
    },
    after_save: function () {
      // Create a relationship between request & assessment
      // if the request is created from the assessment view page
      var dfd;
      if (!(this.attr('assessment') && this.attr('assessment').stub)) {
        return;
      }
      dfd = new CMS.Models.Relationship({
        source: this.attr('assessment').stub(),
        destination: this.stub(),
        context: this.context.stub()
      }).save();
      GGRC.delay_leaving_page_until(dfd);
    },
    _refresh: function (bindings) {
      var refresh_queue = new RefreshQueue();
      can.each(bindings, function (binding) {
        refresh_queue.enqueue(binding.instance);
      });
      return refresh_queue.trigger();
    }
  });

  can.Model.Cacheable('CMS.Models.Meeting', {
    root_collection: 'meetings',
    root_object: 'meeting',
    findAll: 'GET /api/meetings',
    create: 'POST /api/meetings',
    update: 'PUT /api/meetings/{id}',
    destroy: 'DELETE /api/meetings/{id}',
    attributes: {
      context: 'CMS.Models.Context.stub',
      people: 'CMS.Models.Person.stubs',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      start_at: 'datetime',
      end_at: 'datetime'
    },
    defaults: {},
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validateNonBlank('title');
      this.validateNonBlank('start_at');
      this.validateNonBlank('end_at');
    }
  }, {
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.each(function (value, name) {
        if (value === null) {
          this.removeAttr(name);
        }
      }.bind(this));
      this.bind('change', function () {
        if (typeof this.response !== 'undefined' && !this._preloaded_people) {
          this._preloaded_people = true;
          _.map(this.response.reify().people, function (person) {
            this.mark_for_addition('people', person);
          }.bind(this));
        }
      }.bind(this));
    }
  });

  /**
   * A model describing a template for the newly created Assessment objects.
   *
   * This is useful when creating multiple similar Assessment objects. Using an
   * AssessmentTemplate helps avoiding repeatedly defining the same set of
   * Assessment object properties for each new instance.
   */
  can.Model.Cacheable('CMS.Models.AssessmentTemplate', {
    root_object: 'assessment_template',
    root_collection: 'assessment_templates',
    model_singular: 'AssessmentTemplate',
    model_plural: 'AssessmentTemplates',
    title_singular: 'Assessment Template',
    title_plural: 'Assessment Templates',
    table_singular: 'assessment_template',
    table_plural: 'assessment_templates',

    findOne: 'GET /api/assessment_templates/{id}',
    findAll: 'GET /api/assessment_templates',
    update: 'PUT /api/assessment_templates/{id}',
    destroy: 'DELETE /api/assessment_templates/{id}',
    create: 'POST /api/assessment_templates',

    is_custom_attributable: false,

    attributes: {
      audit: 'CMS.Models.Audit.stub',
      context: 'CMS.Models.Context.stub'
    },

    defaults: {
      test_plan_procedure: false,
      template_object_type: 'Control',
      default_people: {
        assessors: 'Object Owners',
        verifiers: 'Object Owners'
      },
      // the custom lists of assessor / verifier IDs if "other" is selected for
      // the corresponding default_people setting
      assessorsList: {},
      verifiersList: {},
      people_values: [
        {value: 'Object Owners', title: 'Object Owners'},
        {value: 'Audit Lead', title: 'Audit Lead'},
        {value: 'Auditors', title: 'Auditors'},
        {value: 'Primary Assessor', title: 'Principal Assignee'},
        {value: 'Secondary Assessors', title: 'Secondary Assignee'},
        {value: 'Primary Contact', title: 'Primary Contact'},
        {value: 'Secondary Contact', title: 'Secondary Contact'},
        {value: 'other', title: 'Others...'}
      ]
    },

    /**
     * Initialize the newly created object instance. Validate that its title is
     * non-blank and its default assessors / verifiers lists are set if
     * applicable.
     */
    init: function () {
      this._super.apply(this, arguments);
      this.validateNonBlank('title');

      this.validateListNonBlank(
        'assessorsList',
        function () {
          return this.attr('default_people.assessors') === 'other';
        }
      );
      this.validateListNonBlank(
        'verifiersList',
        function () {
          return this.attr('default_people.verifiers') === 'other';
        }
      );
    }
  }, {
    // the object types that are not relevant to the AssessmentTemplate,
    // i.e. it does not really make sense to assess them
    _NON_RELEVANT_OBJ_TYPES: Object.freeze({
      AssessmentTemplate: true,
      Assessment: true,
      Audit: true,
      CycleTaskGroupObjectTask: true,
      Request: true,
      TaskGroup: true,
      TaskGroupTask: true,
      Workflow: true
    }),

    /**
     * An event handler when the add/edit form is about to be displayed.
     *
     * It builds a list of all object types used to populate the corresponding
     * dropdown menu on the form.
     * It also deserializes the default people settings so that those form
     * fields are correctly populated.
     *
     * @param {Boolean} isNewObject - true if creating a new instance, false if
     *   editing and existing one
     *
     */
    form_preload: function (isNewObject) {
      if (!this.custom_attribute_definitions) {
        this.attr('custom_attribute_definitions', new can.List());
      }
      if (!this.attr('_objectTypes')) {
        this.attr('_objectTypes', this._choosableObjectTypes());
      }
      this._unpackPeopleData();

      this._updateDropdownEnabled('assessors');
      this._updateDropdownEnabled('verifiers');
    },

    /**
     * Save the model instance by sending a POST/PUT request to the server
     *
     * @return {can.Deferred} - a deferred object resolved or rejected
     *   depending on the outcome of the undrelying API request
     */
    save: function () {
      this.attr('default_people', this._packPeopleData());

      return this._super.apply(this, arguments);
    },

    before_save: function () {
      this.attr('_objectTypes', undefined);
    },

    after_save: function () {
      if (this.audit) {
        this.audit.reify().refresh('related_assessment_templates');
      }
    },

    /**
     * Event handler when an assessor is picked in an autocomplete form field.
     * It adds the picked assessor's ID to the assessors list.
     *
     * @param {can.Map} context - the Mustache context of the `$el`
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the event that was triggered
     */
    assessorAdded: function (context, $el, ev) {
      var user = ev.selectedItem;
      this.assessorsList.attr(user.id, true);
    },

    /**
     * Event handler when a user clicks to remove an assessor from the
     * assessors list. It removes the corresponding assessor ID from the list.
     *
     * @param {can.Map} context - the Mustache context of the `$el`
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the event that was triggered
     */
    assessorRemoved: function (context, $el, ev) {
      var user = ev.person;
      this.assessorsList.removeAttr(String(user.id));
    },

    /**
     * Event handler when a verifier is picked in an autocomplete form field.
     * It adds the picked verifier's ID to the verifiers list.
     *
     * @param {can.Map} context - the Mustache context of the `$el`
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the event that was triggered
     */
    verifierAdded: function (context, $el, ev) {
      var user = ev.selectedItem;
      this.verifiersList.attr(user.id, true);
    },

    /**
     * Event handler when a user clicks to remove a verifier from the verifiers
     * list. It removes the corresponding verifier ID from the list.
     *
     * @param {can.Map} context - the Mustache context of the `$el`
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the event that was triggered
     */
    verifierRemoved: function (context, $el, ev) {
      var user = ev.person;
      this.verifiersList.removeAttr(String(user.id));
    },

    /**
     * Event handler when a user changes the default assessors option.
     *
     * @param {can.Map} context - the Mustache context of the `$el`
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the event that was triggered
     */
    defaultAssesorsChanged: function (context, $el, ev) {
      this._updateDropdownEnabled('assessors');
    },

    /**
     * Event handler when a user changes the default verifiers option.
     *
     * @param {can.Map} context - the Mustache context of the `$el`
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the event that was triggered
     */
    defaultVerifiersChanged: function (context, $el, ev) {
      this._updateDropdownEnabled('verifiers');
    },

    /**
     * Update the autocomplete field's disabled flag based on the current value
     * of the corresponding dropdown.
     *
     * @param {String} name - the value to inspect, must be either "assessors"
     *   or "verifiers"
     */
    _updateDropdownEnabled: function (name) {
      var disable = this.attr('default_people.' + name) !== 'other';
      this.attr(name + 'ListDisable', disable);
    },

    /**
     * Pack the "default people" form data into a JSON string.
     *
     * @return {String} - the JSON-packed default people data
     */
    _packPeopleData: function () {
      var data = {};

      /**
       * Create a sorted (ascending) list of numbers from the given map's keys.
       *
       * @param {can.Map} peopleIds - the map to convert
       * @return {Array} - ordered IDs
       */
      function makeList(peopleIds) {
        var result = Object.keys(peopleIds.attr()).map(Number);
        return result.sort(function (x, y) {
          return x - y;
        });
      }

      data.assessors = this.attr('default_people.assessors');
      data.verifiers = this.attr('default_people.verifiers');

      if (data.assessors === 'other') {
        data.assessors = makeList(this.attr('assessorsList'));
      }

      if (data.verifiers === 'other') {
        data.verifiers = makeList(this.attr('verifiersList'));
      }

      return data;
    },

    /**
     * Inspect the default people settings object, convert any lists of
     * user IDs to comma-separated strings, and use that to populate the
     * corresponding text input fields.
     */
    _unpackPeopleData: function () {
      var instance = this;  // the AssessmentTemplate model instance
      var peopleData = instance.default_people;

      ['assessors', 'verifiers'].forEach(function (name) {
        var idsMap;
        var peopleIds = peopleData[name];

        if (peopleIds instanceof can.List) {
          idsMap = new can.Map();
          peopleIds.forEach(function (id) {
            idsMap.attr(id, true);
          });
          instance.attr(name + 'List', idsMap);
          instance.attr('default_people.' + name, 'other');
        } else {
          instance.attr(name + 'List', {});
        }
      });
    },

    /**
     * Return the object types that can be assessed.
     *
     * Used to populate the "Objects under assessment" dropdown on the modal
     * AssessmentTemplate's modal form.
     *
     * @return {Object} - the "assessable" object types
     */
    _choosableObjectTypes: function () {
      var ignoreTypes = this._NON_RELEVANT_OBJ_TYPES;
      var mapper;
      var MapperModel = GGRC.Models.MapperModel;
      var objectTypes;

      mapper = new MapperModel({
        object: 'MultitypeSearch',
        search_only: true
      });
      objectTypes = mapper.initTypes();

      // the all objects group is not needed
      delete objectTypes.all_objects;

      // remove ignored types and sort the rest
      _.each(objectTypes, function (objGroup) {
        objGroup.items = _.filter(objGroup.items, function (item) {
          return !ignoreTypes[item.value];
        });
        objGroup.items = _.sortBy(objGroup.items, 'name');
      });

      // remove the groups that have ended up being empty
      objectTypes = _.pick(objectTypes, function (objGroup) {
        return objGroup.items.length > 0;
      });

      return objectTypes;
    },
    ignore_ca_errors: true
  });
})(window.can, window.CMS);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC, CMS) {
  'use strict';
  /**
   * A model describing a comment to Assessment or Request objects.
   */
  can.Model.Cacheable('CMS.Models.Comment', {
    root_object: 'comment',
    root_collection: 'comments',
    findOne: 'GET /api/comments/{id}',
    findAll: 'GET /api/comments',
    update: 'PUT /api/comments/{id}',
    destroy: 'DELETE /api/comments/{id}',
    create: 'POST /api/comments',
    mixins: [],
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub'
    },
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validatePresenceOf('description');
    },
    info_pane_options: {
      documents: {
        model: CMS.Models.Document,
        mapping: 'documents_and_urls',
        show_view: GGRC.mustache_path + '/base_templates/attachment.mustache',
        sort_function: GGRC.Utils.sortingHelpers.commentSort
      },
      urls: {
        model: CMS.Models.Document,
        mapping: 'urls',
        show_view: GGRC.mustache_path + '/base_templates/urls.mustache'
      }
    }
  }, {
    form_preload: function () {
      var pageInstance = GGRC.page_instance();
      this.attr('comment', pageInstance);
    },
    /**
     * Update the description of an instance. Mainly used as an event handler for
     * updating Requests' and Audits' comments.
     *
     * @param {can.Map} instance - the (Comment) instance to update
     * @param {jQuery.Element} $el - the source of the event `ev`
     * @param {jQuery.Event} ev - the onUpdate event object
     */
    updateDescription: function (instance, $el, ev) {
      var $body = $(document.body);

      // for some reason the instance must be refreshed before saving to avoid
      // the HTTP "precondition required" error
      this.refresh()
        .then(function () {
          this.attr('description', ev.newVal);
          return this.save();
        }.bind(this))
        .done(function () {
          $body.trigger('ajax:flash', {
            success: 'Saved.'
          });
        })
        .fail(function () {
          $body.trigger('ajax:flash', {
            error: 'There was a problem with saving.'
          });
          this.attr('description', ev.oldVal);
        }.bind(this));
    },

    /**
     * Return the "name" of the comment as represented to end users.
     *
     * If the "value" of the comment (i.e. its description) does not exist,
     * an empty string is returned.
     *
     * @return {String} - an end user-friendly "name" of the comment
     */
    display_name: function () {
      return this.description || '';
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function (can) {
  can.Model.Cacheable('CMS.Models.Issue', {
    root_object: 'issue',
    root_collection: 'issues',
    findOne: 'GET /api/issues/{id}',
    findAll: 'GET /api/issues',
    update: 'PUT /api/issues/{id}',
    destroy: 'DELETE /api/issues/{id}',
    create: 'POST /api/issues',
    mixins: ['ownable', 'contactable', 'ca_update', 'timeboxed'],
    is_custom_attributable: true,
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    },
    tree_view_options: {
      attr_list: can.Model.Cacheable.attr_list.concat([
        {attr_title: 'URL', attr_name: 'url'},
        {attr_title: 'Reference URL', attr_name: 'reference_url'}
      ])
    },
    defaults: {
      status: 'Draft'
    },
    statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validateNonBlank('title');
    }
  }, {
    object_model: can.compute(function () {
      return CMS.Models[this.attr('object_type')];
    })
  });
})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all
//= require models/cacheable

(function(can) {

  can.Model.Cacheable("CMS.Models.NotificationConfig", {
    root_object: "notification_config",
    root_collection: "notification_configs",
    category: "person",
    findAll: "GET /api/notification_configs",
    findOne: "GET /api/notification_configs/{id}",
    create: "POST /api/notification_configs",
    update: "PUT /api/notification_configs/{id}",
    destroy: "DELETE /api/notification_configs/{id}",
    active: "POST /api/set_active_notifications",

    findActive: function(){
      if(GGRC.current_user === null || GGRC.current_user === undefined){
        return $.when([]);
      }
      return this.findAll({person_id: GGRC.current_user.id});
    },
    setActive: function(active){
      var existing_types, all_types, valid_types;

      if(!GGRC.current_user){
        console.warn('User object is not set.');
        return $.when();
      }

      valid_types = $.map($('input[name=notifications]'), function(input){
        return input.value;
      });

      return this.findActive().then(function(configs){

        existing_types = $.map(configs, function(config){
          return config.notif_type;
        });
        all_types = $.map(valid_types, function(type){
          var index = existing_types.indexOf(type);
          if(index == -1){
            // Create a new notificationConfig if it doesn't exist yet
            return new CMS.Models.NotificationConfig({
              person_id: GGRC.current_user.id,
              notif_type: type,
              enable_flag: null,
              context: {id: null}
            });
          }
          return configs[index];
        });
        return $.when.apply($, $.map(all_types, function(config){
          var enabled = active.indexOf(config.notif_type) != -1;
          if(config.attr('enable_flag') === enabled){
            // There was no change to this config object
            return;
          }
          if(!config.id){
            // This is a new object so no need for refresh()
            config.attr('enable_flag', enabled);
            return config.save();
          }
          return config.refresh().then(function(refreshed_config){
            refreshed_config.attr('enable_flag', enabled);
            return refreshed_config.save();
          });
        }));
      });
    }
  }, {});

})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all
//= require models/cacheable

can.Model.Cacheable("CMS.Models.CategoryBase", {
    root_object : "category_base"
  , root_collection : "category_bases"
  , root_model : "CategoryBase"
  , findAll : "GET /api/category_bases"
  , findOne : "GET /api/category_bases/{id}"
  , cache_by_scope: {}
  , for_scope: function(scope) {
      var self = this;

      if (!this.cache_by_scope[scope])
        this.cache_by_scope[scope] =
          this.findAll({ scope_id: scope }).then(function(categories) {
            self.cache_by_scope[scope] = categories;
            return categories;
          });
      return $.when(this.cache_by_scope[scope]);
    }
  , attributes : {
      children : "CMS.Models.Category.stubs"
    //, controls : "CMS.Models.Control.stubs"
    , owners : "CMS.Models.Person.stubs"
  }
  , tree_view_options : {
    show_view : "/static/mustache/controls/categories_tree.mustache"
    , start_expanded : false
    , child_options : [{
      model : null
      , property : "children"
    }, {
      model : CMS.Models.Control
      , property : "controls"
      , show_view : "/static/mustache/controls/tree_with_section_mappings.mustache"
    }]

  }
}, {
});

CMS.Models.CategoryBase("CMS.Models.ControlCategory", {
    root_object : "control_category"
  , root_collection : "control_categories"
  , findAll : "GET /api/control_categories"
  , findOne : "GET /api/control_categories/{id}"
}, {
});

CMS.Models.CategoryBase("CMS.Models.ControlAssertion", {
    root_object : "control_assertion"
  , root_collection : "control_assertions"
  , findAll : "GET /api/control_assertions"
  , findOne : "GET /api/control_assertions/{id}"
}, {
});

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $) {
  /*  RefreshQueue
   *
   *  enqueue(obj, force=false) -> queue or null
   *  trigger() -> Deferred
   */

  can.Construct('ModelRefreshQueue', {}, {
    init: function (model) {
      this.model = model;
      this.ids = [];
      this.deferred = new $.Deferred();
      this.triggered = false;
      this.completed = false;
      this.updated_at = Date.now();
    },
    enqueue: function (id) {
      if (this.triggered) {
        return null;
      }
      if (this.ids.indexOf(id) === -1) {
        this.ids.push(id);
        this.updated_at = Date.now();
      }
      return this;
    },
    trigger: function () {
      var self = this;
      if (!this.triggered) {
        this.triggered = true;
        if (this.ids.length && this.model) {
          this.model.findAll({id__in: this.ids.join(',')}).then(function () {
            self.completed = true;
            self.deferred.resolve();
          }, function () {
            self.deferred.reject.apply(self.deferred, arguments);
          });
        } else {
          this.completed = true;
          this.deferred.resolve();
        }
      }
      return this.deferred;
    },
    trigger_with_debounce: function (delay, manager) {
      var msToWait = (delay || 0) + this.updated_at - Date.now();

      if (!this.triggered) {
        if (msToWait < 0 &&
          (!manager || manager.triggered_queues().length < 6)) {
          this.trigger();
        } else {
          setTimeout(
            this.proxy('trigger_with_debounce', delay, manager), msToWait);
        }
      }

      return this.deferred;
    }
  });

  can.Construct('RefreshQueueManager', {
    model_bases: {
      // This won't work until Relatable/Documentable/etc mixins can handle
      // queries with multiple `type` values.
      //  Regulation: 'Directive'
      // , Contract: 'Directive'
      // , Policy: 'Directive'
      // , Standard: 'Directive'
      // , System: 'SystemOrProcess'
      // , Process: 'SystemOrProcess'
    }
  }, {
    init: function () {
      this.null_queue = new ModelRefreshQueue(null);
      this.queues = [];
    },
    triggered_queues: function () {
      return can.map(this.queues, function (queue) {
        if (queue.triggered)
          return queue;
      });
    },
    enqueue: function (obj, force) {
      var self = this;
      var model = obj.constructor;
      var modelName = model.shortName;
      var foundQueue = null;
      var id = obj.id;

      if (!obj.selfLink) {
        if (obj instanceof can.Model) {
          modelName = obj.constructor.shortName;
        } else if (obj.type) {
          // FIXME: obj.kind is to catch invalid stubs coming from Directives
          modelName = obj.type || obj.kind;
        }
      }
      model = CMS.Models[modelName];

      if (this.constructor.model_bases[modelName]) {
        modelName = this.constructor.model_bases[modelName];
        model = CMS.Models[modelName];
      }

      if (!force)
      // Check if the ID is already contained in another queue
        can.each(this.queues, function (queue) {
          if (!foundQueue &&
            queue.model === model && queue.ids.indexOf(id) > -1)
            foundQueue = queue;
        });

      if (!foundQueue) {
        can.each(this.queues, function (queue) {
          if (!foundQueue &&
            queue.model === model &&
            !queue.triggered && queue.ids.length < 150) {
            foundQueue = queue.enqueue(id);
            return false;
          }
        });
        if (!foundQueue) {
          foundQueue = new ModelRefreshQueue(model);
          this.queues.push(foundQueue);
          foundQueue.enqueue(id);
          foundQueue.deferred.done(function () {
            var index = self.queues.indexOf(foundQueue);
            if (index > -1)
              self.queues.splice(index, 1);
          });
        }
      }

      return foundQueue;
    }
  });

  can.Construct('RefreshQueue', {
    refresh_queue_manager: new RefreshQueueManager(),
    refresh_all: function (instance, props, force) {
      var dfd = new can.Deferred();

      refreshAll(instance, props, dfd);
      return dfd;

      // Helper function called recursively for each property
      function refreshAll(instance, props, dfd) {
        var prop = props[0];
        var nextProps = props.slice(1);
        var next = instance[prop];
        var refreshQueue = new RefreshQueue();
        var dfds = [];
        var deferred;
        var hasBinding;

        if (next) {
          refreshQueue.enqueue(next, force);
          deferred = refreshQueue.trigger();
        } else if (instance.get_binding) {
          next = instance.get_binding(prop);
          hasBinding = instance.has_binding(prop);

          if (!hasBinding) {
            dfd.reject({
              message: prop + ' binding not found'
            });
          }
          if (hasBinding && next) {
            deferred = next.refresh_instances(force);
          }
        }
        if (deferred) {
          deferred.then(function (refreshedItems) {
            if (nextProps.length) {
              can.each(refreshedItems, function (item) {
                var df = new can.Deferred();
                refreshAll(item, nextProps, df);
                dfds.push(df);
              });
              // Resolve the original deferred only when all list deferreds
              //   have been resolved
              $.when.apply($, dfds).then(function (items) {
                dfd.resolve(items);
              }, function () {
                dfd.reject.apply(this, arguments);
              });
              return;
            }
            // All items were refreshed, resolve the deferred
            if (next.push || next.list) {
              // Last refreshed property was a list
              dfd.resolve(refreshedItems);
            }
            // Last refreshed property was a single instance, return it as such
            dfd.resolve(refreshedItems[0]);
          }, function () {
            dfd.reject.apply(this, arguments);
          });
        } else {
          console.warn('refresh_all failed at', prop);
        }
      }
    }
  }, {
    init: function () {
      this.objects = [];
      this.queues = [];
      this.deferred = new $.Deferred();
      this.triggered = false;
      this.completed = false;

      return this;
    },
    enqueue: function (obj, force) {
      var queue;
      if (!obj) {
        return;
      }
      if (this.triggered) {
        return null;
      }
      if (obj.push) {
        can.each(obj, function (o) {
          this.enqueue(o, force);
        }, this);
        return this;
      }

      this.objects.push(obj);
      if (force || !obj.selfLink) {
        queue = this.constructor.refresh_queue_manager.enqueue(obj, force);
        if (this.queues.indexOf(queue) === -1)
          this.queues.push(queue);
      }
      return this;
    },
    trigger: function (delay) {
      var self = this;
      var deferreds = [];

      if (!delay) {
        delay = 150;
      }

      this.triggered = true;
      can.each(this.queues, function (queue) {
        deferreds.push(
          queue.trigger_with_debounce(delay,
            self.constructor.refresh_queue_manager));
      });

      if (deferreds.length) {
        $.when.apply($, deferreds).then(function () {
          self.deferred.resolve(can.map(self.objects, function (obj) {
            return obj.reify();
          }));
        }, function () {
          self.deferred.reject.apply(self.deferred, arguments);
        });
      } else {
        return this.deferred.resolve(this.objects);
      }

      return this.deferred;
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  /**
   * A model holding data and metadata describing a particular revision of
   * some business object at a particular point, i.e. the business object's
   * state.
   *
   * This is useful for e.g. reconstruction of an object's change history.
   */
  can.Model.Cacheable('CMS.Models.Revision', {
    root_object: 'revision',
    root_collection: 'revisions',

    // NOTE: only read API methods, because Revisions should not be modified
    // by the client directly
    findAll: '/api/revisions',
    findOne: '/api/revisions/{id}',

    mixins: [],
    attributes: {}
  },
  {});
})(this.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  /*  GGRC.SaveQueue
   *
   *  SaveQueue is used by CMS.Models.Cacheable to prevent firing
   *  multiple requests to the server at once. It makes sure the requests
   *  are grouped together (inside _queue) and then resolved in batches.
   *
   *  It will also try to group POST request and use the custom collection post
   *  API and then redistribute responses in order to trace in latency for
   *  throughput. This is done by a "thread" (of timeouts) per object type (per
   *  bucket) that enqueues as a regular request but then greedily dispatches
   *  requests that arrived while it was in the queue.
   *
   *  enqueue(obj: CMS.Models.Cacheable, save_args) -> null
   */
  can.Construct('GGRC.SaveQueue', {

    DELAY: 100, // Number of ms to wait before the first batch is fired
    BATCH: GGRC.config.MAX_INSTANCES || 3, // Maximum number of POST/PUT requests at any given time
    BATCH_SIZE: 1000,
    _queue: [],
    _buckets: {},
    _timeout: null,

    _enqueue_bucket: function (bucket) {
      var that = this;
      return function () {
        var size = bucket.background ? bucket.objs.length : that.BATCH_SIZE;
        var objs = bucket.objs.splice(0, size);
        var body = _.map(objs, function (obj) {
          var list = {};
          list[bucket.type] = obj.serialize();
          return list;
        });
        var dfd = $.ajax({
          type: 'POST',
          url: '/api/' + bucket.plural,
          data: body,
          beforeSend: function (xhr) {
            if (bucket.background) {
              xhr.setRequestHeader('X-GGRC-BackgroundTask', 'true');
            }
          }
        }).promise();
        dfd.always(function (data, type) {
          if (type === 'error') {
            can.each(objs, function (obj) {
              obj._dfd.reject(data);
            });
          }
          if ('background_task' in data) {
            return CMS.Models.BackgroundTask.findOne({
              id: data.background_task.id
            }).then(function (task) {
              // Resolve all the dfds with the task
              can.each(objs, function (obj) {
                obj._dfd.resolve(task);
              });
            });
          }

          // Push the response to a queue for later processing.
          bucket.save_responses.push([objs, data]);
        }).always(function () {
          if (bucket.objs.length) {
            that._step(that._enqueue_bucket(bucket));
          } else {
            // Process all of the batches of save responses.
            that._process_save_responses(bucket);
            bucket.in_flight = false;
          }
        });

        return dfd;
      };
    },

    _process_save_responses: function (bucket) {
      can.each(bucket.save_responses, function (resp) {
        var objs = resp[0];
        var data = resp[1];
        var cb = function (single) {
          return function () {
            this.created(single[1][bucket.type]);
            return $.when(
              can.Model.Cacheable.resolve_deferred_bindings(this));
          };
        };
        can.each(objs, function (obj, idx) {
          var single = data[idx];
          // Add extra check to avoid possible exceptions
          single = Array.isArray(single) ? single : false;
          if (single && single[0] >= 200 && single[0] < 300) {
            obj._save(cb(single));
          } else {
            obj._dfd.reject(obj, single);
          }
        });
      });

      bucket.save_responses.length = 0;
    },

    _step: function (elem) {
      this._queue.push(elem);
      if (_.isNumber(this._timeout)) {
        clearTimeout(this._timeout);
      }
      this._timeout = setTimeout(function () {
        new GGRC.SaveQueue(this._queue.splice(0, this._queue.length));
      }.bind(this), this.DELAY);
    },

    enqueue: function (obj, args) {
      var type;
      var bucket;
      var bucketName;
      var plural;
      var elem = function () {
        return obj._save.apply(obj, args);
      };
      if (obj.isNew()) {
        type = obj.constructor.table_singular;
        bucketName = type + (obj.run_in_background ? '_bg' : '');
        bucket = this._buckets[bucketName];

        if (_.isUndefined(bucket)) {
          plural = obj.constructor.table_plural;
          bucket = {
            objs: [],
            type: type,
            plural: plural,
            background: obj.run_in_background,
            // List of batch request responses that are yet to be processed.
            save_responses: [],
            in_flight: false // is there a "thread" running for this bucket
          };
          this._buckets[bucketName] = bucket;
        }
        bucket.objs.push(obj);
        if (bucket.in_flight) {
          return;
        }
        elem = this._enqueue_bucket(bucket);
        bucket.in_flight = true;
      }
      this._step(elem);
    }
  }, {
    init: function (queue) {
      this._queue = queue;
      this._resolve();
    },
    _resolve: function () {
      var objs;
      if (!this._queue.length) {
        // Finished
        return;
      }
      objs = this._queue.splice(0, this.constructor.BATCH);
      $.when.apply($, objs.map(function (fn) {
        return fn.apply(this);
      }.bind(this.constructor))).always(this._resolve.bind(this)); // Move on to the next one
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, GGRC, CMS) {
  /* function sortCustomAttributables
   *
   * Groups custom attributes by category.
   *
   */
  function sortCustomAttributables(a, b) {
    if (a.category < b.category) {
      return 1;
    } else if (a.category > b.category) {
      return -1;
    }
    return 0;
  }

  /* class CustomAttributable
   *
   * CustomAttributable does not query the backend, it is used to display a
   * list of objects in the custom attributes widget. It inherits from
   * cacheable because it needs getBinding to properly display
   * CustomAttributeDefinitions as children
   *
   */
  can.Model.Cacheable('CMS.Models.CustomAttributable', {
    findAll: function () {
      var types;
      types = GGRC.custom_attributable_types.sort(sortCustomAttributables);
      return can.when(can.map(types, function (type, i) {
        return new CMS.Models.CustomAttributable(can.extend(type, {
          id: i
        }));
      }));
    }
  }, {
    // Cacheable checks if selfLink is set when the findAll deferred is done
    selfLink: '/custom_attribute_list'
  });

  can.Model.Cacheable('CMS.Models.CustomAttributeDefinition', {
    // static properties
    root_object: 'custom_attribute_definition',
    root_collection: 'custom_attribute_definitions',
    category: 'custom_attribute_definitions',
    findAll: 'GET /api/custom_attribute_definitions',
    findOne: 'GET /api/custom_attribute_definitions/{id}',
    create: 'POST /api/custom_attribute_definitions',
    update: 'PUT /api/custom_attribute_definitions/{id}',
    destroy: 'DELETE /api/custom_attribute_definitions/{id}',
    mixins: [],
    attributes: {
      values: 'CMS.Models.CustomAttributeValue.stubs',
      modified_by: 'CMS.Models.Person.stub'
    },
    links_to: {},
    defaults: {
      title: '',
      attribute_type: 'Text'
    },
    attributeTypes: ['Text', 'Rich Text', 'Date', 'Checkbox', 'Dropdown',
      'Map:Person'],

    _customValidators: {
      /**
       * Validate a comma-separated list of possible values defined by the
       * custom attribute definition.
       *
       * This validation is only applicable to multi-choice CA types such as
       * Dropdown, and does not do anything for other CA types.
       *
       * There must be at most one empty value defined (whitespace trimmed),
       * and the values must be unique.
       *
       * @param {*} newVal - the new value of the property
       * @param {String} propName - the instance property to validate
       *
       * @return {String} - A validation error message, if any. An empty string
       *   is returned if the validation passes.
       */
      multiChoiceOptions: function (newVal, propName) {
        var choices;
        var nonBlanks;
        var uniques;

        if (propName !== 'multi_choice_options') {
          return '';  // nothing  to validate here
        }

        if (this.attribute_type !== 'Dropdown') {
          return '';  // all ok, the value of multi_choice_options not needed
        }

        choices = _.splitTrim(newVal, ',');

        if (!choices.length) {
          return 'At least one possible value required.';
        }

        nonBlanks = _.compact(choices);
        if (nonBlanks.length < choices.length) {
          return 'Blank values not allowed.';
        }

        uniques = _.unique(nonBlanks);
        if (uniques.length < nonBlanks.length) {
          return 'Duplicate values found.';
        }

        return '';  // no errors
      }
    },

    init: function () {
      this.validateNonBlank('title');

      // Besides multi_choice_options we need toset the validation on the
      // attribute_type field as well, even though its validation always
      // succeeds. For some reson this is required for the modal UI buttons to
      // properly update themselves when choosing a different attribute type.
      this.validate(
        ['multi_choice_options', 'attribute_type'],
        this._customValidators.multiChoiceOptions
      );

      this._super.apply(this, arguments);
    }
  }, {
    init: function () {
      this._super.apply(this, arguments);
    }
  });

  can.Model.Cacheable('CMS.Models.CustomAttributeValue', {
    // static properties
    root_object: 'custom_attribute_value',
    root_collection: 'custom_attribute_values',
    category: 'custom_attribute_values',
    findAll: 'GET /api/custom_attribute_values',
    findOne: 'GET /api/custom_attribute_values/{id}',
    create: 'POST /api/custom_attribute_values',
    update: 'PUT /api/custom_attribute_values/{id}',
    destroy: 'DELETE /api/custom_attribute_values/{id}',
    mixins: [],
    attributes: {
      definition: 'CMS.Models.CustomAttributeDefinition.stub',
      modified_by: 'CMS.Models.Person.stub'
    },
    links_to: {},
    init: function () {
      this._super.apply(this, arguments);
    }
  }, {
    init: function () {
      this._super.apply(this, arguments);
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, GGRC, CMS) {
  can.Model.Cacheable('CMS.Models.Assessment', {
    root_object: 'assessment',
    root_collection: 'assessments',
    findOne: 'GET /api/assessments/{id}',
    findAll: 'GET /api/assessments',
    update: 'PUT /api/assessments/{id}',
    destroy: 'DELETE /api/assessments/{id}',
    create: 'POST /api/assessments',
    mixins: [
      'ownable', 'contactable', 'unique_title', 'relatable',
      'autoStatusChangeable', 'timeboxed'
    ],
    relatable_options: {
      relevantTypes: {
        Audit: {
          objectBinding: 'audits',
          relatableBinding: 'program_assessments',
          weight: 5
        },
        Regulation: {
          objectBinding: 'related_regulations',
          relatableBinding: 'related_assessments',
          weight: 3
        },
        Control: {
          objectBinding: 'related_controls',
          relatableBinding: 'related_assessments',
          weight: 10
        }
      },
      threshold: 5
    },
    is_custom_attributable: true,
    attributes: {
      related_sources: 'CMS.Models.Relationship.stubs',
      related_destinations: 'CMS.Models.Relationship.stubs',
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      finished_date: 'date',
      verified_date: 'date'
    },
    defaults: {
      status: 'Not Started'
    },
    tree_view_options: {
      add_item_view: GGRC.mustache_path +
        '/base_objects/tree_add_item.mustache',
      attr_list: [{
        attr_title: 'Title',
        attr_name: 'title'
      }, {
        attr_title: 'Code',
        attr_name: 'slug'
      }, {
        attr_title: 'State',
        attr_name: 'status'
      }, {
        attr_title: 'Verified',
        attr_name: 'verified'
      }, {
        attr_title: 'Last Updated',
        attr_name: 'updated_at'
      }, {
        attr_title: 'Conclusion: Design',
        attr_name: 'design'
      }, {
        attr_title: 'Conclusion: Operation',
        attr_name: 'operationally'
      }, {
        attr_title: 'Finished Date',
        attr_name: 'finished_date'
      }, {
        attr_title: 'Verified Date',
        attr_name: 'verified_date'
      }, {
        attr_title: 'URL',
        attr_name: 'url'
      }, {
        attr_title: 'Reference URL',
        attr_name: 'reference_url'
      }]
    },
    info_pane_options: {
      mapped_objects: {
        model: can.Model.Cacheable,
        mapping: 'info_related_objects',
        show_view: GGRC.mustache_path + '/base_templates/subtree.mustache'
      },
      evidence: {
        model: CMS.Models.Document,
        mapping: 'all_documents',
        show_view: GGRC.mustache_path + '/base_templates/attachment.mustache',
        sort_function: GGRC.Utils.sortingHelpers.commentSort
      },
      comments: {
        model: can.Model.Cacheable,
        mapping: 'comments',
        show_view: GGRC.mustache_path +
        '/base_templates/comment_subtree.mustache',
        sort_function: GGRC.Utils.sortingHelpers.commentSort
      },
      urls: {
        model: CMS.Models.Document,
        mapping: 'all_urls',
        show_view: GGRC.mustache_path + '/base_templates/urls.mustache'
      }
    },
    confirmEditModal: {
      title: 'Confirm moving Request to "In Progress"',
      description: 'You are about to move request from ' +
      '"{{status}}" to "In Progress" - are you sure about that?',
      button: 'Confirm'
    },
    assignable_list: [{
      title: 'Creator(s)',
      type: 'creator',
      mapping: 'related_creators',
      required: true
    }, {
      title: 'Assignee(s)',
      type: 'assessor',
      mapping: 'related_assessors',
      required: true
    }, {
      title: 'Verifier(s)',
      type: 'verifier',
      mapping: 'related_verifiers',
      required: false
    }],
    conflicts: [
      ['assessor', 'verifier']
    ],
    conclusions: ['Effective', 'Ineffective', 'Needs improvement',
      'Not Applicable'],
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validatePresenceOf('audit');
      this.validateNonBlank('title');

      this.validate(
        'validate_creator',
        function () {
          if (!this.validate_creator) {
            return 'You need to specify at least one creator';
          }
        }
      );
      this.validate(
        'validate_assessor',
        function () {
          if (!this.validate_assessor) {
            return 'You need to specify at least one assignee';
          }
        }
      );
    }
  }, {
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.setIsReadyForRender(false);
    },
    save: function () {
      if (!this.attr('program')) {
        this.attr('program', this.attr('audit.program'));
      }
      return this._super.apply(this, arguments);
    },
    after_save: function () {
      this.updateValidation();
      if (this.audit && this.audit.selfLink) {
        this.audit.refresh();
      }
    },
    setIsReadyForRender: function (isReady) {
      this.attr('isReadyForRender', isReady);
    },
    updateValidation: function () {
      var values = this.attr('custom_attribute_values');
      var definitions = this.attr('custom_attribute_definitions');
      var errorsList = {
        attachment: [],
        comment: [],
        value: []
      };
      this.setIsReadyForRender(false);
      this.validateValues(definitions, values, errorsList);
      this.setErrorMessages(errorsList);
      this.setAggregatedErrorMessage();
      this.setIsReadyForRender(true);
    },
    validateValues: function (definitions, values, errorsList) {
      can.each(definitions, function (cad) {
        var cav;
        var value;

        can.each(values, function (item) {
          if (item.custom_attribute_id === cad.id) {
            cav = item;
            value = cav.attribute_value;
          }
        });
        if (cad.mandatory &&
            GGRC.Utils.isEmptyCA(value, cad.attribute_type)) {
          // If Custom Attribute is mandatory and empty
          errorsList.value.push(cad.title);
        } else if (cav) {
          // If Custom Attribute Value is presented - do all required checks
          cav.preconditions_failed = cav.preconditions_failed || [];
          if (cav.preconditions_failed.indexOf('comment') > -1) {
            errorsList.comment.push(cad.title + ': ' + value);
          }
          if (cav.preconditions_failed.indexOf('evidence') > -1) {
            errorsList.attachment.push(cad.title + ': ' + value);
          }
        }
      });
    },
    setErrorMessages: function (needed) {
      if (needed.comment.length) {
        this.attr('_mandatory_comment_msg',
          'Comment required by: ' + needed.comment.join(', '));
      } else {
        this.removeAttr('_mandatory_comment_msg');
      }

      if (needed.attachment.length) {
        this.attr('_mandatory_attachment_msg',
          'Evidence required by: ' + needed.attachment.join(', '));
      } else {
        this.removeAttr('_mandatory_attachment_msg');
      }

      if (needed.value.length) {
        this.attr(
          '_mandatory_value_msg',
          'Values required for: ' + needed.value.join(', ')
        );
      } else {
        this.removeAttr('_mandatory_value_msg');
      }
    },
    setAggregatedErrorMessage: function () {
      this.attr('_mandatory_msg',
        _.filter([
          this.attr('_mandatory_value_msg'),
          this.attr('_mandatory_attachment_msg'),
          this.attr('_mandatory_comment_msg')
        ]).join('; <br />') || null
      );
    },
    form_preload: function (newObjectForm) {
      var pageInstance = GGRC.page_instance();
      var currentUser = CMS.Models.get_instance('Person',
        GGRC.current_user.id, GGRC.current_user);
      var auditLead;

      if (!newObjectForm) {
        return;
      }

      if (pageInstance && pageInstance.type === 'Audit' && !this.audit) {
        this.attr('audit', pageInstance);
      }

      if (this.audit) {
        auditLead = this.audit.contact.reify();
        if (currentUser === auditLead) {
          markForAddition(this, auditLead, 'Creator,Assessor');
        } else {
          markForAddition(this, auditLead, 'Assessor');
          markForAddition(this, currentUser, 'Creator');
        }
      } else {
        markForAddition(this, currentUser, 'Creator');
      }

      function markForAddition(instance, user, type) {
        instance.mark_for_addition('related_objects_as_destination', user, {
          attrs: {
            AssigneeType: type
          }
        });
      }
    },
    refreshInstance: function () {
      return this.refresh().then(function () {
        this.updateValidation();
      }.bind(this));
    },
    info_pane_preload: function () {
      if (!this._pane_preloaded) {
        this.get_mapping('comments').bind('length',
          this.refreshInstance.bind(this));
        this.get_mapping('all_documents').bind('length',
          this.refreshInstance.bind(this));
        this.refreshInstance();
        this._pane_preloaded = true;
      }
    },
    related_issues: function () {
      var relevantTypes = {
        Audit: {
          objectBinding: 'audits',
          relatableBinding: 'program_issues',
          weight: 5
        },
        Regulation: {
          objectBinding: 'related_regulations',
          relatableBinding: 'related_issues',
          weight: 3
        },
        Control: {
          objectBinding: 'related_controls',
          relatableBinding: 'related_issues',
          weight: 10
        }
      };
      return this._related(relevantTypes, 5);
    },
    related_requests: function () {
      var relevantTypes = {
        Audit: {
          objectBinding: 'audits',
          relatableBinding: 'program_requests',
          weight: 5
        },
        Regulation: {
          objectBinding: 'related_regulations',
          relatableBinding: 'related_requests',
          weight: 3
        },
        Control: {
          objectBinding: 'related_controls',
          relatableBinding: 'related_requests',
          weight: 10
        }
      };
      return this._related(relevantTypes, 5);
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (namespace, $) {
  can.Model.Cacheable('CMS.Models.Control', {
  // static properties
    root_object: 'control',
    root_collection: 'controls',
    category: 'governance',
    findAll: 'GET /api/controls',
    findOne: 'GET /api/controls/{id}',
    create: 'POST /api/controls',
    update: 'PUT /api/controls/{id}',
    destroy: 'DELETE /api/controls/{id}',
    mixins: ['ownable', 'contactable', 'unique_title', 'ca_update',
             'timeboxed'],
    is_custom_attributable: true,
    attributes: {
      context: 'CMS.Models.Context.stub',
      owners: 'CMS.Models.Person.stubs',
      modified_by: 'CMS.Models.Person.stub',
      object_people: 'CMS.Models.ObjectPerson.stubs',
      people: 'CMS.Models.Person.stubs',
      categories: 'CMS.Models.ControlCategory.stubs',
      assertions: 'CMS.Models.ControlAssertion.stubs',
      objectives: 'CMS.Models.Objective.stubs',
      directive: 'CMS.Models.Directive.stub',
      audit_objects: 'CMS.Models.AuditObject.stubs',
      sections: 'CMS.Models.get_stubs',
      programs: 'CMS.Models.Program.stubs',
      kind: 'CMS.Models.Option.stub',
      means: 'CMS.Models.Option.stub',
      verify_frequency: 'CMS.Models.Option.stub',
      principal_assessor: 'CMS.Models.Person.stub',
      secondary_assessor: 'CMS.Models.Person.stub',
      custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
    },
    links_to: {},
    defaults: {
      selected: false,
      title: '',
      slug: '',
      description: '',
      url: '',
      status: 'Draft'
    },
    tree_view_options: {
      show_view: GGRC.mustache_path + '/controls/tree.mustache',
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      attr_list: can.Model.Cacheable.attr_list.concat([
        {attr_title: 'URL', attr_name: 'url'},
        {attr_title: 'Reference URL', attr_name: 'reference_url'},
        {attr_title: 'Effective Date', attr_name: 'start_date'},
        {attr_title: 'Stop Date', attr_name: 'end_date'},
        {attr_title: 'Kind/Nature', attr_name: 'kind',
          attr_sort_field: 'kind.title'},
        {attr_title: 'Fraud Related ', attr_name: 'fraud_related'},
        {attr_title: 'Significance', attr_name: 'significance'},
        {attr_title: 'Type/Means', attr_name: 'means',
          attr_sort_field: 'means.title'},
        {attr_title: 'Frequency', attr_name: 'frequency',
          attr_sort_field: 'frequency.title'},
        {attr_title: 'Assertions', attr_name: 'assertions'},
        {attr_title: 'Categories', attr_name: 'categories'},
        {attr_title: 'Principal Assignee', attr_name: 'principal_assessor',
          attr_sort_field: 'principal_assessor.name|email'},
        {attr_title: 'Secondary Assignee', attr_name: 'secondary_assessor',
          attr_sort_field: 'secondary_assessor.name|email'}
      ]),
      add_item_view: GGRC.mustache_path + '/controls/tree_add_item.mustache',
      draw_children: true,
      child_options: [{
        model: can.Model.Cacheable,
        mapping: 'related_objects', // 'related_and_able_objects'
        footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
        add_item_view: GGRC.mustache_path +
        '/base_objects/tree_add_item.mustache',
        title_plural: 'Business Objects',
        draw_children: false
      }]
    },
    statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
    init: function () {
      this.validateNonBlank('title');
      this._super.apply(this, arguments);
    }
  }, {
    init: function () {
      var that = this;
      this._super.apply(this, arguments);
      this.bind('change', function (ev, attr, how, newVal, oldVal) {
        // Emit the 'orphaned' event when the directive attribute is removed
        if (attr === 'directive' && how === 'remove' && oldVal &&
          newVal === undefined) {
          // It is necessary to temporarily add the attribute back for orphaned
          // processing to work properly.
          that.directive = oldVal;
          can.trigger(that.constructor, 'orphaned', that);
          delete that.directive;
        }
      });
    }
  });
})(this, can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/


// this model doesn't exist anymore, can we get rid of it?
can.Model.Cacheable('CMS.Models.Section', {
  root_object: 'section',
  root_collection: 'sections',
  model_plural: 'Sections',
  table_plural: 'sections',
  title_plural: 'Sections',
  model_singular: 'Section',
  title_singular: 'Section',
  table_singular: 'section',
  category: 'governance',
  root_model: 'Section',
  findAll: 'GET /api/sections',
  findOne: 'GET /api/sections/{id}',
  create: 'POST /api/sections',
  update: 'PUT /api/sections/{id}',
  destroy: 'DELETE /api/sections/{id}',
  is_custom_attributable: true,
  mixins: ['ownable', 'contactable', 'unique_title', 'ca_update'],
  attributes: {
    context: 'CMS.Models.Context.stub',
    owners: 'CMS.Models.Person.stubs',
    modified_by: 'CMS.Models.Person.stub',
    object_people: 'CMS.Models.ObjectPerson.stubs',
    people: 'CMS.Models.Person.stubs',
    directive: 'CMS.Models.get_stub',
    children: 'CMS.Models.get_stubs',
    directive_sections: 'CMS.Models.DirectiveSection.stubs',
    directives: 'CMS.Models.get_stubs',
    objectives: 'CMS.Models.Objective.stubs',
    custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options: {
    show_view: '/static/mustache/sections/tree.mustache',
    footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
    attr_list: can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'}
    ]),
    add_item_view: GGRC.mustache_path + '/sections/tree_add_item.mustache',
    child_options: [{
      model: can.Model.Cacheable,
      mapping: 'related_objects',
      title_plural: 'Business Objects',
      draw_children: function () {
        return this.instance.type === 'Objective';
      },
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      add_item_view: GGRC.mustache_path +
      '/base_objects/tree_add_item.mustache',
      child_options: [{
        model: CMS.Models.Control,
        title_plural: 'Controls',
        mapping: 'controls',
        draw_children: false,
        footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
        add_item_view: GGRC.mustache_path + '/controls/tree_add_item.mustache'
      }]
    }]
  },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
    'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    this._super.apply(this, arguments);
    this.validateNonBlank('title');
  }
}, {
});

can.Model.Cacheable('CMS.Models.Clause', {
  root_object: 'clause',
  root_collection: 'clauses',
  model_plural: 'Clauses',
  table_plural: 'clauses',
  title_plural: 'Clauses',
  model_singular: 'Clause',
  title_singular: 'Clause',
  table_singular: 'clause',
  category: 'governance',
  root_model: 'Clause',
  findAll: 'GET /api/clauses',
  findOne: 'GET /api/clauses/{id}',
  create: 'POST /api/clauses',
  update: 'PUT /api/clauses/{id}',
  destroy: 'DELETE /api/clauses/{id}',
  is_custom_attributable: true,
  mixins: ['ownable', 'contactable', 'unique_title', 'ca_update'],
  attributes: {
    context: 'CMS.Models.Context.stub',
    owners: 'CMS.Models.Person.stubs',
    modified_by: 'CMS.Models.Person.stub',
    object_people: 'CMS.Models.ObjectPerson.stubs',
    people: 'CMS.Models.Person.stubs',
    directive: 'CMS.Models.get_stub',
    children: 'CMS.Models.get_stubs',
    directive_sections: 'CMS.Models.DirectiveSection.stubs',
    directives: 'CMS.Models.get_stubs',
    objectives: 'CMS.Models.Objective.stubs',
    custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options: {
    show_view: '/static/mustache/sections/tree.mustache',
    footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
    attr_list: can.Model.Cacheable.attr_list.concat([
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'}
    ]),
    add_item_view: GGRC.mustache_path + '/sections/tree_add_item.mustache',
    child_options: [{
      model: can.Model.Cacheable,
      mapping: 'related_objects', // 'related_and_able_objects'
      title_plural: 'Business Objects',
      draw_children: function () {
        return this.instance.type === 'Objective';
      },
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      add_item_view: GGRC.mustache_path +
      '/base_objects/tree_add_item.mustache',
      child_options: [{
        model: CMS.Models.Control,
        title_plural: 'Controls',
        mapping: 'controls',
        draw_children: false,
        footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
        add_item_view: GGRC.mustache_path + '/controls/tree_add_item.mustache'
      }]
    }]
  },
  defaults: {
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
    'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    this._super.apply(this, arguments);
    this.validateNonBlank('title');
  }
}, {});

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

can.Model.Cacheable('CMS.Models.SystemOrProcess', {
  root_object: 'system_or_process',
  root_collection: 'systems_or_processes',
  title_plural: 'Systems/Processes',
  category: 'business',
  findAll: 'GET /api/systems_or_processes',
  model: function (params) {
    if (this.shortName !== 'SystemOrProcess') {
      return this._super(params);
    }
    if (!params) {
      return params;
    }
    params = this.object_from_resource(params);
    if (!params.selfLink) {
      if (params.type !== 'SystemOrProcess') {
        return CMS.Models[params.type].model(params);
      }
    } else if (params.is_biz_process) {
      return CMS.Models.Process.model(params);
    } else {
      return CMS.Models.System.model(params);
    }
  },
  mixins: ['ownable', 'contactable', 'unique_title', 'timeboxed'],
  attributes: {
    context: 'CMS.Models.Context.stub',
    owners: 'CMS.Models.Person.stubs',
    modified_by: 'CMS.Models.Person.stub',
    object_people: 'CMS.Models.ObjectPerson.stubs',
    people: 'CMS.Models.Person.stubs',
    related_sources: 'CMS.Models.Relationship.stubs',
    related_destinations: 'CMS.Models.Relationship.stubs',
    objectives: 'CMS.Models.Objective.stubs',
    controls: 'CMS.Models.Control.stubs',
    sections: 'CMS.Models.get_stubs',
    network_zone: 'CMS.Models.Option.stub',
    custom_attribute_values: 'CMS.Models.CustomAttributeValue.stubs'
  },
  tree_view_options: {
    show_view: '/static/mustache/base_objects/tree.mustache',
    footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
    attr_list: can.Model.Cacheable.attr_list.concat([
      {
        attr_title: 'Network Zone',
        attr_name: 'network_zone',
        attr_sort_field: 'network_zone.title'
      },
      {attr_title: 'Effective Date', attr_name: 'start_date'},
      {attr_title: 'Stop Date', attr_name: 'end_date'},
      {attr_title: 'URL', attr_name: 'url'},
      {attr_title: 'Reference URL', attr_name: 'reference_url'}
    ]),
    add_item_view: GGRC.mustache_path + '/base_objects/tree_add_item.mustache',
    link_buttons: true,
    child_options: []
  },
  links_to: {
    System: {},
    Process: {},
    Control: {},
    Product: {},
    Facility: {},
    OrgGroup: {},
    Vendor: {},
    Project: {},
    DataAsset: {},
    AccessGroup: {},
    Program: {},
    Market: {},
    Regulation: {},
    Policy: {},
    Standard: {},
    Contract: {},
    Objective: {}
  }
}, {
  system_or_process: function () {
    var result;
    if (this.attr('is_biz_process')) {
      result = 'process';
    } else {
      result = 'system';
    }
    return result;
  },
  system_or_process_capitalized: function () {
    var str = this.system_or_process();
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
});

CMS.Models.SystemOrProcess('CMS.Models.System', {
  root_object: 'system',
  root_collection: 'systems',
  findAll: 'GET /api/systems',
  findOne: 'GET /api/systems/{id}',
  create: 'POST /api/systems',
  update: 'PUT /api/systems/{id}',
  destroy: 'DELETE /api/systems/{id}',
  mixins: ['ca_update'],
  cache: can.getObject('cache', CMS.Models.SystemOrProcess, true),
  is_custom_attributable: true,
  attributes: {},
  defaults: {
    title: '',
    url: '',
    status: 'Draft'
  },
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
    'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    can.extend(this.attributes, CMS.Models.SystemOrProcess.attributes);
    this._super && this._super.apply(this, arguments);
    this.tree_view_options = $.extend({},
      CMS.Models.SystemOrProcess.tree_view_options, {
        // systems is a special case; can be imported to programs
        footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
        add_item_view: GGRC.mustache_path +
        (GGRC.infer_object_type(GGRC.page_object) === CMS.Models.Program ?
          '/systems/tree_add_item.mustache' :
          '/base_objects/tree_add_item.mustache')
      });
    this.validateNonBlank('title');
  } // don't rebind the ObjectDocument/ObjectPerson events.
}, {
  init: function () {
    this._super && this._super.apply(this, arguments);
    this.attr('is_biz_process', false);
  }
});

CMS.Models.SystemOrProcess('CMS.Models.Process', {
  root_object: 'process',
  root_collection: 'processes',
  model_plural: 'Processes',
  table_plural: 'processes',
  title_plural: 'Processes',
  model_singular: 'Process',
  title_singular: 'Process',
  table_singular: 'process',
  findAll: 'GET /api/processes',
  findOne: 'GET /api/processes/{id}',
  create: 'POST /api/processes',
  update: 'PUT /api/processes/{id}',
  destroy: 'DELETE /api/processes/{id}',
  cache: can.getObject('cache', CMS.Models.SystemOrProcess, true),
  is_custom_attributable: true,
  attributes: {},
  defaults: {
    title: '',
    url: '',
    status: 'Draft'
  },
  mixins: ['ca_update'],
  statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
    'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
  init: function () {
    can.extend(this.attributes, CMS.Models.SystemOrProcess.attributes);
    this._super && this._super.apply(this, arguments);
    this.tree_view_options = $.extend({},
      CMS.Models.SystemOrProcess.tree_view_options);
    this.validateNonBlank('title');
  } // don't rebind the ObjectDocument/ObjectPerson events.
}, {
  init: function () {
    this._super && this._super.apply(this, arguments);
    this.attr('is_biz_process', true);
  }
});

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
(function (can, $) {
  can.Model.Cacheable('can.Model.Join', {
    join_keys: null,
    setup: function () {
      this._super.apply(this, arguments);
    },
    init: function () {
      if (this._super) {
        this._super.apply(this, arguments);
      }
      function reinit(ev, instance) {
        var refreshQueue;
        if (instance instanceof can.Model.Join) {
          instance.reinit();
          refreshQueue = new RefreshQueue();
          can.each(instance.constructor.join_keys, function (cls, key) {
            var obj;
            if (instance[key]) {
              if (instance[key].reify && instance[key].reify().refresh) {
                obj = instance[key].reify();
              } else {
                obj = cls.findInCacheById(instance[key].id);
              }
            }
            if (obj) {
              refreshQueue.enqueue(obj);
            }
          });
          refreshQueue.trigger();
        }
      }
      if (this === can.Model.Join) {
        this.bind('created', reinit);
        this.bind('destroyed', reinit);
      }
    }
  }, {
    init: function () {
      this._super.apply(this, arguments);
      can.each(this.constructor.join_keys, function (cls, key) {
        this.bind(key + '.stub_destroyed', function () {
          // Trigger `destroyed` on self, since it was destroyed on the server
          this.destroyed();
        }.bind(this));
      }.bind(this));
    },

    reinit: function () {
      this.init_join_objects();
    },

    init_join_object_with_type: function (attr) {
      var objectId;
      var objectType;
      if (this[attr] instanceof can.Model) {
        return;
      }

      objectId = this[attr + '_id'] || (this[attr] || {}).id;
      objectType = this[attr + '_type'] || (this[attr] || {}).type;

      if (objectId && objectType && typeof objectType === 'string') {
        this.attr(attr, CMS.Models.get_instance(
              objectType
            , objectId
            , this[attr]
            ) || this[attr]);
      } else if (objectId) {
        this.attr(attr, CMS.Models.get_instance(this[attr]));
      }
    },

    init_join_object: function (attr, modelName) {
      var objectId = this[attr + '_id'] || (this[attr] || {}).id;

      if (objectId) {
        this.attr(
            attr,
            CMS.Models.get_instance(
              modelName, objectId, this[attr]
            ).stub() || this[attr]
        );
      }
    },

    init_join_objects: function () {
      var that = this
        ;

      can.each(this.constructor.join_keys, function (model, attr) {
        if (model === can.Model.Cacheable) {
          that.init_join_object_with_type(attr);
        } else {
          that.init_join_object(attr, model.shortName);
        }
      });
    }
  });

  can.Model.Join('CMS.Models.Snapshot', {
    root_object: 'snapshot',
    root_collection: 'snapshots',
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      parent: 'CMS.Models.Cacheable.stub',
      revision: 'CMS.Models.Revision.stub'
    },
    join_keys: {
      parent: can.Model.Cacheable,
      revision: can.Model.Revision
    },
    defaults: {
      parent: null,
      revision: null
    },
    findAll: 'GET /api/snapshots',
    update: 'PUT /api/snapshots/{id}',
    child_instance: function (snapshotData) {
    },
    snapshot_instance: function (snapshotData) {
    }
  }, {
    reinit: function () {
      var revision = CMS.Models.Revision.findInCacheById(this.revision_id);
      this.content = revision.content;
    },
    display_name: function () {
      return '';
    },
    title: function () {
      return '';
    },
    description: function () {
      return '';
    }
  });

  can.Model.Join('CMS.Models.Relationship', {
    root_object: 'relationship',
    root_collection: 'relationships',
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      source: 'CMS.Models.get_stub',
      destination: 'CMS.Models.get_stub'
    },
    join_keys: {
      source: can.Model.Cacheable,
      destination: can.Model.Cacheable
    },
    defaults: {
      source: null,
      destination: null
    },
    findAll: 'GET /api/relationships',
    create: 'POST /api/relationships',
    update: 'PUT /api/relationships/{id}',
    destroy: 'DELETE /api/relationships/{id}',
    createAssignee: function (options) {
      return new this({
        attrs: {
          AssigneeType: options.role
        },
        source: {
          href: options.source.href,
          type: options.source.type,
          id: options.source.id
        },
        context: options.context,
        destination: {
          href: options.destination.href,
          type: options.destination.type,
          id: options.destination.id
        }
      });
    },
    get_relationship: function (source, destination) {
      return _.first(_.filter(CMS.Models.Relationship.cache, function (model) {
        if (!model.source || !model.destination) {
          return false;
        }
        return model.source.type === source.type &&
                model.source.id === source.id &&
                model.destination.type === destination.type &&
                model.destination.id === destination.id ||
                model.source.type === destination.type &&
                model.source.id === destination.id &&
                model.destination.type === source.type &&
                model.destination.id === source.id;
      }));
    },
    /**
     * Return the Relationship between two objects.
     *
     * @param {CMS.Models.Cacheable} first - First object.
     * @param {CMS.Models.Cacheable} second - Second object.
     * @param {boolean} noRefresh - Flag for reject if not relationship.
     * @return {Promise} - Resolved with Relationship instances if they were
     * found or an empty list if instances are not related.
     */
    getRelationshipBetweenInstances: function rec(first, second, noRefresh) {
      var relationshipIds = _.intersection(getRelationshipsIds(first),
        getRelationshipsIds(second));
      var relationships;
      var result = $.Deferred();

      function getRelationshipsIds(obj) {
        var union = _.union(obj.related_sources, obj.related_destinations);
        return _.map(union, 'id');
      }
      if (!relationshipIds.length && noRefresh) {
        result.resolve([]);
        return result.promise();
      }
      if (!relationshipIds.length) {
        // try to refresh the instances if don't find the relationship between them
        return $.when(first.refresh(), second.refresh())
          .then(function (fObj, sObj) {
            return rec(fObj, sObj, true);
          }).fail(function (e) {
            result.resolve([]);
          });
      }
      if (relationshipIds.length > 1) {
        console.warn('Duplicated relationship objects', relationshipIds);
      }
      relationships = can.map(relationshipIds, function (id) {
        return CMS.Models.Relationship.findInCacheById(id) ||
          CMS.Models.get_instance('Relationship', id);
      });
      result.resolve(relationships);
      return result.promise();
    }
  }, {
    reinit: function () {
      this.attr('source', CMS.Models.get_instance(
        this.source_type ||
          (this.source &&
            (this.source.constructor &&
              this.source.constructor.shortName ||
              (!this.source.selfLink && this.source.type))),
          this.source_id || (this.source && this.source.id),
          this.source) || this.source);
      this.attr('destination', CMS.Models.get_instance(
        this.destination_type ||
          (this.destination &&
            (this.destination.constructor &&
              this.destination.constructor.shortName ||
              (!this.source.selfLink && this.destination.type))),
        this.destination_id || (this.destination && this.destination.id),
        this.destination) || this.destination);
    }
  });

  can.Model.Join('CMS.Models.UserRole', {
    root_object: 'user_role',
    root_collection: 'user_roles',
    findAll: 'GET /api/user_roles',
    update: 'PUT /api/user_roles/{id}',
    create: 'POST /api/user_roles',
    destroy: 'DELETE /api/user_roles/{id}',
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      person: 'CMS.Models.Person.stub',
      role: 'CMS.Models.Role.stub'
    },
    join_keys: {
      person: CMS.Models.Person,
      role: CMS.Models.Role
    }
  }, {
    save: function () {
      var role;
      var _super = this._super;

      if (this.role && !this.role_name) {
        return _super.apply(this, arguments);
      }

      role = _.find(CMS.Models.Role.cache, {name: this.role_name});
      if (role) {
        this.attr('role', role.stub());
        return _super.apply(this, arguments);
      }
      return CMS.Models.Role.findAll({
        name__in: this.role_name
      }).then(function (role) {
        if (!role.length) {
          return new $.Deferred().reject('Role not found');
        }
        role = role[0];
        this.attr('role', role.stub());
        return _super.apply(this, arguments);
      }.bind(this));
    }
  });

  can.Model.Join('CMS.Models.ObjectPerson', {
    root_object: 'object_person',
    root_collection: 'object_people',
    findAll: 'GET /api/object_people',
    create: 'POST /api/object_people',
    update: 'PUT /api/object_people/{id}',
    destroy: 'DELETE /api/object_people/{id}',
    join_keys: {
      personable: can.Model.Cacheable,
      person: CMS.Models.Person
    },
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      person: 'CMS.Models.Person.stub',
      personable: 'CMS.Models.get_stub'
    }

  }, {});

  can.Model.Join('CMS.Models.ObjectOwner', {
    root_object: 'object_owner',
    root_collection: 'object_owners',
    findOne: 'GET /api/object_owners/{id}',
    findAll: 'GET /api/object_owners',
    create: 'POST /api/object_owners',
    update: 'PUT /api/object_owners/{id}',
    destroy: 'DELETE /api/object_owners/{id}',
    join_keys: {
      ownable: can.Model.Cacheable,
      person: CMS.Models.Person
    },
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      person: 'CMS.Models.Person.stub',
      ownable: 'CMS.Models.get_stub'
    }
  }, {});

  can.Model.Join('CMS.Models.ObjectDocument', {
    root_object: 'object_document',
    root_collection: 'object_documents',
    findAll: 'GET /api/object_documents',
    create: 'POST /api/object_documents',
    destroy: 'DELETE /api/object_documents/{id}',
    join_keys: {
      documentable: can.Model.Cacheable,
      document: CMS.Models.Document
    },
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      document: 'CMS.Models.Document.stub',
      documentable: 'CMS.Models.get_stub'
    }
  }, {});

  can.Model.Join('CMS.Models.MultitypeSearchJoin', {
    join_keys: {}
  }, {});

  can.Model.Join('CMS.Models.AuditObject', {
    root_object: 'audit_object',
    root_collection: 'audit_objects',
    findAll: 'GET /api/audit_objects',
    create: 'POST /api/audit_objects',
    destroy: 'DELETE /api/audit_objects/{id}',
    join_keys: {
      auditable: can.Model.Cacheable,
      audit: CMS.Models.Audit
    },
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      audit: 'CMS.Models.Audit.stub',
      auditable: 'CMS.Models.get_stub'
    }
  }, {});
})(this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all

(function(can, $) {

can.Control("CMS.Controllers.Filterable", {
  defaults : {
    filterable_items_selector : "[data-model]"
    , spinner_while_filtering : false
    , spinner_style : {
      top : 100
      , left : 100
      , height : 50
      , width : 50
      , position : "absolute"
    }
  }
  //static
}, {
  filter : function(str, extra_params, dfd) {
    var that = this
    , spinner
    , search_dfds = str ? [GGRC.Models.Search.search(str, extra_params)] : [$.when(null)];
    dfd && search_dfds.push(dfd);

    if(this.options.spinner_while_filtering) {
      spinner = new Spinner().spin();
      $(spinner.el).css(this.options.spinner_style);
      this.element.append(spinner.el);
    }
    return $.when.apply($, search_dfds).then(function(data) {
      var _filter = null, ids = null;
      if(data) {
        _filter = that.options.model ? data.getResultsFor(that.options.model) : data;
        ids = data ? can.map(data.entries, function(v) { return v.id; }) : null;
      }
      that.last_filter_ids = ids;
      that.last_filter = _filter;
      that.redo_last_filter();
      spinner && spinner.stop();
      return ids;
    });
  }

  , redo_last_filter : function(id_to_add) {
    id_to_add && this.last_filter_ids.push(id_to_add);
    var that = this;
    that.element.find(that.options.filterable_items_selector).each(function() {
      var $this = $(this);
      if(that.last_filter_ids == null || can.inArray($this.data("model").id, that.last_filter_ids) > -1)
        $this.show();
      else
        $this.hide();
    });
    return $.when(this.last_filter_ids);
  }

});

})(this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all
//= require controllers/filterable_controller

CMS.Controllers.Filterable("CMS.Controllers.DashboardWidgets", {
  defaults : {
    model : null
    , widget_id : ""
    , widget_name : ""
    , widget_icon : ""
    , widget_view : "/static/mustache/dashboard/object_widget.mustache"
    , widget_guard : null
    , widget_initial_content : ''
    , show_filter : false
    , object_category : null //e.g. "governance"
    , content_selector : ".content"
    //, minimum_widget_height : 100
    , content_controller : null
    , content_controller_options : {}
    , content_controller_selector : null
  }
}, {

  init : function() {
    if(!this.options.model && GGRC.page_model) {
      this.options.model = GGRC.infer_object_type(GGRC.page_object);
    }

    if(!this.options.widget_icon && this.options.model) {
      this.options.widget_icon = this.options.model.table_singular;
    }
    if(this.options.widget_icon && !/^fa/.test(this.options.widget_icon)) {
      this.options.widget_icon = this.options.widget_icon;
    }

    if(!this.options.object_category && this.options.model) {
      this.options.object_category = this.options.model.category;
    }

    this.options.widget_count = new can.Observe();

    this.element
          .addClass("widget")
          .addClass(this.options.object_category)
          .attr("id", this.options.widget_id + "_widget")
      //  This is used only by ResizeWidgets controller
          .trigger("section_created");
  }

  , prepare: function() {
      if (this._prepare_deferred)
        return this._prepare_deferred;

      this._prepare_deferred = $.when(
        can.view(this.options.widget_view, $.when(this.options))
        , CMS.Models.DisplayPrefs.getSingleton()
      ).then(this.proxy("draw_widget"));

      return this._prepare_deferred;
    }

  , draw_widget : function(frag, prefs) {

    this.element.html(frag[0]);

    var content = this.element
      , controller_content = null;

    if (prefs.getCollapsed(window.getPageToken(), this.element.attr("id"))) {

      this.element
      .find(".widget-showhide > a")
      .showhide("hide");

      content.add(this.element).css("height", "");
      if(content.is(".ui-resizable")) {
        content.resizable("destroy");
      }
    } else {
      content.trigger("min_size");
    }

    if(this.options.content_controller) {
      controller_content = this.element.find(this.options.content_selector);
      if (this.options.content_controller_selector)
        controller_content =
          controller_content.find(this.options.content_controller_selector);

      if (this.options.content_controller_options.init) {
        this.options.content_controller_options.init();
      }

      this.options.content_controller_options.show_header = true;
      this.content_controller = new this.options.content_controller(
          controller_content
        , this.options.content_controller_options
      );

      if (this.content_controller.prepare) {
        return this.content_controller.prepare();
      }
      else {
        return new $.Deferred().resolve();
      }
    }
  }

  , display: function() {
      var that = this
       , tracker_stop = GGRC.Tracker.start(
          "DashboardWidget", "display", this.options.model.shortName)
       ;

      if (this._display_deferred)
        return this._display_deferred;

      this._display_deferred = this.prepare().then(function() {
        if (that.content_controller && that.content_controller.display) {
          return that.content_controller.display();
        }
        else {
          return new $.Deferred().resolve();
        }
      }).done(tracker_stop);

      return this._display_deferred;
    },

  /*, ".remove-widget click" : function() {
    var parent = this.element.parent();
    this.element.remove();
    parent.trigger("sortremove");
  }

  , ".widgetsearch keydown" : function(el, ev) {
    if(ev.which === 13) {
      this.filter(el.val());
      this.element.trigger('kill-all-popovers');
    }
    ev.stopPropagation();
    ev.originalEvent && ev.originalEvent.stopPropagation();
  }*/
  "updateCount": function (el, ev, count, updateCount) {
    this.options.widget_count.attr("count", "" + count);
  }

  , display_path: function(path) {
      var that = this;
      return this.display().then(function() {
        if (that.content_controller && that.content_controller.display_path)
          return that.content_controller.display_path(path);
      });
    }
});

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (_, can, GGRC, CMS) {
  can.Control('GGRC.Controllers.InfoWidget', {
    defaults: {
      model: null,
      instance: null,
      widget_view: GGRC.mustache_path + '/base_objects/info.mustache'
    },
    init: function () {
      var that = this;
      can.$(function () {
        if (GGRC.page_object) {
          can.extend(that.defaults, {
            model: GGRC.infer_object_type(GGRC.page_object),
            instance: GGRC.page_instance()
          });
        }
      });
    }
  }, {
    init: function () {
      this.init_menu();

      if (this.element.data('widget-view')) {
        this.options.widget_view = GGRC.mustache_path +
          this.element.data('widget-view');
      }
      if (this.options.instance.info_pane_preload) {
        this.options.instance.info_pane_preload();
      }
      this.options.context = new can.Observe({
        model: this.options.model,
        instance: this.options.instance,
        start_menu: this.options.start_menu,
        object_menu: this.options.object_menu,
        error_msg: '',
        error: true
      });
      can.view(this.get_widget_view(this.element),
        this.options.context, function (frag) {
          this.element.html(frag);
        }.bind(this));
    },

    get_widget_view: function (el) {
      var widgetView = can.$(el)
          .closest('[data-widget-view]').attr('data-widget-view');
      if (widgetView && widgetView.length > 0) {
        return GGRC.mustache_path + widgetView;
      }
      return this.options.widget_view;
    },

    generate_menu_items: function (itemNames, displayPrefix) {
      displayPrefix = displayPrefix || '';
      return _.filter(_.map(itemNames, function (name) {
        if (name in CMS.Models) {
          return {
            model_name: CMS.Models[name].model_singular,
            model_lowercase: CMS.Models[name].table_singular,
            model_plural: CMS.Models[name].table_plural,
            display_name: displayPrefix + CMS.Models[name].title_singular
          };
        }
      }));
    },

    init_menu: function () {
      var names;
      if (!this.options.start_menu) {
        names = [
          'Program',
          'Audit',
          'Workflow'
        ];
        this.options.start_menu = this.generate_menu_items(names, 'Start new ');
      }
      if (!this.options.object_menu) {
        names = [
          'AccessGroup',
          'Clause',
          'Contract',
          'Control',
          'Assessment',
          'DataAsset',
          'Facility',
          'Issue',
          'Market',
          'Objective',
          'OrgGroup',
          'Person',
          'Policy',
          'Process',
          'Product',
          'Project',
          'Regulation',
          'Request',
          'Risk',
          'Section',
          'Standard',
          'System',
          'Threat',
          'Vendor'
        ];
        this.options.object_menu = this.generate_menu_items(names);
      }
    }
  });
})(window._, window.can, window.GGRC, window.CMS);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  can.Control('GGRC.Controllers.SummaryWidget', {
    defaults: {
      model: null,
      instance: null,
      widget_view: GGRC.mustache_path + '/base_objects/summary.mustache',
      isLoading: true
    },
    init: function () {
      var that = this;
      $(function () {
        if (GGRC.page_object) {
          $.extend(that.defaults, {
            model: GGRC.infer_object_type(GGRC.page_object),
            instance: GGRC.page_instance()
          });
        }
      });
    }
  }, {
    init: function () {
      var that = this;
      if (this.element.data('widget-view')) {
        this.options.widget_view = GGRC.mustache_path +
          this.element.data('widget-view');
      }
      this.element.closest('.widget')
        .on('widget_shown', this.widget_shown.bind(this));
      this.element.closest('.widget')
        .on('widget_hidden', this.widget_hidden.bind(this));
      this.options.context = new can.Map({
        model: this.options.model,
        instance: this.options.instance,
        error_msg: '',
        error: true
      });
      can.view(this.get_widget_view(this.element),
        this.options.context, function (frag) {
          that.element.html(frag);
        });
      return 0;
    },
    get_widget_view: function (el) {
      var widgetView = $(el)
        .closest('[data-widget-view]')
        .attr('data-widget-view');
      return (widgetView && widgetView.length > 0) ?
          GGRC.mustache_path + widgetView :
          this.options.widget_view;
    },
    widget_shown: function (event) {
      setTimeout(this.reloadSummary.bind(this), 0);
      return false;
    },
    widget_hidden: function (event) {
      this.setState('requests', {total: 0, statuses: { }}, true);
      this.setState('assessments', {total: 0, statuses: { }}, true);
      return false;
    },
    reloadSummary: function () {
      var that = this;
      this.loadChartLibrary(function () {
        that.reloadChart('Assessment', 'assessments',
          'piechart_audit_assessments_chart');
        that.reloadChart('Request', 'requests',
          'piechart_audit_requests_chart');
      });
    },
    reloadChart: function (type, name, elementId) {
      var that = this;
      that.setState(name, {total: 0, statuses: { }}, true);
      that.getStatuses(type, that.options.instance.id).then(function (raw) {
        var data = that.parseStatuses(raw[0][type]);
        that.drawChart(elementId, data);
        that.setState(name, data, false);
      });
    },
    drawChart: function (elementId, raw) {
      var columns = [['Status', 'Count']];
      var data;
      var chart;
      var options = this.getChartOptions(raw);
      columns.push.apply(columns, raw.statuses);
      data = google.visualization.arrayToDataTable(columns);
      chart = new google.visualization.PieChart(
        document.getElementById(elementId));
      chart.draw(data, options);
      this.resizeChart(chart, data, options);
    },
    getChartOptions: function (raw) {
      var options = {
        pieSliceText: 'value-and-percentage',
        chartArea: {
          width: '100%',
          height: '90%'
        },
        legend: {
          position: 'right',
          alignment: 'center'
        }
      };
      var colorMaps = {
        Completed: '#8bc34a',
        'In Progress': '#ffab40',
        'Not Started': '#bdbdbd',
        Verified: '#1378bb'
      };
      options.colors = raw.statuses.map(function (e) {
        return colorMaps[e[0]];
      });
      return options;
    },
    resizeChart: function (chart, data, options) {
      $(window).resize(function () {
        chart.draw(data, options);
      });
      setTimeout(function () {
        $(window).trigger('resize');
      }, 0);
    },
    setState: function (name, data, isLoading) {
      var instance = this.options.context.instance;
      instance.attr(name + '_total', data.total);
      instance.attr(name + '_any', data.total > 0);
      instance.attr(name + '_none', isLoading || data.total === 0);
      instance.attr(name + '_isLoading', isLoading);
      instance.attr(name + '_isLoaded', !isLoading);
    },
    parseStatuses: function (data) {
      var groups = _.groupBy(data.values, 'status');
      var pairs = _.pairs(groups);
      var sorted = _.sortBy(pairs, function (e) {
        return e[0];
      });
      var result = sorted.map(function (e) {
        var name = e[0];
        var count = e[1].length;
        return [name, count];
      });
      return {
        total: data.total,
        statuses: result
      };
    },
    getStatuses: function (type, auditId) {
      var query = GGRC.Utils.QueryAPI.buildParam(
        type,
        {},
        {id: auditId, type: 'Audit'},
        ['status']);
      return GGRC.Utils.QueryAPI.makeRequest({data: [query]});
    },
    loadChartLibrary: function (callback) {
      if (typeof google !== 'undefined' &&
          typeof google.charts !== 'undefined') {
        callback();
        return;
      }
      GGRC.Utils.loadScript('https://www.gstatic.com/charts/loader.js', function () {
        google.charts.load('45', {packages: ['corechart']});
        google.charts.setOnLoadCallback(callback);
      });
    }
  });
})(this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
can.Control('GGRC.Controllers.Modals', {
  BUTTON_VIEW_DONE: GGRC.mustache_path + '/modals/done_buttons.mustache',
  BUTTON_VIEW_CLOSE: GGRC.mustache_path + '/modals/close_buttons.mustache',
  BUTTON_VIEW_SAVE_CANCEL:
    GGRC.mustache_path + '/modals/save_cancel_buttons.mustache',
  BUTTON_VIEW_SAVE_CANCEL_DELETE:
    GGRC.mustache_path + '/modals/save_cancel_delete_buttons.mustache',
  BUTTON_VIEW_OK_CLOSE:
    GGRC.mustache_path + '/modals/confirm_cancel_buttons.mustache',

  defaults: {
    preload_view: GGRC.mustache_path + '/dashboard/modal_preload.mustache',
    content_view: GGRC.mustache_path + '/help/help_modal_content.mustache',
    header_view: GGRC.mustache_path + '/modals/modal_header.mustache',
    custom_attributes_view:
      GGRC.mustache_path + '/custom_attributes/modal_content.mustache',
    button_view: null,
    model: null,    // model class to use when finding or creating new
    instance: null, // model instance to use instead of finding/creating (e.g. for update)
    new_object_form: false,
    mapping: false,
    find_params: {},
    add_more: false,
    ui_array: [],
    reset_visible: false,
    isSaving: false  // is there a save/map operation currently in progress
  },

  init: function () {
    this.defaults.button_view = this.BUTTON_VIEW_DONE;
  }

  , confirm : function(options, success, dismiss) {
    var $target = $('<div class="modal hide"></div>');
    $target
    .modal({ backdrop: "static" })
    .ggrc_controllers_modals(can.extend({
      new_object_form : false
      , button_view : GGRC.mustache_path + "/modals/confirm_buttons.mustache"
      , modal_confirm : "Confirm"
      , modal_description : "description"
      , modal_title : "Confirm"
      , content_view : GGRC.mustache_path + "/modals/confirm.mustache"
    }, options))
    .on('click', 'a.btn[data-toggle=confirm]', function(e) {
      var params = $(e.target).closest('.modal').find('form').serializeArray();
      $target.modal('hide').remove();
      success && success(params, $(e.target).data('option'));
    })
    .on('click.modal-form.close', '[data-dismiss="modal"]', function() {
      $target.modal('hide').remove();
      dismiss && dismiss();
    });
  }
}, {
  init : function() {
    if (!(this.options instanceof can.Observe)) {
      this.options = new can.Observe(this.options);
    }

    if (!this.element.find(".modal-body").length) {
      can.view(this.options.preload_view, {}, this.proxy("after_preload"));
    } else {
      this.after_preload();
    }
    //this.options.attr("mapping", !!this.options.mapping);
  }
  , after_preload : function(content) {
    var that = this;
    if (content) {
      this.element.html(content);
    }
    CMS.Models.DisplayPrefs.getSingleton().then(function (display_prefs) {
      this.display_prefs = display_prefs;

      this.options.attr("$header", this.element.find(".modal-header"));
      this.options.attr("$content", this.element.find(".modal-body"));
      this.options.attr("$footer", this.element.find(".modal-footer"));
      this.on();
      this.fetch_all()
        .then(this.proxy("apply_object_params"))
        .then(this.proxy("serialize_form"))
        .then(function() {
          // If the modal is closed early, the element no longer exists
          that.element && that.element.trigger("preload");
        })
        .then(this.proxy("autocomplete"));
      this.restore_ui_status_from_storage();
    }.bind(this));
  },

  apply_object_params: function () {
    if (!this.options.object_params) {
      return;
    }
    this.options.object_params.each(function (value, key) {
      this.set_value({name: key, value: value});
    }, this);
  },

  'input[data-lookup] focus': function (el, ev) {
    this.autocomplete(el);
  },

  'input[data-lookup] keyup': function (el, ev) {
    // Set the transient field for validation
    var name;
    var instance;
    var value;

    // in some cases we want to disable automapping the selected item to the
    // modal's underlying object (e.g. we don't want to map the picked Persons
    // to an AssessmentTemplates object)
    if (el.data('no-automap')) {
      return;
    }

    name = el.attr('name').split('.');
    instance = this.options.instance;
    value = el.val();

    name.pop(); // set the owner to null, not the email

    if (!instance._transient) {
      instance.attr('_transient', new can.Observe({}));
    }

    can.reduce(name.slice(0, -1), function (current, next) {
      current = current + '.' + next;
      if (!instance.attr(current)) {
        instance.attr(current, new can.Observe({}));
      }
      return current;
    }, '_transient');

    if (name.length) {
      instance.attr(['_transient'].concat(name).join('.'), value);
    }
  },

  autocomplete: function (el) {
    $.cms_autocomplete.call(this, el);
  },
  autocomplete_select: function (el, event, ui) {
    var path;
    var instance;
    var index;
    var cb;
    $('#extended-info').trigger('mouseleave'); // Make sure the extra info tooltip closes

    path = el.attr('name').split('.');
    instance = this.options.instance;
    index = 0;
    path.pop(); // remove the prop
    cb = el.data('lookup-cb');

    if (cb) {
      cb = cb.split(' ');
      instance[cb[0]].apply(instance, cb.slice(1).concat([ui.item]));
      setTimeout(function () {
        el.val(ui.item.name || ui.item.email || ui.item.title, ui.item);
      }, 0);
      return;
    }

    if (/^\d+$/.test(path[path.length - 1])) {
      index = parseInt(path.pop(), 10);
      path = path.join('.');
      if (!instance.attr(path)) {
        instance.attr(path, []);
      }
      instance.attr(path).splice(index, 1, ui.item.stub());
    } else {
      path = path.join('.');
      setTimeout(function () {
        el.val(ui.item.name || ui.item.email || ui.item.title, ui.item);
      }, 0);
      instance.attr(path, null).attr(path, ui.item);
      if (!instance._transient) {
        instance.attr('_transient', can.Map());
      }
      instance.attr('_transient.' + path, ui.item);
    }
  },
  immediate_find_or_create: function(el, ev, data) {
    var that = this
    , prop = el.data("drop")
    , model = CMS.Models[el.data("lookup")]
    , params = { context : that.options.instance.context && that.options.instance.context.serialize ? that.options.instance.context.serialize() : that.options.instance.context };

    setTimeout(function() {
      params[prop] = el.val();
      el.prop("disabled", true);
      model.findAll(params).then(function(list) {
        if (list.length) {
          that.autocomplete_select(el, ev, { item : list[0] });
        } else {
          new model(params).save().then(function(d) {
            that.autocomplete_select(el, ev, { item : d });
          });
        }
      })
      .always(function() {
        el.prop("disabled", false);
      });
    }, 100);
  }
  , "input[data-lookup][data-drop] paste" : "immediate_find_or_create"
  , "input[data-lookup][data-drop] drop" : "immediate_find_or_create"
  , fetch_templates : function(dfd) {
    var that = this;
    dfd = dfd ? dfd.then(function() { return that.options; }) : $.when(this.options);
    return $.when(
      can.view(this.options.content_view, dfd)
      , can.view(this.options.header_view, dfd)
      , can.view(this.options.button_view, dfd)
      , can.view(this.options.custom_attributes_view, dfd)
    ).done(this.proxy('draw'));
  },

  fetch_data: function (params) {
    var that = this;
    var dfd;
    var instance = this.options.attr('instance');

    params = params || this.find_params();
    params = params && params.serialize ? params.serialize() : params;

    if (this.options.skip_refresh && instance) {
      return new $.Deferred().resolve(instance);
    } else if (instance) {
      dfd = instance.refresh();
    } else if (this.options.model) {
      if (this.options.new_object_form) {
        dfd = $.when(this.options.attr(
          'instance',
          new this.options.model(params).attr('_suppress_errors', true)
        )).then(function () {
          instance = this.options.attr('instance');
        }.bind(this));
      } else {
        dfd = this.options.model.findAll(params).then(function (data) {
          if (data.length) {
            that.options.attr('instance', data[0]);
            return data[0].refresh(); // have to refresh (get ETag) to be editable.
          }
          that.options.attr('new_object_form', true);
          that.options.attr('instance', new that.options.model(params));
          return instance;
        }).done(function () {
          // Check if modal was closed
          if (that.element !== null) {
            that.on(); // listen to instance.
          }
        });
      }
    } else {
      this.options.attr('instance', new can.Observe(params));
      that.on();
      dfd = new $.Deferred().resolve(instance);
    }

    dfd.then(function () {
      if (instance &&
        _.exists(instance, 'class.is_custom_attributable') &&
        !(instance instanceof CMS.Models.Assessment)) {
        return $.when(
          instance.load_custom_attribute_definitions &&
          instance.load_custom_attribute_definitions(),
          instance.custom_attribute_values ?
            instance.refresh_all('custom_attribute_values') :
            []
        );
      }
    });

    return dfd.done(function () {
      this.reset_form(function () {
        if (instance) {
          // Make sure custom attr validations/values are reset
          if (instance.setup_custom_attributes &&
            !(instance instanceof CMS.Models.Assessment)) {
            instance.removeAttr('custom_attributes');
            instance.setup_custom_attributes();
          }
        }
      });
    }.bind(that));
  },

  reset_form: function (setFieldsCb) {
    // If the modal is closed early, the element no longer exists
    if (this.element) {
      // Do the fields (re-)setting
      if (_.isFunction(setFieldsCb)) {
        setFieldsCb();
      }
      // This is to trigger `focus_first_element` in modal_ajax handling
      this.element.trigger('loaded');
    }
    if (!this.options.instance._transient) {
      this.options.instance.attr('_transient', new can.Observe({}));
    }
    if (this.options.instance.form_preload) {
      this.options.instance.form_preload(this.options.new_object_form,
                                            this.options.object_params);
    }
  }

  , fetch_all : function() {
    return this.fetch_templates(this.fetch_data(this.find_params()));
  }

  , find_params: function() {
    return this.options.find_params.serialize ? this.options.find_params.serialize() : this.options.find_params
  }

  , draw : function(content, header, footer, custom_attributes) {
    // Don't draw if this has been destroyed previously
    if (!this.element) {
      return;
    }
    var modal_title = this.options.modal_title,
        is_object_modal = modal_title && (modal_title.indexOf('Edit') === 0 || modal_title.indexOf('New') === 0);

    can.isArray(content) && (content = content[0]);
    can.isArray(header) && (header = header[0]);
    can.isArray(footer) && (footer = footer[0]);
    if (can.isArray(custom_attributes)) {
      custom_attributes = custom_attributes[0];
    }

    header != null && this.options.$header.find("h2").html(header);
    content != null && this.options.$content.html(content).removeAttr("style");
    footer != null && this.options.$footer.html(footer);

    if (custom_attributes != null && is_object_modal) {
      this.options.$content.append(custom_attributes);
    }
    this.setup_wysihtml5();

    //Update UI status array
    var $form = $(this.element).find('form');
    var tab_list = $form.find('[tabindex]');
    var hidable_tabs = 0;
    for (var i = 0; i < tab_list.length; i++) {
      if ($(tab_list[i]).attr('tabindex') > 0)
        hidable_tabs++;
    }
    //ui_array index is used as the tab_order, Add extra space for skipped numbers
    var storable_ui = hidable_tabs + 20;
    for (var i = 0; i < storable_ui; i++) {
      //When we start, all the ui elements are visible
      this.options.ui_array.push(0);
    }
  }

  , setup_wysihtml5 : function() {
    if (!this.element) {
      return;
    }
    this.element.find('.wysihtml5').each(function() {
      $(this).cms_wysihtml5();
    });
  }

  , "input:not(isolate-form input), textarea:not(isolate-form textarea), select:not(isolate-form select) change" : function(el, ev) {
      this.options.instance.removeAttr("_suppress_errors");
      // Set the value if it isn't a search field
      if (!el.hasClass("search-icon") ||
          el.is("[null-if-empty]") &&
          (!el.val() || !el.val().length)
      ) {
        this.set_value_from_element(el);
      }
  }
  , "input:not([data-lookup], isolate-form *), textarea keyup": function (el, ev) {
    // TODO: If statement doesn't work properly. This is the right one:
    //       if (el.attr('value').length ||
    //          (typeof el.attr('value') !== 'undefined' && el.val().length)) {
    if (el.prop('value').length === 0 ||
       (typeof el.attr('value') !== 'undefined' && !el.attr('value').length)) {
      this.set_value_from_element(el);
    }
  },

  /**
   * The onChange handler for the custom attribute type dropdown.
   *
   * This handler is specific to the Custom Attribute Edit modal.
   *
   * @param {jQuery} $el - the dropdown DOM element
   * @param {$.Event} ev - the event object
   */
  'dropdown[data-purpose="ca-type"] change': function ($el, ev) {
    var instance = this.options.instance;

    if (instance.attribute_type !== 'Dropdown') {
      instance.attr('multi_choice_options', undefined);
    }
  },

  serialize_form: function () {
    var $form = this.options.$content.find("form");
    var $elements = $form.find(":input:not(isolate-form *)");

    can.each($elements.toArray(), this.proxy("set_value_from_element"));
  },
  set_value_from_element: function (el) {
    var name;
    var value;
    var cb;
    var instance = this.options.instance;
    el = el instanceof jQuery ? el : $(el);
    name = el.attr('name');
    value = el.val();
    cb = el.data('lookup-cb');

    // If no model is specified, short circuit setting values
    // Used to support ad-hoc form elements in confirmation dialogs
    if (!this.options.model) {
      return;
    }
    // if data was populated in a callback, use that data from the instance
    // except if we are editing an instance and some fields are already populated
    if (!_.isUndefined(el.attr('data-populated-in-callback')) && value === '') {
      if (!_.isUndefined(instance[name])) {
        if (typeof instance[name] === 'object' && instance[name] !== null) {
          this.set_value({name: name, value: instance[name].id});
        } else {
          this.set_value({name: name, value: instance[name]});
        }
        return;
      }
    }
    if (cb) {
      cb = cb.split(' ');
      instance[cb[0]].apply(instance, cb.slice(1).concat([value]));
    } else if (name) {
      this.set_value({name: name, value: value});
    }
    if (el.is('[data-also-set]')) {
      can.each(el.data('also-set').split(','), function (oname) {
        this.set_value({name: oname, value: value});
      }, this);
    }
  },
  set_value: function (item) {
    var instance = this.options.instance;
    var name = item.name.split(".");
    var $elem;
    var value;
    var model;
    var $other;

    // Don't set `_wysihtml5_mode` on the instances
    if (item.name === '_wysihtml5_mode') {
      return;
    }

    if (!(instance instanceof this.options.model)) {
      instance = this.options.instance
               = new this.options.model(instance && instance.serialize ? instance.serialize() : instance);
    }
    $elem = this.options.$content.find("[name='" + item.name + "']:not(isolate-form *)");
    model = $elem.attr("model");

    if (model) {
      if (item.value instanceof Array) {
        value = can.map(item.value, function (id) {
          return CMS.Models.get_instance(model, id);
        });
      } else {
        value = CMS.Models.get_instance(model, item.value);
      }
    } else if ($elem.is("[type=checkbox]")) {
      value = $elem.is(":checked");
    } else {
      value = item.value;
    }

    if ($elem.is("[null-if-empty]") && (!value || !value.length)) {
      value = null;
    }

    if ($elem.is("[data-binding]") && $elem.is("[type=checkbox]")) {
      can.map($elem, function (el) {
        if (el.value !== value.id) {
          return;
        }
        if ($(el).is(":checked")) {
          instance.mark_for_addition($elem.data("binding"), value);
        } else {
          instance.mark_for_deletion($elem.data("binding"), value);
        }
      });
      return;
    } else if ($elem.is("[data-binding]")) {
      can.each(can.makeArray($elem[0].options), function (opt) {
        instance.mark_for_deletion(
          $elem.data("binding"),
          CMS.Models.get_instance(model, opt.value));
      });
      if (value.push) {
        can.each(value, $.proxy(
          instance,
          "mark_for_addition",
          $elem.data("binding")));
      } else {
        instance.mark_for_addition($elem.data("binding"), value);
      }
    }

    if (name.length > 1) {
      if (can.isArray(value)) {
        value = new can.Observe.List(can.map(value, function(v) { return new can.Observe({}).attr(name.slice(1).join("."), v); }));
      } else {
        if($elem.is("[data-lookup]")) {
          if(!value) {
            value = null;
          } else {
            // Setting a "lookup field is handled in the autocomplete() method"
            return;
          }
        } else if (name[name.length - 1] === "date") {
          name.pop(); //date is a pseudoproperty of datetime objects
          if(!value) {
            value = null;
          } else {
            value = this.options.model.convert.date(value);
            $other = this.options.$content.find("[name='" + name.join(".") + ".time']:not(isolate-form *)");
            if($other.length) {
              value = moment(value).add(parseInt($other.val(), 10)).toDate();
            }
          }
        } else if (name[name.length - 1] === "time") {
          name.pop(); //time is a pseudoproperty of datetime objects
          value = moment(this.options.instance.attr(name.join("."))).startOf("day").add(parseInt(value, 10)).toDate();
        } else {
          value = new can.Observe({}).attr(name.slice(1).join("."), value);
        }
      }
    }

    value = value && value.serialize ? value.serialize() : value;
    if ($elem.is('[data-list]')) {
      var list_path = name.slice(0, name.length-1).join(".")
        , cur = instance.attr(list_path)
        ;
      if (!cur || !(cur instanceof can.Observe.List)) {
        instance.attr(list_path, []);
        cur = instance.attr(list_path);
      }
      value = value || [];
      cur.splice.apply(cur, [0, cur.length].concat(value));
    } else {
      if (name[0] === "custom_attributes") {
        instance.custom_attributes.attr(name[1], value[name[1]]);
      } else if(name[0] !== "people") {
        instance.attr(name[0], value);
      }
    }
    this.setup_wysihtml5(); // in case the changes in values caused a new wysi box to appear.
  },
  "[data-before], [data-after] change": function (el, ev) {
    if (!el.data("datepicker")) {
      el.datepicker({changeMonth: true, changeYear: true});
    }
    var date = el.datepicker("getDate"),
        data = el.data(),
        options = {
          "before": "maxDate",
          "after": "minDate"
        };

    _.each(options, function (val, key) {
      if (!data[key]) {
        return;
      }
      var targetEl = this.element.find("[name=" + data[key] + "]"),
          isInput = targetEl.is("input"),
          targetDate = isInput ? targetEl.val() : targetEl.text(),
          otherKey;

      el.datepicker("option", val, targetDate);
      if (targetEl) {
        otherKey = key === "before" ? "after" : "before";
        targetEl.datepicker("option", options[otherKey], date);
      }
    }, this);
  },

  "{$footer} a.btn[data-toggle='modal-submit-addmore'] click" : function(el, ev){
    if (el.hasClass('disabled')) {
      return;
    }
    this.options.attr("add_more", true);
    this.save_ui_status();
    this.triggerSave(el, ev);
  }

  , "{$footer} a.btn[data-toggle='modal-submit'] click" : function(el, ev){
    if (el.hasClass('disabled')) {
      return;
    }
    this.options.attr("add_more", false);
    this.triggerSave(el, ev);
  }

  , "{$content} a.field-hide click" : function(el, ev) { //field hide
    var $el = $(el),
      $hidable = $el.closest('[class*="span"].hidable'),
      $innerHide = $el.closest('[class*="span"]').find('.hidable'),
      $showButton = $(this.element).find('#formRestore'),
      $hideButton = $(this.element).find('#formHide'),
      totalInner = $el.closest('.hide-wrap.hidable').find('.inner-hide').length,
      totalHidden;

      $el.closest('.inner-hide').addClass('inner-hidable');
      totalHidden = $el.closest('.hide-wrap.hidable').find('.inner-hidable').length;
      //$hidable.hide();
      $hidable.addClass("hidden");
      this.options.reset_visible = true;
      //update ui array
      var ui_unit = $hidable.find('[tabindex]');
      var i, tab_value;
      for (i = 0; i < ui_unit.length; i++) {
        tab_value = $(ui_unit[i]).attr('tabindex');
        if(tab_value > 0) {
          this.options.ui_array[tab_value-1] = 1;
          $(ui_unit[i]).attr('tabindex', '-1');
          $(ui_unit[i]).attr('uiindex', tab_value);
        }
      }

      if (totalInner == totalHidden) {
        $el.closest('.inner-hide').parent('.hidable').addClass("hidden");
      }

      $hideButton.hide();
      $showButton.show();
      return false;
  }

  , "{$content} #formHide click" : function(el, ev) {
    var i, ui_arr_length = this.options.ui_array.length,
        $showButton = this.element.find("#formRestore"),
        $hidables = this.element.find(".hidable"),
        hidden_elements = $hidables.find("[tabindex]");

    for (i = 0; i < ui_arr_length; i++) {
      this.options.ui_array[i] = 0;
    }

    this.options.reset_visible = true;

    $hidables.addClass("hidden");
    this.element.find(".inner-hide").addClass("inner-hidable");

    //Set up the hidden elements index to 1
    for (i = 0; i < hidden_elements.length; i++) {
      var $hidden_element = $(hidden_elements[i]),
          tab_value = $hidden_element.attr("tabindex");
      //The UI array index start from 0, and tab-index/io-index is from 1
      if(tab_value > 0){
        this.options.ui_array[tab_value-1] = 1;
        $hidden_element.attr({
          tabindex: "-1",
          uiindex: tab_value
        });
      }
    }

    el.hide();
    $showButton.show();
    return false;
  }

  , "{$content} #formRestore click" : function(el, ev) {
    //Update UI status array to initial state
    var i, ui_arr_length = this.options.ui_array.length,
        $form = this.element.find("form"),
        $body = $form.closest(".modal-body"),
        uiElements = $body.find("[uiindex]"),
        $hideButton = this.element.find("#formHide");

    for (i = 0; i < ui_arr_length; i++) {
      this.options.ui_array[i] = 0;
    }

    //Set up the correct tab index for tabbing
    //Get all the ui elements with 'uiindex' set to original tabindex
    //Restore the original tab index

    for (i = 0; i < uiElements.length; i++) {
      var $el = $(uiElements[i]);
      var tab_val = $el.attr("uiindex");
      $el.attr("tabindex", tab_val);
    }

    this.options.reset_visible = false;
    this.element.find(".hidden").removeClass("hidden");
    this.element.find(".inner-hide").removeClass("inner-hidable");
    el.hide();
    $hideButton.show();
    return false
  }

  , save_ui_status : function() {
    if (!this.options.model) {
      return;
    }
    var model_name = this.options.model.model_singular,
        reset_visible = this.options.reset_visible ? this.options.reset_visible : false,
        ui_array = this.options.ui_array ? this.options.ui_array : [],
        display_state = {
          reset_visible : reset_visible,
          ui_array : ui_array
        };

    this.display_prefs.setModalState(model_name, display_state);
    this.display_prefs.save();
  }

  , restore_ui_status_from_storage : function() {
    if (!this.options.model) {
      return;
    }
    var model_name = this.options.model.model_singular,
        display_state = this.display_prefs.getModalState(model_name);

    //set up reset_visible and ui_array
    if (display_state !== null) {
      if (display_state.reset_visible) {
        this.options.reset_visible = display_state.reset_visible;
      }
      if (display_state.ui_array) {
        this.options.ui_array = display_state.ui_array;
      }
    }
    this.restore_ui_status();
  }

  , restore_ui_status : function() {
    //walk through the ui_array, for the one values,
    //select the element with tab index and hide it

    if (this.options.reset_visible) {//some elements are hidden
      var $selected, str, tabindex, i,
          $form = this.element.find("form"),
          $body = $form.closest(".modal-body"),
          $hideButton = $form.find("#formHide"),
          $showButton = $form.find("#formRestore");

      for (i = 0; i < this.options.ui_array.length; i++) {
        if (this.options.ui_array[i] == 1) {
          tabindex = i + 1;
          str = "[tabindex=" + tabindex + "]";
          $selected = $body.find(str);

          if ($selected) {
            $selected.closest(".hidable").addClass("hidden");
            $selected.attr({
              uiindex: tabindex,
              tabindex: "-1"
            });
          }
        }
      }

      $hideButton.hide();
      $showButton.show();

      return false;
    }

  },

  //make buttons non-clickable when saving, make it disable afterwards
  bindXHRToButton_disable: function (xhr, el, newtext, disable) {
    // binding of an ajax to a click is something we do manually
    var $el = $(el),
        oldtext = $el.text();

    if (newtext) {
      $el[0].innerHTML = newtext;
    }
    $el.addClass("disabled pending-ajax");
    if (disable !== false) {
      $el.attr("disabled", true);
    }
    xhr.fail(function () {
        if ($el.length) {
          $el.removeClass("disabled");
        }
      }).always(function () {
        // If .text(str) is used instead of innerHTML, the click event may not fire depending on timing
        if ($el.length) {
          $el.removeAttr("disabled").removeClass("pending-ajax")[0].innerHTML = oldtext;
        }
      }.bind(this));
  },
  //make buttons non-clickable when saving
  bindXHRToBackdrop: function (xhr, el, newtext, disable) {
    // binding of an ajax to a click is something we do manually
    var $el = $(el),
        oldtext = $el.text(),
        alt;

    $el.addClass("disabled pending-ajax");
    if (disable !== false) {
      $el.attr("disabled", true);
    }
    xhr.always(function() {
      // If .text(str) is used instead of innerHTML, the click event may not fire depending on timing
      $el.removeAttr("disabled").removeClass("disabled pending-ajax");//[0].innerHTML = oldtext;
    });
  }

  , triggerSave: function (el, ev) {
    var ajd;
    var saveCloseBtn = this.element.find('a.btn[data-toggle=modal-submit]');
    var saveAddmoreBtn = this.element.find(
      'a.btn[data-toggle=modal-submit-addmore]');
    var modalBackdrop = this.element.data('modal_form').$backdrop;

    // Normal saving process
    if (el.is(':not(.disabled)')) {
      ajd = this.save_instance(el, ev);

      if (!ajd) {
        return;
      }

      this.options.attr('isSaving', true);

      ajd.always(function () {
        this.options.attr('isSaving', false);
      }.bind(this));

      if (this.options.add_more) {
        this.bindXHRToButton_disable(ajd, saveCloseBtn);
        this.bindXHRToButton_disable(ajd, saveAddmoreBtn);
        this.bindXHRToBackdrop(ajd, modalBackdrop, 'Saving, please wait...');
      } else {
        this.bindXHRToButton(ajd, saveCloseBtn, 'Saving, please wait...');
        this.bindXHRToButton(ajd, saveAddmoreBtn);
      }
    } else if (this._email_check) {
      // Queue a save if clicked after verifying the email address
      this._email_check.done(function (data) {
        if (!_.isNull(data.length) && !_.isUndefined(data.length)) {
          data = data[0];
        }
        if (data) {
          setTimeout(function () {
            delete this._email_check;
            el.trigger('click');
          }.bind(this), 0);
        }
      });
    }
  }

  , new_instance: function (data) {
    var wysihtml5;
    var params = this.find_params(),
        new_instance;
    new_instance = new this.options.model(params);
    new_instance.attr('_suppress_errors', true)
        .attr('custom_attribute_definitions', this.options.instance.custom_attribute_definitions)
        .attr('custom_attributes', new can.Map());

    // Reset custom attribute values manually
    can.each(new_instance.custom_attribute_definitions, function(definition) {
      var element = this.element.find('[name="custom_attributes.' + definition.id + '"]');
      if (definition.attribute_type === 'Checkbox') {
        element.attr('checked', false);
      } else if (definition.attribute_type === 'Rich Text') {
        // Check that wysihtml5 is still alive, otherwise just clean textarea
        wysihtml5 = element.data("wysihtml5");
        if (wysihtml5) {
          wysihtml5.editor.clear();
        } else {
          element.val('');
        }
      } else if (definition.attribute_type === 'Map:Person') {
        element = this.element.find('[name="_custom_attribute_mappings.' +
                                    definition.id + '.email"]');
        element.val('');
      } else {
        element.val('');
      }
    }, this);

    $.when(this.options.attr('instance', new_instance))
      .done(function () {
        this.reset_form(function () {
          var $form = $(this.element).find('form');
          $form.trigger('reset');
        });
      }.bind(this))
      .then(this.proxy("apply_object_params"))
      .then(this.proxy("serialize_form"))
      .then(this.proxy("autocomplete"));

    this.restore_ui_status();
  }

  , "save_instance" : function(el, ev) {
      var that = this,
        instance = this.options.instance,
        ajd,
        instance_id = instance.id;

      if (instance.errors()) {
        instance.removeAttr("_suppress_errors");
        return;
      }

      this.serialize_form();

      // Special case to handle context outside the form itself
      // - this avoids duplicated change events, and the API requires
      //   `context` to be present even if `null`, unlike other attributes
      if (!instance.context) {
        instance.attr('context', { id: null });
      }

      this.disable_hide = true;

      ajd = instance.save();
      ajd.fail(this.save_error.bind(this))
        .done(function (obj) {
          function finish() {
            delete that.disable_hide;
            if (that.options.add_more) {
              if (that.options.$trigger && that.options.$trigger.length) {
                that.options.$trigger.trigger("modal:added", [obj]);
              }
              that.new_instance();
            } else {
              that.element.trigger("modal:success", [obj, {map_and_save: $("#map-and-save").is(':checked')}]).modal_form("hide");
              that.update_hash_fragment();
            }
          }

          // If this was an Objective created directly from a Section, create a join
          var params = that.options.object_params;
          if (obj instanceof CMS.Models.Objective && params && params.section) {
            new CMS.Models.Relationship({
              source: obj,
              destination: CMS.Models.Section.findInCacheById(params.section.id),
              context: { id: null }
            }).save()
            .fail(that.save_error.bind(that))
            .done(function(){
              $(document.body).trigger("ajax:flash",
                  { success : "Objective mapped successfully." });
              finish();
            });
          } else {
            var type = obj.type ? can.spaceCamelCase(obj.type) : '',
                name = obj.title ? obj.title : '',
                msg;
            if (instance_id === undefined) { //new element
              if (obj.is_declining_review && obj.is_declining_review == '1') {
                msg = "Review declined";
              } else if (name) {
                msg = "New " + type + " " + name + " added successfully.";
              } else {
                msg = "New " + type + " added successfully.";
              }
            } else {
              msg = name + " modified successfully.";
            }
            $(document.body).trigger("ajax:flash", { success : msg });
            finish();
          }
        });
      this.save_ui_status();
      return ajd;
  },
  save_error: function (_, error) {
    $('html, body').animate({
      scrollTop: '0px'
    }, {
      duration: 200,
      complete: function () {
        if (error) {
          GGRC.Errors.notifier('error', error.responseText);
        }
        delete this.disable_hide;
      }.bind(this)
    });
  },

  '{instance} destroyed': ' hide',

  ' hide': function (el, ev) {
    var cad;
    if (this.disable_hide) {
      ev.stopImmediatePropagation();
      ev.stopPropagation();
      ev.preventDefault();
      return false;
    }
    if (this.options.instance instanceof can.Model &&
      // Ensure that this modal was hidden and not a child modal
      this.element && ev.target === this.element[0] &&
      !this.options.skip_refresh && !this.options.instance.isNew()) {
      if (this.options.instance.type === 'AssessmentTemplate') {
        cad = this.options.instance.attr('custom_attribute_definitions');
        cad = _.filter(cad, function (attr) {
          return attr.id;
        });
        this.options.instance.attr('custom_attribute_definitions', cad);
      }
      this.options.instance.refresh();
    }
  },

  destroy: function () {
    if (this.options.model && this.options.model.cache) {
      delete this.options.model.cache[undefined];
    }
    if (this._super) {
      this._super.apply(this, arguments);
    }
    if (this.options.instance && this.options.instance._transient) {
      this.options.instance.removeAttr('_transient');
    }
  },

  should_update_hash_fragment: function () {
    var $trigger = this.options.$trigger;

    if (!$trigger) {
      return false;
    }
    return !$trigger.closest('.modal, .cms_controllers_info_pin').length;
  },

  update_hash_fragment: function () {
    if (!this.should_update_hash_fragment()) return;

    var hash = window.location.hash.split('/')[0],
        tree_controller = this.options
            .$trigger
            .closest(".cms_controllers_tree_view_node")
            .control();

    hash += [tree_controller
             ? tree_controller.hash_fragment()
             : "",
             this.options.instance.hash_fragment()].join('/');

    hash = this.updateSummaryHash(hash, this.options.instance.type);
    window.location.hash = hash;
  },

  updateSummaryHash: function (hash, type) {
    var summary = 'Summary';
    var replacements = {
      Request: 'Request',
      Assessment: 'assessment'
    };
    var replacement = replacements[type];
    return replacement && hash.indexOf(summary) > 0 ?
        hash.replace(summary, replacement) :
        hash;
  }
});

/*
  Below this line we're defining a can.Component, which is in this file
  because it works in tandem with the modals form controller.

  The purpose of this component is to allow for pending adds/removes of connected
  objects while the modal is visible.  On save, the actual pending actions will
  be resolved and we won't worry about the transient state we use anymore.
*/
can.Component.extend({
  tag: "ggrc-modal-connector",
  // <content> in a component template will be replaced with whatever is contained
  //  within the component tag.  Since the views for the original uses of these components
  //  were already created with content, we just used <content> instead of making
  //  new view template files.
  template: "<isolate-form><content/></isolate-form>",
  scope: {
    parent_instance: null,
    instance: null,
    instance_attr: "@",
    source_mapping: "@",
    source_mapping_source: "@",
    default_mappings: [], // expects array of objects
    mapping: "@",
    deferred: "@",
    attributes: {},
    list: [],
    // the following are just for the case when we have no object to start with,
    changes: []
  },
  events: {
    init: function() {
      var that = this,
          key;

      this.scope.attr("controller", this);
      if (!this.scope.instance) {
        this.scope.attr("deferred", true);
      } else if (this.scope.instance.reify) {
        this.scope.attr("instance", this.scope.instance.reify());
      }

      this.scope.default_mappings.forEach(function (default_mapping) {
        if (default_mapping.id && default_mapping.type) {
          var model = CMS.Models[default_mapping.type];
          var object_to_add = model.findInCacheById(default_mapping.id);
          that.scope.instance.mark_for_addition("related_objects_as_source", object_to_add, {});
          that.scope.list.push(object_to_add);
        }
      });

      if (!this.scope.source_mapping) {
        this.scope.attr("source_mapping", this.scope.mapping);
      }
      if (!this.scope.source_mapping_source) {
        this.scope.source_mapping_source = 'instance';
      }
      if (this.scope[this.scope.source_mapping_source]) {
        this.scope[this.scope.source_mapping_source]
        .get_binding(this.scope.source_mapping)
        .refresh_instances()
        .then(function (list) {
          var current_list = this.scope.attr("list");
          this.scope.attr("list", current_list.concat(can.map(list, function (binding) {
            return binding.instance;
          })));
        }.bind(this));
        //this.scope.instance.attr("_transient." + this.scope.mapping, this.scope.list);
      } else {
        key = this.scope.instance_attr + "_" + (this.scope.mapping || this.scope.source_mapping);
        if (!this.scope.parent_instance._transient[key]) {
          this.scope.attr("list", []);
          this.scope.parent_instance.attr(
            "_transient." + key,
            this.scope.list
            );
        } else {
          this.scope.attr("list", this.scope.parent_instance._transient[key]);
        }
      }

      this.options.parent_instance = this.scope.parent_instance;
      this.options.instance = this.scope.instance;
      this.on();
    },
    "{scope} list": function () {
      // Workaround so we render pre-defined users.
      if (~['owners'].indexOf(this.scope.mapping) && this.scope.list && !this.scope.list.length) {
        var person = CMS.Models.Person.findInCacheById(GGRC.current_user.id);
        this.scope.instance.mark_for_addition(this.scope.mapping, person, {});
        this.scope.list.push(person);
      }
    },
    deferred_update: function () {
      var changes = this.scope.changes,
          instance = this.scope.instance;

      if (!changes.length) {
        if (instance && instance._pending_joins && instance._pending_joins.length) {
          instance.delay_resolving_save_until(instance.constructor.resolve_deferred_bindings(instance));
        }
        return;
      }
      this.scope.attr("instance", this.scope.attr("parent_instance").attr(this.scope.instance_attr).reify());
      can.each(
        changes,
        function(item) {
          var mapping = this.scope.mapping || GGRC.Mappings.get_canonical_mapping_name(this.scope.instance.constructor.shortName, item.what.constructor.shortName);
          if (item.how === "add") {
            this.scope.instance.mark_for_addition(mapping, item.what, item.extra);
          } else {
            this.scope.instance.mark_for_deletion(mapping, item.what);
          }
        }.bind(this)
      );
      this.scope.instance.delay_resolving_save_until(this.scope.instance.constructor.resolve_deferred_bindings(this.scope.instance));
    },
    "{parent_instance} updated": "deferred_update",
    "{parent_instance} created": "deferred_update",

    // this works like autocomplete_select on all modal forms and
    // descendant class objects.
    "autocomplete_select" : function(el, event, ui) {
      if (!this.element) {
        return;
      }

      var mapping, extra_attrs;
      extra_attrs = can.reduce(this.element.find("input:not([data-mapping], [data-lookup])").get(), function(attrs, el) {
        attrs[$(el).attr("name")] = $(el).val();
        return attrs;
      }, {});
      if (this.scope.attr("deferred")) {
        this.scope.changes.push({ what: ui.item, how: "add", extra: extra_attrs });
      } else {
        mapping = this.scope.mapping || GGRC.Mappings.get_canonical_mapping_name(this.scope.instance.constructor.shortName, ui.item.constructor.shortName);
        this.scope.instance.mark_for_addition(mapping, ui.item, extra_attrs);
      }
      function doesExist(arr, owner) {
        if (!arr || !arr.length) {
          return false;
        }
        return !!~can.inArray(owner.id, $.map(arr, function (item) {
          return item.id;
        }));
      }

      // If it's owners and user isn't pre-added
      if (!(~['owners'].indexOf(this.scope.mapping) && doesExist(this.scope.list, ui.item))) {
        this.scope.list.push(ui.item);
      }
      this.scope.attr('show_new_object_form', false);
    },
    '[data-toggle=unmap] click': function (el, ev) {
      ev.stopPropagation();
      can.map(el.find('.result'), function (result_el) {
        var obj = $(result_el).data('result'),
            len = this.scope.list.length,
            mapping;

        if (this.scope.attr("deferred")) {
          this.scope.changes.push({ what: obj, how: "remove" });
        } else {
          mapping = this.scope.mapping || GGRC.Mappings.get_canonical_mapping_name(this.scope.instance.constructor.shortName, obj.constructor.shortName);
          this.scope.instance.mark_for_deletion(mapping, obj);
        }
        for (; len >= 0; len--) {
          if (this.scope.list[len] === obj) {
            this.scope.list.splice(len, 1);
          }
        }
      }.bind(this));
    },
    "input[null-if-empty] change" : function(el) {
      if (!el.val()) {
        this.scope.attributes.attr(el.attr("name"), null);
      }
    },
    "input keyup" : function(el, ev) {
      ev.stopPropagation();
    },
    "input, textarea, select change": function (el, ev) {
      this.scope.attributes.attr(el.attr("name"), el.val());
    },

    "input:not([data-lookup], [data-mapping]), textarea keyup" : function(el, ev) {
      if (el.prop('value').length == 0 ||
        (typeof el.attr('value') !== 'undefined' && el.attr('value').length == 0)) {
        this.scope.attributes.attr(el.attr("name"), el.val());
      }
    },
    "a[data-toggle=submit]:not(.disabled) click": function(el, ev) {
      var obj, mapping,
          that = this,
          binding = this.scope.instance.get_binding(this.scope.mapping),
          extra_attrs = can.reduce(
                          this.element
                          .find("input:not([data-mapping], [data-lookup])")
                          .get(),
                          function(attrs, el) {
                            if ($(el).attr("model")) {
                              attrs[$(el).attr("name")] = CMS.Models[$(el).attr("model")].findInCacheById($(el).val());
                            } else {
                              attrs[$(el).attr("name")] = $(el).val();
                            }
                            return attrs;
                          }, {});

      ev.stopPropagation();

      extra_attrs[binding.loader.object_attr] = this.scope.instance;
      if(binding.loader instanceof GGRC.ListLoaders.DirectListLoader) {
        obj = new CMS.Models[binding.loader.model_name](extra_attrs);
      } else {
        obj = new CMS.Models[binding.loader.option_model_name](extra_attrs);
      }

      if (that.scope.attr("deferred")) {
        that.scope.changes.push({ what: obj, how: "add", extra: extra_attrs });
      } else {
        mapping = that.scope.mapping || GGRC.Mappings.get_canonical_mapping_name(that.scope.instance.constructor.shortName, obj.constructor.shortName);
        that.scope.instance.mark_for_addition(mapping, obj, extra_attrs);
      }
      that.scope.list.push(obj);
      that.scope.attr("attributes", {});
    },
    "a[data-object-source] modal:success": "addMapings",
    "defer:add": "addMapings",
    "addMapings": function(el, ev, data) {
      ev.stopPropagation();
      var mapping;

      can.each(data.arr || [data], function(obj) {
        if (this.scope.attr("deferred")) {
          this.scope.changes.push({ what: obj, how: "add" });
        } else {
          mapping = this.scope.mapping || GGRC.Mappings.get_canonical_mapping_name(this.scope.instance.constructor.shortName, obj.constructor.shortName);
          this.scope.instance.mark_for_addition(mapping, obj);
        }
        this.scope.list.push(obj);
      }, this);
    },
    ".ui-autocomplete-input modal:success" : function(el, ev, data, options) {
      var that = this,
          extra_attrs = can.reduce(
                          this.element
                          .find("input:not([data-mapping], [data-lookup])")
                          .get(),
                          function(attrs, el) {
                            if ($(el).attr("model")) {
                              attrs[$(el).attr("name")] = CMS.Models[$(el).attr("model")].findInCacheById($(el).val());
                            } else {
                              attrs[$(el).attr("name")] = $(el).val();
                            }
                            return attrs;
                          }, {});

      can.each(data.arr || [data], function(obj) {
        var mapping;
        if (that.scope.attr("deferred")) {
          that.scope.changes.push({ what: obj, how: "add", extra: extra_attrs });
        } else {
          mapping = that.scope.mapping || GGRC.Mappings.get_canonical_mapping_name(that.scope.instance.constructor.shortName, obj.constructor.shortName);
          that.scope.instance.mark_for_addition(mapping, obj, extra_attrs);
        }
        that.scope.list.push(obj);
        that.scope.attr("attributes", {});
      });
    }
  },
  helpers: {
    // Mapping-based autocomplete selectors use this helper to
    //  attach the mapping autocomplete ui widget.  These elements should
    //  be decorated with data-mapping attributes.
    mapping_autocomplete : function(options) {
      return function(el) {
        var $el = $(el);
        $el.ggrc_mapping_autocomplete({
          controller : options.contexts.attr("controller"),
          model : $el.data("model"),
          mapping : false
        });
      };
    }
  },
});
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $) {

GGRC.Controllers.Modals("GGRC.Controllers.Delete", {
    defaults: {
        skip_refresh: true
    }
}, {
  init : function() {
    this._super();
  }

  , "{$footer} a.btn[data-toggle=delete]:not(:disabled) click" : function(el, ev) {
    var that = this,
    // Disable the cancel button.
        cancel_button = this.element.find("a.btn[data-dismiss=modal]"),
        modal_backdrop = this.element.data("modal_form").$backdrop;

    this.bindXHRToButton(this.options.instance.refresh().then(function(instance) {
      return instance.destroy();
    }).then(function(instance) {
      // If this modal is spawned from an edit modal, make sure that one does
      // not refresh the instance post-delete.
      var parent_controller = $(that.options.$trigger).closest('.modal').control();
      var msg;
      if (parent_controller) {
        parent_controller.options.skip_refresh = true;
      }

      msg = instance.display_name() + " deleted successfully";
      $(document.body).trigger("ajax:flash", { success : msg});
      if (that.element) {
        that.element.trigger("modal:success", that.options.instance);
      }

      return new $.Deferred(); // on success, just let the modal be destroyed or navigation happen.
                               // Do not re-enable the form elements.

    }).fail(function(xhr, status){
      $(document.body).trigger("ajax:flash", { error : xhr.responseText });
    }), el.add(cancel_button).add(modal_backdrop));
  }

});

})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $) {

GGRC.Controllers.Modals("GGRC.Controllers.Help", {
  defaults : {
    content_view : GGRC.mustache_path + "/help/help_modal_content.mustache"
    , header_view : GGRC.mustache_path + "/help/help_modal_header.mustache"
    , model : CMS.Models.Help
    , edit_btn_active : false
  }
}, {
  init : function() {
    //this.options.edit_btn_active = can.compute(this.options.edit_btn_active);
    this._super();
  }

  , "{$content} input.btn[name='commit'] click" : function(el, ev) {
    if (!this.options.instance.context)
      this.options.instance.attr('context', { id: null });

    this.bindXHRToButton(this.options.instance.save().done(function() {
      $(document.body).trigger("ajax:flash", { success : "Help content saved successfully"});
    }), el);
  }

  , "{$header} .help-edit click" : function(el, ev) {
    var that = this;
    setTimeout(function() {
      that.options.edit_btn_active = that.options.$content.find("#helpedit").is(".in");
    }, 10);
  }

  , find_params : function() {
    return {slug : this.options.slug};
  }
});

})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//require can.jquery-all

(function(can, $, Mousetrap) {
  function with_params(href, params) {
    if (href.charAt(href.length - 1) === '?')
      return href + params;
    else if (href.indexOf('?') > 0)
      return href + '&' + params;
    else
      return href + '?' + params;
  }

  function get_attr(el, attrnames) {
    var attrval = null
    , $el = $(el);
    can.each(can.makeArray(attrnames), function(attrname) {
      var a = $el.attr(attrname);
      if(a) {
        attrval = a;
        return false;
      }
    });
    return attrval;
  }

CMS.Controllers.Filterable("CMS.Controllers.QuickSearch", {
  defaults : {
    list_view : GGRC.mustache_path + "/dashboard/object_list.mustache"
    , spin : true
    , tab_selector : 'ul.nav-tabs:first > li > a'
    , tab_href_attr : [ "href", "data-tab-href" ]
    , tab_target_attr : [ "data-tab-target", "href" ]
    , tab_model_attr : [ "data-model", "data-object-singular" ]
    , limit : null
  }
}, {

  setup : function(el, opts) {
    this._super && this._super.apply(this, arguments);
    if(!opts.observer) {
      opts.observer = new can.Observe();
    }
  }

  , init : function(opts) {
    var that = this;
    var $tabs = this.element.find(this.options.tab_selector);
    $tabs.each(function(i, tab) {
      var $tab = $(tab)
      , href = get_attr($tab, that.options.tab_href_attr)
      , loaded = $tab.data('tab-loaded')
      , pane = get_attr($tab, that.options.tab_target_attr)
      , $pane = $(pane)
      , template = $tab.data("template") || that.options.list_view
      , model_name = get_attr($tab, that.options.tab_model_attr)
      , model = can.getObject("CMS.Models." + model_name) || can.getObject("GGRC.Models." + model_name)
      , view_data = null
      , xhrs = {};

      if(!template && typeof console !== "undefined") {
        console.warn("No template defined for quick_search in ", $pane.attr("id"));
      }

      if(model && template) {
        view_data = new can.Observe({
          list: new model.List()
          , all_items: new model.List()
          , filtered_items: new model.List()
          , observer: that.options.observer
          , model : model
        });

        $tab.data("view_data", view_data);
        $tab.data("model", model);
        $pane.trigger("loading");
        model.findAll().done(function(data) {
          view_data.attr('all_items', data);
          view_data.attr('filtered_items', data.slice(0));
          if($tab.is("li.active a")) {
            can.Observe.startBatch();
            if(that.options.limit != null) {
              view_data.attr('list').replace(data.slice(0, that.options.limit));
            } else {
              view_data.attr('list', data);
            }
            can.Observe.stopBatch();
            $pane.trigger("loaded", xhrs[$pane.attr("id")], $tab.data("list"));
          } else {
            GGRC.queue_event(function() {
              if(that.options.limit != null) {
                view_data.attr('list').replace(data.slice(0, that.options.limit));
              } else {
                view_data.attr('list', data);
              }
              $pane.trigger("loaded", xhrs[$pane.attr("id")], $tab.data("list"));
            });
          }
          $tab.find(".item-count").html(data ? data.length : 0);
        });

        model.bind("created", function(ev, instance) {
          if(instance.constructor === model) {
            view_data.list.unshift(instance.serialize());
          }
        });
      }

      if(that.options.spin) {
        // Scroll up so spinner doesn't get pushed out of visibility
        $pane.scrollTop(0);
      }

      if (view_data) {
        can.view(template, view_data, function(frag, xhr) {
          $tab.data('tab-loaded', true);
          $pane.html(frag);
          xhrs[$pane.attr("id")] = xhr;
        });
      }
    });
  }

  , "{observer} value" : function(el, ev, newval) {
    this.filter(newval);
    this.element.trigger('kill-all-popovers');
  }

  , "{observer} my_work" : function(el, ev, newval) {
    this.filter(null, newval ? { "contact_id": GGRC.current_user.id } : null);
    this.element.trigger('kill-all-popovers');
  }

  // @override
  , redo_last_filter : function(id_to_add) {
    var that = this;
    var $tabs = $(this.element).find(this.options.tab_selector);
    var old_sel = this.options.filterable_items_selector;
    var old_ids = this.last_filter_ids;

    $tabs.each(function(i, tab) {
      var $tab = $(tab)
      , model = $tab.data("model")
      , res = old_ids ? that.last_filter.getResultsFor(model) : null
      , view_data = $tab.data("view_data");

      //that.options.filterable_items_selector = $(get_attr($tab, that.options.tab_href_attr)).find("li:not(.view-more, .add-new)");
      that.last_filter_ids = res = res ? can.unique(can.map(res, function(v) { return v.id; })) : null; //null is the show-all case
      if(res) {
        view_data.filtered_items.replace(can.map(view_data.all_items, function(item) { return ~can.inArray(item.id, res) ? item : undefined; }));
      } else {
        view_data.filtered_items.replace(view_data.all_items.slice(0));
      }
      view_data.list.replace(that.options.limit ? view_data.filtered_items.slice(0, that.options.limit) : view_data.filtered_items);

      //that._super();
      // res = can.map(res, function(obj, i) {
      //   var m = new model(obj);
      //   if(!m.selfLink) {
      //     m.refresh();
      //   }
      //   return m;
      // });
      $tab.find(".item-count").html(res ? res.length : $tab.data("view_data").filtered_items.length);
    });
  }

  , ".tabbable loaded" : function(el, ev) {
    $(el).scrollTop(0);
  }

  , ".nav-tabs li click" : function(el, ev) {
    var plural = el.children("a").attr("data-object-plural");
    var singular = can.map(window.cms_singularize(plural).split("_"), can.capitalize).join(" ");
    el.closest(".widget").find(".object-type").text(singular)
      .closest("a").attr("data-object-plural", plural.split(" ").join("_").toLowerCase())
      .attr("data-object-singular", singular.replace(" ", ""));
  }
});

can.Control("CMS.Controllers.LHN", {
    defaults: {
    }
}, {
    init: function() {
      var self = this
        ;

      this.obs = new can.Observe();

      this.init_lhn();

      // Set up a scroll handler to capture the current scroll-Y position on the
      // whole LHN search panel.  scroll events do not bubble, so this cannot be
      // set as a delegate on the controller element.
      self.lhs_holder_onscroll = _.debounce(function() {
        self.options.display_prefs.setLHNState({ "panel_scroll" : this.scrollTop });
      }, 250);
      this.element.find(".lhs-holder").on("scroll", self.lhs_holder_onscroll);
    }

  , is_lhn_open: function () {
      var _is_open = this.options.display_prefs.getLHNState().is_open;

      if (typeof _is_open === "undefined") {
          return false;
      }

      return _is_open;
  }

  , "input.widgetsearch keypress": function(el, ev) {
      var value;
      if (ev.which === 13) {
        ev.preventDefault();

        value = $(ev.target).val();
        this.do_search(value);
        this.toggle_filter_active();
      }
    }

  , "submit": function (el, ev) {
      ev.preventDefault();

      var value = $(ev.target).find("input.widgetsearch").val();
      this.do_search(value);
      this.toggle_filter_active();
  }

  , toggle_filter_active: function () {
      // Set active state to search field if the input is not empty:
      var $filter = this.element.find('.widgetsearch'),
          $button = this.element.find('.widgetsearch-submit'),
          $off = this.element.find('.filter-off'),
          $search_title = this.element.find(".search-title"),
          got_filter = !!$filter.val().trim().length;

      $filter.toggleClass("active", got_filter);
      $button.toggleClass("active", got_filter);
      $off.toggleClass("active", got_filter);
      $search_title.toggleClass("active", got_filter);
  }

  , ".filter-off a click": function (el, ev) {
    ev.preventDefault();

    this.element.find('.widgetsearch').val('');
    this.do_search('');
    this.toggle_filter_active();
  }

  , "a[data-name='work_type'] click": function(el, ev) {
      var target = $(ev.target),
          checked;

      checked = target.data('value') === 'my_work';
      this.obs.attr("my_work", checked);
        //target.closest('.btn')[checked ? 'addClass' : 'removeClass']('btn-success');
      this.options.display_prefs.setLHNState("my_work", checked);
      this.set_active_tab(checked);
    }

  , toggle_lhn: function (ev) {
      ev && ev.preventDefault();
      var is_open = this.is_lhn_open();

      if (is_open) {
          this.close_lhn();
      } else {
          this.open_lhn();
      }
  }

  , close_lhn: function () {
      if (this.options.display_prefs.getLHNState().is_pinned) {
        return;
      }

      // not nested
      $(".lhn-trigger").removeClass("active");

      var _width = this.options.display_prefs.getLHNavSize(null, null).lhs,
          width = _width || this.element.find(".lhs-holder").width(),
          safety = 20;

      this.element.find(".lhs-holder")
          .removeClass("active")
          .css("left", (-width-safety)+"px");

      this.element.find(".lhn-type")
          .removeClass("active")
          .css("left", (-width-safety)+"px");

      this.element.find(".bar-v")
          .removeClass("active");

      this.element.find(".lhs-search")
          .removeClass("active");

      this.options.display_prefs.setLHNState({is_open: false});
   },
  open_lhn: function () {
    var lhsCtr = $('#lhs').control();
    this.set_active_tab();

    // not nested
    $('.lhn-trigger').removeClass('hide').addClass('active');

    this.element.find('.lhs-holder')
      .css('left', '')
      .addClass('active');

    this.element.find('.lhn-type')
      .css('left', '')
      .addClass('active');

    this.element.find('.bar-v')
      .addClass('active');

    this.element.find('.lhs-search')
      .addClass('active');

    this.options.display_prefs.setLHNState({
      is_open: true
    });
    if (lhsCtr.options._hasPendingRefresh) {
      lhsCtr.refresh_counts();
      lhsCtr.refresh_visible_lists();
    }
  }

  , set_active_tab: function (newval) {
    newval || (newval = this.obs.attr("my_work"));

    var value = ["all", "my_work"][Number(newval)];
    $("a[data-name='work_type']").removeClass("active");
    $("a[data-name='work_type'][data-value='"+value+"'").addClass("active");
  }

  , init_lhn: function() {
      CMS.Models.DisplayPrefs.getSingleton().done(function(prefs) {
        var $lhs = $("#lhs"),
            lhn_search_dfd,
            my_work_tab = false;

        this.options.display_prefs = prefs;

        if (typeof prefs.getLHNState().my_work !== "undefined") {
          my_work_tab = !!prefs.getLHNState().my_work;
        }
        this.obs.attr("my_work", my_work_tab);

        lhn_search_dfd = $lhs
          .cms_controllers_lhn_search({
            observer: this.obs,
            display_prefs: prefs
          })
          .control('lhn_search')
          .display();

        $lhs.cms_controllers_lhn_tooltips();

        // Delay LHN initializations until after LHN is rendered
        lhn_search_dfd.then(function() {
          var checked = this.obs.attr('my_work'),
              value = checked ? "my_work" : "all",
              target = this.element.find('#lhs input.my-work[value='+value+']');

          target.prop('checked', true);
          target.closest('.btn')[checked ? 'addClass' : 'removeClass']('btn-success');

          // When first loading up, wait for the list in the open section to be loaded (if there is an open section), then
          //  scroll the LHN panel down to the saved scroll-Y position.  Scrolling the
          //  open section is handled in the LHN Search controller.

          if(this.options.display_prefs.getLHNState().open_category) {
            this.element.one("list_displayed", this.initial_scroll.bind(this));
          } else {
            this.initial_scroll();
          }

          this.toggle_filter_active();

          if (this.options.display_prefs.getLHNState().is_pinned) {
            this.pin();
          }
        }.bind(this));

        this.initial_lhn_render();
      }.bind(this));
    }
  , initial_scroll: function () {
    this.element.find(".lhs-holder").scrollTop(
        this.options.display_prefs.getLHNState().panel_scroll
        || 0
    );
  }
  // this uses polling to make sure LHN is there
  // requestAnimationFrame takes browser render optimizations into account
  // it ain't pretty, but it works
  , initial_lhn_render: function (try_count) {
    if (!$(".lhs-holder").size() || !$(".lhn-trigger").size()) {
      window.requestAnimationFrame(this.initial_lhn_render.bind(this));
      return;
    }

    // this is ugly, but the trigger doesn't nest inside our top element
    $(".lhn-trigger").on("click", this.toggle_lhn.bind(this));
    Mousetrap.bind("alt+m", this.toggle_lhn.bind(this));

    this.resize_lhn();
    this.open_lhn();
  }
  , lhn_width : function(){
    return $(".lhs-holder").width()+8;
  }
  , hide_lhn: function() {
    //UI-revamp
    //Here we should hide the button ||| also
      var $area = $(".area")
        , $lhsHolder = $(".lhs-holder")
        , $bar = $('.bar-v')
        , $lhnTrigger = $(".lhn-trigger")
        ;

      this.element.hide();
      $lhsHolder.css("width", 0);
      $area.css("margin-left", 0);
      $bar.hide();
      $lhnTrigger.hide();
      $lhnTrigger.addClass('hide')

      window.resize_areas();
    }

  , do_search: function (value) {
    var $search_title = this.element.find(".search-title");
    value = $.trim(value);
    if (this._value === value) {
      return;
    }
    $search_title.addClass("active");
    this.obs.attr("value", value);
    this.options.display_prefs.setLHNState("search_text", value);
    this._value = value;
  }

  , mousedown : false
  , dragged : false
  , resize_lhn : function(resize, no_trigger){
    resize || (resize = this.options.display_prefs && this.options.display_prefs.getLHNavSize(null, null).lhs);

    var max_width = window.innerWidth*.75,
        default_size = 240;

    if (resize < default_size) {
      resize = default_size;
    }
    resize = Math.min(resize, max_width);

    this.element.find(".lhs-holder").width(resize);

    if (resize) {
      this.options.display_prefs.setLHNavSize(null, "lhs", resize);
    }

    if (!no_trigger) {
      $(window).trigger("resize");
    }
  }
  , ".bar-v mousedown" : function(el, ev) {
    var $target = $(ev.target);
    this.mousedown = true;
    this.dragged = false;
  }
  , "{window} mousemove" : function(el, ev){
    if(!this.mousedown){
      return;
    }

    ev.preventDefault();
    this.dragged = true;

    if (!this.element.find(".bar-v").hasClass("disabled")) {
      this.resize_lhn(ev.pageX);
    }
  }
  , "{window} mouseup" : function(el, ev){
    var self = this;
    if(!this.mousedown) return;

    this.mousedown = false;
  }
  , "{window} resize" : function(el, ev) {
    this.resize_lhn(null, true); // takes care of height and min/max width
  }
  , "{window} mousedown": function (el, event) {
    var x = event.pageX,
        y = event.pageY;

    if (x === undefined || y === undefined) {
      return;
    }

    var on_lhn = [".lhn-trigger:visible", ".lhn-type:visible", ".lhs-holder:visible"]
            .reduce(function (yes, selector) {
                var $selector = $(selector),
                    bounds;

                if (!$selector.length) {
                  return;
                }

                bounds = $selector[0].getBoundingClientRect();

                return yes
                    || x >= bounds.left
                    && x <= bounds.right
                    && y >= bounds.top
                    && y <= bounds.bottom;
            }, false);

    // #extended-info - makes sure that menu doesn't close if tooltip is open and user has clicked inside
    // We should handle this form some manager, and avoid having God object
    if (!on_lhn && this.options.display_prefs && !this.options.display_prefs.getLHNState().is_pinned &&
        !$('#extended-info').hasClass('in')) {
      this.close_lhn();
    }
  }

  , destroy : function() {
    this.element.find(".lhs-holder").off("scroll", self.lhs_holder_onscroll);
    this._super && this._super.apply(this, arguments);
  }

  , ".lhn-pin click": function (element, event) {
    if (this.options.display_prefs.getLHNState().is_pinned) {
      this.unpin();
    }else{
      this.pin();
    }
  }

  , unpin: function () {
    this.element.find(".lhn-pin").removeClass("active");
    this.element.find(".bar-v").removeClass("disabled");
    this.options.display_prefs.setLHNState("is_pinned", false);
  }

  , pin: function () {
    this.element.find(".lhn-pin").addClass("active");
    this.element.find(".bar-v").addClass("disabled");
    this.options.display_prefs.setLHNState("is_pinned", true);
  }
});


can.Control("CMS.Controllers.InfiniteScroll", {
    defaults: {
    }
}, {
    init: function() {
    }

  , " DOMMouseScroll": "prevent_overscroll"
  , " mousewheel": "prevent_overscroll"
  , " scroll": "prevent_overscroll"

  , prevent_overscroll: function($el, ev) {
      // Based on Troy Alford's response on StackOverflow:
      //   http://stackoverflow.com/a/16324762
      var scrollTop = $el[0].scrollTop
        , scrollHeight = $el[0].scrollHeight
        , height = $el.height()
        , scrollTopMax = scrollHeight - height
        , delta
        , up
        , loadTriggerOffset = 50
        ;

      if (ev.type === "DOMMouseScroll")
        delta = ev.originalEvent.detail * -40;
      else
        delta = ev.originalEvent.wheelDelta;

      up = delta > 0;

      var prevent = function() {
        ev.stopPropagation();
        ev.preventDefault();
        ev.returnValue = false;
        return false;
      }

      if (ev.type === "scroll" &&
          scrollTop > scrollTopMax - loadTriggerOffset) {
        this.show_more($el);
        return prevent();
      } else if (!up && scrollTop - delta > scrollTopMax) {
        // Scrolling down, but this will take us past the bottom.
        $el.scrollTop(scrollHeight);
        this.show_more($el);
        return prevent();
      } else if (up && delta > scrollTop) {
        // Scrolling up, but this will take us past the top.
        $el.scrollTop(0);
        return prevent();
      } else if (!up && scrollTop - delta > scrollTopMax - loadTriggerOffset) {
        // Scrolling down, close to bottom, so start loading more
        this.show_more($el);
      }
    }

  , show_more: function($el) {
      this.element.trigger("scrollNext");
    }
});


can.Control("CMS.Controllers.LHN_Search", {
    defaults : {
        list_view : GGRC.mustache_path + "/base_objects/search_result.mustache"
      , actions_view : GGRC.mustache_path + "/base_objects/search_actions.mustache"
      , list_selector: 'ul.top-level > li, ul.mid-level > li'
      , list_toggle_selector: 'li > a.list-toggle'
      , model_attr_selector: null
      , model_attr: 'data-model-name'
      , model_extra_attr: 'data-model-extra'
      , count_selector: '.item-count'
      , list_mid_level_selector: 'ul.mid-level'
      , list_content_selector: 'ul.sub-level'
      , actions_content_selector: 'ul.sub-actions'
      , limit : 50
      , observer : null
      , filter_params: new can.Observe()
      , counts : new can.Observe()
    }
}, {
    display: function() {
      var self = this
        , prefs = this.options.display_prefs
        , prefs_dfd
        , template_path = GGRC.mustache_path + this.element.data('template')
        ;

      prefs_dfd = CMS.Models.DisplayPrefs.getSingleton();

      // 2-way binding is set up in the view using can-value, directly connecting the
      //  search box and the display prefs to save the search value between page loads.
      //  We also listen for this value in the controller
      //  to trigger the search.
      return can.view(template_path, prefs_dfd.then(function(prefs) { return prefs.getLHNState(); })).then(function(frag, xhr) {
        var lhn_prefs = prefs.getLHNState()
          , initial_term
          , initial_params = {}
          , saved_filters = prefs.getLHNState().filter_params
          ;

        self.element.html(frag);
        self.post_init();
        self.element.find(".sub-level")
          .cms_controllers_infinite_scroll()
          .on("scroll", _.debounce(function() {
            self.options.display_prefs.setLHNState("category_scroll", this.scrollTop);
          }, 250));

        initial_term = self.options.display_prefs.getLHNState().search_text || "";
        if (self.options.observer.my_work) {
          initial_params = { "contact_id": GGRC.current_user.id };
        }
        $.map(CMS.Models, function(model, name) {
          if (model.attributes && model.attributes.default_lhn_filters) {
            self.options.filter_params.attr(model.attributes.default_lhn_filters);
          }
        });
        self.options.filter_params.attr(saved_filters);
        self.options.loaded_lists = [];
        self.run_search(initial_term, initial_params);

        // Above, category scrolling is listened on to save the scroll position.  Below, on page load the
        //  open category is toggled open, and the search placed into the search box by display prefs is
        //  sent to the search service.

        if(lhn_prefs.open_category) {
          var selector = self.options.list_selector
                  .split(",")
                  .map(function(s) {
                      return s + " > a[data-object-singular=" + lhn_prefs.open_category + "]";
                  })
                  .join(",");

          self.toggle_list_visibility(
            self.element.find(selector)
          );
        }
      });
    },
    post_init: function () {
      var lhnCtr = $('#lhn').control();
      var refreshCounts = _.debounce(this.refresh_counts.bind(this), 1000, {
        leading: true,
        trailing: false
      });

      this.init_object_lists();
      this.init_list_views();

      can.Model.Cacheable.bind('created', function (ev, instance) {
        var modelNames;
        var modelName;

        if (instance instanceof can.Model.Join) {
          // Don't refresh LHN counts when joins are created
          return;
        }
        if (!lhnCtr.is_lhn_open()) {
          this.options._hasPendingRefresh = true;
          return;
        }
        modelNames = can.map(
          this.get_visible_lists(), this.proxy('get_list_model'));
        modelName = instance.constructor.shortName;

        if (modelNames.indexOf(modelName) > -1) {
          this.options.visible_lists[modelName].unshift(instance);
          this.options.results_lists[modelName].unshift(instance);
        }
        // Refresh the counts whenever the lists change
        refreshCounts();
      }.bind(this));
    }

  , "{list_toggle_selector} click": function (el, ev) {
      ev && ev.preventDefault();
      this.toggle_list_visibility(el);
  }

  , ensure_parent_open: function (el) {
      var $toggle = el.parents(this.options.list_mid_level_selector).parents("li").find("a.list-toggle.top"),
          $ul = $toggle.parent("li").find(this.options.list_mid_level_selector);

      if ($toggle.size() && !$toggle.hasClass("active")) {
          this.open_list($toggle, $ul, null, true);
      }
  }

  , toggle_list_visibility: function(el, dont_update_prefs) {
      var sub_selector = this.options.list_content_selector + ',' + this.options.actions_content_selector
        , mid_selector = this.options.list_mid_level_selector
        , $parent = el.parent("li")
        , selector
        ;

      if ($parent.find(mid_selector).size()) {
        selector = mid_selector;
      }else{
        selector = sub_selector;
      }

      var $ul = $parent.find(selector);

      // Needed because the `list_selector` selector matches the Recently Viewed
      // list, which will cause errors
      if ($ul.length < 1) {
        return;
      }

      if ($ul.is(":visible")) {
        this.close_list(el, $ul, dont_update_prefs);
      } else {
        this.open_list(el, $ul, selector, dont_update_prefs);
      }
    }

  , open_list: function (el, $ul, selector, dont_update_prefs) {
      // Use a cached max-height if one exists
      var holder = el.closest('.lhs-holder')
      , $content = $ul.filter([this.options.list_content_selector,
                               this.options.list_mid_level_selector].join(","))
      , $siblings = selector ? $ul.closest(".lhs").find(selector) : $(false)
      , extra_height = 0
      , top
      ;

      // Collapse other lists
      var $mids = $ul.closest(".lhs").find(this.options.list_mid_level_selector)
                    .not(el.parents(this.options.list_mid_level_selector))
                    .not(el.parent().find(this.options.list_mid_level_selector)),
          $non_children = $ul.closest(".lhs")
              .find([this.options.list_content_selector,
                     this.options.actions_content_selector].join(","))
              .filter(".in")
              .filter(function (i, el) {
                  return !$.contains($ul[0], el);
              });

      [$siblings, $mids, $non_children].map(function ($selection) {
          $selection.slideUp().removeClass("in");
      });

      // Expand this list
      $ul.slideDown().addClass("in");

      // Remove active classes from others
      // remove all except current element or children
      // this works because open_list is called twice if we ensure parent is open
      var $others = $ul.closest(".lhs").find(this.options.list_selector)
              .find("a.active")
              .not(el)
              .filter(function (i, el) {
                  return !$.contains($ul[0], el);
              });
      $others.removeClass("active");

      // Add active class to this list
      el.addClass("active");

      // Compute the extra height to add to the expandable height,
      // based on the size of the content that is sliding away.
      top = $content.offset().top;
      $siblings.filter(':visible').each(function() {
          var sibling_top = $(this).offset().top;
          if (sibling_top <= top) {
              extra_height += this.offsetHeight + (sibling_top < 0 ? -holder[0].scrollTop : 0);
          }
      });

      // Determine the expandable height
      this._holder_height = holder.outerHeight();
      if (!$ul.hasClass("mid-level")) {
        $content.filter(this.options.list_content_selector).css(
            'maxHeight',
            Math.max(160,
                     (this._holder_height - holder.position().top
                      + extra_height - top - 40))
        );
      }

      // Notify the display prefs that the category the user just opened is to be reopened on next page load.
      if (!dont_update_prefs) {
          this.options.display_prefs.setLHNState({ "open_category" : el.attr("data-object-singular") });
      }

      this.ensure_parent_open(el);
      this.on_show_list($ul);
  }

  , close_list: function (el, $ul, dont_update_prefs) {
      el.removeClass("active");
      $ul.slideUp().removeClass("in");
      // on closing a category, set the display prefs to reflect that there is no open category and no scroll
        //  for the next category opened.
      if (!dont_update_prefs) {
          this.options.display_prefs.setLHNState({ "open_category" : null, category_scroll : 0 });
      }
  }

  , " resize": function() {
      var $content = this.element.find([this.options.list_content_selector].join(",")).filter(':visible');


      if ($content.length) {
        var last_height = this._holder_height
          , holder = this.element.closest('.lhs-holder')
          ;
        this._holder_height = holder.outerHeight();


        $content.css(
            'maxHeight',
            Math.max(160,
                     (this._holder_height - last_height))
        );
      }
    }

  , on_show_list: function(el, ev) {
      var $list = $(el).closest(this.get_lists())
        , model_name = this.get_list_model($list)
        , tracker_stop = GGRC.Tracker.start("LHN_show_list", model_name)
        , that = this
        ;

      setTimeout(function() {
        that.refresh_visible_lists().done(tracker_stop);
      }, 20);
    }

  , "{observer} value" : function(el, ev, newval) {
      this.run_search(newval, this.current_params);
    }

  , "{observer} my_work" : function(el, ev, newval) {
    this.run_search(this.current_term, newval ? { "contact_id": GGRC.current_user.id } : null);
  }

  , ".sub-level scrollNext": "show_more"

  , show_more: function($el, ev) {
      if (this._show_more_pending)
        return;

      var that = this
        , $list = $el.closest(this.get_lists())
        , model_name = this.get_list_model($list)
        , visible_list = this.options.visible_lists[model_name]
        , results_list = this.options.results_lists[model_name]
        , refresh_queue
        , new_visible_list
        , tracker_stop = GGRC.Tracker.start("LHN", "show_more", model_name)
        ;

      if (visible_list.length >= results_list.length)
        return;

      this._show_more_pending = true;
      refresh_queue = new RefreshQueue();
      new_visible_list =
        //results_list.slice(0, visible_list.length + this.options.limit);
        results_list.slice(visible_list.length, visible_list.length + this.options.limit);

      can.each(new_visible_list, function(item) {
        refresh_queue.enqueue(item);
      });
      refresh_queue.trigger().then(function() {
        visible_list.push.apply(visible_list, new_visible_list);
        visible_list.attr('is_loading', false);
        //visible_list.replace(new_visible_list);
        delete that._show_more_pending;
      }).done(tracker_stop);
      visible_list.attr('is_loading', true);
    }

  , init_object_lists: function() {
      var self = this;
      if (!this.options.results_lists)
        this.options.results_lists = {};
      if (!this.options.visible_lists)
        this.options.visible_lists = {};

      can.each(this.get_lists(), function($list) {
        var model_name;
        $list = $($list);
        model_name = self.get_list_model($list);
        self.options.results_lists[model_name] = new can.Observe.List();
        self.options.visible_lists[model_name] = new can.Observe.List();
        self.options.visible_lists[model_name].attr('is_loading', true);
      });
    }

  , init_list_views: function() {
      var self = this;

      can.each(this.get_lists(), function($list) {
        var model_name;
        $list = $($list);
        model_name = self.get_list_model($list);

        var context = {
            model: CMS.Models[model_name]
          , filter_params: self.options.filter_params
          , list: self.options.visible_lists[model_name]
          , counts: self.options.counts
          , count: can.compute(function() {
              return self.options.results_lists[model_name].attr('length');
            })
        };

        can.view($list.data("template") || self.options.list_view, context, function(frag, xhr) {
          $list.find(self.options.list_content_selector).html(frag);

          // If this category we're rendering is the one that is open, wait for the
          //  list to finish rendering in the content pane, then set the scrolltop
          //  of the category to the stored value in display prefs.
          if(model_name === self.options.display_prefs.getLHNState().open_category) {
            $list.one("list_displayed", function() {
              $(this).find(self.options.list_content_selector).scrollTop(
                self.options.display_prefs.getLHNState().category_scroll || 0
              );
            });
          }
        });
        can.view($list.data("actions") || self.options.actions_view, context, function(frag, xhr) {
          $list.find(self.options.actions_content_selector).html(frag);
        });
      });
    }

  , get_list_model: function($list, count) {
      $list = $($list);
      if (this.options.model_attr_selector)
        $list = $list.find(this.options.model_attr_selector).first();
      if (count && $list.attr('data-count')) {
        return $list.attr('data-count');
      }
      return $list.attr(this.options.model_attr);
    }
  , get_extra_list_model: function($list) {
      $list = $($list);
      if (this.options.model_attr_selector)
        $list = $list.find(this.options.model_attr_selector).first();
      if(!$list.attr(this.options.model_extra_attr)) {
        return null;
      }
      var model = $list.attr(this.options.model_attr),
          extra = $list.attr(this.options.model_extra_attr).split(',');

      extra = $.map(extra, function(e){
        return e + "=" + model;
      }).join(',');
      return extra;
    }

  , display_counts: function(search_result) {
      var self = this;

      // Remove all current counts
      self.options.counts.each(function(val, key) {
          self.options.counts.removeAttr(key);
      });
      // Set the new counts
      self.options.counts.attr(search_result.counts);

      can.each(this.get_lists(), function($list) {
        var model_name, count;
        $list = $($list);
        model_name = self.get_list_model($list, true);
        if (model_name) {
          count = search_result.getCountFor(model_name);

          // Remove filter suffix (ie Workflow_All) from model_name before
          //  checking permissions
          model_name = model_name.split('_')[0];
          $list
            .find(self.options.count_selector)
            .text(count);
        }
      });
    }

  , display_lists: function(search_result, display_now) {
      var self = this
        , lists = this.get_visible_lists()
        , dfds = []
        , search_text = this.current_term
        , my_work = self.current_params && self.current_params.contact_id
        , extra_params = self.current_params && self.current_params.extra_params
        ;

      can.each(lists, function(list) {
        var dfd
          , $list = $(list)
          , model_name = self.get_list_model($list)
          , results = search_result.getResultsForType(model_name)
          , refresh_queue = new RefreshQueue()
          , initial_visible_list = null;
          ;

        self.options.results_lists[model_name].replace(results);
        initial_visible_list =
          self.options.results_lists[model_name].slice(0, self.options.limit);

        can.each(initial_visible_list, function(obj) {
          refresh_queue.enqueue(obj);
        });

        function finish_display(_) {
          can.Map.startBatch();
          self.options.visible_lists[model_name].attr('is_loading', false);
          self.options.visible_lists[model_name].replace(initial_visible_list);
          can.Map.stopBatch();
          setTimeout(function() {
            $list.trigger("list_displayed", model_name);
          }, 1);
        }
        dfd = refresh_queue.trigger().then(function(d) {
          new CMS.Models.LocalListCache({
            name : "search_" + model_name
            , objects : d
            , search_text : search_text
            , my_work : my_work
            , extra_params: extra_params
            , type : model_name
            , keys : ["title", "contact", "private", "viewLink"]
          }).save();
          return d;
        });
        if(display_now) {
          finish_display();
        } else {
          dfd = dfd.then(finish_display);
        }
        dfds.push(dfd);
      });

      return $.when.apply($, dfds);
    },

  refresh_counts: function () {
    var search_id = this.search_id;
    var models;
    var extraModels;

    if (!$('.lhn-trigger').hasClass('active')) {
      this.options._hasPendingRefresh = true;
      return can.Deferred().resolve();
    }


    models = can.map(this.get_lists(), this.proxy('get_list_model'));
    extraModels = can.map(
      this.get_lists(), this.proxy('get_extra_list_model'));

    this.options._hasPendingRefresh = false;
    // Retrieve and display counts
    return GGRC.Models.Search.counts_for_types(
        this.current_term, models, this.current_params, extraModels
      ).then(function () {
        if (this.search_id === search_id) {
          return this.display_counts.apply(this, arguments);
        }
      }.bind(this));
  },

  refresh_visible_lists: function() {
    var self = this;
    var search_id = this.search_id;
    var lists = this.get_visible_lists();
    var models = can.map(lists, this.proxy("get_list_model"));

    if (!$('.lhn-trigger').hasClass('active')) {
      this.options._hasPendingRefresh = true;
      return can.Deferred().resolve();
    }

    models = can.map(models, function(model_name) {
      if (self.options.loaded_lists.indexOf(model_name) == -1)
        return model_name;
    });

    if (models.length > 0) {
      // Register that the lists are loaded
      can.each(models, function(model_name) {
        self.options.loaded_lists.push(model_name);
      });

      $.when.apply(
        $
        , models.map(function(model_name) {
          return CMS.Models.LocalListCache.findAll({ "name" : "search_" + model_name});
        })
      ).then(function() {
        var types = {}, fake_search_result;
        can.each(can.makeArray(arguments), function(a) {
          var a = a[0];
          if (a
              && a.search_text == self.current_term
              && a.my_work == (self.current_params && self.current_params.contact_id)
              && a.extra_params == (self.current_params && self.current_params.extra_params)) {
            types[a.name] = a.objects;
          }
        });

        if (Object.keys(types).length > 0) {
          fake_search_result = {
            getResultsForType : function(type) {
              if(types["search_" + type]) {
                return types["search_" + type];
              }
            }
          };
          return fake_search_result;
        }
      }).done(function(fake_search_result) {
        if (fake_search_result)
          self.display_lists(fake_search_result, true);
      });

      return GGRC.Models.Search.search_for_types(
          this.current_term, models, this.current_params
        ).then(function() {
          if (self.search_id === search_id) {
            return self.display_lists.apply(self, arguments);
          }
        });
    } else {
      return new $.Deferred().resolve();
    }
  }

  , run_search: function(term, extra_params) {
      var self = this
        , tracker_stop = GGRC.Tracker.start(
          "LHN_run_search",
          extra_params && extra_params.contact_id ? "MyWork" : "Normal")
        , filter_list = [];

        ;
      if (term !== this.current_term || extra_params !== this.current_params) {
        // Clear current result lists
        can.each(this.options.results_lists, function(list) {
          list.replace([]);
        });
        can.each(this.options.visible_lists, function(list) {
          list.replace([]);
          list.attr('is_loading', true);
        });
        this.options.loaded_lists = [];

        //  `search_id` exists solely to provide a simple unique value for
        //  each search to ensure results are shown for the correct search
        //  parameters (avoiding a race condition with quick search term
        //  changes)
        this.search_id = (this.search_id || 0) + 1;
        this.current_term = term;
        this.current_params = extra_params || {};

        // Construct extra_params based on filters:
        delete this.current_params.extra_params;
        this.options.display_prefs.setLHNState("filter_params",
          this.options.filter_params);
        this.options.filter_params.each(function(obj, type) {
          var properties_list = [];
          obj.each(function(v, k){
            properties_list.push(k + "=" + v);
          });
          if (properties_list.length) {
            filter_list.push(type + ":" + properties_list.join(','));
          }
        });
        this.current_params.extra_params = filter_list.join(';');

        // Retrieve and display results for visible lists
        return $.when(
            this.refresh_counts(),
            this.refresh_visible_lists()
          ).done(tracker_stop);
      }
    }

  , get_lists: function() {
      return $.makeArray(
          this.element.find(this.options.list_selector));
    }

  , get_visible_lists: function() {
      var self = this;
      return can.map(this.get_lists(), function($list) {
        $list = $($list);
        if ($list.find([self.options.list_content_selector,
                        self.options.list_mid_level_selector].join(",")).hasClass('in'))
          return $list;
      });
    },

  ".filters a click" : function(el, ev) {
    var term = this.options.display_prefs.getLHNState().search_text || "",
        param = {},
        key = el.data('key'),
        value = el.data('value'),
        for_model = el.parent().data('for'),
        filters = this.options.filter_params;
    if (this.options.observer.my_work) {
      param = { "contact_id": GGRC.current_user.id };
    }

    if (el.hasClass('active')) {
      filters[for_model].removeAttr(key);
      this.run_search(term, param);
      return;
    }
    if (!(for_model in filters)) {
      filters.attr(for_model, {});
    }
    filters[for_model].attr(key, value);
    this.run_search(term, param);
  }
});


can.Control("CMS.Controllers.LHN_Tooltips", {
    defaults : {
        tooltip_view: GGRC.mustache_path + "/base_objects/extended_info.mustache"
      , trigger_selector: ".show-extended"
      , fade_in_delay: 300
      , fade_out_delay: 300
    }
}, {
    init: function() {
      if (!this.options.$extended) {
        this.options.$extended = $('#extended-info');
        if (this.options.$extended.length < 1)
          this.options.$extended =
            $('<div id="extended-info" class="extended-info hide" />')
              .appendTo('body');
      }
      if (!this.options.$lhs)
        this.options.$lhs = $('#lhs');
      // Renew event listening, since we assigned $extended, $lhs
      this.on();
    }

  // Tooltip / popover handling
  , "{trigger_selector} mouseenter": "on_mouseenter"
  , "{trigger_selector} mouseleave": "on_mouseleave"
  , "{$extended} mouseleave": "on_mouseleave"
  , "{$extended} mouseenter": "on_tooltip_mouseenter"

  , on_mouseenter: function(el, ev) {
      var instance = el.closest("[data-model]").data("model")
                      || el.closest(":data(model)").data("model")
        , delay = this.options.fade_in_delay
        ;

      // There isn't tooltip data available for recently viewed objects
      if (instance instanceof GGRC.Models.RecentlyViewedObject)
        return;

      if (this.options.$extended.data('model') !== instance) {
        clearTimeout(this.fade_in_timeout);
        // If tooltip is already showing, show new content without delay
        if (this.options.$extended.hasClass('in'))
          delay = 0;
        this.fade_in_timeout = setTimeout(
            this.proxy('on_fade_in_timeout', el, instance), delay);
        clearTimeout(this.fade_out_timeout);
        this.fade_out_timeout = null;
      } else if (this.fade_out_timeout) {
        clearTimeout(this.fade_out_timeout);
        this.fade_out_timeout = null;
      }
    }

  , ensure_tooltip_visibility: function() {
      var offset = this.options.$extended.offset().top
        , height = this.options.$extended.height()
        // "- 24" compensates for the Chrome URL display when hovering a link
        // "348" should be the widht of the Chrome URL display when displaying javascript://
        , window_height = $(window).height() + $(window).scrollTop() -
            (this.options.$extended.offset().left > 348 ? 0 : 24)
        , new_offset
        ;

      if (offset + height > window_height) {
        if (height > window_height)
          new_offset = 0;
        else
          new_offset = window_height - height;
        this.options.$extended.css({ top: new_offset });
      }
    }

  , get_tooltip_view: function(el) {
      var tooltip_view = $(el)
            .closest('[data-tooltip-view]').attr('data-tooltip-view');
      if (tooltip_view && tooltip_view.length > 0) {
        if (tooltip_view === "null") {
          return null;
        }
        else {
          return GGRC.mustache_path + tooltip_view;
        }
      }
      else {
        return this.options.tooltip_view;
      }
    }

  , on_fade_in_timeout: function(el, instance) {
      var self = this
        , tooltip_view = this.get_tooltip_view(el)
        ;

      if (tooltip_view) {
        this.fade_in_timeout = null;
        can.view(tooltip_view, { instance: instance }, function(frag) {

          var tooltip_width = self.options.$extended.outerWidth()
            , offset = el.parent().offset()
            , el_left = offset ? offset.left : 0
            , offset_left = el_left - tooltip_width > 0 ?
                el_left - tooltip_width : el_left + el.parent().width();

          self.options.$extended
            .html(frag)
            .addClass('in')
            .removeClass('hide')
            .css({ top: el.offset().top, left: offset_left })
            .data('model', instance);
          self.ensure_tooltip_visibility();
        });
      }
    }

  , on_tooltip_mouseenter: function() {
      clearTimeout(this.fade_out_timeout);
      this.fade_out_timeout = null;
    }

  , on_fade_out_timeout: function() {
      clearTimeout(this.fade_in_timeout);
      this.fade_in_timeout = null;
      this.fade_out_timeout = null;
      this.options.$extended
        .removeClass('in')
        .addClass('hide')
        .data('model', null);
    }

  , on_mouseleave: function(el, ev) {
      // Cancel fade_in, if we haven't displayed yet
      clearTimeout(this.fade_in_timeout);
      this.fade_in_timeout = null;

      clearTimeout(this.fade_out_timeout);
      this.fade_out_timeout =
        setTimeout(
            this.proxy("on_fade_out_timeout"),
            this.options.fade_out_delay);
    }
  , destroy: function() {
    this._super();
    this.on_mouseleave();
  }
});
})(this.can, this.can.$, Mousetrap);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $) {

can.Control("GGRC.Controllers.RecentlyViewed", {
  defaults : {
    list_view : GGRC.mustache_path + "/dashboard/recently_viewed_list.mustache"
    , max_history : 10
    , max_display : 3
  }
}, {
  init : function() {
    var page_model = GGRC.page_instance();
    var instance_list = [];
    var that = this;

    GGRC.Models.RecentlyViewedObject.findAll().done(function(objs) {
      var max_history = that.options.max_history;
      if(page_model) {
        instance_list.push(new GGRC.Models.RecentlyViewedObject(page_model));
        instance_list[0].save();
        max_history--;
      }

      for(var i = objs.length - 1; i >= 0; i--) {
        if((page_model && page_model.viewLink === objs[i].viewLink)
          || objs.length - i > max_history || !("viewLink" in objs[i])
          ) {
          objs.splice(i, 1)[0].destroy(); //remove duplicate of current page object or excessive objects
        } else if(instance_list.length < that.options.max_display) {
          instance_list.push(objs[i]);
        }
      }

      can.view(that.options.list_view, {list : instance_list}, function(frag) {
        that.element.find(".top-level.recent").html(frag);
      });
    });
  }
});

})(this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

// require can.jquery-all

function _firstElementChild(el) {
  var i;
  if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    for (i = 0; i < el.childNodes.length; i++) {
      if (el.childNodes[i].nodeType !== Node.TEXT_NODE) {
        return el.childNodes[i];
      }
    }
  } else {
    return el;
  }
}

if (!GGRC.tree_view) {
  GGRC.tree_view = new can.Map();
}
GGRC.tree_view.attr('basic_model_list', []);
GGRC.tree_view.attr('sub_tree_for', {});

function _display_tree_subpath(el, path, attempt_counter) {
  var rest = path.split('/');
  var type = rest.shift();
  var id = rest.shift();
  var selector = '[data-object-type=\'' + type + '\'][data-object-id=' + id + ']';
  var $node;
  var node_controller;
  var controller;

  if (!attempt_counter) {
    attempt_counter = 0;
  }

  rest = rest.join('/');

  if (type || id) {
    $node = el.find(selector);

    // sometimes nodes haven't loaded yet, wait for them
    if (!$node.size() && attempt_counter < 5) {
      setTimeout(function () {
        _display_tree_subpath(el, path, attempt_counter + 1);
      }, 100);
      return undefined;
    }

    if (!rest.length) {
      controller = $node
              .closest('.cms_controllers_tree_view_node')
              .control();

      if (controller) {
        controller.select();
      }
    } else {
      node_controller = $node.control();
      if (node_controller && node_controller.display_path) {
        return node_controller.display_path(rest);
      }
    }
  }
  return can.Deferred().resolve();
}

can.Map.extend('CMS.Models.TreeViewOptions', {
  defaults: {
    instance: undefined,
    parent: null,
    children_drawn: false
  }
}, {});

can.Control.extend('CMS.Controllers.TreeLoader', {
  defaults: {}
}, {
  init_spinner: function () {
    var spinner;
    var $spinner;
    var $footer;
    var $wrapper;
    var spinnerTopOffset = '40%';
    var elementOffset = $(window).height() - this.element.offset().top;

    if (this.element) {
      $footer = this.element.children('.tree-item-add').first();
      spinner = new Spinner({
        radius: 4,
        length: 4,
        width: 2
      }).spin();
      $spinner = $(spinner.el);
      if (this.options.is_subtree) {
        $wrapper = $('<li class="tree-item tree-spinner"/>');
      } else {
        $wrapper = $('<div class="tree-spinner"/>');
      }
      if (!this.options.is_subtree && !this.element.next().length) {
        $wrapper.css('height', '40px');
      }

      if (this.element.height() > elementOffset) {
        spinnerTopOffset = Math.floor(elementOffset / 2) + 'px';
      }

      $wrapper.append($spinner);
      $spinner.css({
        display: 'absolute',
        left: '50%',
        top: spinnerTopOffset
      });

      // Admin dashboard
      if ($footer.length === 0 &&
        this.element.children('.tree-structure').length > 0) {
        this.element.children('.tree-structure')
          .addClass('new-tree_loading').append($wrapper);
      } else if ($footer.length === 0) { // My work
        this.element.addClass('new-tree_loading').append($wrapper);
      } else {
        $footer.before($wrapper);
      }
    }
  },
  prepare: function () {
    if (this._prepare_deferred) {
      return this._prepare_deferred;
    }

    this._prepare_deferred = can.Deferred();
    this._prepare_deferred.resolve();

    this._attached_deferred.then(function () {
      if (!this.element) {
        return;
      }
      can.trigger(this.element, 'updateCount', [0, this.options.update_count]);
      this.init_count();
    }.bind(this));

    return this._prepare_deferred;
  },

  show_info_pin: function () {
    var children;
    var controller;
    if (this.element && !this.element.data('no-pin')) {
      children = this.element.children();
      controller = children && children.find('.select:visible')
              .first()
              .closest('.cms_controllers_tree_view_node')
              .control();

      if (controller) {
        controller.select();
      }
    }
  },

  display: function () {
    var that = this;
    var tracker_stop = GGRC.Tracker.start(
          'TreeView', 'display', this.options.model.shortName);
    // TODO: Currently Query API doesn't support CustomAttributable.
    var isCustomAttr = /CustomAttr/.test(this.options.model.shortName);
    var isTreeView = this instanceof CMS.Controllers.TreeView;
    // Use Query API only for first tier in TreeViewController
    var loader = !isTreeView || isCustomAttr ||
      this.options.attr('is_subtree') ?
        this.fetch_list.bind(this) : this.loadPage.bind(this);

    if (this._display_deferred) {
      return this._display_deferred;
    }

    this._display_deferred = $.when(this._attached_deferred, this.prepare());

    this._display_deferred = this._display_deferred
      .then(this._ifNotRemoved(function () {
        return $.when(loader(), that.init_view());
      }))
      .then(that._ifNotRemoved(that.proxy('draw_list')))
      .done(tracker_stop);

    return this._display_deferred;
  },

  draw_list: function (list, is_reload, force_prepare_children) {
    is_reload = is_reload === true;
    // TODO figure out why this happens and fix the root of the problem
    if (!list && !this.options.list) {
      return undefined;
    }
    if (this._draw_list_deferred) {
      return this._draw_list_deferred;
    }
    this._draw_list_deferred = can.Deferred();
    if (this.element && !this.element.closest('body').length) {
      return undefined;
    }

    if (list) {
      list = list.length === null ? new can.List([list]) : list;
    } else {
      list = this.options.list;
    }

    if (!this.element) {
      return undefined;  // controller has been destroyed
    }

    this.options.attr('original_list', list);
    this.options.attr('list', []);
    this.on();

    this._draw_list_deferred =
      this.enqueue_items(list, is_reload, force_prepare_children);
    return this._draw_list_deferred;
  },

  _loading_started: function () {
    var $contentContainer;

    if (!this._loading_deferred) {
      this._loading_deferred = can.Deferred();

      // for some reason, .closest(<selector>) does not work, thus need to use
      // using a bit less roboust .parent()
      $contentContainer = this.element.parent();
      $contentContainer
        .find('spinner[extra-css-class="initial-spinner"]')
        .remove();

      this.init_spinner();  // the tree view's own items loading spinner
      this.element.trigger('loading');
    }
  },

  _loading_finished: function () {
    var loading_deferred;
    if (this._loading_deferred) {
      this.element.trigger('loaded');
      this.element.find('.tree-spinner').remove();
      if (this.element.hasClass('new-tree_loading')) {
        this.element.removeClass('new-tree_loading');
      } else {
        this.element.find('.new-tree_loading').removeClass('new-tree_loading');
      }
      loading_deferred = this._loading_deferred;
      this._loading_deferred = null;
      loading_deferred.resolve();
    }
  },

  enqueue_items: function (items, is_reload, force_prepare_children) {
    var child_tree_display_list = [];
    var filtered_items = [];
    var i;
    var refreshed_deferred;
    var that = this;
    var parent_model_name;
    var parent_instance_type;
    is_reload = is_reload === true;

    // find current widget model and check if first layer tree
    if (GGRC.page_object && this.options.parent) { // this is a second label tree
      parent_model_name = this.options.parent.options.model.shortName;
      parent_instance_type = this.options.parent.options.instance.type;
      child_tree_display_list =
        (GGRC.tree_view.sub_tree_for[parent_model_name] ||
         GGRC.tree_view.sub_tree_for[parent_instance_type] ||
         {} // all hope is lost, skip filtering
        ).display_list;

      // check if no objects selected, then skip filter
      if (!child_tree_display_list) {
        // skip filter
        filtered_items = items;
      } else if (child_tree_display_list.length === 0) { // no item is selected to filter, so just return
        return can.Deferred().resolve();
      } else {
        for (i = 0; i < items.length; i++) {
          if (child_tree_display_list.indexOf(items[i].instance.class.model_singular) !== -1) {
            filtered_items.push(items[i]);
          }
        }
      }
    } else {
      filtered_items = items;
    }

    if (!this._pending_items) {
      this._pending_items = [];
      this._loading_started();
    }

    if (!is_reload) {
      refreshed_deferred = $.when.apply($,
        can.map(filtered_items, function (item) {
          var instance = item.instance || item;
          if (instance.custom_attribute_values &&
              !GGRC.Utils.Snapshots.isSnapshot(instance)) {
            return instance.refresh_all('custom_attribute_values').then(function (values) {
              var rq = new RefreshQueue();
              _.each(values, function (value) {
                if (value.attribute_object) {
                  rq.enqueue(value.attribute_object);
                }
              });
              return rq.trigger().then(function () {
                return values;
              });
            });
          }
        }));
    } else {
      refreshed_deferred = can.Deferred().resolve();
    }
    refreshed_deferred
      .then(function () {
        return that.insert_items(filtered_items, force_prepare_children);
      })
      .then(this._ifNotRemoved(this.proxy('_loading_finished')));

    return this._loading_deferred;
  },

  insert_items: function (items, force_prepare_children) {
    var that = this;
    var preppedItems = [];
    var idMap = {};
    var toInsert;
    var dfd;

    if (this.options.attr('is_subtree')) {
      // Check the list of items to be inserted for any duplicate items.
      can.each(this.options.list || [], function (item) {
        idMap[item.instance.type + item.instance.id] = true;
      });
      toInsert = _.filter(items, function (item) {
        return !idMap[item.instance.type + item.instance.id];
      });
    } else {
      toInsert = items;
    }

    can.each(toInsert, function (item) {
      var prepped = that.prepare_child_options(item, force_prepare_children);
      // Should we skip items without selfLink?
      if (prepped.instance.selfLink) {
        preppedItems.push(prepped);
      }
    });

    if (preppedItems.length > 0) {
      this.options.list.push.apply(this.options.list, preppedItems);
      dfd = this.add_child_lists(preppedItems);
    } else {
      dfd = can.Deferred().resolve();
    }

    return dfd;
  }
});

CMS.Controllers.TreeLoader.extend('CMS.Controllers.TreeView', {
  // static properties
  defaults: {
    model: null,
    header_view: GGRC.mustache_path + '/base_objects/tree_header.mustache',
    show_view: null,
    show_header: false,
    footer_view: null,
    add_item_view: null,
    parent: null,
    list: null,
    filteredList: [],
    single_object: false,
    find_params: {},
    paging: {
      current: 1,
      total: null,
      pageSize: 10,
      count: null,
      pageSizeSelect: [10, 25, 50],
      filter: null,
      sortDirection: null,
      sortBy: null,
      disabled: false
    },
    fields: [],
    sortable: true,
    start_expanded: false, // true
    draw_children: true,
    find_function: null,
    options_property: 'tree_view_options',
    allow_reading: true,
    allow_mapping: true,
    allow_creating: true,
    child_options: [], // this is how we can make nested configs. if you want to use an existing
    // example child option:
    // { property: "controls", model: CMS.Models.Control, }
    // { parent_find_param: "system_id" ... }
    scroll_page_count: 1, // pages above and below viewport
    is_subtree: false
  },
  do_not_propagate: [
    'header_view',
    'footer_view',
    'add_item_view',
    'list',
    'original_list',
    'single_object',
    'find_function',
    'find_all_deferred'
  ]
}, {
  // prototype properties
  setup: function (el, opts) {
    var defaultOptions;
    var optionsProperty;
    var defaults = this.constructor.defaults;
    if (typeof this._super === 'function') {
      this._super(el);
    }

    if (typeof (opts.model) === 'string') {
      opts.model = CMS.Models[opts.model];
    }
    optionsProperty = opts.options_property || defaults.options_property;
    defaultOptions = opts.model[optionsProperty] || {};

    this.options = new can.Map(defaults).attr(defaultOptions).attr(opts);
    if (opts instanceof can.Map) {
      this.options = can.extend(this.options, opts);
    }
  },
  deselect: function () {
    var active = this.element.find('.cms_controllers_tree_view_node.active');
    active
      .removeClass('active')
      .removeClass('maximized-info-pane');
    this.update_hash_fragment(active.length);
  },
  update_hash_fragment: function (status) {
    var hash;
    if (!status) {
      return;
    }
    hash = window.location.hash.split('/');
    hash.pop();
    window.location.hash = hash.join('/');
  },
  // Total display with is set to be span12.
  // Default: title: span4
  //          middle selectable: span4, by default 2 attributes are selected
  //          action: span4
  // When user selects 3 middle selectable attribute, title width is reduced to span3
  // and when user selects 4 attributes, the action column is also reduced to span3
  setup_column_width: function () {
    // Special case when import and export buttons should not be wisible for snapshots
    var snapshots = GGRC.Utils.Snapshots;
    var hideImportExport =
        snapshots.isSnapshotScope(this.options.parent_instance) &&
        snapshots.isSnapshotModel(this.options.model.model_singular);
    var display_options;
    var display_width = 12;
    var attr_count = this.options.display_attr_list.length;
    var nested = this.options.parent !== null;
    var widths = {
      defaults: [4, 4, 4],
      '0': [7, 1, 4],
      '3': [3, 5, 4],
      '4': [3, 6, 3],
      nested: [4, 0, 8]
    };
    var selected_widths = widths[attr_count] || widths.defaults;

    if (nested) {
      selected_widths = widths.nested;
    }

    display_options = {
      title_width: selected_widths[0],
      selectable_width: selected_widths[1],
      action_width: selected_widths[2],
      selectable_attr_width: display_width / Math.max(attr_count, 1),
      hideImportExport: hideImportExport
    };
    this.options.attr('display_options', display_options);
  },

  init_child_tree_display: function (model) {
    var model_name;
    var child_tree_model_list;
    var valid_models;
    var w_list;
    var sub_tree;
    if (!GGRC.page_object) { // Admin dashboard
      return;
    }

    // Set child tree options
    model_name = model.model_singular;
    child_tree_model_list = [];
    valid_models = can.Map.keys(GGRC.tree_view.base_widgets_by_type);

    w_list = GGRC.tree_view.base_widgets_by_type[model_name]; // possible widget/mapped model_list
    if (w_list === undefined) {
      child_tree_model_list = GGRC.tree_view.basic_model_list;
      GGRC.tree_view.sub_tree_for.attr(model_name, {
        model_list: child_tree_model_list,
        display_list: valid_models
      });
    }

    sub_tree = GGRC.tree_view.sub_tree_for[model_name];
    this.options.attr('child_tree_model_list', sub_tree.model_list);
    this.options.attr('selected_child_tree_model_list', sub_tree.model_list);
    this.options.attr('select_model_list', GGRC.tree_view.basic_model_list);
    this.options.attr('selected_model_name', model_name);
  },

  // Displays attribute list for tree-header, Select attribute list drop down
  // Gets default and custom attribute list for each model, and sets upthe display-list
  init_display_options: function (opts) {
    var i;
    var saved_attr_list;
    var select_attr_list = [];
    var display_attr_list = [];
    var model = opts.model;
    var model_name = model.model_singular;
    var model_definition = model().class.root_object;
    var mandatory_attr_names;
    var display_attr_names;
    var attr;

    // get standard attrs for each model
    can.each(model.tree_view_options.attr_list || can.Model.Cacheable.attr_list, function (item) {
      if (!item.attr_sort_field) {
        item.attr_sort_field = item.attr_name;
      }
      select_attr_list.push(item);
    });
    // Get mandatory_attr_names
    mandatory_attr_names = model.tree_view_options.mandatory_attr_names ?
      model.tree_view_options.mandatory_attr_names :
        can.Model.Cacheable.tree_view_options.mandatory_attr_names;

    // get custom attrs
    can.each(GGRC.custom_attr_defs, function (def, i) {
      var obj;
      if (def.definition_type === model_definition && def.attribute_type !== 'Rich Text') {
        obj = {};
        obj.attr_title = obj.attr_name = def.title;
        obj.display_status = false;
        obj.attr_type = 'custom';
        obj.attr_sort_field = obj.attr_name;
        select_attr_list.push(obj);
      }
    });

    // Get the display attr_list from local storage
    saved_attr_list = this.display_prefs.getTreeViewHeaders(model_name);

    if (!saved_attr_list.length) {
      // Initialize the display status, Get display_attr_names for model
      display_attr_names = model.tree_view_options.display_attr_names ?
        model.tree_view_options.display_attr_names :
          can.Model.Cacheable.tree_view_options.display_attr_names;

      for (i = 0; i < select_attr_list.length; i++) {
        attr = select_attr_list[i];

        attr.display_status = display_attr_names.indexOf(attr.attr_name) !== -1;
        attr.mandatory = mandatory_attr_names.indexOf(attr.attr_name) !== -1;
      }
    } else {
      // Mandatory attr should be always displayed in tree view
      can.each(mandatory_attr_names, function (attr_name) {
        saved_attr_list.push(attr_name);
      });

      for (i = 0; i < select_attr_list.length; i++) {
        attr = select_attr_list[i];
        attr.display_status = saved_attr_list.indexOf(attr.attr_name) !== -1;
        attr.mandatory = mandatory_attr_names.indexOf(attr.attr_name) !== -1;
      }
    }

    // Create display list
    can.each(select_attr_list, function (item) {
      if (!item.mandatory && item.display_status) {
        display_attr_list.push(item);
      }
    });

    this.options.attr('select_attr_list', select_attr_list);
    this.options.attr('display_attr_list', display_attr_list);
    this.setup_column_width();
    this.init_child_tree_display(model);
  },

  init: function (el, opts) {
    var setAllowMapping;

    this.element.closest('.widget')
      .on('widget_hidden', this.widget_hidden.bind(this));
    this.element.closest('.widget')
      .on('widget_shown', this.widget_shown.bind(this));
    CMS.Models.DisplayPrefs.getSingleton().then(function (display_prefs) {
      var allowed;
      // TODO: Currently Query API doesn't support CustomAttributable.
      var isCustomAttr = /CustomAttr/.test(this.options.model.shortName);

      this.display_prefs = display_prefs;
      this.options.filter_is_hidden = this.display_prefs.getFilterHidden();

      this.element.uniqueId();

      this.options.attr('is_subtree',
        this.element && this.element.closest('.inner-tree').length > 0);

      if (!this.options.attr('is_subtree') && !isCustomAttr) {
        this.page_loader = new GGRC.ListLoaders.TreePageLoader(this.options.model,
          this.options.parent_instance, this.options.mapping);
      }

      if ('parent_instance' in opts && 'status' in opts.parent_instance) {
        setAllowMapping = function () {
          var is_accepted = opts.parent_instance.attr('status') === 'Accepted';
          var admin = Permission.is_allowed('__GGRC_ADMIN__');
          this.options.attr('allow_mapping_or_creating', (admin || !is_accepted) &&
                            (this.options.allow_mapping || this.options.allow_creating));
        }.bind(this);
        setAllowMapping();
        opts.parent_instance.bind('change', setAllowMapping);
      } else {
        this.options.attr('allow_mapping_or_creating',
          this.options.allow_mapping || this.options.allow_creating);
      }

      if (this.element.parent().length === 0 || // element not attached
          this.element.data('disable-lazy-loading')) { // comment list
        this.options.disable_lazy_loading = true;
      }

      this.options.update_count =
        _.isBoolean(this.element.data('update-count')) ?
        this.element.data('update-count') :
        true;

      if (!this.options.scroll_element) {
        this.options.attr('scroll_element', $('.object-area'));
      }

      // Override nested child options for allow_* properties
      allowed = {};
      this.options.each(function (item, prop) {
        if (prop.indexOf('allow') === 0 && item === false) {
          allowed[prop] = item;
        }
      });
      this.options.attr('child_options', this.options.child_options.slice(0));
      can.each(this.options.child_options, function (options, i) {
        this.options.child_options.attr(i, new can.Map(can.extend(options.attr(), allowed)));
      }.bind(this));

      this.options.attr('filter_is_hidden', display_prefs.getFilterHidden());

      this._attached_deferred = can.Deferred();
      if (this.element && this.element.closest('body').length) {
        this._attached_deferred.resolve();
      }
      this.init_display_options(opts);
    }.bind(this));
    // Make sure the parent_instance is not a computable
    if (typeof this.options.parent_instance === 'function') {
      this.options.attr('parent_instance', this.options.parent_instance());
    }
  },

  ' inserted': function () { // eslint-disable-line quote-props
    this._attached_deferred.resolve();
  },

  init_view: function () {
    var dfds = [];

    if (this.options.header_view && this.options.show_header) {
      dfds.push(
        can.view(this.options.header_view, $.when(this.options)).then(
          this._ifNotRemoved(function (frag) {
            this.element.before(frag);
            // TODO: This is a workaround so we can toggle filter. We should refactor this ASAP.
            can.bind.call(
                this.element.parent().find('.filter-trigger > a'),
                'click',
                function () {
                  if (this.display_prefs.getFilterHidden()) {
                    this.show_filter();
                  } else {
                    this.hide_filter();
                  }
                }.bind(this)
            );

            can.bind.call(this.element.parent().find('.widget-col-title[data-field]'),
                          'click',
                          this.sort.bind(this)
                         );
            can.bind.call(this.element.parent().find('.set-tree-attrs'),
                          'click',
                          this.set_tree_attrs.bind(this)
                         );
            can.bind.call(this.element.parent().find('.set-display-object-list'),
                          'click',
                          this.set_tree_display_list.bind(this)
                         );
          }.bind(this))));
    }

    this.init_count();

    if (this.options.footer_view) {
      dfds.push(
        can.view(this.options.footer_view, this.options,
          this._ifNotRemoved(function (frag) {
            this.element.after(frag);
          }.bind(this))
        ));
    }
    return $.when.apply($.when, dfds);
  },

  init_count: function () {
    var self = this;
    var options = this.options;
    var counts;
    var countsName = options.counts_name || options.model.shortName;

    if (this.options.parent_instance && this.options.mapping) {
      counts = GGRC.Utils.QueryAPI.getCounts();

      if (self.element) {
        can.trigger(self.element, 'updateCount',
          [counts.attr(countsName), self.options.update_count]);
      }

      counts.on(countsName, function (ev, newVal, oldVal) {
        can.trigger(self.element, 'updateCount',
          [newVal, self.options.update_count]);
      });
    } else if (this.options.list_loader) {
      this.options.list_loader(this.options.parent_instance)
        .then(function (list) {
          return can.compute(function () {
            return list.attr('length');
          });
        })
        .then(function (count) {
          if (self.element) {
            can.trigger(self.element, 'updateCount', [count(),
              self.options.update_count]);
          }
          count.bind('change', self._ifNotRemoved(function () {
            can.trigger(self.element, 'updateCount', [count(),
              self.options.update_count]);
          }));
        });
    }
  },

  fetch_list: function () {
    if (this.find_all_deferred) {
      //  Skip, because already done, e.g., display() already called
      return this.find_all_deferred;
    }
    if (can.isEmptyObject(this.options.find_params.serialize())) {
      this.options.find_params.attr(
        'id', this.options.parent_instance ? this.options.parent_instance.id : undefined);
    }

    if (this.options.mapping) {
      if (this.options.parent_instance === undefined) {
        // TODO investigate why is this method sometimes called twice
        return undefined; // not ready, will try again
      }
      this.find_all_deferred =
        this.options.parent_instance.get_list_loader(this.options.mapping);
    } else if (this.options.list_loader) {
      this.find_all_deferred =
        this.options.list_loader(this.options.parent_instance);
    } else {
      console.debug('Unexpected code path', this);
    }

    return this.find_all_deferred;
  },

  display_path: function (path) {
    return this.display().then(this._ifNotRemoved(function () {
      return _display_tree_subpath(this.element, path);
    }.bind(this)));
  },

  prepare_child_options: function (v, force_reload) {
    //  v may be any of:
    //    <model_instance>
    //    { instance: <model instance>, mappings: [...] }
    //    <TreeOptions>
    var tmp;
    var that = this;
    var original = v;
    if (v._child_options_prepared && !force_reload) {
      return v._child_options_prepared;
    }
    if (!(v instanceof CMS.Models.TreeViewOptions)) {
      tmp = v;
      v = new CMS.Models.TreeViewOptions();
      v.attr('instance', tmp);
      this.options.each(function (val, k) {
        if (can.inArray(k, that.constructor.do_not_propagate) === -1) {
          v.attr(k, val);
        }
      });
    }
    if (!(v.instance instanceof can.Model)) {
      if (v.instance.instance instanceof can.Model) {
        v.attr('result', v.instance);
        v.attr('mappings', v.instance.mappings_compute());
        v.attr('instance', v.instance.instance);
      } else {
        v.attr('instance', this.options.model.model(v.instance));
      }
    }
    v.attr('child_count', can.compute(function () {
      var total_children = 0;
      if (v.attr('child_options')) {
        can.each(v.attr('child_options'), function (child_options) {
          var list = child_options.attr('list');
          if (list) {
            total_children += list.attr('length');
          }
        });
      }
      return total_children;
    }));
    original._child_options_prepared = v;
    return v;
  },
  el_position: function (el) {
    var se = this.options.scroll_element;
    var se_o = se.offset().top;
    var se_h = se.outerHeight();
    var el_o;
    var el_h;
    var above_top;
    var below_bottom;
    if (!(el instanceof jQuery)) {
      el = $(el);
    }
    if (!el.offset()) {
      return 0;
    }
    el_o = el.offset().top;
    el_h = el.outerHeight();
    above_top = (el_o + el_h - se_o) / se_h;
    below_bottom = (el_o - se_o) / se_h - 1;
    if (above_top < 0) {
      return above_top;
    } else if (below_bottom > 0) {
      return below_bottom;
    }
    return 0;
  },
  draw_visible_call_count: 0,
  draw_visible: _.debounce(function () {
    var MAX_STEPS = 100;
    var elPosition;
    var children;
    var lo;
    var hi;
    var max;
    var steps;
    var visible;
    var alreadyVisible;
    var toRender;
    var i;
    var control;
    var index;
    var pageCount;
    var mid;
    var pos;
    var options = this.options;

    if (options.disable_lazy_loading ||
        !this.element ||
        options.attr('drawingItems')) {
      return;
    }

    elPosition = this.el_position.bind(this);
    children = options.attr('filteredList') || [];

    if (!children.length || !children[0].element) {
      return;
    }

    lo = 0;
    hi = children.length - 1;
    max = hi;
    steps = 0;
    visible = [];
    toRender = [];

    alreadyVisible = _.filter(children, function (child) {
      return !child.options.attr('isPlaceholder');
    });

    while (steps < MAX_STEPS && lo < hi) {
      steps += 1;
      mid = (lo + hi) / 2 | 0;
      pos = elPosition(children[mid].element);
      if (pos < 0) {
        lo = mid;
        continue;
      }
      if (pos > 0) {
        hi = mid;
        continue;
      }
      lo = mid;
      hi = mid;
    }
    pageCount = options.scroll_page_count;
    while (lo > 0 && elPosition(children[lo - 1].element) >= (-pageCount)) {
      lo -= 1;
    }
    while (hi < max && elPosition(children[hi + 1].element) <= pageCount) {
      hi += 1;
    }

    _.each(alreadyVisible, function (control) {
      if (!control) {
        return;
      }
      if (Math.abs(elPosition(control.element)) <= pageCount) {
        visible.push(control);
      } else {
        control.draw_placeholder();
      }
    });

    for (i = lo; i <= hi; i++) {
      index = this._is_scrolling_up ? (hi - (i - lo)) : i;
      control = children[index];
      if (!control) {
        // TODO this should not be necessary
        // draw_visible is called too soon when controllers are not yet
        // available and then again when they are. Remove the too soon
        // invocation and this continue can be dropped too.
        continue;
      }
      if (!_.contains(visible, control)) {
        visible.push(control);
        toRender.push(control);
      }
    }
    this.renderStep(toRender, ++this.draw_visible_call_count);
  }, 100, {leading: true}),
  renderStep: function renderStep(toRender, count) {
    // If there is nothing left to render or if draw_visible was run while
    // rendering we simply terminate.
    if (toRender.length === 0 || this.draw_visible_call_count > count) {
      return;
    }
    toRender[0].draw_node();
    setTimeout(function () {
      renderStep(toRender.slice(1), count);
    }, 0);
  },
  _last_scroll_top: 0,

  _is_scrolling_up: false,

  '{scroll_element} scroll': function (el, ev) {
    this._is_scrolling_up = this._last_scroll_top > el.scrollTop();
    this._last_scroll_top = el.scrollTop();
    this.draw_visible();
  },

  '{scroll_element} resize': function (el, ev) {
    setTimeout(this.draw_visible.bind(this), 0);
  },

  '.tree-item-placeholder click': function (el, ev) {
    var node = el.control();
    node.draw_node();
    node.select();
  },

  '{original_list} add': function (list, ev, newVals, index) {
    var that = this;
    var real_add = [];

    can.each(newVals, function (newVal) {
      var _newVal = newVal.instance ? newVal.instance : newVal;
      if (that.oldList && ~can.inArray(_newVal, that.oldList)) {
        that.oldList.splice(can.inArray(_newVal, that.oldList), 1);
      } else if (that.element) {
        real_add.push(newVal);
      }
    });
    this.enqueue_items(real_add);
  },

  '{original_list} remove': function (list, ev, oldVals, index) {
    var remove_marker = {}; // Empty object used as unique marker
    var removedObjectType;
    var skipInfoPinRefresh = false;

    //  FIXME: This assumes we're replacing the entire list, and corrects for
    //    instances being removed and immediately re-added.  This should be
    //    changed to support exact mirroring of the order of
    //    `this.options.list`.
    if (!this.oldList) {
      this.oldList = [];
    }
    this.oldList.push.apply(
        this.oldList,
        can.map(oldVals, function (v) {
          return v.instance ? v.instance : v;
        }));

    // If a removed object is a Document or a Person, it is likely that it
    // was removed from the info pin, thus refreshing the latter is not needed.
    // The check will fail, though, if the info pane was displaying a person
    // located in a subtree, and we unmapped that person from the object
    // displayed in the parent tree view node.
    if (oldVals.length === 1 && oldVals[0].instance) {
      removedObjectType = oldVals[0].instance.type;
      if (removedObjectType === 'Person' || removedObjectType === 'Document') {
        skipInfoPinRefresh = true;
      }
    }

    // `remove_marker` is to ensure that removals are not attempted until 20ms
    //   after the *last* removal (e.g. for a series of removals)
    this._remove_marker = remove_marker;
    setTimeout(this._ifNotRemoved(function () {
      if (this._remove_marker === remove_marker) {
        can.each(this.oldList, function (v) {
          this.element.trigger('removeChild', v);
        }.bind(this));
        this.oldList = null;
        this._remove_marker = null;

        if (skipInfoPinRefresh) {
          return;
        }

        // TODO: This is a workaround. We need to update communication between
        //       info-pin and tree views through Observer
        if (!this.element.closest('.cms_controllers_info_pin').length) {
          $('.cms_controllers_info_pin').control().unsetInstance();
        }
        this.show_info_pin();
      }
    }.bind(this)), 200);
  },

  '.tree-structure subtree_loaded': function (el, ev) {
    var instance_id;
    var parent;
    ev.stopPropagation();
    instance_id = el.closest('.tree-item').data('object-id');
    parent = can.reduce(this.options.list, function (a, b) {
      switch (true) {
        case !!a : return a;
        case b.instance.id === instance_id: return b;
        default: return null;
      }
    }, null);
    if (parent && !parent.children_drawn) {
      parent.attr('children_drawn', true);
    }
  },
  // add child options to every item (TreeViewOptions instance) in the drawing list at this level of the tree.
  add_child_lists: function (list) {
    var that = this;
    var currentList = can.makeArray(list);
    var listWindow = [];
    var finalDfd;
    var queue = [];
    var BATCH = 200;
    var opId = this._add_child_lists_id = (this._add_child_lists_id || 0) + 1;

    can.each(currentList, function (item) {
      listWindow.push(item);
      if (listWindow.length >= BATCH) {
        queue.push(listWindow);
        listWindow = [];
      }
    });
    if (listWindow.length > 0) {
      queue.push(listWindow);
    }
    this.options.attr('filter_shown', 0);
    this.options.attr('filteredList', []);
    finalDfd = _.foldl(queue, function (dfd, listWindow) {
      return dfd.then(function () {
        var res = can.Deferred();
        if (that._add_child_lists_id !== opId) {
          return dfd;
        }
        setTimeout(function () {
          var draw;
          var drawDfd;
          if (that._add_child_lists_id !== opId) {
            return;
          }
          draw = that._ifNotRemoved(that.draw_items.bind(that));

          drawDfd = draw(listWindow);

          if (drawDfd) {
            drawDfd.then(res.resolve);
          } else {
            res.resolve();
          }
        }, 0);
        return res;
      });
    }, can.Deferred().resolve());

    finalDfd.done(this._ifNotRemoved(function () {
      var shown = this.element[0].children.length;
      var count = this.options.list.length;
      // We need to hide `of` in case the numbers are same
      if (shown === count && shown > 0) {
        shown = false;
      } else {
        shown = shown.toString();
      }
      this.options.attr('filter_shown', shown);
      this.options.attr('filter_count', count.toString());
      this.element.parent().find('.sticky').Stickyfill();
    }.bind(this)));
    return finalDfd;
  },
  draw_items: function (optionsList) {
    var items;
    var $footer = this.element.children('.tree-item-add').first();
    var drawItemsDfds = [];
    var filteredItems = this.options.attr('filteredList') || [];
    var res;

    items = can.makeArray(optionsList);

    items = _.map(items, function (options) {
      var control;
      var elem = document.createElement('li');
      if (this.options.disable_lazy_loading) {
        options.disable_lazy_loading = true;
      }
      control = new CMS.Controllers.TreeViewNode(elem, options);
      drawItemsDfds.push(control._draw_node_deferred);
      filteredItems.push(control);
      return control.element[0];
    }.bind(this));

    if ($footer.length) {
      $(items).insertBefore($footer);
    } else {
      this.element.append(items);
    }
    if (this.options.sortable) {
      $(this.element).sortable({element: 'li.tree-item', handle: '.drag'});
    }
    this.options.attr('filteredList', filteredItems);
    res = $.when.apply($, drawItemsDfds);

    res.then(function () {
      _.defer(this.draw_visible.bind(this));
    }.bind(this));
    return res;
  },

  ' removeChild': function (el, ev, data) { // eslint-disable-line quote-props
    var that = this;
    var instance;

    if (data.instance && data.instance instanceof this.options.model) {
      instance = data.instance;
    } else {
      instance = data;
    }

    //  FIXME: This should be done using indices, when the order of elements
    //    is guaranteed to mirror the order of `this.options.list`.

    //  Replace the list with the list sans the removed instance
    that.options.list.replace(
      can.map(this.options.list, function (options, i) {
        if (options.instance !== instance) {
          return options;
        }
      }));

    //  Remove items by data attributes
    that.element.children([
      '[data-object-id=' + instance.id + ']',
      '[data-object-type=' + instance.constructor.table_singular + ']'
    ].join('')).remove();
    ev.stopPropagation();
  },

  ' updateCount': function (el, ev) { // eslint-disable-line quote-props
    // Suppress events from sub-trees
    if (!($(ev.target).closest('.' + this.constructor._fullName).is(this.element))) {
      ev.stopPropagation();
    }
  },

  widget_hidden: function (event) {
    if (this.options.original_list) {
      this.element.children('.cms_controllers_tree_view_node').remove();
    }
    if (this._add_child_lists_id) {
      this._add_child_lists_id += 1;
    }

    this.triggerListeners(true);

    return false;
  },

  widget_shown: function (event) {
    if (this.options.original_list) {
      setTimeout(this.reload_list.bind(this), 0);
    }

    this.triggerListeners();

    $('body').on('treeupdate', this.refreshList.bind(this));

    return false;
  },

  _verifyRelationship: function (instance, shortName) {
    if (!(instance instanceof CMS.Models.Relationship)) {
      return false;
    }
    return _.includes([instance.destination.type, instance.source.type],
      shortName);
  },

  triggerListeners: (function () {
    var activeTabModel;
    var self;

    function onCreated(ev, instance) {
      var parentInstance = self.options.parent_instance;

      function callback() {
        parentInstance.unbind('change', callback);
        _refresh(true);
      }

      if (self._verifyRelationship(instance, activeTabModel)) {
        parentInstance.on('change', callback);
      } else if (activeTabModel === instance.type) {
        _refresh(true);
      } else if (activeTabModel === 'Person' &&
        _.includes(['ObjectPerson', 'WorkflowPerson', 'UserRole'],
          instance.type)) {
        _refresh();
      }
    }

    function onDestroyed(ev, instance) {
      var current;
      var destType;
      var srcType;

      if (self._verifyRelationship(instance, activeTabModel) ||
        instance instanceof CMS.Models[activeTabModel]) {
        if (self.options.attr('original_list').length === 1) {
          current = self.options.attr('paging.current');
          self.options.attr('paging.current',
            current > 1 ? current - 1 : 1);
        }

        // if unmapping e.g. an URL (a "Document") or an assignee from
        // the info pin, refreshing the latter is not needed
        if (instance instanceof CMS.Models.Relationship) {
          srcType = instance.source.type;
          destType = instance.destination.type;
          if (srcType === 'Person' || destType === 'Person' ||
              srcType === 'Document' || destType === 'Document') {
            return;
          }
        }

        _refresh();

        // TODO: This is a workaround.We need to update communication between
        //       info-pin and tree views through Observer
        if (!self.element.closest('.cms_controllers_info_pin').length) {
          $('.cms_controllers_info_pin').control().unsetInstance();
        }
        self.show_info_pin();
      }
    }

    function _refresh(sortByUpdatedAt) {
      if (sortByUpdatedAt) {
        self.options.attr('paging.sortDirection', 'desc');
        self.options.attr('paging.sortBy', 'updated_at');
        self.options.attr('paging.current', 1);
      }
      self.refreshList();
    }

    return function (needDestroy) {
      activeTabModel = this.options.model.shortName;
      self = this;
      if (needDestroy) {
        // Remove listeners for inactive tabs
        can.Model.Cacheable.unbind('created', onCreated);
        can.Model.Cacheable.unbind('destroyed', onDestroyed);
      } else {
        // Add listeners on creations instance or mappings objects for current tab
        // and refresh page after that.
        can.Model.Cacheable.bind('created', onCreated);
        can.Model.Cacheable.bind('destroyed', onDestroyed);
      }
    };
  })(),

  '.edit-object modal:success': function (el, ev, data) {
    var model = el.closest('[data-model]').data('model');
    model.attr(data[model.constructor.root_object] || data);
    ev.stopPropagation();
  },

  reload_list: function (force_reload) {
    if (this.options.list === undefined || this.options.list === null) {
      return;
    }
    this._draw_list_deferred = false;
    this._is_scrolling_up = false;
    this.find_all_deferred = false;
    this.options.list.replace([]);
    this.element.children('.cms_controllers_tree_view_node').remove();
    this.draw_list(this.options.original_list, true, force_reload);
    this.init_count();
  },

  '[custom-event] click': function (el, ev) {
    var event_name = el.attr('custom-event');
    if (this.options.events && typeof this.options.events[event_name] === 'function') {
      this.options.events[event_name].apply(this, arguments);
    }
  },

  hide_filter: function () {
    var $filter = this.element.parent().find('.tree-filter');
    var height = $filter.outerHeight(true);
    var margin = $filter.css('margin-bottom').replace('px', '');

    $filter
        .data('height', height)
        .data('margin-bottom', margin)
        .css({
          'margin-bottom': 0,
          height: 0,
          overflow: 'hidden'
        });

    this.element.parent().find('.filter-trigger > a')
        .removeClass('active')
        .find('span')
        .text('Show filter');

    this.element.parent().find('.sticky.tree-header').addClass('no-filter');
    Stickyfill.rebuild();

    this.display_prefs.setFilterHidden(true);
    this.display_prefs.save();
  },

  show_filter: function () {
    var $filter = this.element.parent().find('.tree-filter');

    $filter
        .css({
          'margin-bottom': $filter.data('margin-bottom'),
          height: $filter.data('height'),
          overflow: ''
        });

    this.element.parent().find('.filter-trigger > a')
        .addClass('active')
        .find('span')
        .text('Hide filter');

    this.element.parent().find('.sticky.tree-header').removeClass('no-filter');
    Stickyfill.rebuild();

    this.display_prefs.setFilterHidden(false);
    this.display_prefs.save();
  },

  /* Update the tree attributes as selected by the user CORE-1546
  */
  set_tree_attrs: function () {
    // update the display attrbute list and re-draw
    // 1: find checked items
    // 2. update
    var attr_to_save = [];
    var $check = this.element.parent().find('.attr-checkbox');
    var $selected = $check.filter(':checked');
    var selected_items = [];

    $selected.each(function (index) {
      selected_items.push(this.value);
    });

    can.each(this.options.select_attr_list, function (item) {
      item.display_status = selected_items.indexOf(item.attr_name) !== -1;
    });

    this.options.attr('select_attr_list', this.options.select_attr_list);
    this.options.display_attr_list = [];

    can.each(this.options.select_attr_list, function (item) {
      if (!item.mandatory && item.display_status) {
        this.options.display_attr_list.push(item);
      }
    }, this);
    this.options.attr('display_attr_list', this.options.display_attr_list);
    this.setup_column_width();

    this.reload_list(true);
    // set user preferences for next time
    can.each(this.options.display_attr_list, function (item) {
      attr_to_save.push(item.attr_name);
    });
    this.display_prefs.setTreeViewHeaders(this.options.model.model_singular,
      attr_to_save);
    this.display_prefs.save();

    can.bind.call(this.element.parent().find('.widget-col-title[data-field]'),
      'click',this.sort.bind(this));
  },

  set_tree_display_list: function (ev) {
    var model_name; // = this.options.model.model_singular,
    var $check = this.element.parent().find('.model-checkbox');
    var $selected = $check.filter(':checked');
    var selected_items = [];
    var i;
    var el;
    var open_items;
    var control;
    var tview_el;

    model_name = this.element.parent().find('.object-type-selector').val();

    // save the list
    $selected.each(function (index) {
      selected_items.push(this.value);
    });
    // update GGRC.tree_view
    GGRC.tree_view.sub_tree_for.attr(model_name + '.display_list',
      selected_items);

    // save in local storage
    this.display_prefs.setChildTreeDisplayList(model_name, selected_items);

    // check if any inner tree is open
    el = this.element;
    if (el.hasClass('tree-open')) {
      // find the inner tree and reload it
      open_items = el.find('.item-open .cms_controllers_tree_view');

      for (i = 0; i < open_items.length; i++) {
        tview_el = $(open_items[i]);
        control = tview_el.control();
        if (control) {
          control.reload_list();
        }
      }
    }
  },

  sort: function (event) {
    var $el = $(event.currentTarget);
    var key = $el.data('field');
    var order;

    if (key !== this.options.attr('paging.sortBy')) {
      this.options.attr('paging.sortDirection', null);
    }

    order =
      this.options.attr('paging.sortDirection') === 'asc' ? 'desc' : 'asc';

    this.options.attr('paging.sortDirection', order);
    this.options.attr('paging.sortBy', key);

    $el.closest('.tree-header')
        .find('.widget-col-title')
        .removeClass('asc')
        .removeClass('desc');

    $el.addClass(order);

    this.options.attr('paging.current', 1);
    this.refreshList();
  },

  filter: function (filterString) {
    this.options.attr('paging.filter', filterString);
    this.options.attr('paging.current', 1);
    this.refreshList();
  },

  loadPage: function () {
    var options = this.options;
    var queryAPI = GGRC.Utils.QueryAPI;
    var modelName = options.model.shortName;
    var params = queryAPI.buildParam(
        modelName,
        options.paging,
        queryAPI.makeExpression(modelName, options.parent_instance.type,
          options.parent_instance.id),
        undefined,
        options.additional_filter
      );

    this._draw_list_deferred = false;
    return this.page_loader.load({data: [params]})
      .then(function (data) {
        var total = data.total;
        var countsName = this.options.counts_name || params.object_name;
        this.options.attr('paging.total', total);
        this.options.attr('paging.count',
          Math.ceil(data.total / this.options.paging.pageSize));

        if (!this.options.paging.filter &&
          total !== queryAPI.getCounts().attr(countsName)) {
          queryAPI.getCounts().attr(countsName, total);
        }
        return data.values;
      }.bind(this));
  },
  refreshList: function () {
    if (this.options.attr('paging.disabled')) {
      return;
    }
    this.options.attr('paging.disabled', true);
    this._loading_started();
    this.loadPage()
      .then(function (data) {
        this.element.children('.cms_controllers_tree_view_node').remove();
        return data;
      }.bind(this))
      .then(this._ifNotRemoved(this.proxy('draw_list')))
      .then(function () {
        this.options.attr('paging.disabled', false);
      }.bind(this))
      .fail(function () {
        this.options.attr('paging.disabled', false);
        this.options.attr('original_list', []);
        this.element.children('.cms_controllers_tree_view_node').remove();
        this._loading_finished();
        GGRC.Errors.notifier('warning',
          'Filter format is incorrect, data cannot be filtered.');
      }.bind(this));
  },
  '{paging} change': _.debounce(
    function (object, event, type, action, newVal, oldVal) {
      if (oldVal !== newVal && _.contains(['current', 'pageSize'], type)) {
        this.refreshList();
      }
    })
});

can.Control.extend('CMS.Controllers.TreeViewNode', {
  defaults: {
    model: null,
    parent: null,
    instance: null,
    options_property: 'tree_view_options',
    show_view: null,
    expanded: false,
    draw_children: true,
    child_options: []
  }
}, {
  setup: function (el, opts) {
    var that = this;
    if (typeof this._super === 'function') {
      this._super(el);
    }
    if (opts instanceof can.Map) {
      this.options = opts;
      if (typeof (this.options.model) === 'string') {
        this.options.attr('model', CMS.Models[this.options.model]);
      }
      can.each(this.constructor.defaults, function (v, k) {
        if (!that.options.hasOwnProperty(k)) {
          that.options.attr(k, v);
        }
      });
    } else {
      if (typeof (opts.model) === 'string') {
        opts.model = CMS.Models[opts.model];
      }
      this.options = new CMS.Models.TreeViewOptions(this.constructor.defaults)
      .attr(opts.model ? opts.model[opts.options_property || this.constructor.defaults.options_property] : {})
      .attr(opts);
    }
  },

  init: function (el, opts) {
    var parent = opts.parent_instance || {};
    if (this.options.instance && !this.options.show_view) {
      this.options.show_view =
        this.options.instance.constructor[this.options.options_property].show_view ||
         this.options.model[this.options.options_property].show_view ||
         GGRC.mustache_path + '/base_objects/tree.mustache';
    }
    this._draw_node_deferred = can.Deferred();

    if (this.options.child_options) {
      this.options.child_options.each(function (option) {
        option.attr({
          parent: this,
          parent_instance: this.options.instance,
          is_snapshotable:
            GGRC.Utils.Snapshots.isSnapshotScope(parent),
          snapshot_scope_id: parent.id,
          snapshot_scope_type: parent.type
        });
      }.bind(this));
    }

    // this timeout is required because the invoker will access the control via
    // the element synchronously so we must not replace the element just yet
    setTimeout(function () {
      if (this.options.disable_lazy_loading) {
        this.draw_node();
      } else {
        this.draw_placeholder();
      }
    }.bind(this), 0);
  },

  '{instance} custom_attribute_values': function (object, ev, newVal, oldVal) {
    function getValues(cav) {
      return _.pluck(cav.reify(), 'attribute_value');
    }
    if ((!oldVal || !newVal) || (oldVal.length === newVal.length &&
      _.difference(getValues(oldVal), getValues(newVal)).length)) {
      this.draw_node(true);
    }
  },

  /**
   * Trigger rendering the tree node in the DOM.
   * @param {Boolean} force - indicates redraw is/is not mandatory
   */
  draw_node: function (force) {
    var isActive;
    var isPlaceholder;
    var lazyLoading = this.options.disable_lazy_loading;

    if (!this.element) {
      return;
    }
    isPlaceholder = this.element.hasClass('tree-item-placeholder');

    if (this._draw_node_in_progress ||
        !force && (!lazyLoading && !isPlaceholder)) {
      return;
    }

    this._draw_node_in_progress = true;

    // the node's isActive state is not stored anywhere, thus we need to
    // determine it from the presemce of the corresponding CSS class
    isActive = this.element.hasClass('active');

    can.view(
      this.options.show_view,
      this.options,
      this._ifNotRemoved(function (frag) {
        this.replace_element(frag);

        if (isActive) {
          this.element.addClass('active');
        }

        this._draw_node_deferred.resolve();
      }.bind(this))
    );
    this.options.attr('isPlaceholder', false);
    this._draw_node_in_progress = false;
  },

  draw_placeholder: function () {
    can.view(
      GGRC.mustache_path + '/base_objects/tree_placeholder.mustache',
      this.options,
      this._ifNotRemoved(function (frag) {
        this.replace_element(frag);
        this._draw_node_deferred.resolve();
        this.options.expanded = false;
        delete this._expand_deferred;
      }.bind(this))
    );
    this.options.attr('isPlaceholder', true);
  },

  should_draw_children: function () {
    var draw_children = this.options.draw_children;
    if (can.isFunction(draw_children)) {
      return draw_children.apply(this.options);
    }
    return draw_children;
  },

  // add all child options to one TreeViewOptions object
  add_child_lists_to_child: function () {
    var originalChildList = this.options.child_options;
    var newChildList = [];

    if (this.options.attr('_added_child_list')) {
      return;
    }
    this.options.attr('child_options', new can.Observe.List());

    if (originalChildList.length === null) {
      originalChildList = [originalChildList];
    }

    if (this.should_draw_children()) {
      can.each(originalChildList, function (data, i) {
        var options = new can.Map();
        data.each(function (v, k) {
          options.attr(k, v);
        });
        this.add_child_list(this.options, options);
        options.attr({
          options_property: this.options.options_property,
          single_object: false,
          parent: this,
          parent_instance: this.options.instance
        });
        newChildList.push(options);
      }.bind(this));

      this.options.attr('child_options', newChildList);
      this.options.attr('_added_child_list', true);
    }
  },

  // data is an entry from child options.  if child options is an array, run once for each.
  add_child_list: function (item, data) {
    var find_params;
    data.attr({start_expanded: false});
    if (can.isFunction(item.instance[data.property])) {
      // Special case for handling mappings which are functions until
      // first requested, then set their name via .attr('...')
      find_params = function () {
        return item.instance[data.property]();
      };
      data.attr('find_params', find_params);
    } else if (data.property) {
      find_params = item.instance[data.property];
      if (find_params && find_params.isComputed) {
        data.attr('original_list', find_params);
        find_params = find_params();
      } else if (find_params && find_params.length) {
        data.attr('original_list', find_params);
        find_params = find_params.slice(0);
      }
      data.attr('list', find_params);
    } else {
      find_params = data.attr('find_params');
      if (find_params) {
        find_params = find_params.serialize();
      } else {
        find_params = {};
      }
      if (data.parent_find_param) {
        find_params[data.parent_find_param] = item.instance.id;
      } else {
        find_params['parent.id'] = item.instance.id;
      }
      data.attr('find_params', new can.Map(find_params));
    }
    // $subtree.cms_controllers_tree_view(opts);
  },

  replace_element: function (el) {
    var old_el = this.element;
    var old_data;
    var firstchild;

    if (!this.element) {
      return;
    }

    old_data = $.extend({}, old_el.data());

    firstchild = $(_firstElementChild(el));

    old_data.controls = old_data.controls.slice(0);
    old_el.data('controls', []);
    this.off();
    old_el.replaceWith(el);
    this.element = firstchild.addClass(this.constructor._fullName).data(old_data);
    this.on();
  },

  display: function () {
    return this.trigger_expand();
  },

  display_path: function (path) {
    return this.display().then(this._ifNotRemoved(function () {
      return _display_tree_subpath(this.element, path);
    }.bind(this)));
  },

  display_subtrees: function () {
    var child_tree_dfds = [];
    var that = this;

    this.element.find('.' + CMS.Controllers.TreeView._fullName).each(function (_, el) {
      var $el = $(el);
      var child_tree_control;

      //  Ensure this targets only direct child trees, not sub-tree trees
      if ($el.closest('.' + that.constructor._fullName).is(that.element)) {
        child_tree_control = $el.control();
        if (child_tree_control) {
          child_tree_dfds.push(child_tree_control.display());
        }
      }
    });

    return $.when.apply($, child_tree_dfds);
  },

  /**
   * Expand the tree node to make its subnodes visible.
   *
   * @return {can.Deferred} - a deferred object resolved when all the child
   *   nodes have been loaded and displayed
   */
  expand: function () {
    var $el = this.element;

    this.add_child_lists_to_child();
    if (this._expand_deferred && $el.find('.openclose').is('.active')) {
      // If we have already expanded and are currently still expanded, then
      // short-circuit the call. However, we still need to toggle `expanded`,
      // but if it's the first time expanding, `this.add_child_lists_to_child`
      // *must* be called first.
      this.options.attr('expanded', true);
      return this._expand_deferred;
    }

    this.options.attr('expanded', true);

    this._expand_deferred = can.Deferred();
    setTimeout(this._ifNotRemoved(function () {
      this.display_subtrees()
        .then(this._ifNotRemoved(function () {
          this.element.trigger('subtree_loaded');
          this.element.trigger('loaded');
          if (this._expand_deferred) {
            this._expand_deferred.resolve();
          }
        }.bind(this)));
    }.bind(this)), 0);
    return this._expand_deferred;
  },

  '.openclose:not(.active) click': function (el, ev) {
    // Ignore unless it's a direct child
    if (el.closest('.' + this.constructor._fullName).is(this.element)) {
      this.expand();
    }
  },

  '.select:not(.disabled) click': function (el, ev) {
    var tree = el.closest('.cms_controllers_tree_view_node');
    var node = tree.control();
    if (node) {
      node.select();
    }
  },

  /**
   * Mark the tree node as active (and all other tree nodes as inactive).
   * @param {Boolean} maximizeInfoPane - Info pane maximized state
   */
  select: function (maximizeInfoPane) {
    var $tree = this.element;
    var treeHasMaximizedClass = $tree.hasClass('maximized-info-pane');
    if (typeof maximizeInfoPane === 'undefined') {
      if (treeHasMaximizedClass) {
        maximizeInfoPane = true;
      } else {
        maximizeInfoPane = false;
      }
    }

    if ($tree.hasClass('active') &&
      ((maximizeInfoPane && treeHasMaximizedClass) ||
      (!maximizeInfoPane && !treeHasMaximizedClass))) {
      return;  // tree node already selected, no need to activate it again
    }

    $tree.closest('section')
      .find('.cms_controllers_tree_view_node')
      .removeClass('active');

    $tree
      .addClass('active');

    if (maximizeInfoPane) {
      $tree
        .addClass('maximized-info-pane');
    } else {
      $tree
        .removeClass('maximized-info-pane');
    }

    this.update_hash_fragment();
    $('.pin-content').control()
      .setInstance(this.options.instance, $tree, maximizeInfoPane);
  },

  'input,select click': function (el, ev) {
    // Don't toggle accordion when clicking on input/select fields
    ev.stopPropagation();
  },

  trigger_expand: function () {
    var $expand_el = this.element.find('.openclose').first();
    if (!$expand_el.hasClass('active')) {
      $expand_el.trigger('click');
    }
    return this.expand();
  },

  hash_fragment: function () {
    var parent_fragment = '';

    if (this.options.parent) {
      parent_fragment = this.options.parent.hash_fragment();
    }

    return [parent_fragment,
            this.options.instance.hash_fragment()].join('/');
  },

  update_hash_fragment: function () {
    var hash = window.location.hash.split('/')[0];

    window.location.hash = [hash,
                            this.hash_fragment()].join('');
  }
});

(function (can, $) {
  can.Component.extend({
    tag: 'tree-header-selector',
    // <content> in a component template will be replaced with whatever is contained
    //  within the component tag.  Since the views for the original uses of these components
    //  were already created with content, we just used <content> instead of making
    //  new view template files.
    template: '<content/>',
    scope: {},
    events: {
      init: function (element, options) {
        this.scope.attr('controller', this);
        this.scope.attr('$rootEl', $(element));
      },

      disable_attrs: function (el, ev) {
        var MAX_ATTR = 5;
        var $check = this.element.find('.attr-checkbox');
        var $mandatory = $check.filter('.mandatory');
        var $selected = $check.filter(':checked');
        var $not_selected = $check.not(':checked');

        if ($selected.length === MAX_ATTR) {
          $not_selected.prop('disabled', true)
            .closest('li').addClass('disabled');
        } else {
          $check.prop('disabled', false)
            .closest('li').removeClass('disabled');
          // Make sure mandatory items are always disabled
          $mandatory.prop('disabled', true)
            .closest('li').addClass('disabled');
        }
      },

      'input.attr-checkbox click': function (el, ev) {
        this.disable_attrs(el, ev);
        ev.stopPropagation();
      },

      '.dropdown-menu-form click': function (el, ev) {
        ev.stopPropagation();
      },

      '.tview-dropdown-toggle click': function (el, ev) {
        this.disable_attrs(el, ev);
      },

      '.set-tree-attrs,.close-dropdown click': function (el, ev) {
        this.scope.$rootEl.removeClass('open');
        this.scope.$rootEl.parents('.dropdown-menu')
          .parent().removeClass('open');
      }
    }
  });

  can.Component.extend({
    tag: 'tree-type-selector',
    // <content> in a component template will be replaced with whatever is contained
    //  within the component tag.  Since the views for the original uses of these components
    //  were already created with content, we just used <content> instead of making
    //  new view template files.
    template: '<content/>',
    scope: {},
    events: {
      init: function (element, options) {
        this.scope.attr('controller', this);
        this.scope.attr('$rootEl', $(element));
      },

      'input.model-checkbox click': function (el, ev) {
        ev.stopPropagation();
      },

      '.dropdown-menu-form click': function (el, ev) {
        ev.stopPropagation();
      },

      update_check_boxes: function (el, ev) {
        // change checkboxes based on the model_type
        // get the closest tree_view controller, change the options to reload the checkboxes.
        var i;
        var select_el = this.element.find('.object-type-selector');
        var model_name = select_el.val();
        var sec_el = select_el.closest('section');
        var tree_view_el = sec_el.find('.cms_controllers_tree_view');
        var control = tree_view_el.control();
        var display_list = GGRC.tree_view.sub_tree_for[model_name].display_list;
        var select_model_list = GGRC.tree_view.sub_tree_for[model_name].model_list;
        var obj;

        // set up display status for UI
        for (i = 0; i < select_model_list.length; i++) {
          obj = select_model_list[i];
          obj.display_status = display_list.indexOf(obj.model_name) !== -1;
        }
        control.options.attr('selected_child_tree_model_list', select_model_list);
      },

      'select.object-type-selector change': 'update_check_boxes',

      '.tview-type-toggle click': 'update_check_boxes',

      'a.select-all click': function (el, ev) {
        var $check = this.element.find('.model-checkbox');

        $check.prop('checked', true);
      },

      'a.select-none click': function (el, ev) {
        var $check = this.element.find('.model-checkbox');

        $check.prop('checked', false);
      },

      '.set-display-object-list,.close-dropdown click': function (el, ev) {
        this.scope.$rootEl.removeClass('open');
        this.scope.$rootEl.parents('.dropdown-menu')
          .parent().removeClass('open');
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/
//= require tree-view-controller.js

(function(can, $) {

function model_list_loader(controller, params) {
  var model = controller.options.model
    , page = new $.Deferred()
    ;

  pager = model.findPage(params).then(function(results) {
    var collection_name = model.root_collection + "_collection"
      , collection = results[collection_name] || []
      ;
    page.resolve(new can.Observe.List(collection), results.paging);
  });
  return page;
}

CMS.Controllers.TreeLoader("GGRC.Controllers.ListView", {
  defaults : {
    is_related : false
    , model : null
    , extra_params : null
    , search_query : ""
    , search_params : null
    , parent_instance : null
    , parent_type : null
    , object_display : null
    , parent_display : null
    , header_view : null
    , list_view : "/static/mustache/dashboard/object_list.mustache"
    , list_objects : null
    , list_loader : null
    , tooltip_view : "/static/mustache/dashboard/object_tooltip.mustache"
  }
}, {

  init : function() {
    var that = this;
    !this.options.extra_params && (this.options.extra_params = {});
    !this.options.search_params && (this.options.search_params = {});
    this.options.state = new can.Observe();

    this.context = new can.Observe({
      // FIXME: Needed?  Default `pager` to avoid binding issues.
      pager: { has_next: function() { return false; } }
    });
    this.context.attr("has_next_page", can.compute(function() {
      var pager = that.context.attr("pager");
      return pager && pager.has_next && pager.has_next();
    }));
    this.context.attr("has_prev_page", can.compute(function() {
      var pager = that.context.attr("pager");
      return pager && pager.has_prev && pager.has_prev();
    }));
    this.context.attr(this.options);

    if(this.options.header_view) {
      can.view(this.options.header_view, $.when(this.context)).then(function(frag) {
        if (that.element) {
          that.element.prepend(frag);
        }
      });
    }

    if (!this.options.list) {
      this.options.list_loader = model_list_loader;
    }
  }

  , prepare : function() {
    var that = this
      , params = $.extend({}, this.options.extra_params || {})
      ;

    if (this._prepare_deferred)
      return this._prepare_deferred;

    params.__page_only = true;
    this._prepare_deferred = this.options.list_loader(this, params).then(function(results, pager) {
      that.options.pager = pager;
      that.context.attr("pager", pager);
      that.update_count();
      return results;
    });

    return this._prepare_deferred;
  }

  , fetch_list : function(params) {
    // Assemble extra search params
    var extra_params = this.options.extra_params || {}
      , search_params = this.options.search_params
      , that = this
      , page
      , pager
      ;

    this.element.trigger("loading");

    if(this.options.list)
      this.options.list.replace([]);

    params = $.extend({}, params, extra_params);

    if (this.options.model.list_view_options
        && this.options.model.list_view_options.find_params) {
      params = $.extend(params, this.options.model.list_view_options.find_params);
    }

    if (this.options.model == CMS.Models.Person) {
      params.__sort = "name,email";
      if (search_params.search_term)
        params.__search = search_params.search_term;
      if (search_params.role_id)
        params["user_roles.role_id"] = search_params.role_id;
    }

    return this.options.list_loader(this, params).then(function(results, pager) {
      that.options.pager = pager;
      that.context.attr("pager", pager);
      return results;
    });
  }

  , draw_list : function(list) {
    if (list && this.options.fetch_post_process) {
      list = this.options.fetch_post_process(list);
    }

    var that = this;
    if(list) {
      if(!this.options.list){
        this.options.list = new can.Observe.List();
        list.on('add', function(list, item, index){
          that.enqueue_items(item);
        }).on('remove', function(list, item, index){
          that.options.list.splice(index, 1);
          that.element.find('ul.tree-open').removeClass('tree-open');
        });
      }
      else{
        this.options.list.splice();
      }
      this.enqueue_items(list);
      this.on();
    }

    this.context.attr(this.options);
    this.update_count();
  }

  , init_view : function() {
    var that = this;
    return can.view(this.options.list_view, this.context, function(frag) {
      that.element.find('.spinner, .tree-structure').hide();
      that.element
        .append(frag)
        .trigger("loaded");
      that.options.state.attr('loading', false);
    });
  }

  , update_count: function() {
      if (this.element) {
        if (this.options.pager) {
          this.element.trigger("updateCount", this.options.pager.total);
        }
        this.element.trigger("widget_updated");
      }
    }
  , reset_search: function(el, ev){
      this.options.search_params = {};
      this.options.search_query = '';
      this.element.find('.search-filters').find('input[name=search], select[name=user_role]').val('');
      this.fetch_list().then(this.proxy("draw_list"));
  }
  , insert_items : function(items){
    this.options.list.push.apply(this.options.list, items);
  }
  , "{list} change": "update_count"
  , ".view-more-paging click" : function(el, ev) {
      var that = this
        , collection_name = that.options.model.root_collection+"_collection"
        , is_next = el.data('next')
        , can_load = is_next ? that.options.pager.has_next() : that.options.pager.has_prev()
        , load = is_next ? that.options.pager.next : that.options.pager.prev;
      that.options.list.replace([]);
      that.element.find('.spinner').show();
      if (can_load) {
        load().done(function(data) {
          that.element.find('.spinner').hide();
          if(typeof data === 'undefined') return;
          if (data[collection_name] && data[collection_name].length > 0) {
            that.enqueue_items(data[collection_name]);
          }
          that.options.pager = data.paging;
          that.context.attr("pager", data.paging);
        });
      }
    }

  , ".search-filters input[name=search] change" : function(el, ev) {
      var that = this;
      this.options.search_params.search_term = el.val();
      this.fetch_list().then(this.proxy("draw_list"));
    }

  , ".search-filters select[name=user_role] change" : function(el, ev) {
      var that = this;
      this.options.search_params.role_id = el.val();
      this.fetch_list().then(this.proxy("draw_list"));
    }

  , ".search-filters button[type=reset] click" : "reset_search"
  , ".btn-add modal:success" : "reset_search"
  }
);

})(this.can, this.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

can.Control('GGRC.Controllers.TreeFilter', {}, {
  init: function () {
    var filterExpression;
    var queryParams;  // just a parsed query string
    var queryString;
    var parentControl;

    this._super && this._super.apply(this, arguments);
    this.options.states = new can.Observe();
    parentControl = this.element.closest('.cms_controllers_dashboard_widgets')
      .find('.cms_controllers_tree_view').control();
    parentControl && parentControl.options.attr('states', this.options.states);

    this.$txtFilter = this.element.find('input[name=filter_query]');

    // determine the tree view filter and automatically apply it if it exists
    queryString = location.search.substr(1);  // remove the '?' prefix
    queryParams = can.route.deparam(queryString);
    filterExpression = queryParams.filter || '';

    if (filterExpression) {
      this.$txtFilter.val(filterExpression);

      // This is needed (?) for the old filter code, because setting the
      // input's value here does not fire the change event... but we should
      // delete this once we get rid of that legacy filter code.
      this.options.states.attr('filter_query', filterExpression);

      // NOTE: We must wait for the parent tree view controller (that does the
      // actual filtering heavy lifting) and it's DOM element to be present and
      // initialized. We should probably use some other event than window load,
      // but could not find a better candidate...
      $(window).on('load', function () {
        this.apply_filter(filterExpression);
      }.bind(this));
    }

    this.on();
  },
  toggle_indicator: function (currentFilter) {
    var isExpression =
      !!currentFilter && !!currentFilter.expression.op &&
      currentFilter.expression.op.name !== 'text_search' &&
      currentFilter.expression.op.name !== 'exclude_text_search';

    this.element.find('.tree-filter__expression-holder')
      .toggleClass('tree-filter__expression-holder--active', isExpression);
    this.element.find('.tree-filter__expression-holder span i')
      .toggleClass('fa-check-circle green', isExpression);
    this.element.find('.tree-filter__expression-holder span i')
      .toggleClass('fa-check-circle-o', !isExpression);
  },
  apply_filter: function (filterString) {
    var currentFilter = GGRC.query_parser.parse(filterString);
    var parentControl = this.element
      .closest('.cms_controllers_dashboard_widgets')
      .find('.cms_controllers_tree_view').control();

    this.toggle_indicator(currentFilter);
    parentControl.filter(filterString);
  },
  'input[type=reset] click': function (el, ev) {
    this.element.find('input[type=text]').val('');
    this.apply_filter('');
  },
  'input[type=submit] click': function (el, ev) {
    this.apply_filter(this.$txtFilter.val());
  },
  'input keyup': function (el, ev) {
    this.toggle_indicator(GGRC.query_parser.parse(el.val()));

    if (ev.keyCode === 13) {
      this.apply_filter(el.val());
    }
    ev.stopPropagation();
  },
  'input, select change': function (el, ev) {
    // this is left from the old filters and should eventually be replaced
    // Convert '.' to '__' ('.' will cause can.Observe to try to update a path instead of just a key)
    var name = el.attr('name').replace(/\./g, '__');
    if (el.is('.hasDatepicker')) {
      this.options.states.attr(name, moment(el.val(), 'MM/DD/YYYY'));
    } else if (el.is(':checkbox') && !el.is(':checked')) {
      this.options.states.removeAttr(name);
    } else {
      this.options.states.attr(name, el.val());
    }
    ev.stopPropagation();
  },
  'input[data-lookup] focus': function (el, ev) {
    this.autocomplete(el);
  },
  autocomplete: function (el) {
    $.cms_autocomplete.call(this, el);
  },
  autocomplete_select: function (el, event, ui) {
    setTimeout(function () {
      if (ui.item.title) {
        el.val(ui.item.title, ui.item);
      } else {
        el.val(ui.item.name ? ui.item.name : ui.item.email, ui.item);
      }
      el.trigger('change');
    }, 0);
  },
  '{states} change': function (states) {
    var that = this;
    this.element
      .closest('.tree-structure')
      .children(':has(> [data-model],:data(model))').each(function (i, el) {
        var model = $(el).children('[data-model],:data(model)').data('model');
        if (can.reduce(Object.keys(states._data), function (st, key) {
          var result;
          var val = states[key];
          var test = that.resolve_object(model, key.replace(/__/g, '.'));

          if (val && val.isAfter) {
            if (!test || moment(test).isBefore(val)) {
              result = false;
            } else {
              result = st;
            }
          } else if (val === '[empty]' && test === '') {
            result = st;
          } else if (val &&
            (!test || !~test.toUpperCase().indexOf(val.toUpperCase()))) {
            result = false;
          } else {
            result = st;
          }
          return result;
        }, true)) {
          $(el).show();
        } else {
          $(el).hide();
        }
      });
  },
  '[data-toggle="filter-reset"] click': function (el, ev) {
    var that = this;
    var filterResetTarget = 'input, select';
    var checked;

    this.element.find(filterResetTarget).each(function (i, elem) {
      var $elem = $(elem)
        ;

      that.options.states.removeAttr($elem.attr('name').replace(/\./g, '__'));
    });

    if (el.is(':checkbox')) {
      checked = el.prop('checked');
      // Manually reset the form
      el.closest('form')[0].reset();
      if (el.is(':checkbox')) {
        // But not the checkbox
        el.prop('checked', checked);
      }
    }
    can.trigger(this.options.states, 'change', '*');
  },
  resolve_object: function (obj, path) {
    path = path.split('.');
    can.each(path, function (prop) {
      // If the name is blank, use email
      if (prop === 'name' && obj.attr &&
        (!obj.attr(prop) || !obj.attr(prop).trim()) &&
        obj.attr('email') && obj.attr('email').trim()) {
        prop = 'email';
      }
      if (obj.instance) {
        obj = obj.instance;
      }
      obj = obj.attr ? obj.attr(prop) : obj.prop;
      obj = obj && obj.reify ? obj.reify() : obj;
      return !_.isEmpty(obj); // stop iterating in case of null/undefined.
    });
    return obj;
  }
});

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $) {

GGRC.Controllers.Modals("GGRC.Controllers.Unmap", {
    defaults: {
        skip_refresh: true
    }
}, {
  init : function() {
    this._super();
  }

  , "{$footer} a.btn[data-toggle=delete] click" : function(el, ev) {
    this.element.trigger("modal:success", this.options.instance);
  }

});

})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

can.Control('CMS.Controllers.InfoPin', {
  defaults: {
    view: GGRC.mustache_path + '/base_objects/info.mustache'
  }
}, {
  init: function (el, options) {
    this.element.height(0);
  },
  findView: function (instance) {
    var view = instance.class.table_plural + '/info';

    if (instance instanceof CMS.Models.Person) {
      view = GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/info.mustache';
    } else if (view in GGRC.Templates) {
      view = GGRC.mustache_path + '/' + view + '.mustache';
    } else {
      view = this.options.view;
    }
    return view;
  },
  findOptions: function (el) {
    var treeNode = el.closest('.cms_controllers_tree_view_node').control();
    return treeNode.options;
  },
  loadChildTrees: function () {
    var childTreeDfds = [];
    var that = this;
    var $el;
    var childTreeControl;

    this.element.find('.' + CMS.Controllers.TreeView._fullName)
      .each(function (_, el) {
        $el = $(el);

        //  Ensure this targets only direct child trees, not sub-tree trees
        if ($el.closest('.' + that.constructor._fullName).is(that.element)) {
          childTreeControl = $el.control();
          if (childTreeControl) {
            childTreeDfds.push(childTreeControl.display());
          }
        }
      });
  },
  getPinHeight: function (maximizedState) {
    if (maximizedState) {
      return Math.floor($(window).height() * 3 / 4);
    }
    return Math.floor($(window).height() / 3);
  },
  hideInstance: function () {
    this.element.stop(true);
    this.element.height(0).html('');
    $(window).trigger('resize');
  },
  unsetInstance: function () {
    this.element.stop(true);
    this.element.animate({
      height: 0
    }, {
      duration: 800,
      start: function () {
        $(window).trigger('resize', 0);
      },
      complete: function () {
        this.element.html('');
        $('.cms_controllers_tree_view_node').removeClass('active');
      }.bind(this)
    });
  },
  setInstance: function (instance, el, maximizedState) {
    var self = this;
    var options = this.findOptions(el);
    var view = this.findView(instance);
    var panelHeight = this.getPinHeight(maximizedState);
    var confirmEdit = instance.class.confirmEditModal ?
      instance.class.confirmEditModal : {};
    var currentPanelHeight;

    if (!_.isEmpty(confirmEdit)) {
      confirmEdit.confirm = this.confirmEdit;
    }

    this.element.html(can.view(view, {
      instance: instance,
      model: instance.class,
      confirmEdit: confirmEdit,
      is_info_pin: true,
      options: options,
      result: options.result,
      page_instance: GGRC.page_instance(),
      maximized: maximizedState,
      onChangeMaximizedState: function () {
        return self.changeMaximizedState.bind(self);
      },
      onClose: function () {
        return self.close.bind(self);
      }
    }));

    if (instance.info_pane_preload) {
      instance.info_pane_preload();
    }

    // Load trees inside info pin
    this.loadChildTrees();

    // Make sure pin is visible
    currentPanelHeight = this.element.height();
    if (!currentPanelHeight || currentPanelHeight !== panelHeight) {
      this.element.animate({
        height: panelHeight
      }, {
        duration: 800,
        easing: 'easeOutExpo',
        complete: function () {
          this.ensureElementVisible(el);
        }.bind(this)
      });
    } else {
      this.ensureElementVisible(el);
    }
    this.element.trigger('scroll');
  },
  ensureElementVisible: function (el) {
    var $objectArea;
    var $header;
    var $filter;
    var elTop;
    var elBottom;
    var headerTop;
    var headerBottom;
    var infoTop;

    $(window).trigger('resize');
    $objectArea = $('.object-area');
    $header = $('.tree-header:visible');
    $filter = $('.tree-filter:visible');

    if (_.isEmpty(el) || _.isEmpty($header)) {
      return;
    }

    elTop = el.offset().top;
    elBottom = elTop + el.height();

    headerTop = $header.offset().top;
    headerBottom = headerTop + $header.height();
    infoTop = this.element.offset().top;

    if (elTop < headerBottom || elBottom > infoTop) {
      el[0].scrollIntoView(false);
      if (elTop < headerBottom) {
        el[0].scrollIntoView(true);
        $objectArea.scrollTop(
          $objectArea.scrollTop() - $header.height() - $filter.height());
      } else {
        el[0].scrollIntoView(false);
      }
    }
  },
  confirmEdit: function (instance, modalDetails) {
    var confirmDfd = $.Deferred();
    var renderer = can.view.mustache(modalDetails.description);
    GGRC.Controllers.Modals.confirm({
      modal_description: renderer(instance).textContent,
      modal_confirm: modalDetails.button,
      modal_title: modalDetails.title,
      button_view: GGRC.mustache_path + '/quick_form/confirm_buttons.mustache'
    }, confirmDfd.resolve);
    return confirmDfd;
  },
  changeMaximizedState: function (maximizedState) {
    var $win = $(window);
    var options = {
      duration: 800,
      easing: 'easeOutExpo'
    };
    var $activeTree = $('.cms_controllers_tree_view_node.active');
    var size = this.getPinHeight(maximizedState);
    if (size <= this.element.height()) {
      options.start = function () {
        $win.trigger('resize', size);
      };
    } else {
      options.complete = function () {
        $win.trigger('resize');
      };
    }

    this.element.animate({height: size}, options);

    if (maximizedState) {
      $activeTree
        .addClass('maximized-info-pane');
    } else {
      $activeTree
        .removeClass('maximized-info-pane');
    }
  },
  close: function () {
    $('.widget-area .widget:visible')
      .find('.cms_controllers_tree_view')
      .control()
      .deselect();

    this.unsetInstance();
  },
  ' scroll': function (el, ev) {
    var header = this.element.find('.pane-header');
    var isFixed = el.scrollTop() > 0;
    var offset = isFixed ? header.height() : 0;
    var HEADER_PADDING = -15;

    this.element.find('.tier-content').css('paddingTop', offset);
    header.css('marginTop', function () {
      // Header in info pane is padded by 15px, and we need to make sure
      // text doesn't bleed below.
      return HEADER_PADDING - offset;
    });
    header.toggleClass('pane-header__fixed', isFixed);
  }
});

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

;(function (CMS, GGRC, can, $) {
  var MIN_WAIT = 2000;
  var MAX_WAIT = 5000;

  var refresher = {
    instanceQueue: [],
    lastRefresh: Date.now(),
    refreshInstance: function (instance) {
      this.instanceQueue.push(instance);
      setTimeout(this.tick(instance), MIN_WAIT);
    },
    tick: function (instance) {
      return (function () {
        var isCurrent =
          this.instanceQueue[this.instanceQueue.length - 1] === instance;
        var isOverdue = (this.lastRefresh + MAX_WAIT) < Date.now();
        if (isCurrent || isOverdue) {
          this.go();
        }
      }).bind(this);
    },
    go: function () {
      var instances = this.instanceQueue;
      var ids = $.map(instances, function (instance) {
        return instance.id;
      });
      var filter = {automapping_id__in: ids.join()};
      this.lastRefresh = Date.now();
      this.instanceQueue = [];

      CMS.Models.Relationship.findAll(filter).then(function (relationships) {
        var rq = new RefreshQueue();
        can.each(relationships.concat(instances), function (relationship) {
          rq.enqueue(relationship.source);
          rq.enqueue(relationship.destination);
        });
        rq.trigger();
      });
    }
  };

  var flashWarning = function () {
    // timeout is required because a 'mapping created' success flash will show up
    // and we do not currently support multiple simultaneous flashes
    setTimeout(function () {
      $(document.body).trigger('ajax:flash', {
        warning: 'Automatic mappings were not created because that would ' +
        'result in too many new mappings'
      });
    }, 2000); // 2000 is a magic number that feels nice in the UI
  };

  var Controller = can.Control({
    '{CMS.Models.Relationship} created': function (model, ev, instance) {
      var limitExceeded;
      if (instance instanceof CMS.Models.Relationship) {
        limitExceeded = instance.extras &&
          instance.extras.automapping_limit_exceeded;
        if (limitExceeded) {
          flashWarning();
        } else {
          refresher.refreshInstance(instance);
        }
      }
    }
  });

  $(function () {
    new Controller();
  });
})(this.CMS, this.GGRC, this.can, this.can.$);


/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  can.Control('CMS.Controllers.Dashboard', {
    defaults: {
      widget_descriptors: null
    }

  }, {
    init: function (el, options) {
      CMS.Models.DisplayPrefs.getSingleton().then(function (prefs) {
        this.display_prefs = prefs;

        this.init_tree_view_settings();
        this.init_page_title();
        this.init_page_help();
        this.init_page_header();
        this.init_widget_descriptors();
        if (!this.inner_nav_controller) {
          this.init_inner_nav();
        }
        this.update_inner_nav();

        // Before initializing widgets, hide the container to not show
        // loading state of multiple widgets before reducing to one.
        this.hide_widget_area();
        this.init_default_widgets();
        this.init_widget_area();
        this.init_info_pin();
      }.bind(this));
    },

    init_tree_view_settings: function () {
      var valid_models;
      var saved_child_tree_display_list;
      if (!GGRC.page_object) { // Admin dashboard
        return;
      }

      valid_models = can.Map.keys(GGRC.tree_view.base_widgets_by_type);
    // only change the display list
      can.each(valid_models, function (m_name) {
        saved_child_tree_display_list = this.display_prefs.getChildTreeDisplayList(m_name);
        if (saved_child_tree_display_list !== null) {
          GGRC.tree_view.sub_tree_for.attr(m_name + '.display_list',
            saved_child_tree_display_list);
        }
      }.bind(this));
    },

    init_page_title: function () {
      var page_title = null;
      if (typeof (this.options.page_title) === 'function') {
        page_title = this.options.page_title(this);
      } else if (this.options.page_title) {
        page_title = this.options.page_title;
      }
      if (page_title) {
        $('head > title').text(page_title);
      }
    },

    init_page_help: function () {
      var page_help = null;
      if (typeof (this.options.page_help) === 'function') {
        page_help = this.options.page_help(this);
      } else if (this.options.page_help) {
        page_help = this.options.page_help;
      }
      if (page_help) {
        this.element.find('#page-help').attr('data-help-slug', page_help);
      }
    },

    init_page_header: function () {
      var that = this;
      if (this.options.header_view) {
        can.view(this.options.header_view, this.options, function (frag) {
          that.element.find('#page-header').html(frag);
        });
      }
    },

    init_widget_area: function () {
      if (!this.inner_nav_controller) {
        //  If there is no inner-nav, then ensure widgets are shown
        //  FIXME: This is a workaround because widgets and widget-areas are
        //    hidden, assuming InnerNav controller will show() them
        this.get_active_widget_containers()
          .show()
          .find('.widget').show()
          .find('> section.content').show();
      }
    },

    init_inner_nav: function () {
      var $internav = this.element.find('.internav');
      if ($internav.length) {
        this.inner_nav_controller = new CMS.Controllers.InnerNav(
          this.element.find('.internav'), {
            dashboard_controller: this
          });
      }
    },

    init_info_pin: function () {
      this.info_pin = new CMS.Controllers.InfoPin(this.element.find('.pin-content'));
    },

    '.nav-logout click': function (el, ev) {
      can.Model.LocalStorage.clearAll();
    },

    init_widget_descriptors: function () {
      this.options.widget_descriptors = this.options.widget_descriptors || {};
    },

    init_default_widgets: function () {
      can.each(this.options.default_widgets, function (name) {
        this.add_dashboard_widget_from_descriptor(this.options.widget_descriptors[name]);
      }.bind(this));
    },

    hide_widget_area: function () {
      this.get_active_widget_containers().addClass('hidden');
    },
    show_widget_area: function () {
      this.get_active_widget_containers().removeClass('hidden');
    },
    ' widgets_updated': 'update_inner_nav',
    ' updateCount': function (el, ev, count, updateCount) {
      if (_.isBoolean(updateCount) && !updateCount) {
        return;
      }
      this.inner_nav_controller.update_widget_count($(ev.target), count, updateCount);
    },
    update_inner_nav: function (el, ev, data) {
      if (this.inner_nav_controller) {
        if (data) {
          this.inner_nav_controller.update_widget(data.widget || data, data.index);
        } else {
          this.inner_nav_controller.update_widget_list(
            this.get_active_widget_elements());
        }
        this.inner_nav_controller.sortWidgets();
      }
    },

    get_active_widget_containers: function () {
      return this.element.find('.widget-area');
    },

    get_active_widget_elements: function () {
      return this.element.find("section.widget[id]:not([id=''])").toArray();
    },

    add_widget_from_descriptor: function () {
      var descriptor = {};
      var that = this;
      var $element;
      var control;
      var $container;
      var $last_widget;

      // Construct the final descriptor from one or more arguments
      can.each(arguments, function (name_or_descriptor) {
        if (typeof (name_or_descriptor) === 'string') {
          name_or_descriptor =
            that.options.widget_descriptors[name_or_descriptor];
        }
        $.extend(descriptor, name_or_descriptor || {});
      });

      // Create widget in container?
      // return this.options.widget_container[0].add_widget(descriptor);

      if ($('#' + descriptor.controller_options.widget_id + '_widget').length > 0) {
        return;
      }

      // FIXME: This should be in some Widget superclass
      if (descriptor.controller_options.widget_guard &&
          !descriptor.controller_options.widget_guard()) {
        return;
      }

      $element = $("<section class='widget'>");
      control = new descriptor.controller($element, descriptor.controller_options);

      // FIXME: This should be elsewhere -- currently required so TreeView can
      //   initialize ObjectNav with counts
      control.prepare();

      // FIXME: Abstraction violation: Sortable/DashboardWidget/ResizableWidget
      //   controllers should maybe handle this?
      $container = this.get_active_widget_containers().eq(0);
      $last_widget = $container.find('section.widget').last();

      if ($last_widget.length > 0) {
        $last_widget.after($element);
      } else {
        $container.append($element);
      }

      $element
        .trigger('sortreceive')
        .trigger('section_created')
        .trigger('widgets_updated', $element);

      return control;
    },

    add_dashboard_widget_from_descriptor: function (descriptor) {
      return this.add_widget_from_descriptor({
        controller: CMS.Controllers.DashboardWidgets,
        controller_options: $.extend(descriptor, {dashboard_controller: this})
      });
    },

    add_dashboard_widget_from_name: function (name) {
      var descriptor = this.options.widget_descriptors[name];
      if (!descriptor) {
        console.debug('Unknown descriptor: ', name);
      } else {
        return this.add_dashboard_widget_from_descriptor(descriptor);
      }
    }

  });

  CMS.Controllers.Dashboard('CMS.Controllers.PageObject', {}, {
    init: function () {
      this.options.model = this.options.instance.constructor;
      this._super();
    },

    init_page_title: function () {
      // Reset title when page object is modified
      var that = this;
      var that_super = this._super;

      this.options.instance.bind('change', function () {
        that_super.apply(that);
      });
      this._super();
    },

    init_widget_descriptors: function () {
      this.options.widget_descriptors = this.options.widget_descriptors || {};
    }
  });

  can.Control('CMS.Controllers.InnerNav', {
    defaults: {
      internav_view: '/static/mustache/dashboard/internav_list.mustache',
      pin_view: '.pin-content',
      widget_list: null,
      spinners: {},
      contexts: null,
      instance: null
    }
  }, {
    init: function (options) {
      CMS.Models.DisplayPrefs.getSingleton().then(function (prefs) {
        this.display_prefs = prefs;
        if (!this.options.widget_list) {
          this.options.widget_list = new can.Observe.List([]);
        }

        this.options.instance = GGRC.page_instance();
        if (!(this.options.contexts instanceof can.Observe)) {
          this.options.contexts = new can.Observe(this.options.contexts);
        }

        // FIXME: Initialize from `*_widget` hash when hash has no `#!`
        can.bind.call(window, 'hashchange', function () {
          this.route(window.location.hash);
        }.bind(this));
        can.view(this.options.internav_view, this.options, function (frag) {
          var fn = function () {
            this.element.append(frag);
            this.route(window.location.hash);
            delete this.delayed_display;
          }.bind(this);

          this.delayed_display = {
            fn: fn,
            timeout: setTimeout(fn, 50)
          };
        }.bind(this));

        this.on();
      }.bind(this));
    },

    route: function (path) {
      if (path.substr(0, 2) === '#!') {
        path = path.substr(2);
      } else if (path.substr(0, 1) === '#') {
        path = path.substr(1);
      }

      window.location.hash = path;

      this.display_path(path.length ? path : 'Summary_widget');
    },

    display_path: function (path) {
      var step = path.split('/')[0];
      var rest = path.substr(step.length + 1);
      var widget_list = this.options.widget_list;

      // Find and make active the widget specified by `step`
      var widget = this.find_widget_by_target('#' + step);
      // If widget was not found and it's not info - try to select info
      if (!widget && step !== 'info') {
        return this.display_path('info_widget');
      }
      if (!widget && widget_list.length) {
        // Target was not found, but we can select the first widget in the list
        widget = widget_list[0];
      }
      if (widget) {
        this.set_active_widget(widget);
        return this.display_widget_path(rest);
      }
      return new $.Deferred().resolve();
    },

    display_widget_path: function (path) {
      var active_widget_selector = this.options.contexts.active_widget.selector;
      var $active_widget = $(active_widget_selector);
      var widget_controller = $active_widget.control();

      if (widget_controller && widget_controller.display_path) {
        return widget_controller.display_path(path);
      }
      return new $.Deferred().resolve();
    },

    set_active_widget: function (widget) {
      if (typeof widget === 'string') {
        widget = this.widget_by_selector(widget);
      }

      if (widget !== this.options.contexts.attr('active_widget')) {
        widget.attr('force_show', true);
        this.update_add_more_link();
        this.options.contexts.attr('active_widget', widget);
        this.show_active_widget();
      }
    },

    show_active_widget: function (selector) {
      var panel = selector ||
        this.options.contexts.attr('active_widget').selector;
      var widget = $(panel);
      var dashboardCtr = this.options.dashboard_controller;
      var infopinCtr = dashboardCtr.info_pin.element.control();

      if (infopinCtr) {
        infopinCtr.hideInstance();
      }

      if (widget.length) {
        dashboardCtr.show_widget_area();
        widget.siblings().addClass('hidden').trigger('widget_hidden');
        widget.removeClass('hidden').trigger('widget_shown');
        $('[href$=' + panel + ']')
        .closest('li').addClass('active')
        .siblings().removeClass('active');
      }
    },

    find_widget_by_target: function (target) {
      var i;
      var widget;
      for (i = 0; i < this.options.widget_list.length; i++) {
        widget = this.options.widget_list[i];
        if (widget.selector === target) {
          return widget;
        }
      }
    },

    widget_by_selector: function (selector) {
      return $.map(this.options.widget_list, function (widget) {
        return widget.selector === selector ? widget : undefined;
      })[0] || undefined;
    },

    /**
     * Sort widgets in place by their `order` attribute in ascending order.
     *
     * The widgets with non-existing / non-numeric `order` value are placed
     * at the end of the list.
     */
    sortWidgets: function () {
      function sortByOrderAttr(widget, widget2) {
        var order = _.isNumber(widget.order) ?
                                widget.order : Number.MAX_SAFE_INTEGER;
        var order2 = _.isNumber(widget2.order) ?
                                 widget2.order : Number.MAX_SAFE_INTEGER;
        return order - order2;
      }
      this.options.widget_list.sort(sortByOrderAttr);
    },

    update_widget_list: function (widget_elements) {
      var widget_list = this.options.widget_list.slice(0);
      var that = this;

      can.each(widget_elements, function (widget_element, index) {
        widget_list.splice(
          can.inArray(
            that.update_widget(widget_element, index)
            , widget_list)
          , 1);
      });

      can.each(widget_list, function (widget) {
        that.options.widget_list.splice(can.inArray(widget, that.options.widget_list), 1);
      });
    },

    update_widget: function (widget_element, index) {
      var $widget = $(widget_element);
      var widget = this.widget_by_selector('#' + $widget.attr('id'));
      var $header = $widget.find('.header h2');
      var icon = $header.find('i').attr('class');
      var menuItem = $header.text().trim();
      var match = menuItem ? menuItem.match(/\s*(\S.*?)\s*(?:\((?:(\d+)|\.*)(\/\d+)?\))?$/) : {};
      var title = match[1];
      var count = match[2] || undefined;
      var existing_index;
      var widget_options;
      var widget_name;

      if (this.delayed_display) {
        clearTimeout(this.delayed_display.timeout);
        this.delayed_display.timeout = setTimeout(this.delayed_display.fn, 50);
      }

    // If the metadata is unrendered, find it via options
      if (!title) {
        widget_options = $widget.control('dashboard_widgets').options;
        widget_name = widget_options.widget_name;
        icon = icon || widget_options.widget_icon;
      // Strips html
        title = $('<div>').html(typeof widget_name === 'function' ? widget_name() : (String(widget_name))).text();
      }
      title = title.replace(/^(Mapped|Linked|My)\s+/, '');

      // Only create the observable once, this gets updated elsewhere
      if (!widget) {
        widget = new can.Observe({
          selector: '#' + $widget.attr('id'),
          count: count,
          has_count: count != null
        });
      }
      existing_index = this.options.widget_list.indexOf(widget);

      widget.attr({
        internav_icon: icon,
        internav_display: title,
        spinner: this.options.spinners['#' + $widget.attr('id')],
        model: widget_options && widget_options.model,
        order: (widget_options || widget).order
      });

      index = this.options.widget_list.length;

      if (existing_index !== index) {
        if (existing_index > -1) {
          if (index >= this.options.widget_list.length) {
            this.options.widget_list.splice(existing_index, 1);
            this.options.widget_list.push(widget);
          } else {
            this.options.widget_list.splice(existing_index, 1, this.options.widget_list[index]);
            this.options.widget_list.splice(index, 1, widget);
          }
        } else {
          this.options.widget_list.push(widget);
        }
      }

      return widget;
    },

    update_widget_count: function ($el, count) {
      var widget_id = $el.closest('.widget').attr('id');
      var widget = this.widget_by_selector('#' + widget_id);

      if (widget) {
        widget.attr({
          count: count,
          has_count: true
        });
      }
      this.update_add_more_link();
    },

    update_add_more_link: function () {
      var has_hidden_widgets = false;
      var $hidden_widgets = $('.hidden-widgets-list:not(.top-space)');
      var instance = this.options.instance || {};
      var model = instance.constructor;
      var show_all_tabs = false;

      if (model.obj_nav_options) {
        show_all_tabs = model.obj_nav_options.show_all_tabs;
      }

      // Update has hidden widget attr
      $.map(this.options.widget_list, function (widget) {
        if (widget.has_count && widget.count === 0 &&
            !widget.force_show && !show_all_tabs) {
          has_hidden_widgets = true;
        }
      });
      if (has_hidden_widgets) {
        $hidden_widgets.show();
      } else {
        $hidden_widgets.hide();
      }
      this.show_hide_titles();
    },
    '{window} resize': function (el, ev) {
      this.show_hide_titles();
    },
    show_hide_titles: _.debounce(function () {
      var $el = this.element;
      var widgets = this.options.widget_list;
      var widths;

      // first expand all
      widgets.forEach(function (widget) {
        widget.attr('show_title', true);
      });

      // see if too wide
      widths = _.map($el.children(':visible'),
                         function (el) {
                           return $(el).width();
                         }).reduce(function (m, w) {
                           return m + w;
                         }, 0);

      // adjust
      if (widths > $el.width()) {
        widgets.forEach(function (widget) {
          widget.attr('show_title', false);
        });
      }
    }, 100),
    '.closed click': function (el, ev) {
      var $link = el.closest('a');
      var widget = this.widget_by_selector('#' + $link.attr('href')
                                                      .split('#')[1]);
      var widgets = this.options.widget_list;

      widget.attr('force_show', false);
      this.route(widgets[0].selector); // Switch to the first widget
      return false; // Prevent the url change back to the widget we are hiding
    },

    // top nav dropdown position
    '.dropdown-toggle click': function (el, ev) {
      var $dropdown = el.closest('.hidden-widgets-list').find('.dropdown-menu');
      var $menu_item = $dropdown.find('.inner-nav-item').find('a');
      var offset = el.offset();
      var left_pos = offset.left;
      var win = $(window);
      var win_width = win.width();

      if (win_width - left_pos < 322) {
        $dropdown.addClass('right-pos');
      } else {
        $dropdown.removeClass('right-pos');
      }
      if ($menu_item.length === 1) {
        $dropdown.addClass('one-item');
      } else {
        $dropdown.removeClass('one-item');
      }
    }
  });
})(this.can, this.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, $, GGRC) {
  GGRC.Controllers.Modals('GGRC.Controllers.QuickForm', {
    defaults: {
      model: null,
      instance: null
    }
  }, {
    init: function () {
      if (this.options.instance && !this.options.model) {
        this.options.model = this.options.instance.constructor;
      }
      this.options.$content = this.element;
      if (this.element.data('force-refresh')) {
        this.options.instance.refresh();
      }
    },
    'input, textarea, select change': function (el) {
      var self = this;
      var val;
      var prop;
      var oldValue;
      if (el.data('toggle') === 'datepicker') {
        val = el.datepicker('getDate');
        prop = el.attr('name');
        oldValue = this.options.instance.attr(prop);

        if (moment(val).isSame(oldValue)) {
          return;
        }
        can.when(this.options.instance.refresh()).then(function () {
          self.options.instance.attr(prop, val);
          self.options.instance.save();
        });
        return;
      }
      if (!el.is('[data-lookup]')) {
        this.set_value_from_element(el);
        setTimeout(function () {
          this.options.instance.save();
        }.bind(this), 100);
      }
    },
    autocomplete_select: function (el, event, ui) {
      var self = this;
      var prop = el.attr('name').split('.').slice(0, -1).join('.');
      if (this._super.apply(this, arguments) !== false) {
        setTimeout(function () {
          self.options.instance.save().then(function () {
            var obj = self.options.instance.attr(prop);
            if (obj.attr) {
              obj.attr('saved', true);
            }
          });
        }, 100);
      } else {
        return false;
      }
    },
    'input, select, textarea click': function (el, ev) {
      if (el.data('toggle') === 'datepicker') {
        return;
      }
      if (this._super) {
        this._super.apply(this, arguments);
      }
      ev.stopPropagation();
    },
    '.dropdown-menu > li click': function (el, ev) {
      var self = this;
      ev.stopPropagation();
      this.set_value({name: el.data('name'), value: el.data('value')});
      setTimeout(function () {
        self.options.instance.save();
        $(el).closest('.open').removeClass('open');
      }, 100);
    },
    'button[data-name][data-value]:not(.disabled), a.undoable[data-toggle*=modal] click': function (el, ev) {
      var self = this;
      var name = el.data('name');
      var oldValue = {};
      var action;
      var openclose;
      var isOpened;

      if (el.data('openclose')) {
        action = el.data('openclose');
        openclose = el.closest('.item-main').find('.openclose');
        isOpened = openclose.hasClass('active');

        // We can't use main.openclose(action) here because content may not be loaded yet
        if (action === 'trigger') {
          openclose.trigger('click');
        } else if (action === 'close' && isOpened) {
          openclose.trigger('click');
        } else if (action === 'open' && !isOpened) {
          openclose.trigger('click');
        }
      }

      oldValue[name] = this.options.instance.attr(name);
      if (el.data('also-undo')) {
        can.each(el.data('also-undo').split(','), function (attrname) {
          attrname = attrname.trim();
          oldValue[attrname] = self.options.instance.attr(attrname);
        });
      }

      // Check if the undo button was clicked:
      self.options.instance.attr('_undo') || self.options.instance.attr('_undo', []);

      if (el.is('[data-toggle*=modal')) {
        setTimeout(function () {
          $('.modal:visible').one('modal:success', function () {
            self.options.instance.attr('_undo').unshift(oldValue);
          });
        }, 100);
      } else {
        ev.stopPropagation();
        self.options.instance.attr('_undo').unshift(oldValue);

        self.options.instance.attr('_disabled', 'disabled');
        self.options.instance.refresh().then(function (instance) {
          self.set_value({name: el.data('name'), value: el.data('value')});
          return instance.save();
        }).then(function () {
          self.options.instance.attr('_disabled', '');
        });
      }
    },
    'a.undo click': function (el, ev) {
      var self = this;
      var newValue = this.options.instance.attr('_undo').shift();
      ev.stopPropagation();

      this.options.instance.attr('_disabled', 'disabled');
      this.options.instance
        .refresh()
        .then(function (instance) {
          can.each(newValue, function (value, name) {
            self.set_value({name: name, value: value});
          });
          return instance.save();
        }).then(function () {
          self.options.instance.attr('_disabled', '');
        });
    }
  });
})(window.can, window.can.$, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $, GGRC) {
  'use strict';

  can.Control('GGRC.Controllers.Comments', {
  }, {
    _create_relationship: function (source, destination) {
      if (!destination) {
        return $.Deferred().resolve();
      }

      return new CMS.Models.Relationship({
        source: source.stub(),
        destination: destination,
        context: source.context
      }).save();
    },
    '{CMS.Models.Comment} created': function (model, ev, instance) {
      var parentDfd;
      var permissionRefresh;
      var source;

      if (!(instance instanceof CMS.Models.Comment)) {
        return;
      }

      source = instance._source_mapping || GGRC.page_instance();
      parentDfd = this._create_relationship(source, instance);
      permissionRefresh = Permission.refresh();

      instance.delay_resolving_save_until(
        $.when(parentDfd, permissionRefresh));
    }
  });

  $(function () {
    $(document.body).ggrc_controllers_comments();
  });
})(this.can, this.can.$, this.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  var selectors = _.map(['unified-mapper', 'unified-search'], function (val) {
    return '[data-toggle="' + val + '"]';
  });

  can.Control('GGRC.Controllers.MapperModal', {
    defaults: {
      component: GGRC.mustache_path + '/modals/mapper/component.mustache'
    },
    launch: function ($trigger, options) {
      var href = $trigger.attr('data-href') || $trigger.attr('href');
      var modalId = 'ajax-modal-' + (href || '').replace(/[\/\?=\&#%]/g, '-').replace(/^-/, '');
      var $target = $('<div id="' + modalId + '" class="modal modal-selector hide"></div>');

      $target.modal_form({}, $trigger);
      this.newInstance($target[0], $.extend({
        $trigger: $trigger
      }, options));
      return $target;
    }
  }, {
    init: function () {
      this.element.html(can.view(this.options.component, this.options));
    }
  });

  $('body').on('click', selectors.join(', '), function (ev, disableMapper) {
    var btn = $(ev.currentTarget);
    var data = {};
    var isSearch;

    _.each(btn.data(), function (val, key) {
      data[can.camelCaseToUnderscore(key)] = val;
    });

    if (data.tooltip) {
      data.tooltip.hide();
    }
    if (!data.clickable) {
      ev.preventDefault();
    }

    isSearch = /unified-search/ig.test(data.toggle);
    if (!disableMapper) {
      GGRC.Controllers.MapperModal.launch(btn, _.extend({
        object: btn.data('join-object-type'),
        type: btn.data('join-option-type'),
        'join-object-id': btn.data('join-object-id'),
        'search-only': isSearch,
        template: {
          title: isSearch ?
            '/static/mustache/base_objects/modal/search_title.mustache' : ''
        }
      }, data));
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function ($, CMS, GGRC) {
  // A widget descriptor has the minimum five properties:
  // widget_id:  the unique ID string for the widget
  // widget_name: the display title for the widget in the UI
  // widget_icon: the CSS class for the widget in the UI
  // content_controller: The controller class for the widget's content section
  // content_controller_options: options passed directly to the content controller; the
  //   precise options depend on the controller itself.  They usually require instance
  //   and/or model and some view.
  can.Construct('GGRC.WidgetDescriptor', {
    /*
      make an info widget descriptor for a GGRC object
      You must provide:
      instance - an instance that is a subclass of can.Model.Cacheable
      widgetView [optional] - a template for rendering the info.
    */
    make_info_widget: function (instance, widgetView) {
      var defaultInfoWidgetView = GGRC.mustache_path +
                                     '/base_objects/info.mustache';
      return new this(
        instance.constructor.shortName + ':info', {
          widget_id: 'info',
          widget_name: function () {
            if (instance.constructor.title_singular === 'Person') {
              return 'Info';
            }
            return instance.constructor.title_singular + ' Info';
          },
          widget_icon: 'info-circle',
          content_controller: GGRC.Controllers.InfoWidget,
          content_controller_options: {
            instance: instance,
            model: instance.constructor,
            widget_view: widgetView || defaultInfoWidgetView
          },
          order: 5
        });
    },
    /*
      make an summary widget descriptor for a GGRC object
      You must provide:
      instance - an instance that is a subclass of can.Model.Cacheable
      widgetView [optional] - a template for rendering the info.
    */
    make_summary_widget: function (instance, widgetView) {
      var defaultView = GGRC.mustache_path +
        '/base_objects/summary.mustache';
      return new this(
        instance.constructor.shortName + ':summary', {
          widget_id: 'Summary',
          widget_name: function () {
            return instance.constructor.title_singular + ' Summary';
          },
          widget_icon: 'pie-chart',
          content_controller: GGRC.Controllers.SummaryWidget,
          content_controller_options: {
            instance: instance,
            model: instance.constructor,
            widget_view: widgetView || defaultView
          },
          order: 3
        });
    },
    /*
      make a tree view widget descriptor with mostly default-for-GGRC settings.
      You must provide:
      instance - an instance that is a subclass of can.Model.Cacheable
      farModel - a can.Model.Cacheable class
      mapping - a mapping object taken from the instance
      extenders [optional] - an array of objects that will extend the default widget config.
    */
    make_tree_view: function (instance, farModel, mapping, extenders) {
      var descriptor;
      // Should not even try to create descriptor if configuration options are missing
      if (!instance || !farModel || !mapping) {
        console
          .debug('Arguments are missing or have incorrect format', arguments);
        return null;
      }
      descriptor = {
        content_controller: CMS.Controllers.TreeView,
        content_controller_selector: 'ul',
        widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
        widget_id: farModel.table_singular,
        widget_guard: function () {
          if (
            farModel.title_plural === 'Audits' &&
            instance instanceof CMS.Models.Program
          ) {
            return 'context' in instance && !!(instance.context.id);
          }
          return true;
        },
        widget_name: function () {
          var $objectArea = $('.object-area');
          if (
            $objectArea.hasClass('dashboard-area') ||
            instance.constructor.title_singular === 'Person'
          ) {
            if (/dashboard/.test(window.location)) {
              return 'My ' + farModel.title_plural;
            }
            return farModel.title_plural;
          } else if (farModel.title_plural === 'Audits') {
            return 'Mapped Audits';
          }
          return (
            farModel.title_plural === 'References' ?
                                         'Linked ' : 'Mapped '
          ) + farModel.title_plural;
        },
        widget_icon: farModel.table_singular,
        object_category: farModel.category || 'default',
        model: farModel,
        content_controller_options: {
          child_options: [],
          draw_children: true,
          parent_instance: instance,
          model: farModel,
          list_loader: function () {
            return mapping.refresh_list();
          }
        }
      };

      $.extend.apply($, [true, descriptor].concat(extenders || []));

      return new this(
        instance.constructor.shortName + ':' + farModel.table_singular,
        descriptor
      );
    },
    newInstance: function (id, opts) {
      var ret;
      if (!opts && typeof id === 'object') {
        opts = id;
        id = opts.widget_id;
      }

      if (GGRC.widget_descriptors[id]) {
        if (GGRC.widget_descriptors[id] instanceof this) {
          $.extend(GGRC.widget_descriptors[id], opts);
        } else {
          ret = this._super.apply(this);
          $.extend(ret, GGRC.widget_descriptors[id], opts);
          GGRC.widget_descriptors[id] = ret;
        }
        return GGRC.widget_descriptors[id];
      }

      ret = this._super.apply(this, arguments);
      $.extend(ret, opts);
      GGRC.widget_descriptors[id] = ret;
      return ret;
    }
  }, {});
})(window.can.$, window.CMS, window.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function ($, CMS, GGRC) {
  /*
    WidgetList - an extensions-ready repository for widget descriptor configs.
    Create a new widget list with new GGRC.WidgetList(list_name, widget_descriptions)
      where widget_descriptions is an object with the structure:
      { <page_name> :
        { <widget_id> :
          { <widget descriptor-ready properties> },
        ...},
      ...}

    See the comments for GGRC.WidgetDescriptor for details in what is necessary to define
    a widget descriptor.
  */
  can.Construct.extend('GGRC.WidgetList', {
    modules: {},
    /*
      get_widget_list_for: return a keyed object of widget descriptors for the specified page type.

      pageType - one of a GGRC object model's shortName, or "admin"

      The widget descriptors are built on the first call of this function; subsequently they are retrieved from the
       widget descriptor cache.
    */
    get_widget_list_for: function (pageType) {
      var widgets = {};
      var descriptors = {};

      can.each(this.modules, function (module) {
        can.each(module[pageType], function (descriptor, id) {
          if (!widgets[id]) {
            widgets[id] = descriptor;
          } else {
            can.extend(true, widgets[id], descriptor);
          }
        });
      });

      can.each(widgets, function (widget, widgetId) {
        switch (widget.content_controller) {
          case GGRC.Controllers.InfoWidget:
            descriptors[widgetId] = GGRC.WidgetDescriptor.make_info_widget(
              widget.content_controller_options && widget.content_controller_options.instance || widget.instance,
              widget.content_controller_options && widget.content_controller_options.widget_view || widget.widget_view
            );
            break;
          case GGRC.Controllers.SummaryWidget:
            descriptors[widgetId] = GGRC.WidgetDescriptor.make_summary_widget(
              widget.content_controller_options &&
              widget.content_controller_options.instance ||
              widget.instance,
              widget.content_controller_options &&
              widget.content_controller_options.widget_view ||
              widget.widget_view
            );
            break;
          case GGRC.Controllers.TreeView:
            descriptors[widgetId] = GGRC.WidgetDescriptor.make_tree_view(
              widget.content_controller_options && (widget.content_controller_options.instance || widget.content_controller_options.parent_instance) || widget.instance,
              widget.content_controller_options && widget.content_controller_options.model || widget.far_model || widget.model,
              widget.content_controller_options && widget.content_controller_options.mapping || widget.mapping,
              widget
            );
            break;
          default:
            descriptors[widgetId] = new GGRC.WidgetDescriptor(
                pageType + ':' + widgetId, widget);
        }
      });

      can.each(descriptors, function (descriptor, id) {
        if (!descriptor || descriptor.suppressed) {
          delete descriptors[id];
        }
      });

      return descriptors;
    },
    /*
      returns a keyed object of widget descriptors that represents the current page.
    */
    get_current_page_widgets: function () {
      return this.get_widget_list_for(
        GGRC.page_instance().constructor.shortName);
    },
    get_default_widget_sort: function () {
      return this.sort;
    }
  }, {
    init: function (name, opts, sort) {
      this.constructor.modules[name] = this;
      can.extend(this, opts);
      if (sort && sort.length) {
        this.constructor.sort = sort;
      }
    },
    /*
      Here instead of using the object format described in the class comments, you may instead
      add widgets to the WidgetList by using add_widget.

      pageType - the shortName of a GGRC object class, or "admin"
      id - the desired widget's id.
      descriptor - a widget descriptor appropriate for the widget type. FIXME - the descriptor's
        widget_id value must match the value passed as "id"
    */
    add_widget: function (pageType, id, descriptor) {
      this[pageType] = this[pageType] || {};
      if (this[pageType][id]) {
        can.extend(true, this[pageType][id], descriptor);
      } else {
        this[pageType][id] = descriptor;
      }
    },
    suppress_widget: function (pageType, id) {
      this[pageType] = this[pageType] || {};
      if (this[pageType][id]) {
        can.extend(true, this[pageType][id], {
          suppressed: true
        });
      } else {
        this[pageType][id] = {
          suppressed: true
        };
      }
    }
  });
})(window.can.$, window.CMS, window.GGRC);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $, Permission) {
  can.Control('GGRC.Controllers.PbcWorkflows', {}, {
    '{CMS.Models.AssessmentTemplate} updated': function (model, ev, instance) {
      // Make sure instance.custom_attribute_definitions cache is cleared
      if (!(instance instanceof CMS.Models.AssessmentTemplate)) {
        return;
      }
      instance.custom_attribute_definitions.splice(0,
        instance.custom_attribute_definitions.length);
    },
    '{CMS.Models.Issue} created': function (model, ev, instance) {
      var auditDfd;
      var controlDfd;
      var programDfd;
      var assessmentDfd;

      if (!(instance instanceof CMS.Models.Issue)) {
        return;
      }

      this._after_pending_joins(instance, function () {
        auditDfd = this._create_relationship(instance, instance.audit);
        controlDfd = this._create_relationship(instance, instance.control);
        programDfd = this._create_relationship(instance, instance.program);
        assessmentDfd = this._create_relationship(
          instance, instance.assessment);
        instance.delay_resolving_save_until($.when(auditDfd, controlDfd,
            programDfd, assessmentDfd));
      }.bind(this));
    },
    '{CMS.Models.Section} created': function (model, ev, instance) {
      var directiveDfd;

      if (!(instance instanceof CMS.Models.Section)) {
        return;
      }

      this._after_pending_joins(instance, function () {
        directiveDfd = this._create_relationship(instance, instance.directive);
        instance.delay_resolving_save_until($.when(directiveDfd));
      }.bind(this));
    },
    '{CMS.Models.UserRole} created': function (model, ev, instance) {
      var dfd;
      if (!(instance instanceof CMS.Models.UserRole)) {
        return;
      }
      if (instance.role_name !== 'Auditor') {
        return;
      }
      // Find the program context
      dfd = instance.refresh_all('context', 'related_object', 'program',
          'context');
      dfd.then(function (programContext) {
        // Find existing auditor roles for program context
        return $.when(
            programContext,
            CMS.Models.UserRole.findAll({context_id: programContext.id,
                person_id: instance.person.id}),
            CMS.Models.Role.findAll({name: 'ProgramReader'}));
      }).then(function (programContext, auditorProgramRoles, readerRoles) {
        // Check if there are any existing roles for the user and program context
        if (auditorProgramRoles.length) {
          return null;
        }
        // If no program role exists for the user, we create a reader role
        return new CMS.Models.UserRole({
          person: instance.person,
          role: readerRoles[0].stub(),
          context: programContext
        }).save();
      });
      instance.delay_resolving_save_until(dfd);
    },
    _after_pending_joins: function (instance, callback) {
      var dfd = instance.attr('_pending_joins_dfd');
      if (!dfd) {
        dfd = new $.Deferred().resolve();
      }
      dfd.then(callback);
    },
    _create_relationship: function (source, destination, context) {
      if (!destination || !destination.id) {
        return $.Deferred().resolve();
      }
      if (!context) {
        context = source.context;
      }
      return new CMS.Models.Relationship({
        source: source.stub(),
        destination: destination,
        context: context
      }).save();
    }
  });

  $(function () {
    $(document.body).ggrc_controllers_pbc_workflows();
  });
})(this.can, this.can.$, window.Permission);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

//= require can.jquery-all
//= require controllers/quick_search_controller

(function(namespace, $) {
  $(document.body).on("click", ".lhn-no-init", function() {
    $(this).removeClass('lhn-no-init');
    $("#lhn").cms_controllers_lhn();
    $(document.body).ggrc_controllers_recently_viewed();
  });
  $(document.body).on("click", "a[data-toggle=unmap]", function(ev) {
    var $el = $(this)
      ;
    //  Prevent toggling `openclose` state in trees
    ev.stopPropagation();
    $el.fadeTo('fast', 0.25);
    $el.children(".result").each(function(i, result_el) {
      var $result_el = $(result_el)
        , result = $result_el.data('result')
        , mappings = result && result.get_mappings()
        , i
        ;

      function notify(instance){
        $(document.body).trigger(
            "ajax:flash"
            , {"success" : "Unmap successful."}
          );
      }

      can.each(mappings, function(mapping) {
        mapping.refresh().done(function() {
          if (mapping instanceof CMS.Models.Control) {
            mapping.removeAttr('directive');
            mapping.save().then(notify);
          }
          else {
            mapping.destroy().then(notify);
          }
        });
      });
    });
  });

  $(document.body).on("click", ".map-to-page-object", function(ev) {
    //  Prevent toggling `openclose` state in trees
    ev.stopPropagation();

    var i, v, $target = $(ev.currentTarget)
    , follow = $target.data("follow")
    , inst = Mustache.resolve($target.data("instance"))
    , page_model = GGRC.infer_object_type(GGRC.page_object)
    , page_instance = GGRC.page_instance()
    //, link = page_model.links_to[inst.constructor.model_singular]
    , params = {}
    , mappings = Mustache.resolve($target.data("existing_mappings"));

    if(can.isArray(inst) || inst instanceof can.List) {
      if(mappings) {
        mappings = can.map(mappings, function(m) {
          return m.instance || m;
        });
      }

      for(i = 0; i < inst.length; i++) {
        v = inst[i].instance || inst[i];
        if(page_instance !== v && (!mappings || !~can.inArray(v, mappings))) {
          $target.data("instance", v);
          arguments.callee.call(this, ev);
        }
      }
      $target.data("instance", inst);
      return;
    }

    if(typeof link === "string") {
      link = GGRC.Models[link] || CMS.Models[link];
    }

    function triggerFlash(type) {
      $target.trigger(
        "ajax:flash"
        , type === "error"
          ? {
            error : [
              "Failed to map"
              , inst.constructor.title_singular
              , inst.title
              , "to"
              , page_model.title_singular
              , page_instance.title
              ].join(" ")
            }
          : {
            success : [
              "Mapped"
              , inst.constructor.title_singular
              , inst.title
              , "to"
              , page_model.title_singular
              , page_instance.title
              ].join(" ")
            }
        );

      // Switch the active widget view if 'data-follow' was specified
      if (follow && type !== "error") {
        window.location.hash = '#' + inst.constructor.root_object + '_widget';
        $('a[href="' + window.location.hash + '"]').trigger("click", true);
      }
    }

    var join_context;
    if (inst instanceof CMS.Models.Program && inst.context) {
      join_context = { id : inst.context.id };
    } else {
      join_context = page_instance.context || { id : null };
    }
    join_object = GGRC.Mappings.make_join_object(
        page_instance, inst, { context : join_context });
    // Map the object if we're able to
    if (join_object) {
      join_object.save()
        .done(triggerFlash)
        .fail(function(xhr) {
          // Currently, the only error we encounter here is uniqueness
          // constraint violations.  Let's use a nicer message!
          var message = "That object is already mapped";
          $(document.body).trigger("ajax:flash", { error: message });
        });
    }
    // Otherwise throw a warning
    else {
      triggerFlash("error");
    }

  });

})(this, jQuery);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  var CoreExtension = {};

  CoreExtension.name = 'core"';
  GGRC.extensions.push(CoreExtension);
  _.extend(CoreExtension, {
    object_type_decision_tree: function () {
      return {
        program: CMS.Models.Program,
        audit: CMS.Models.Audit,
        contract: CMS.Models.Contract,
        policy: CMS.Models.Policy,
        standard: CMS.Models.Standard,
        regulation: CMS.Models.Regulation,
        org_group: CMS.Models.OrgGroup,
        vendor: CMS.Models.Vendor,
        project: CMS.Models.Project,
        facility: CMS.Models.Facility,
        product: CMS.Models.Product,
        data_asset: CMS.Models.DataAsset,
        access_group: CMS.Models.AccessGroup,
        market: CMS.Models.Market,
        system_or_process: {
          _discriminator: function (data) {
            if (data.is_biz_process) {
              return CMS.Models.Process;
            }
            return CMS.Models.System;
          }
        },
        system: CMS.Models.System,
        process: CMS.Models.Process,
        control: CMS.Models.Control,
        assessment: CMS.Models.Assessment,
        assessment_template: CMS.Models.AssessmentTemplate,
        request: CMS.Models.Request,
        issue: CMS.Models.Issue,
        objective: CMS.Models.Objective,
        section: CMS.Models.Section,
        clause: CMS.Models.Clause,
        person: CMS.Models.Person,
        role: CMS.Models.Role,
        threat: CMS.Models.Threat,
        vulnerability: CMS.Models.Vulnerability,
        template: CMS.Models.Template
      };
    },
    init_widgets: function () {
      var base_widgets_by_type = GGRC.tree_view.base_widgets_by_type;
      var widget_list = new GGRC.WidgetList('ggrc_core');
      var object_class = GGRC.infer_object_type(GGRC.page_object);
      var object_table = object_class && object_class.table_plural;
      var object = GGRC.page_instance();
      var path = GGRC.mustache_path;
      var info_widget_views;
      var summaryWidgetViews;
      var model_names;
      var possible_model_type;
      var treeViewDepth = 2;
      var relatedObjectsChildOptions = [GGRC.Utils.getRelatedObjects(treeViewDepth)];

      // TODO: Really ugly way to avoid executing IIFE - needs cleanup
      if (!GGRC.page_object) {
        return;
      }
      // Info and summary widgets display the object information instead of listing
      // connected objects.
      summaryWidgetViews = {
        audits: path + '/audits/summary.mustache'
      };
      if (summaryWidgetViews[object_table]) {
        widget_list.add_widget(object.constructor.shortName, 'summary', {
          widget_id: 'summary',
          content_controller: GGRC.Controllers.SummaryWidget,
          instance: object,
          widget_view: summaryWidgetViews[object_table],
          order: 3
        });
      }
      info_widget_views = {
        programs: path + '/programs/info.mustache',
        audits: path + '/audits/info.mustache',
        people: path + '/people/info.mustache',
        policies: path + '/policies/info.mustache',
        objectives: path + '/objectives/info.mustache',
        controls: path + '/controls/info.mustache',
        systems: path + '/systems/info.mustache',
        processes: path + '/processes/info.mustache',
        products: path + '/products/info.mustache',
        assessments: path + '/assessments/info.mustache',
        assessment_templates:
          path + '/assessment_templates/info.mustache',
        requests: path + '/requests/info.mustache',
        issues: path + '/issues/info.mustache'
      };
      widget_list.add_widget(object.constructor.shortName, 'info', {
        widget_id: 'info',
        content_controller: GGRC.Controllers.InfoWidget,
        instance: object,
        widget_view: info_widget_views[object_table],
        order: 5
      });
      model_names = can.Map.keys(base_widgets_by_type);
      model_names.sort();
      possible_model_type = model_names.slice();
      possible_model_type.push('Request'); // Missing model-type by selection
      can.each(model_names, function (name) {
        var w_list;
        var child_model_list = [];

        GGRC.tree_view.basic_model_list.push({
          model_name: name,
          display_name: CMS.Models[name].title_singular
        });
        // Initialize child_model_list, and child_display_list each model_type
        w_list = base_widgets_by_type[name];

        can.each(w_list, function (item) {
          if (possible_model_type.indexOf(item) !== -1) {
            child_model_list.push({
              model_name: item,
              display_name: CMS.Models[item].title_singular
            });
          }
        });
        GGRC.tree_view.sub_tree_for.attr(name, {
          model_list: child_model_list,
          display_list: CMS.Models[name].tree_view_options.child_tree_display_list || w_list
        });
      });

      function sort_sections(sections) {
        return can.makeArray(sections).sort(window.natural_comparator);
      }

      function apply_mixins(definitions) {
        var mappings = {};

        // Recursively handle mixins
        function reify_mixins(definition) {
          var final_definition = {};
          if (definition._mixins) {
            can.each(definition._mixins, function (mixin) {
              if (typeof (mixin) === 'string') {
                // If string, recursive lookup
                if (!definitions[mixin]) {
                  console.debug('Undefined mixin: ' + mixin, definitions);
                } else {
                  can.extend(
                    final_definition,
                    reify_mixins(definitions[mixin])
                  );
                }
              } else if (can.isFunction(mixin)) {
                // If function, call with current definition state
                mixin(final_definition);
              } else {
                // Otherwise, assume object and extend
                can.extend(final_definition, mixin);
              }
            });
          }
          can.extend(final_definition, definition);
          delete final_definition._mixins;
          return final_definition;
        }

        can.each(definitions, function (definition, name) {
          // Only output the mappings if it's a model, e.g., uppercase first letter
          if (name[0] === name[0].toUpperCase())
            mappings[name] = reify_mixins(definition);
        });

        return mappings;
      }


      var far_models = base_widgets_by_type[object.constructor.shortName],
        // here we are going to define extra descriptor options, meaning that
        //  these will be used as extra options to create widgets on top of

      // NOTE: By default, widgets are sorted alphabetically (the value of
      // the order 100+), but the objects with higher importance that should
      // be  prioritized use order values below 100. An order value of 0 is
      // reserved for the "info" widget which always comes first.
      extra_descriptor_options = {
        all: {
          Standard: {
            order: 10
          },
          Regulation: {
            order: 20
          },
          Contract: {
            order: 30
          },
          Section: {
            order: 40
          },
          Objective: {
            order: 50
          },
          Control: {
            order: 60
          },
          AccessGroup: {
            order: 100
          },
          Assessment: {
            order: 110
          },
          Audit: {
            order: 120
          },
          Clause: {
            order: 130
          },
          DataAsset: {
            order: 140
          },
          Document: {
            widget_icon: 'fa fa-link',
            order: 150
          },
          Facility: {
            order: 160
          },
          Issue: {
            order: 170
          },
          Market: {
            order: 180
          },
          OrgGroup: {
            order: 190
          },
          Person: {
            widget_icon: 'fa fa-person',
            order: 200
          },
          Policy: {
            order: 210
          },
          Process: {
            order: 220
          },
          Product: {
            order: 230
          },
          Program: {
            order: 240
          },
          Project: {
            order: 250
          },
          Request: {
            order: 260
          },
          System: {
            order: 270
          },
          Vendor: {
            order: 280
          }
        },
        Contract: {
          Clause: {
            widget_name: function () {
              var $objectArea = $('.object-area');
              if ($objectArea.hasClass('dashboard-area')) {
                return 'Clauses';
              } else {
                return 'Mapped Clauses';
              }
            }
          }
        },
        Program: {
          Person: {
            widget_id: 'person',
            widget_name: 'People',
            widget_icon: 'person',
            content_controller: GGRC.Controllers.TreeView
          }
        },

        // An Audit has a different set of object that are more relevant to it,
        // thus these objects have a customized priority. On the other hand,
        // the object otherwise prioritized by default (e.g. Regulation) have
        // their priority lowered so that they fit nicely into the alphabetical
        // order among the non-prioritized object types.
        Audit: {
          Assessment: {
            order: 10
          },
          Request: {
            widget_id: 'Request',
            widget_name: 'Requests',
            order: 20
          },
          Issue: {
            order: 30
          },
          AssessmentTemplate: {
            order: 40
          },
          Contract: {
            order: 133  // between default Clause (130) and DataAsset (140)
          },
          Control: {
            order: 137  // between default Clause (130) and DataAsset (140)
          },
          Objective: {
            order: 182  // between default Market (180) and OrgGroup (190)
          },
          Regulation: {
            order: 257  // between default Project (250) and Request (260)
          },
          program: {
            widget_id: 'program',
            widget_name: 'Program',
            widget_icon: 'program'
          },
          Section: {
            order: 263  // between default Request (260) and System (270)
          },
          Standard: {
            order: 267  // between default Request (260) and System (270)
          },
          Person: {
            widget_id: 'person',
            widget_name: 'People',
            widget_icon: 'person',
            // NOTE: "order" not overridden
            content_controller: GGRC.Controllers.TreeView,
            content_controller_options: {
              mapping: 'authorized_people',
              allow_mapping: false,
              allow_creating: false
            }
          }
        },
        Control: {
          Request: {
            widget_id: 'Request',
            widget_name: 'Requests'
          }
        },
        Person: {
          Request: {
            widget_id: 'Request',
            widget_name: 'Requests'
          }
        }
      },
      // Prevent widget creation with <model_name>: false
      // e.g. to prevent ever creating People widget:
      //     { all : { Person: false }}
      // or to prevent creating People widget on Objective page:
      //     { Objective: { Person: false } }
      overridden_models = {
        Program: {
        },
        all: {
          Document: false
        }
      },

      extra_content_controller_options = apply_mixins({
        objectives: {
          Objective: {
            mapping: 'objectives',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/objectives/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/objectives/tree_add_item.mustache'
          }
        },
        controls: {
          Control: {
            mapping: 'controls',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/controls/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/controls/tree_add_item.mustache'
          }
        },
        business_objects: {
          Audit: {
            mapping: 'related_audits',
            draw_children: true,
            child_options: relatedObjectsChildOptions,
            allow_mapping: true,
            add_item_view: path + '/audits/tree_add_item.mustache'
          },
          AccessGroup: {
            mapping: 'related_access_groups',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          DataAsset: {
            mapping: 'related_data_assets',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Facility: {
            mapping: 'related_facilities',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Market: {
            mapping: 'related_markets',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          OrgGroup: {
            mapping: 'related_org_groups',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Vendor: {
            mapping: 'related_vendors',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Process: {
            mapping: 'related_processes',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Product: {
            mapping: 'related_products',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Project: {
            mapping: 'related_projects',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          System: {
            mapping: 'related_systems',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Assessment: {
            mapping: 'related_assessments',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            footer_view: path + '/base_objects/tree_footer.mustache'
          },
          Request: {
            mapping: 'related_requests',
            child_options: [
              _.extend({}, relatedObjectsChildOptions[0], {
                mapping: 'info_related_objects'
              })
            ],
            draw_children: true
          },
          Document: {
            mapping: 'documents',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Person: {
            mapping: 'people',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Program: {
            mapping: 'programs',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        issues: {
          Issue: {
            mapping: 'related_issues',
            footer_view: GGRC.mustache_path +
              '/base_objects/tree_footer.mustache',
            add_item_view: GGRC.mustache_path +
              '/base_objects/tree_add_item.mustache',
            child_options: relatedObjectsChildOptions.concat({
              model: CMS.Models.Person,
              mapping: 'people',
              show_view: GGRC.mustache_path +
                '/base_objects/tree.mustache',
              footer_view: GGRC.mustache_path +
                '/base_objects/tree_footer.mustache',
              draw_children: false
            }),
            draw_children: true
          }
        },
        governance_objects: {
          Regulation: {
            mapping: 'regulations',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/directives/tree_add_item.mustache'
          },
          Contract: {
            mapping: 'contracts',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache'
          },
          Policy: {
            mapping: 'policies',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/directives/tree_add_item.mustache'
          },
          Standard: {
            mapping: 'standards',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/directives/tree_add_item.mustache'
          },
          Control: {
            mapping: 'controls',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Objective: {
            mapping: 'objectives',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Section: {
            mapping: 'sections',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Clause: {
            mapping: 'clauses',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        Program: {
          _mixins: [
            'governance_objects', 'objectives', 'controls',
            'business_objects', 'issues'
          ],
          Audit: {
            mapping: 'audits',
            allow_mapping: true,
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/audits/tree.mustache',
            header_view: path + '/audits/tree_header.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/audits/tree_add_item.mustache'
          },
          Person: {
            show_view: path + '/ggrc_basic_permissions/people_roles/authorizations_by_person_tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            parent_instance: GGRC.page_instance(),
            allow_reading: true,
            allow_mapping: true,
            allow_creating: true,
            model: CMS.Models.Person,
            mapping: 'mapped_and_or_authorized_people',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        Audit: {
          _mixins: ['issues', 'governance_objects', 'business_objects'],
          Request: {
            mapping: 'active_requests',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/requests/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/requests/tree_add_item.mustache'
          },
          Program: {
            mapping: '_program',
            parent_instance: GGRC.page_instance(),
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            model: CMS.Models.Program,
            show_view: path + '/programs/tree.mustache',
            allow_mapping: false,
            allow_creating: false
          },
          Section: {
            mapping: 'sections',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Clause: {
            mapping: 'clauses',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Assessment: {
            mapping: 'related_assessments',
            parent_instance: GGRC.page_instance(),
            allow_mapping: true,
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            model: CMS.Models.Assessment,
            show_view: path + '/base_objects/tree.mustache',
            header_view: path + '/base_objects/tree_header.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/assessments/tree_add_item.mustache'
          },
          AssessmentTemplate: {
            mapping: 'related_assessment_templates',
            child_options: relatedObjectsChildOptions,
            draw_children: false,
            allow_mapping: false,
            show_view: GGRC.mustache_path +
              '/base_objects/tree.mustache',
            footer_view: GGRC.mustache_path +
              '/base_objects/tree_footer.mustache',
            add_item_view: GGRC.mustache_path +
              '/assessment_templates/tree_add_item.mustache'
          },
          Person: {
            widget_id: 'person',
            widget_name: 'People',
            widget_icon: 'person',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            content_controller: GGRC.Controllers.TreeView,
            content_controller_options: {
              mapping: 'authorized_people',
              allow_mapping: false,
              allow_creating: false
            }
          }
        },
        directive: {
          _mixins: [
            'objectives', 'controls', 'business_objects'
          ],
          Section: {
            mapping: 'sections',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Clause: {
            mapping: 'clauses',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
         },
        Regulation: {
          _mixins: ['directive', 'issues']
        },
        Standard: {
          _mixins: ['directive', 'issues']
        },
        Policy: {
          _mixins: ['directive', 'issues']
        },
        Contract: {
          _mixins: ['directive', 'issues']
        },
        Clause: {
          _mixins: ['governance_objects', 'business_objects', 'issues'],
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        Section: {
          _mixins: ['governance_objects', 'business_objects', 'issues'],
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        Objective: {
          _mixins: ['governance_objects', 'business_objects', 'issues'],
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        Control: {
          _mixins: ['governance_objects', 'business_objects', 'issues'],
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          }
        },
        Request: {
          _mixins: ['governance_objects', 'business_objects', 'issues'],
          Audit: {
            mapping: 'audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            allow_creating: false,
            allow_mapping: false,
            show_view: path + '/audits/tree.mustache',
            add_item_view: path + '/audits/tree_add_item.mustache'
          },
        },
        Assessment: {
          _mixins: ['governance_objects', 'business_objects', 'issues'],
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            allow_creating: false,
            allow_mapping: true,
            show_view: path + '/audits/tree.mustache',
            add_item_view: path + '/audits/tree_add_item.mustache'
          },
          Section: {
            mapping: 'sections',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Clause: {
            mapping: 'clauses',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Request: {
            mapping: 'related_requests',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/requests/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/requests/tree_add_item.mustache'
          }
        },
        Issue: {
          _mixins: ['governance_objects', 'business_objects'],
          Control: {
            mapping: 'related_controls',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/controls/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/base_objects/tree_add_item.mustache'
          },
          Issue: {
            mapping: 'related_issues',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/base_objects/tree_add_item.mustache'
          },
          Audit: {
            mapping: 'related_audits',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: GGRC.mustache_path + '/audits/tree.mustache',
            footer_view:
              GGRC.mustache_path + '/base_objects/tree_footer.mustache',
            add_item_view:
              GGRC.mustache_path + '/base_objects/tree_add_item.mustache'
          }
        },
        AccessGroup: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        DataAsset: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Facility: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Market: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        OrgGroup: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Vendor: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Process: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Product: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Project: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        System: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Document: {
          _mixins: ['governance_objects', 'business_objects', 'issues']
        },
        Person: {
          _mixins: ['issues'],
          Request: {
            mapping: (/^\/objectBrowser\/?$/.test(window.location.pathname)) ?
              'all_open_audit_requests' : 'open_audit_requests',
            draw_children: true,
            child_options: relatedObjectsChildOptions,
            show_view: GGRC.mustache_path + '/requests/tree.mustache',
            footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
            add_item_view: GGRC.mustache_path + '/requests/tree_add_item.mustache'
          },
          Program: {
            mapping: 'extended_related_programs_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections
          },
          Regulation: {
            mapping: 'extended_related_regulations_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache'
          },
          Contract: {
            mapping: 'extended_related_contracts_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache'
          },
          Standard: {
            mapping: 'extended_related_standards_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache'
          },
          Policy: {
            mapping: 'extended_related_policies_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            fetch_post_process: sort_sections,
            show_view: path + '/directives/tree.mustache'
          },
          Audit: {
            mapping: 'extended_related_audits_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/audits/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache'
          },
          Section: {
            model: CMS.Models.Section,
            mapping: 'extended_related_sections_via_search',
            show_view: GGRC.mustache_path + '/sections/tree.mustache',
            footer_view:
              GGRC.mustache_path + '/base_objects/tree_footer.mustache',
            add_item_view:
              GGRC.mustache_path + '/base_objects/tree_add_item.mustache',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Clause: {
            model: CMS.Models.Clause,
            mapping: 'extended_related_clauses_via_search',
            show_view: GGRC.mustache_path + '/sections/tree.mustache',
            footer_view:
              GGRC.mustache_path + '/base_objects/tree_footer.mustache',
            add_item_view:
              GGRC.mustache_path + '/base_objects/tree_add_item.mustache',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Objective: {
            mapping: 'extended_related_objectives_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/objectives/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/base_objects/tree_add_item.mustache'
          },
          Control: {
            mapping: 'extended_related_controls_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            show_view: path + '/controls/tree.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache',
            add_item_view: path + '/base_objects/tree_add_item.mustache'
          },
          Issue: {
            mapping: 'extended_related_issues_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache'
          },
          AccessGroup: {
            mapping: 'extended_related_access_groups_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          DataAsset: {
            mapping: 'extended_related_data_assets_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Facility: {
            mapping: 'extended_related_facilities_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Market: {
            mapping: 'extended_related_markets_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          OrgGroup: {
            mapping: 'extended_related_org_groups_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Vendor: {
            mapping: 'extended_related_vendors_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Process: {
            mapping: 'extended_related_processes_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Product: {
            mapping: 'extended_related_products_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Project: {
            mapping: 'extended_related_projects_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          System: {
            mapping: 'extended_related_systems_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true
          },
          Document: {
            mapping: 'extended_related_documents_via_search'
          },
          Assessment: {
            mapping: 'extended_related_assessment_via_search',
            child_options: relatedObjectsChildOptions,
            draw_children: true,
            add_item_view: null,
            header_view: path + '/assessments/tree_header.mustache',
            footer_view: path + '/base_objects/tree_footer.mustache'
          }
        }
      });

      // Disable editing on profile pages, as long as it isn't audits on the dashboard
      if (GGRC.page_instance() instanceof CMS.Models.Person) {
        var person_options = extra_content_controller_options.Person;
        can.each(person_options, function (options, model_name) {
          if (model_name !== 'Audit' || !/dashboard/.test(window.location)) {
            can.extend(options, {
              allow_creating: false,
              allow_mapping: true
            });
          }
        });
      }

      can.each(far_models, function (model_name) {
        if ((overridden_models.all && overridden_models.all.hasOwnProperty(model_name) && !overridden_models[model_name]) || (overridden_models[object.constructor.shortName] && overridden_models[object.constructor.shortName].hasOwnProperty(model_name) && !overridden_models[object.constructor.shortName][model_name]))
          return;
        var sources = [],
          far_model, descriptor = {},
          widget_id;

        far_model = CMS.Models[model_name];
        if (far_model) {
          widget_id = far_model.table_singular;
          descriptor = {
            instance: object,
            far_model: far_model,
            mapping: GGRC.Mappings.get_canonical_mapping(object.constructor.shortName, far_model.shortName)
          };
        } else {
          widget_id = model_name;
        }

        // Custom overrides
        if (extra_descriptor_options.all && extra_descriptor_options.all[model_name]) {
          $.extend(descriptor, extra_descriptor_options.all[model_name]);
        }

        if (extra_descriptor_options[object.constructor.shortName] && extra_descriptor_options[object.constructor.shortName][model_name]) {
          $.extend(descriptor, extra_descriptor_options[object.constructor.shortName][model_name]);
        }

        if (extra_content_controller_options.all && extra_content_controller_options.all[model_name]) {
          $.extend(true, descriptor, {
            content_controller_options: extra_content_controller_options.all[model_name]
          });
        }

        if (extra_content_controller_options[object.constructor.shortName] && extra_content_controller_options[object.constructor.shortName][model_name]) {
          $.extend(true, descriptor, {
            content_controller_options: extra_content_controller_options[object.constructor.shortName][model_name]
          });
        }
        widget_list.add_widget(object.constructor.shortName, widget_id, descriptor);
      });
    }
  });
})(window.can, window.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  GGRC.Components('customAttributes', {
    tag: 'custom-attributes',
    template: '<content/>',
    scope: {
      instance: null,
      items: [],
      setItems: function (isReady) {
        var values = [];
        if (isReady) {
          values = this.getValues().sort(function (a, b) {
            return a.cad.id - b.cad.id;
          });
          this.attr('items', values);
        }
      },
      getValues: function () {
        var result = [];

        can.each(this.attr('instance.custom_attribute_definitions'),
          function (cad) {
            var cav;
            var type = cad.attribute_type;
            can.each(this.attr('instance.custom_attribute_values'),
              function (val) {
                val = val.isStub ? val : val.reify();
                if (val.custom_attribute_id === cad.id) {
                  cav = val;
                }
              });
            result.push({
              cav: cav,
              cad: {
                id: cad.id,
                attribute_type: cad.attribute_type,
                mandatory: cad.mandatory,
                title: cad.title,
                label: cad.label,
                placeholder: cad.placeholder,
                helptext: cad.helptext,
                multi_choice_options: cad.multi_choice_options
              },
              type: GGRC.Utils.mapCAType(type)
            });
          }.bind(this));
        return result;
      }
    },
    init: function () {
      if (this.scope.instance.class.is_custom_attributable) {
        this.scope.instance.setup_custom_attributes();
      }
      this.scope.setItems(true);
    },
    events: {
      '{scope.instance} isReadyForRender': function (sc, ev, isReady) {
        this.scope.setItems(isReady);
      }
    }
  });
})(window.can, window.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  'use strict';

  GGRC.Components('spinner', {
    tag: 'spinner',
    template: can.view(
      GGRC.mustache_path +
      '/components/spinner/spinner.mustache'
    ),
    scope: {
      extraCssClass: '@',
      size: '@',
      toggle: null
    }
  });
})(window.can);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tag = 'collapsible-panel';
  var tpl = can.view(GGRC.mustache_path +
    '/components/collapsible-panel/collapsible-panel.mustache');
  /**
   * Collapsible Panel component to add collapsing behavior
   */
  GGRC.Components('collapsiblePanel', {
    tag: tag,
    template: tpl,
    scope: {
      titleText: '@',
      titleIcon: '@',
      extraCssClass: '@',
      expanded: true,
      define: {
        collapsed: {
          type: 'boolean',
          'default': false
        }
      }
    },
    init: function () {
      this.scope.attr('expanded', !(this.scope.attr('collapsed')));
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tag = 'collapsible-panel-header';
  var tpl = can.view(GGRC.mustache_path +
    '/components/collapsible-panel/collapsible-panel-header.mustache');
  /**
   * Collapsible Panel component to add collapsing behavior
   */
  GGRC.Components('collapsiblePanelHeader', {
    tag: tag,
    template: tpl,
    scope: {
      titleIcon: null,
      expanded: null,
      toggle: function () {
        this.attr('expanded', !this.attr('expanded'));
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tag = 'collapsible-panel-body';
  var tpl = can.view(GGRC.mustache_path +
    '/components/collapsible-panel/collapsible-panel-body.mustache');
  /**
   * Collapsible Panel component to add collapsing behavior
   */
  GGRC.Components('collapsiblePanelBody', {
    tag: tag,
    template: tpl,
    scope: {
      expanded: null
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/read-more/read-more.mustache');
  var tag = 'read-more';
  var defaultTextLength = 200;
  var readMore = 'Read More';
  var readLess = 'Read Less';
  var overflowPostfix = '...';
  /**
   * Assessment specific read more view component
   */
  GGRC.Components('readMore', {
    tag: tag,
    template: tpl,
    scope: {
      maxTextLength: '@',
      text: null,
      expanded: false,
      resultedText: null,
      overflowing: false,
      btnText: function () {
        return this.attr('expanded') ? readLess : readMore;
      },
      toggle: function (scope, el, ev) {
        ev.stopPropagation();
        this.attr('expanded', !this.attr('expanded'));
      },
      /**
       * Get Limited text string
       * @param {String} text - is original text
       * @param {Number} limit - is maximum allowed text length
       * @return {string} - returns resulted text part with "..." ending
         */
      getSlicedText: function (text, limit) {
        // As we add extra postfix at the end - remove it's length from the limit
        limit -= overflowPostfix.length;
        return text.slice(0, limit) + overflowPostfix;
      },
      setValues: function (originalText) {
        var limit = Number(this.attr('maxTextLength')) || defaultTextLength;
        var trimmedText = GGRC.Utils.getPlainText(originalText);
        var isOverflowing = trimmedText.length >= limit;
        this.attr('maxTextLength', limit);
        this.attr('overflowing', isOverflowing);
        this.attr('resultedText', isOverflowing ?
          this.getSlicedText(trimmedText, limit) :
          originalText);
      }
    },
    events: {
      init: function () {
        this.scope.setValues(this.scope.attr('text'));
      },
      '{scope} text': function (scope, ev, val) {
        this.scope.setValues(val);
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/assessment/mapped-objects/' +
    'mapped-controls.mustache');
  var tag = 'assessment-mapped-controls';
  /**
   * Assessment specific mapped controls view component
   */
  can.Component.extend({
    tag: tag,
    template: tpl,
    scope: {
      titleText: '@',
      filter: {
        only: ['Control']
      },
      mapping: '@',
      mappingType: '@',
      expanded: true,
      selectedItem: {},
      instance: null
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/assessment/mapped-objects/mapped-controls-popover.mustache');
  var tag = 'assessment-mapped-controls-popover';
  /**
   * Assessment specific mapped controls popover view component
   */
  var defaultResponseArr = [{
    Objective: {
      values: []
    }
  }, {
    Regulation: {
      values: []
    }
  }];

  GGRC.Components('mappedControlsPopover', {
    tag: tag,
    template: tpl,
    scope: {
      item: null,
      expanded: false,
      objectives: new can.List(),
      regulations: new can.List(),
      isLoading: false,
      getParams: function (id, type) {
        var params = {};
        var relevant = {
          id: id,
          type: type
        };
        var fields = ['id', 'title', 'notes', 'description'];
        params.data = [
          GGRC.Utils.QueryAPI.buildParam('Objective', {}, relevant, fields),
          GGRC.Utils.QueryAPI.buildParam('Regulation', {}, relevant, fields)
        ];
        return params;
      },
      setItems: function (responseArr) {
        responseArr.forEach(function (item) {
          if (item.Objective) {
            this.attr('objectives').replace(item.Objective.values);
          }
          if (item.Regulation) {
            this.attr('regulations').replace(item.Regulation.values);
          }
        }.bind(this));
      },
      loadItems: function () {
        var id = this.attr('item.data.id');
        var type = this.attr('item.data.type');
        var params;

        if (!id || !type) {
          this.setItems(defaultResponseArr);
          return;
        }
        params = this.getParams(id, type);

        this.attr('isLoading', true);

        GGRC.Utils.QueryAPI
          .makeRequest(params)
          .done(this.setItems.bind(this))
          .fail(function () {
            console.warn('Errors are: ', arguments);
            this.setItems(defaultResponseArr);
          }.bind(this))
          .always(function () {
            this.attr('isLoading', false);
          }.bind(this));
      }
    },
    events: {
      '{scope} expanded': function (scope, ev, isExpanded) {
        if (isExpanded) {
          this.scope.loadItems();
        }
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/assessment/mapped-objects/' +
    'mapped-related-information.mustache');
  var tag = 'assessment-mapped-related-information';
  /**
   * Assessment specific mapped related information view component
   */
  can.Component.extend({
    tag: tag,
    template: tpl,
    scope: {
      titleText: '@',
      filter: {
        exclude: ['Control']
      },
      mapping: '@',
      mappingType: '@',
      expanded: true,
      selectedItem: {},
      instance: null
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  'use strict';

  var tag = 'assessment-urls-list';
  var template = can.view(GGRC.mustache_path +
    '/components/assessment/urls-list.mustache');

  /**
   * Wrapper Component for rendering and managing of url lists
   */
  GGRC.Components('assessmentUrlsList', {
    tag: tag,
    template: template,
    scope: {},
    events: {}
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (GGRC, can) {
  'use strict';

  var tag = 'assessment-attachments-list';
  var template = can.view(GGRC.mustache_path +
    '/components/assessment/attachments-list.mustache');

  /**
   * Wrapper Component for rendering and managing of attachments lists
   */
  GGRC.Components('assessmentAttachmentsList', {
    tag: tag,
    template: template,
    scope: {},
    events: {
      init: function () {}
    }
  });
})(window.GGRC, window.can);


/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';
  var tpl = can.view(GGRC.mustache_path +
    '/components/assessment/custom-attributes.mustache');

  GGRC.Components('assessmentCustomAttributes', {
    tag: 'assessment-custom-attributes',
    template: tpl,
    scope: {
      instance: null,
      values: null,
      definitions: null,
      isModified: null,
      modal: {
        open: false
      },
      items: [],
      updateValues: function (defs, values) {
        var scope = this;
        return can.map(defs, function (def) {
          var valueData = false;
          var id = def.id;
          var type = GGRC.Utils.mapCAType(def.attribute_type);
          var stub = {
            isStub: true,
            attributable_id: scope.id,
            custom_attribute_id: id,
            attribute_value: null,
            attribute_object: null,
            preconditions_failed: (def.mandatory) ? ['value'] : [],
            def: def,
            attributeType: type
          };

          can.each(values, function (value) {
            if (value.custom_attribute_id === id) {
              value.attr('def', def);
              value.attr('attributeType', type);
              value.attr('preconditions_failed',
                value.attr('preconditions_failed') || []);
              valueData = value;
            }
          });

          return valueData || new can.Map(stub);
        });
      },
      refresh: function (isReady) {
        var scope = this;
        if (isReady) {
          scope.attr('values')
            .replace(scope.updateValues(scope.attr('definitions'),
              scope.attr('values')));
          scope.attr('items', scope.attr('values'));
        }
      }
    },
    init: function () {
      var isReady = this.scope.attr('instance.isReadyForRender');
      this.scope.refresh(isReady);
    },
    events: {
      '{scope.instance} isReadyForRender': function (sc, ev, isReady) {
        this.scope.refresh(isReady);
      }
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (_, can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/assessment/inline/inline.mustache');
  var innerTplFolder = GGRC.mustache_path + '/components/assessment/inline';

  function getTemplateByType(type) {
    type = can.Mustache.resolve(type);
    return innerTplFolder + '/' + type + '.mustache';
  }

  GGRC.Components('assessmentInlineEdit', {
    tag: 'assessment-inline-edit',
    template: tpl,
    scope: {
      titleText: null,
      type: null,
      value: null,
      options: null,
      readonly: false, // whether or not the value can be edited
      isSaving: false,
      isEdit: false,
      context: {
        value: null,
        options: null
      },

      _EV_BEFORE_EDIT: 'before-edit',  // before entering the edit mode

      setPerson: function (scope, el, ev) {
        this.attr('context.value', ev.selectedItem.serialize());
      },
      unsetPerson: function (scope, el, ev) {
        ev.preventDefault();
        this.attr('context.value', undefined);
      },

      /**
       * Enter the edit mode if editing is allowed (i.e. the readonly option is
       * not set).
       *
       * If the readonly option is enabled, do not do anything. The same if the
       * beforeEdit handler is not defined, or if the promise it returns is not
       * resolved.
       *
       * @param {can.Map} scope - the scope object itself (this)
       * @param {jQuery.Element} $el - the DOM element that triggered the event
       * @param {jQuery.Event} ev - the event object
       */
      enableEdit: function (scope, $el, ev) {
        var confirmation;
        var onBeforeEdit = this.$rootEl.attr('can-' + scope._EV_BEFORE_EDIT);

        ev.preventDefault();

        if (this.attr('readonly')) {
          return;
        }

        if (!onBeforeEdit) {
          this.attr('isEdit', true);
          return;
        }

        confirmation = this.$rootEl.triggerHandler({
          type: this._EV_BEFORE_EDIT
        });

        confirmation.done(function () {
          this.attr('isEdit', true);
        }.bind(this));   // and do nothing if no confirmation by the user
      },

      onCancel: function (scope) {
        scope.attr('isEdit', false);
        scope.attr('context.value', scope.attr('_value'));
      },
      onSave: function () {
        var oldValue = this.attr('value');
        var value = this.attr('context.value');

        this.attr('isEdit', false);
        // In case value is String and consists only of spaces - do nothing
        if (typeof value === 'string' && !value.trim()) {
          this.attr('context.value', '');
          value = null;
        }

        if (oldValue === value) {
          return;
        }

        this.attr('_value', oldValue);
        this.attr('value', value);
        this.attr('isSaving', true);
      }
    },
    init: function (element, options) {
      var scope = this.scope;
      var value = scope.attr('value');

      scope.attr('_value', value);
      scope.attr('context.value', value);

      scope.attr('$rootEl', $(element));
    },
    events: {
      '{window} mousedown': function (el, ev) {
        var scope = this.scope;
        var isInside = this.element.has(ev.target).length ||
          this.element.is(ev.target);

        if (!isInside && scope.attr('isEdit')) {
          _.defer(function () {
            scope.onSave();
          });
        }
      }
    },
    helpers: {
      renderInnerTemplateByType: function (type, options) {
        return can.view.render(getTemplateByType(type), options.context);
      }
    }
  });
})(window._, window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (_, GGRC, can, CMS) {
  'use strict';

  var tag = 'assessment-add-comment';
  var template = can.view(GGRC.mustache_path +
    '/components/assessment/add_comment.mustache');
  var defaultState = new can.Map({
    open: false,
    save: false,
    controls: true
  });
  var defaultPlaceHolderText = 'Enter comment (optional)';
  var types = {
    related_creators: 'creator',
    related_verifiers: 'verifier',
    related_assignees: 'assignee',
    related_requesters: 'requester',
    related_assessors: 'assessor'
  };

  function getAssigneeType(instance) {
    var user = GGRC.current_user;
    var userType = null;

    if (!instance || !user) {
      return;
    }
    _.each(types, function (type, mapping) {
      var mappings = instance.get_mapping(mapping);
      if (!mappings.length) {
        return;
      }
      if (_.filter(mappings, function (mapping) {
        return mapping.instance.id === user.id;
      }).length) {
        type = can.capitalize(type);
        userType = userType ? userType + ',' + type : type;
      }
    });
    return userType;
  }

  /**
   * A component that takes care of adding comments with attachments
   *
   */
  GGRC.Components('assessmentAddComment', {
    tag: tag,
    template: template,
    scope: {
      caIds: null,
      instance: null,
      commentPlaceHolder: '@',
      isSaving: false,
      isEmpty: true,
      clean: false,
      comment: {
        notification: false,
        value: '',
        checked: false
      },
      save: function () {
        this.attr('state.save', true);
        this.attr('state.empty', false);
      },
      getCommentData: function () {
        var source = this.attr('instance');
        var description = this.attr('comment.value');
        var sendNotification = this.attr('comment.checked');
        var data;

        data = {
          description: description,
          send_notification: sendNotification,
          context: source.context,
          assignee_type: getAssigneeType(this.attr('instance'))
        };
        // Extra data to map Custom Attribute Value with Comment
        if (this.attr('caIds') && this.attr('caIds.valueId')) {
          data.custom_attribute_revision_upd = {
            custom_attribute_value: {id: this.attr('caIds.valueId')},
            custom_attribute_definition: {id: this.attr('caIds.defId')}
          };
        }
        return data;
      },
      createComment: function () {
        var comment = new CMS.Models.Comment();
        comment._source_mapping = this.attr('instance');
        comment.attr('context', this.attr('instance.context'));
        return comment;
      },
      saveComment: function () {
        var comment = null;

        this.attr('isSaving', true);
        this.attr('clean', false);

        comment = this.createComment();

        comment.attr(this.getCommentData()).save()
          .then(function () {
            return comment.constructor
              .resolve_deferred_bindings(comment);
          }).always(function () {
            this.attr('clean', true);
            this.attr('isSaving', false);
            this.attr('state.open', false);
            this.attr('state.save', false);
          }.bind(this));
      }
    },
    events: {
      init: function () {
        var scope = this.scope;
        scope.attr('instance', scope.attr('instance') || GGRC.page_instance());
        scope.attr('state', scope.attr('state') || defaultState);
        scope.attr('commentPlaceHolder',
          scope.attr('commentPlaceHolder') || defaultPlaceHolderText);
        scope.attr('comment.checked', scope.attr('instance.send_by_default'));
      },
      '{scope.state} save': function (scope, ev, val) {
        if (val) {
          this.scope.saveComment();
        }
      }
    }
  });
})(window._, window.GGRC, window.can, window.CMS);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tag = 'comment-input';
  var template = can.view(GGRC.mustache_path +
    '/components/comment/comment-input.mustache');

  GGRC.Components('commentInput', {
    tag: tag,
    template: template,
    scope: {
      placeholder: '@',
      disabled: false,
      clean: false,
      isEmpty: true,
      value: '',
      input: {
        placeholder: '',
        value: ''
      },
      setDisabled: function (isDisabled) {
        this.attr('disabled', isDisabled);
      },
      /**
       * Updates values of the component on modifications of the input of the Rich Text Editor
       * @param {String|null} value - Value received from the Rich Text Editor
       */
      setValues: function (value) {
        this.attr('value', value);
        this.attr('isEmpty', !(value && value.length));
      },
      initValues: function () {
        // Comment Input by default is empty
        this.attr('isEmpty', true);
        this.attr('input.placeholder', this.attr('placeholder') || '');
        this.attr('input.value', this.attr('value'));
      },
      performCleanup: function () {
        this.attr('input.value', null);
      }
    },
    events: {
      init: function () {
        this.scope.performCleanup();
        // Set default values
        this.scope.initValues();
      },
      '{scope} disabled': function (scope, ev, isDisabled) {
        this.scope.setDisabled(isDisabled);
      },
      '{scope.input} value': function (scope, ev, value) {
        this.scope.setValues(value);
      },
      '{scope} clean': function (scope, ev, doCleaning) {
        if (doCleaning) {
          this.scope.performCleanup();
        }
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';
  var tpl = can.view(GGRC.mustache_path +
    '/components/assessment/controls-toolbar/controls-toolbar.mustache');

  can.Component.extend({
    tag: 'assessment-controls-toolbar',
    template: tpl,
    scope: {
      instance: null,
      modal: {
        open: false
      },
      showRelatedResponses: function (ctx, ev, el) {
        this.attr('modal.open', true);
      }
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/mapped-objects/mapped-objects.mustache');
  var tag = 'mapped-objects';
  /**
   * Mapped objects view component
   */
  GGRC.Components('mappedObjects', {
    tag: tag,
    template: tpl,
    scope: {
      isLoading: false,
      mapping: '@',
      parentInstance: null,
      selectedItem: {},
      mappedItems: [],
      filter: null,
      filterMappedObjects: function (items) {
        var filterObj = this.attr('filter');
        return filterObj ?
          GGRC.Utils.filters.applyTypeFilter(items, filterObj.serialize()) :
          items;
      },
      getBinding: function () {
        return this.attr('parentInstance').get_binding(this.attr('mapping'));
      },
      load: function () {
        var dfd = new can.Deferred();
        var binding = this.getBinding();

        if (!binding) {
          dfd.resolve([]);
          return dfd;
        }
        // Set Loading Status
        this.attr('isLoading', true);
        binding
          .refresh_instances()
          .done(function (items) {
            dfd.resolve(this.filterMappedObjects(items));
          }.bind(this))
          .fail(function () {
            dfd.resolve([]);
          })
          .always(function () {
            this.attr('isLoading', false);
          }.bind(this));
        return dfd;
      },
      setMappedObjects: function () {
        this.attr('mappedItems').replace(this.load());
      }
    },
    init: function () {
      this.scope.setMappedObjects();
    },
    events: {
      '{scope.parentInstance} change': function () {
        this.scope.setMappedObjects();
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tag = 'object-list';
  var tpl = can.view(GGRC.mustache_path +
    '/components/object-list/object-list.mustache');
  /**
   * Object List component
   */
  GGRC.Components('objectList', {
    tag: tag,
    template: tpl,
    scope: {
      spinnerCss: '@',
      isLoading: false,
      selectedItem: {},
      items: [],
      select: function (ctx, el) {
        this.attr('selectedItem.el', el);
        this.attr('selectedItem.data', ctx.instance);
        this.attr('selectedItem.index', el.attr('index'));
      },
      clearSelection: function () {
        this.attr('selectedItem.el', null);
        this.attr('selectedItem.data', null);
        this.attr('selectedItem.index', null);
      },
      onClickHandler: function (el, ev) {
        var isInnerClick = GGRC.Utils.events.isInnerClick(el, ev.target);
        if (!isInnerClick) {
          this.clearSelection();
        }
        ev.stopPropagation();
      }
    },
    events: {
      '{window} click': function (el, ev) {
        this.scope.onClickHandler(this.element, ev);
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tag = 'object-list-item';
  var tpl = can.view(GGRC.mustache_path +
    '/components/object-list/object-list-item.mustache');

  /**
   * Object List Item component
   */
  GGRC.Components('objectsListItem', {
    tag: tag,
    template: tpl,
    scope: {
      index: '@',
      selectedItem: {},
      isSelected: function () {
        return this.attr('selectedItem.index') === this.attr('index');
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/object-popover/object-popover.mustache');
  var tag = 'object-popover';
  var defaultMaxInnerHeight = 400;
  /**
   * Assessment specific mapped objects popover view component
   */
  GGRC.Components('objectPopover', {
    tag: tag,
    template: tpl,
    scope: {
      expanded: false,
      maxInnerHeight: defaultMaxInnerHeight,
      openStyle: '',
      item: null,
      itemData: function () {
        return this.attr('item.data');
      },
      isActive: function () {
        return this.attr('active');
      },
      setPopoverStyle: function (el) {
        var pos = el[0].getBoundingClientRect();
        var top = Math.floor(el.position().top);
        var left = Math.floor(pos.width / 2);
        var width = Math
          .floor(window.innerWidth - (pos.right - pos.width / 2));
        var topStyle = 'top: ' + top + 'px;';
        var leftStyle = 'left: ' + left + 'px;';
        var widthStyle = 'width: ' + width + 'px;';
        return topStyle + leftStyle + widthStyle;
      },
      setStyle: function (el) {
        var style = el ? this.setPopoverStyle(el) : '';
        this.attr('active', style.length);
        this.attr('openStyle', style);
      }
    },
    events: {
      '{scope.item} el': function (scope, ev, el) {
        this.scope.setStyle(el);
      },
      '.object-popover-wrapper click': function (el, event) {
        event.stopPropagation();
      },
      '{scope} expanded': function (scope, ev, isExpanded) {
        // Double max height property in case additional content is expanded and visible
        var maxInnerHeight = isExpanded ?
          defaultMaxInnerHeight * 2 :
          defaultMaxInnerHeight;
        this.scope.attr('maxInnerHeight', maxInnerHeight);
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (_, can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/ca-object/ca-object.mustache');

  GGRC.Components('customAttributesObject', {
    tag: 'ca-object',
    template: tpl,
    scope: {
      instance: null,
      isModified: null,
      valueId: '@',
      value: null,
      type: null,
      def: null,
      isSaving: false,
      addComment: function () {
        can.batch.start();
        this.attr('modal', {
          content: {
            value: this.attr('value'),
            title: this.attr('def.title'),
            type: this.attr('type')
          },
          caIds: {
            defId: this.attr('def.id'),
            valueId: parseInt(this.attr('valueId'), 10)
          },
          modalTitleText: 'Add comment',
          fields: ['comment']
        });
        can.batch.stop();

        this.attr('modal.open', true);
      },
      setModified: function () {
        this.attr('isModified', this.attr('def.id'));
      },
      save: function () {
        var value = this.attr('value');
        var type = this.attr('type');
        var valueId = Number(this.attr('valueId'));
        var attributeObjectId;
        var valueParts;
        var customAttributeValue;
        if (type === 'person') {
          valueParts = value.split(':');
          attributeObjectId = Number(valueParts[1]);
          value = valueParts[0];
        }
        this.setModified();
        this.attr('instance').save()
          .done(function () {
            if (type === 'person') {
              customAttributeValue =
                can.makeArray(this.attr('instance.custom_attribute_values'))
                  .find(function (v) {
                    return v.id === valueId;
                  });
              if (customAttributeValue &&
                  customAttributeValue.attribute_object &&
                  customAttributeValue.attribute_object.id !==
                    attributeObjectId) {
                return;
              }
            }
            if (String(value) !== this.attr('value')) {
              return;
            }
            GGRC.Errors.notifier('success', 'Saved');
          }.bind(this))
          .fail(function (inst, err) {
            GGRC.Errors.notifierXHR('error')(err);
          })
          .always(function () {
            this.attr('isSaving', false);
          }.bind(this));
      }
    },
    events: {
      '{scope} isSaving': function (scope, ev, isSaving) {
        if (isSaving) {
          scope.save();
        }
      }
    }
  });
})(window._, window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (_, can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/ca-object/ca-object-validation.mustache');

  GGRC.Components('сustomAttributeObjectValidation', {
    tag: 'ca-object-validation',
    template: tpl,
    scope: {
      valueId: '@',
      def: null,
      errors: null,
      value: null,
      isModified: null,
      validation: {},
      isEmpty: function () {
        var errors = this.attr('errors');
        return errors.length && this.hasError(errors, 'value');
      },
      hasError: function (errors, field) {
        return errors.indexOf(field) > -1;
      },
      isValid: function () {
        var errors = this.attr('errors');
        var requireComment = this.hasError(errors, 'comment');
        var requireEvidence = this.hasError(errors, 'evidence');
        return !(requireComment || requireEvidence);
      },
      setValidation: function () {
        this.attr('validation', {
          mandatory: this.attr('def.mandatory'),
          empty: this.isEmpty(),
          valid: this.isValid()
        });
      },
      checkRequired: function () {
        var isModified = this.attr('isModified');
        if (isModified && isModified === this.attr('def').id) {
          if (!this.isValid()) {
            this.setRequired(this.attr('errors').serialize());
          }
        }
      },
      setRequired: function (fields) {
        can.batch.start();
        this.attr('modal', {
          content: {
            value: this.attr('value'),
            title: this.attr('def.title'),
            type: this.attr('type')
          },
          caIds: {
            defId: this.attr('def.id'),
            valueId: parseInt(this.attr('valueId'), 10)
          },
          modalTitleText: 'Required ' + fields.map(function (field) {
            return can.capitalize(field);
          }).join(' and '),
          fields: fields
        });
        can.batch.stop();
        this.attr('isModified', null);
        this.attr('modal.open', true);
      }
    },
    events: {
      init: function () {
        this.scope.setValidation();
        this.scope.checkRequired();
      }
    }
  });
})(window._, window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/ca-object/ca-object-validation-icon.mustache');
  var tag = 'ca-object-validation-icon';
  /**
   * State object to present possible icons for validation
   */
  var icons = {
    noValidation: 'fa-check-circle',
    empty: 'fa-times-circle validation-icon-empty',
    valid: 'fa-check-circle validation-icon-valid',
    invalid: 'fa-times-circle validation-icon-invalid'
  };

  /**
   * Assessment specific validation icon component
   */
  GGRC.Components('assessmentValidationIcon', {
    tag: tag,
    template: tpl,
    scope: {
      validation: null,
      iconCls: icons.noValidation,
      applyState: function () {
        var icon = icons.noValidation;

        if (this.attr('validation.mandatory')) {
          icon = this.attr('validation.empty') ? icons.empty : icons.valid;
        }
        /* This validation is required for DropDowns with required attachments */
        if (!this.attr('validation.valid')) {
          icon = icons.invalid;
        }

        this.attr('iconCls', icon);
      }
    },
    events: {
      init: function () {
        this.scope.applyState();
      },
      '{scope} validation': function () {
        this.scope.applyState();
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/ca-object/ca-object-title.mustache');

  GGRC.Components('customAttributesObjectTitle', {
    tag: 'ca-object-title',
    template: tpl,
    scope: {
      titleText: null
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (_, can, GGRC) {
  'use strict';

  GGRC.Components('customAttributesObjectValueMapper', {
    tag: 'ca-object-value-mapper',
    template: '<content></content>',
    scope: {
      input: {
        value: null,
        type: null,
        options: [],
        placeholder: 'Please enter the value...'
      },
      value: null,
      valueObj: null,
      type: null,
      def: null,
      initInput: function () {
        this.attr('input', {
          options: this.getOptions(),
          value: this.getValue(),
          type: this.getType(),
          title: this.getTitle()
        });
      },
      getOptions: function () {
        var options = this.attr('def.multi_choice_options');
        return options && _.isString(options) ? options.split(',') : [];
      },
      getTitle: function () {
        return this.attr('def.title');
      },
      getType: function () {
        var type = this.attr('type');
        return type;
      },
      getValue: function () {
        var type = this.attr('type');
        var value = this.attr('value');
        var valueObj = this.attr('valueObj');

        if (type === 'checkbox') {
          return value === '1';
        }

        if (type === 'input') {
          if (!value) {
            return null;
          }
          return value.trim();
        }

        if (type === 'person') {
          if (valueObj) {
            return valueObj;
          }
          return null;
        }

        if (type === 'dropdown') {
          if (_.isNull(value) || _.isUndefined(value)) {
            return '';
          }
        }
        return value;
      },
      setValue: function (value) {
        var type = this.attr('type');
        value = this.formatValueByType(value, type);
        this.attr('value', value);
      },
      formatValueByType: function (value, type) {
        if (type === 'checkbox') {
          return value ? 1 : 0;
        }

        if (type === 'person') {
          if (value && value instanceof can.Map) {
            value = value.serialize();
            return 'Person:' + value.id;
          }
          return 'Person:None';
        }
        return value || null;
      }
    },

    events: {
      init: function () {
        this.scope.initInput();
      },
      '{scope.input} value': function (scope, ev, val) {
        this.scope.setValue(val);
      }
    }
  });
})(window._, window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/ca-object/ca-object-modal.mustache');
  var baseCls = 'simple-modal';

  function recalculatePosition(el) {
    var pos = el[0].getBoundingClientRect();
    var top = Math
      .floor(window.document.body.scrollHeight / 2 - pos.height / 2);
    var left = Math
      .floor(window.document.body.scrollWidth / 2 - pos.width / 2);

    return {top: top, left: left};
  }

  GGRC.Components('customAttributeObjectModal', {
    tag: 'ca-object-modal',
    template: tpl,
    scope: {
      instance: null,
      modifiedField: null,
      modalEl: null,
      isEmpty: true,
      modalCls: function () {
        return this.attr('state.open') ? baseCls + '-open' : '';
      },
      modalOverlayCls: function () {
        return this.attr('state.open') ? baseCls + '__overlay-open' : '';
      },
      actionBtnText: function () {
        return this.attr('comment') ? 'Save' : 'Done';
      },
      isPerson: function () {
        return this.attr('modifiedField.value') &&
          this.attr('modifiedField.type') === 'person';
      },
      comment: false,
      evidence: false,
      state: {
        open: false,
        save: false,
        controls: false
      },
      saveAttachments: function () {
        return this.attr('comment') ?
          this.attr('state.save', true) :
          this.attr('state.open', false);
      },
      hide: function hide() {
        this.attr('state.open', false);
        this.attr('state.save', false);
      },
      show: function () {
        this.attr('state.open', true);
        this.attr('state.save', false);
      },
      toggle: function (isOpen) {
        this.setAttachmentFields(isOpen);
        this.setPosition(isOpen);
      },
      mapToInternal: function () {
        this.attr('modifiedField', this.attr('modal'));
      },
      setAttachmentFields: function (isOpen) {
        var attachments = this.attr('modifiedField.fields');

        if (attachments && attachments.length) {
          attachments.forEach(function (item) {
            this.attr(item, isOpen);
          }.bind(this));
        }
      },
      setPosition: function (isOpen) {
        var modal = this.attr('modalEl');
        if (isOpen && modal) {
          modal.offset(recalculatePosition(modal));
        }
      }
    },
    events: {
      inserted: function (el) {
        var modal = el.find('.' + baseCls);
        modal.appendTo('body');
        this.scope.attr('modalEl', modal);
        el.find('.' + baseCls + '__overlay').appendTo('body');
      },
      show: function (scope, ev, val) {
        if (val) {
          this.scope.mapToInternal();
          this.scope.show();
        }
      },
      '{scope.modal} open': 'show',
      '{scope.state} open': function (scope, ev, val) {
        this.scope.toggle(val);
      },
      '{window} resize': function () {
        var isOpen = this.scope.attr('modifiedField.open');
        this.scope.setPosition(isOpen);
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/ca-object/ca-object-modal-content.mustache');

  GGRC.Components('customAttributeObjectModalContent', {
    tag: 'ca-object-modal-content',
    template: tpl,
    scope: {
      content: {
        title: null,
        value: null,
        type: null
      },
      caIds: null
    },
    helpers: {
      renderFieldValue: function (value) {
        value = value();
        return value || '<span class="empty-message">None</span>';
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC, CMS) {
  'use strict';

  var defaultOrderBy = 'created_at';

  can.Component.extend({
    tag: 'related-objects',
    scope: {
      isLoading: false,
      baseInstance: null,
      relatedObjects: [],
      relatedItemsType: '@',
      orderBy: '@',
      paging: {
        current: 1,
        pageSize: 5,
        pageSizeSelect: [5, 10, 15]
      },
      getParams: function () {
        var id = this.attr('baseInstance.id');
        var type = this.attr('baseInstance.type');
        var relatedType = this.attr('relatedItemsType');
        var page = this.attr('paging');
        var orderBy = this.attr('orderBy') || defaultOrderBy;
        var params = {};
        var first;
        var last;

        if (page.current && page.pageSize) {
          first = (page.current - 1) * page.pageSize;
          last = page.current * page.pageSize;
        }
        params.data = [{
          limit: [first, last],
          object_name: relatedType,
          order_by: [{name: orderBy, desc: true}],
          filters: {
            expression: {
              object_name: type,
              op: {name: 'similar'},
              ids: [id]
            }
          }
        }];
        return params;
      },
      updatePaging: function (total) {
        var count = Math.ceil(total / this.attr('paging.pageSize'));
        this.attr('paging.total', total);
        this.attr('paging.count', count);
      },
      loadRelatedItems: function () {
        var dfd = new can.Deferred();
        var params = this.getParams();
        this.attr('isLoading', true);
        GGRC.Utils.QueryAPI
          .makeRequest(params)
          .done(function (responseArr) {
            var relatedType = this.attr('relatedItemsType');
            var data = responseArr[0];
            var values = data[relatedType].values;
            var result = values.map(function (item) {
              item.instance = new CMS.Models[relatedType](item);
              return item;
            });
            // Update paging object
            this.updatePaging(data[relatedType].total);
            dfd.resolve(result);
          }.bind(this))
          .fail(function () {
            dfd.resolve([]);
          })
          .always(function () {
            this.attr('isLoading', false);
          }.bind(this));
        return dfd;
      },
      setRelatedItems: function () {
        this.attr('relatedObjects').replace(this.loadRelatedItems());
      }
    },
    init: function () {
      this.scope.setRelatedItems();
    },
    events: {
      '{scope.paging} current': function () {
        this.scope.setRelatedItems();
      },
      '{scope.paging} pageSize': function () {
        this.scope.setRelatedItems();
      },
      '{scope.baseInstance} related_destinations': function () {
        if (!this.scope.attr('isLoading')) {
          this.scope.setRelatedItems();
        }
      },
      '{scope.baseInstance} related_sources': function () {
        if (!this.scope.attr('isLoading')) {
          this.scope.setRelatedItems();
        }
      }
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC, CMS) {
  'use strict';

  var mapper = {
    createRelationship: function (source, destination) {
      return new CMS.Models.Relationship({
        context: source.context,
        source: source.stub(),
        destination: destination
      });
    },
    createObjectRelationship: function (source, destination) {
      return new CMS.Models.ObjectDocument({
        context: source.context,
        documentable: source,
        document: destination
      });
    },
    isEvidence: function (type) {
      return type === 'evidence';
    },
    mapObjects: function (source, destination, type) {
      return this.isEvidence(type) ?
        this.createObjectRelationship(source, destination) :
        this.createRelationship(source, destination);
    }
  };

  can.Component.extend({
    tag: 'reusable-objects-list',
    scope: {
      baseInstance: null,
      checkReusedStatus: false,
      evidenceList: [],
      urlList: [],
      isSaving: false,
      setHasSelected: function () {
        var hasSelected =
          this.attr('evidenceList.length') || this.attr('urlList.length');
        this.attr('hasSelected', hasSelected);
      },
      getMapObjects: function (source, list, mapperType) {
        return Array.prototype.filter
        // Get Array of unique items
          .call(list, function (item, index) {
            return index === list.indexOf(item);
          })
          // Get Array of mapped models
          .map(function (destination) {
            return mapper
              .mapObjects(source, destination, mapperType)
              .save();
          });
      },
      getReusedObjectList: function () {
        var source = this.attr('baseInstance');
        var evidences =
          this.getMapObjects(source, this.attr('evidenceList'), 'evidence');
        var urls =
          this.getMapObjects(source, this.attr('urlList'));
        return [].concat(evidences, urls);
      },
      reuseSelected: function () {
        var reusedObjectList = this.getReusedObjectList();

        this.attr('isSaving', true);
        this.attr('checkReusedStatus', false);

        can.when.apply(can, reusedObjectList)
          .done(function () {
            can.$(document.body).trigger('ajax:flash', {
              success: 'Selected evidences are reused'
            });
          })
          .fail(function () {
            can.$(document.body).trigger('ajax:flash', {
              error: 'Selected evidences were not reused'
            });
          })
          .always(this.restoreDefaults.bind(this));
      },
      restoreDefaults: function () {
        this.attr('evidenceList').replace([]);
        this.attr('urlList').replace([]);
        this.attr('isSaving', false);
        this.attr('checkReusedStatus', true);
      }
    },
    events: {
      '{scope.evidenceList} length': function () {
        this.scope.setHasSelected();
      },
      '{scope.urlList} length': function () {
        this.scope.setHasSelected();
      }
    }
  });
})(window.can, window.GGRC, window.CMS);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
      '/components/reusable-objects/reusable-objects-item.mustache');

  can.Component.extend({
    tag: 'reusable-objects-item',
    template: tpl,
    scope: {
      isSaving: false,
      instance: null,
      checkReusedStatus: false,
      selectedList: [],
      disabled: false,
      mapping: null,
      isDisabled: function () {
        return this.attr('disabled');
      },
      setDisabled: function () {
        var isDisabled = GGRC.Utils.is_mapped(
          this.attr('baseInstance'),
          this.attr('instance'),
          this.attr('mapping'));
        this.attr('disabled', isDisabled);
      },
      toggleSelection: function (isChecked) {
        var list = this.attr('selectedList');
        var index;
        if (isChecked) {
          list.push(this.attr('instance'));
        } else {
          index = list.indexOf(this.attr('instance'));
          list.splice(index, 1);
        }
      }
    },
    init: function () {
      this.scope.setDisabled();
    },
    events: {
      'input[type="checkbox"] change': function (el) {
        this.scope.toggleSelection(el.is(':checked'));
      },
      '{scope} checkReusedStatus': function (scope, ev, performCheck) {
        if (performCheck) {
          this.scope.setDisabled();
        }
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/simple-modal/simple-modal.mustache');
  var baseCls = 'simple-modal';

  function recalculatePosition(el) {
    var pos = el[0].getBoundingClientRect();
    var top = Math
      .floor(window.document.body.scrollHeight / 2 - pos.height / 2);
    var left = Math
      .floor(window.document.body.scrollWidth / 2 - pos.width / 2);

    return {top: top, left: left};
  }

  can.Component.extend({
    tag: 'simple-modal',
    template: tpl,
    scope: {
      extraCssClass: '@',
      instance: null,
      modalEl: null,
      modalTitle: '@',
      state: {
        open: false
      },
      modalCls: function () {
        return this.attr('state.open') ? baseCls + '-open' : '';
      },
      modalOverlayCls: function () {
        return this.attr('state.open') ? baseCls + '__overlay-open' : '';
      },
      hide: function hide() {
        this.attr('state.open', false);
      },
      show: function () {
        this.attr('state.open', true);
      },
      toggle: function (isOpen) {
        this.setPosition(isOpen);
      },
      setPosition: function (isOpen) {
        var modal = this.attr('modalEl');
        if (isOpen && modal) {
          modal.offset(recalculatePosition(modal));
        }
      }
    },
    events: {
      inserted: function (el) {
        var modal = el.find('.' + baseCls);
        modal.appendTo('body');
        this.scope.attr('modalEl', modal);
        el.find('.' + baseCls + '__overlay').appendTo('body');
      },
      '{scope.state} open': function (scope, ev, val) {
        this.scope.toggle(val);
      },
      '{window} resize': function () {
        var isOpen = this.scope.attr('state.open');
        this.scope.setPosition(isOpen);
      }
    }
  });
})(window.can, window.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, GGRC) {
  'use strict';

  GGRC.Components('mappingTypeSelector', {
    tag: 'mapping-type-selector',
    template: can.view(
      GGRC.mustache_path +
      '/components/mapping-controls/mapping-type-selector.mustache'
    ),
    scope: {
      disabled: false,
      readonly: false,
      types: [],
      selectedType: ''
    },
    events: {
      init: function () {
        // We might need to add some specific logic for disabled/enable DropDown items
      }
    }
  });
})(window.can, window.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  /*
    Component abstracts <select> dropdown in HTML.

    It receives `name` of the attribute that should be set and `optionsList`
    with titles and values
   */
  GGRC.Components('dropdown', {
    tag: 'dropdown',
    template: can.view(
      GGRC.mustache_path +
      '/components/dropdown/dropdown.mustache'
    ),
    scope: {
      name: '@',
      className: '@',
      onChange: $.noop,
      noValue: '@',
      noValueLabel: '@',
      /*
        Options list should be an `array` of object containing `title` and `value`
        [{
          title: `title`
          value: `value`
        }]
       */
      optionsList: null,
      options: function () {
        var none = [{
          title: this.attr('noValueLabel') || 'None',
          value: ''
        }];
        var list = can.map(this.attr('optionsList') || [], function (option) {
          if (_.isString(option)) {
            return {
              value: option,
              title: option
            };
          }
          return option;
        });
        if (this.attr('noValue')) {
          return none.concat(list);
        }
        return list;
      },
      isDisabled: false
    },
    init: function (element, options) {
      var $el = $(element);
      var attrVal = $el.attr('is-disabled');
      var disable;
      var scope = this.scope;

      // By default CanJS evaluates the component element's attribute values in
      // the current context, but we want to support passing in literal values
      // as well. We thus inspect some of the directly and override what CanJS
      // initializes in scope.
      if (attrVal === '' || attrVal === 'false') {
        disable = false;
      } else if (attrVal === 'true') {
        disable = true;
      } else {
        disable = Boolean(scope.attr('isDisabled'));
      }

      scope.attr('isDisabled', disable);
    }
  });
})(window.can, window.can.$);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

/**
 * A component that renders an autocomplete text input field.
 */
(function (GGRC, can) {
  'use strict';

  // the component's configuration object (i.e. its constructor's prototype)
  var component = {
    tag: 'autocomplete',

    template: can.view(
      GGRC.mustache_path +
      '/components/autocomplete/autocomplete.mustache'
    ),

    scope: {
      placeholder: '@',
      searchItemsType: '@',
      className: '@',
      value: null,

      // disable automatically mapping the picked item from the live search
      // results to the instance object of the current context
      automappingOff: true,
      define: {
        disable: {
          type: 'boolean',
          'default': false
        }
      }
    },

    _EV_ITEM_SELECTED: 'item-selected',

    events: {
      inserted: function (el, ev) {
        this.element.find('.autocomplete--input').ggrc_autocomplete({
          appendTo: this.element.find('.autocomplete--wrapper')
        });
      },

      /**
       * Event handler when an item is selected from the list of autocomplete's
       * search results.
       *
       * @param {jQuery.Element} $el - the source of the event `ev`
       * @param {jQuery.Event} ev - the event object
       * @param {Object} data - information about the selected item
       */
      'autocomplete:select': function ($el, ev, data) {
        $el.triggerHandler({
          type: component._EV_ITEM_SELECTED,
          selectedItem: data.item
        });
        // If the input still has focus after selecting an item, search results
        // do not appear unless user clicks out and back in the input (or
        // starts typing). Removing the focus spares one unnecessary click.
        $el.find('input').blur();
      }
    }
  };

  GGRC.Components('autocomplete', component);
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc., authors, and contributors
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, GGRC) {
  'use strict';

  var tpl = can.view(GGRC.mustache_path +
    '/components/search-toolbar/search-toolbar.mustache');
  var tag = 'search-toolbar';
  /**
   * Search Toolbar component
   */
  GGRC.Components('searchToolbar', {
    tag: tag,
    template: tpl,
    scope: {
    },
    events: {
    }
  });
})(window.can, window.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, GGRC, moment) {
  'use strict';

  GGRC.Components('datepicker', {
    tag: 'datepicker',
    template: can.view(
      GGRC.mustache_path +
      '/components/datepicker/datepicker.mustache'
    ),
    scope: {
      date: null,
      format: '@',
      helptext: '@',
      isShown: false,
      pattern: 'MM/DD/YYYY',
      setMinDate: null,
      setMaxDate: null,
      _date: null,
      required: '@',
      define: {
        label: {
          type: 'string'
        },
        persistent: {
          type: 'boolean',
          'default': false
        }
      },
      onSelect: function (val, ev) {
        this.attr('_date', val);
        this.attr('isShown', false);
      },
      onFocus: function (el, ev) {
        this.attr('showTop', false);
        this.attr('isShown', true);

        if (!GGRC.Utils.inViewport(this.picker)) {
          this.attr('showTop', true);
        }
      }
    },
    events: {
      inserted: function () {
        var element = this.element.find('.datepicker__calendar');
        var date = this.getDate(this.scope.date);

        element.datepicker({
          altField: this.element.find('.datepicker__input'),
          onSelect: this.scope.onSelect.bind(this.scope)
        });

        this.scope.attr('picker', element);

        this.scope.picker.datepicker('setDate', date);
        if (this.scope.setMinDate) {
          this.updateDate('minDate', this.scope.setMinDate);
        }
        if (this.scope.setMaxDate) {
          this.updateDate('maxDate', this.scope.setMaxDate);
        }
        this.scope._date = date;
      },
      getDate: function (date) {
        if (date instanceof Date) {
          date = moment(date).format(this.scope.pattern);
        } else if (!this.isValidDate(date)) {
          date = null;
        }
        return date;
      },
      isValidDate: function (date) {
        return moment(date, this.scope.pattern, true).isValid();
      },
      updateDate: function (type, date) {
        var types = {
          minDate: function () {
            date.add(1, 'day');
          },
          maxDate: function () {
            date.subtract(1, 'day');
          }
        };
        if (!date) {
          return;
        }
        date = moment(date);

        if (types[type]) {
          types[type]();
        }
        date = date.toDate();
        this.scope.picker.datepicker('option', type, date);
        return date;
      },
      '{scope} setMinDate': function (scope, ev, date) {
        var updated = this.updateDate('minDate', date);
        if (this.scope.attr('date') < updated) {
          this.scope.attr('_date', moment(updated).format(this.scope.pattern));
        }
      },
      '{scope} setMaxDate': function (scope, ev, date) {
        this.updateDate('maxDate', date);
      },
      '{scope} _date': function (scope, ev, val) {
        scope.attr('date', val);
      },
      '{window} mousedown': function (el, ev) {
        var isInside;

        if (this.scope.attr('persistent')) {
          return;
        }
        isInside = GGRC.Utils.events.isInnerClick(this.element, ev.target);

        if (this.scope.isShown && !isInside) {
          this.scope.attr('isShown', false);
        }
      }
    },
    helpers: {
      isHidden: function (opts) {
        if (this.attr('isShown') || this.attr('persistent')) {
          return opts.inverse();
        }
        return opts.fn();
      }
    }
  });
})(window.can, window.GGRC, window.moment);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

/**
 * A component that renders a single Person item, fetching the object from the
 * server if necessary.
 */
(function (GGRC, can) {
  'use strict';

  // the component's configuration object (i.e. its constructor's prototype)
  var component = {
    tag: 'person-info',

    template: can.view(
      GGRC.mustache_path +
      '/components/person/person.mustache'
    ),

    scope: {
      personObj: null,
      emptyText: '@',
      define: {
        personId: {
          type: 'number'
        },
        editable: {
          type: 'boolean'
        }
      }
    },

    _EV_REMOVE_CLICK: 'person-remove',

    /**
     * The component's entry point. Invoked when a new component instance has
     * been created.
     *
     * @param {Object} element - the (unwrapped) DOM element that triggered the
     *   creation of the component instance
     * @param {Object} options - the component instantiation options
     */
    init: function (element, options) {
      var scope = this.scope;
      var personId = scope.attr('personId');
      var person = scope.attr('personObj');
      var personModel;
      var noPerson = _.isEmpty(
        person && person.serialize ? person.serialize() : person);

      if (noPerson && isNaN(personId)) {
        console.warn('`personObj` or `personId` are missing');
        return;
      }

      if (noPerson ||
        (person && !person.email)) {
        personModel = CMS.Models.Person.cache[personId || person.id];
        if (personModel) {
          personModel = personModel.reify();
        }
      } else if (person) {
        personModel = person;
      }
      // For some reason the cache sometimes contains partially loaded objects,
      // thus we also need to check if "email" (a required field) is present.
      // If it is, we can be certain that we can use the object from the cache.
      if (personModel && personModel.email) {
        scope.attr('personObj', personModel);
        return;
      }
      if (isNaN(personId) || personId <= 0) {
        personId = person.id;
      }

      // but if not in cache, we need to fetch the person object...
      person = new CMS.Models.Person({id: personId});
      new RefreshQueue().enqueue(person).trigger()
        .then(function (person) {
          person = Array.isArray(person) ? person[0] : person;
          scope.attr('personObj', person);
        }, function () {
          $(document.body).trigger(
            'ajax:flash',
            {error: 'Failed to fetch data for person ' + personId + '.'});
        });
    },

    events: {
      /**
       * Event handler when a user clicks the trash icon.
       *
       * @param {jQuery.Element} $el - the source of the event `ev`
       * @param {jQuery.Event} ev - the event object
       */
      'a.unmap click': function ($el, ev) {
        // the handler is registered on the component's root element,
        // thus it needs to be triggered on it (and not on the $el)
        this.element.triggerHandler({
          type: component._EV_REMOVE_CLICK,
          person: this.scope.personObj
        });
      }
    }
  };

  GGRC.Components('personItem', component);
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlineEdit', {
    tag: 'inline-edit',
    template: can.view(
      GGRC.mustache_path + '/components/inline_edit/inline.mustache'
    ),
    scope: {
      instance: null,
      caId: null,
      property: '@',
      value: null,
      values: null,
      readonly: false,  // whether or not the value can be edited
      isSaving: false,
      mandatory: null,
      context: {
        isEdit: false,
        value: null,
        values: null
      },
      emptyText: '@',
      $rootEl: null,
      type: '@',

      // event names definitions
      _EV_INSTANCE_SAVE: 'on-save',  // "save" button is clicked
      _EV_BEFORE_EDIT: 'before-edit',  // before entering the edit mode

      /**
       * Enter the edit mode if editing is allowed (i.e. the readonly option is
       * not set).
       *
       * If the readonly option is enabled, do not do anything. The same if the
       * beforeEdit handler is not defined, or if the promise it returns is not
       * resolved.
       *
       * @param {can.Map} scope - the scope object itself (this)
       * @param {jQuery.Element} $el - the DOM element that triggered the event
       * @param {jQuery.Event} ev - the event object
       */
      enableEdit: function (scope, $el, ev) {
        var confirmation;
        var onBeforeEdit = this.$rootEl.attr('can-' + scope._EV_BEFORE_EDIT);

        ev.preventDefault();

        if (this.attr('readonly')) {
          return;
        }

        if (!onBeforeEdit) {
          this.attr('context.isEdit', true);
          return;
        }

        confirmation = this.$rootEl.triggerHandler({
          type: this._EV_BEFORE_EDIT
        });

        confirmation.done(function () {
          this.attr('context.isEdit', true);
        }.bind(this));   // and do nothing if no confirmation by the user
      },

      onCancel: function (ctx, el, ev) {
        ev.preventDefault();
        this.attr('context.isEdit', false);
        this.attr('context.value', this.attr('_value'));
      },
      onSave: function (ctx, el, ev) {
        var caid = this.attr('caId');
        var property = this.attr('property');
        var instance = this.attr('instance');
        var oldValue = this.attr('value');
        var onSaveHandler = this.$rootEl.attr('can-' + this._EV_INSTANCE_SAVE);
        var value = this.attr('context.value');
        var type = this.attr('type');

        ev.preventDefault();

        // If a custom onSave handler is provided, trigger it, otherwise use
        // the component's onSave logic (deprecated, should be moved out of the
        // component as it is not the latter's resposnisiblity).
        if (onSaveHandler) {
          // CAUTION: triggering the event must come before changing any of the
          // scope attributes, otherwise the event gets lost for some reason
          this.$rootEl.triggerHandler({
            type: this._EV_INSTANCE_SAVE,
            oldVal: oldValue,
            newVal: value
          });

          this.attr('context.isEdit', false);
          return;
        }

        this.attr('context.isEdit', false);
        if (oldValue === value) {
          return;
        }

        this.attr('_value', value);
        this.attr('isSaving', true);

        if (this.attr('caId')) {
          if (type === 'checkbox') {
            value = value ? 1 : 0;
          }
          if (type === 'person') {
            value = value ? ('Person:' + value.id) : 'Person:None';
          }
          if (type === 'dropdown') {
            if (value && value === '') {
              value = undefined;
            }
          }
          instance.attr('custom_attributes.' + caid, value);
        } else {
          instance.attr(property, value);
        }
        instance.attr('isReadyForRender', false);
        instance.save()
          .done(function () {
            $(document.body).trigger('ajax:flash', {
              success: 'Saved'
            });
          })
          .fail(function () {
            this.attr('context.value', this.attr('_value'));
            $(document.body).trigger('ajax:flash', {
              error: 'There was a problem saving'
            });
          }.bind(this))
          .always(function () {
            this.attr('isSaving', false);
          }.bind(this));
      }
    },
    init: function (element, options) {
      var scope = this.scope;
      var value = scope.attr('value');
      var values = scope.attr('values');
      var property = scope.attr('property');
      var instance = scope.attr('instance');
      var type = scope.attr('type');

      scope.attr('$rootEl', $(element));

      if (scope.attr('caId')) {
        if (type === 'checkbox') {
          value = value === '1';
        } else if (type === 'person') {
          if (value && value instanceof can.Map) {
            value = value.serialize();
          }
          value = _.isEmpty(value) ? undefined : value;
        }

        if (type === 'dropdown') {
          if (_.isNull(value) || _.isUndefined(value)) {
            value = '';
          }
        }

        if (!scope.attr('emptyText')) {
          scope.attr('emptyText', 'None');  // default for custom attributes
        }
      }

      if (property) {
        value = instance.attr(property);
      }
      scope.attr('_value', value);
      scope.attr('context.value', value);

      if (values && _.isString(values)) {
        values = values.split(',');
      }
      scope.attr('context.values', values);
    },
    events: {
      '{window} mousedown': function (el, ev) {
        var isInside = this.element.has(ev.target).length ||
                   this.element.is(ev.target);

        if (!isInside &&
            this.scope.attr('context.isEdit')) {
          _.defer(function () {
            this.scope.onSave(this.scope, this.element, ev);
          }.bind(this));
        }
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlineCheckbox', {
    tag: 'inline-checkbox',
    template: can.view(
      GGRC.mustache_path +
      '/components/inline_edit/checkbox.mustache'
    ),
    scope: {
    },
    events: {
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlineDropdown', {
    tag: 'inline-dropdown',
    template: can.view(
      GGRC.mustache_path +
      '/components/inline_edit/dropdown.mustache'
    ),
    scope: {
    },
    events: {
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlineInput', {
    tag: 'inline-input',
    template: can.view(
      GGRC.mustache_path +
      '/components/inline_edit/input.mustache'
    ),
    scope: {
    },
    events: {
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlineText', {
    tag: 'inline-text',
    template: can.view(
      GGRC.mustache_path +
      '/components/inline_edit/text.mustache'
    ),
    scope: {
    },
    events: {

    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlinePerson', {
    tag: 'inline-person',
    template: can.view(
      GGRC.mustache_path +
      '/components/inline_edit/person.mustache'
    ),
    scope: {
      setPerson: function (scope, el, ev) {
        this.attr('context.value', ev.selectedItem.serialize());
      },
      unsetPerson: function (scope, el, ev) {
        ev.preventDefault();
        this.attr('context.value', undefined);
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('inlineDatepicker', {
    tag: 'inline-datepicker',
    template: can.view(
      GGRC.mustache_path +
      '/components/inline_edit/datepicker.mustache'
    ),
    scope: {
      context: null
    },
    events: {
      '{scope.context} value': function (scope, ev, val) {
        if (_.isEmpty(val)) {
          return;
        }
        if (!moment(val, 'MM/DD/YYYY', true).isValid()) {
          this.scope.attr('context.value', undefined);
        }
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $, Clipboard) {
  'use strict';

  can.Component.extend({
    tag: 'clipboard-link',
    scope: {
      text: '@',
      title: '@',
      notify: '@',
      isActive: false,
      timeout: '@',
      notifyText: 'Link has been copied to your clipboard.'
    },
    template: ['<a data-clipboard-text="{{text}}" {{#isActive}}class="active"{{/isActive}} href="#">',
               '<i class="fa fa-link"></i> {{title}}',
               '</a>'].join(''),
    events: {
      'a click': function (el, evnt) {
        evnt.preventDefault();
      },
      'inserted': function (el, evnt) {
        var timeout = this.scope.attr('timeout') || 10000;
        this._clip = new Clipboard(el.find('a')[0]);

        this._clip.on('success', function () {
          if (this.scope.attr('notify')) {
            $('body').trigger('ajax:flash', {'success': this.scope.attr('notifyText')});
          }
          this.scope.attr('isActive', true);
          setTimeout(function () {
            this.scope.attr('isActive', false);
          }.bind(this), timeout);
        }.bind(this));
      }
    }
  });

})(window.can, window.can.$, window.Clipboard);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $, GGRC) {
  GGRC.Components('relevantFilter', {
    tag: 'relevant-filter',
    template: can.view(GGRC.mustache_path + '/mapper/relevant_filter.mustache'),
    scope: {
      define: {
        disableCreate: {
          type: 'boolean',
          'default': false
        }
      },
      relevant_menu_item: '@',
      show_all: '@',
      addFilter: function () {
        var menu = this.attr('menu');

        if (this.attr('relevant_menu_item') === 'parent' &&
             Number(this.attr('panel_number')) !== 0 &&
             !this.attr('has_parent')) {
          menu.unshift({
            title_singular: 'Previous objects',
            model_singular: '__previous__'
          });
        }

        this.attr('relevant').push({
          value: false,
          filter: new can.Map(),
          menu: menu,
          model_name: menu[0].model_singular
        });
      },
      menu: can.compute(function () {
        var type = this.attr('type');
        var mappings;
        var models;
        if (/true/i.test(this.attr('show_all'))) {
          // find all widget types and manually add Cycle since it's missing
          // convert names to CMS models and prune invalid (undefined)
          models = can.Map.keys(GGRC.tree_view.base_widgets_by_type);
          models = _.difference(_.unique(models),
                               ['CycleTaskEntry', 'CycleTaskGroupObject']);
          models = _.map(models, function (mapping) {
            return CMS.Models[mapping];
          });
          return _.sortBy(_.compact(models), 'model_singular');
        }

        if (type === 'AllObject') {
          type = GGRC.page_model.type;
        }
        mappings = GGRC.Mappings.get_canonical_mappings_for(type);
        return _.sortBy(_.compact(_.map(_.keys(mappings), function (mapping) {
          return CMS.Models[mapping];
        })), 'model_singular');
      })
    },
    events: {
      init: function () {
        this.setRelevant();
      },
      setRelevant: function () {
        this.scope.attr('relevant').replace([]);
        can.each(this.scope.attr('relevantTo') || [], function (item) {
          var model = CMS.Models[item.type].cache[item.id];
          this.scope.attr('relevant').push({
            value: true,
            filter: model,
            menu: this.scope.attr('menu'),
            model_name: model.constructor.shortName
          });
        }, this);
      },
      '.ui-autocomplete-input autocomplete:select': function (el, ev, data) {
        var index = el.data('index');
        var panel = this.scope.attr('relevant')[index];

        panel.attr('filter', data.item);
        panel.attr('value', true);
      },
      '.remove_filter click': function (el) {
        this.scope.attr('relevant').splice(el.data('index'), 1);
      },
      '{scope.relevant} change': function (list, item, which, type, val, old) {
        this.scope.attr('has_parent',
                        _.findWhere(this.scope.attr('relevant'),
                        {model_name: '__previous__'}));
        if (!/model_name/gi.test(which)) {
          return;
        }
        item.target.attr('filter', new can.Map());
        item.target.attr('value', false);
      }
    }
  });
})(window.can, window.can.$, window.GGRC);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $) {
  var url = can.route.deparam(window.location.search.substr(1)),
      filterModel = can.Map({
        model_name: "Program",
        value: "",
        filter: {}
      }),
      panelModel = can.Map({
        selected: {},
        models: null,
        type: "Program",
        filter: "",
        relevant: can.compute(function () {
          return new can.List();
        }),
        columns: function () {
          return _.filter(GGRC.model_attr_defs[this.attr("type")], function (el) {
            return (!el.import_only) &&
                   (el.display_name.indexOf("unmap:") === -1);
          });
        }
      }),
      panelsModel = can.Map({
        items: new can.List()
      }),
      exportModel = can.Map({
        panels: new panelsModel(),
        loading: false,
        url: "/_service/export_csv",
        type: url.model_type || "Program",
        edit_filename: false,
        only_relevant: false,
        filename: "Export Objects",
        get_filename: can.compute(function () {
          return this.attr("filename").replace(/\s+/, "_").toLowerCase() + ".csv";
        })
      });


  can.Component.extend({
    tag: "csv-template",
    template: "<content></content>",
    scope: {
      url: "/_service/export_csv",
      selected: [],
      importable: GGRC.Bootstrap.importable,
    },
    events: {
      "#importSelect change": function (el, ev) {
        var $items = el.find(":selected"),
            selected = this.scope.attr("selected");

        $items.each(function () {
          var $item = $(this);
          if (_.findWhere(selected, {value: $item.val()})) {
            return;
          }
          return selected.push({
            name: $item.attr("label"),
            value: $item.val()
          });
        });
      },
      ".import-button click": function (el, ev) {
        ev.preventDefault();
        var data = _.map(this.scope.attr("selected"), function (el) {
              return {
                object_name: el.value,
                fields: "all"
              };
            });
        if (!data.length) {
          return;
        }

        GGRC.Utils.export_request({
          data: data
        }).then(function (data) {
          GGRC.Utils.download("import_template.csv", data);
        }.bind(this))
        .fail(function (data) {
          $("body").trigger("ajax:flash", {
            "error": $(data.responseText.split("\n")[3]).text()
          });
        }.bind(this));
      },
      ".import-list a click": function (el, ev) {
        ev.preventDefault();

        var index = el.data("index"),
            item = this.scope.attr("selected").splice(index, 1)[0];

        this.element.find("#importSelect option:selected").each(function () {
          var $item = $(this);
          if ($item.val() === item.value) {
            $item.prop("selected", false);
          }
        });
      }
    }
  });

  can.Component.extend({
    tag: "csv-export",
    template: "<content></content>",
    scope: function () {
      return {
        isFilterActive: false,
        export: new exportModel()
      };
    },
    events: {
      ".btn-title-change click": function (el, ev) {
        ev.preventDefault();
        this.scope.attr("export.edit_filename", !this.scope.attr("export.edit_filename"));
      },

      toggleIndicator: function (currentFilter) {
        var isExpression =
            !!currentFilter &&
            !!currentFilter.expression.op &&
            currentFilter.expression.op.name !== 'text_search' &&
            currentFilter.expression.op.name !== 'exclude_text_search';
        this.scope.attr('isFilterActive', isExpression);
      },
      '.tree-filter__expression-holder input keyup': function (el, ev) {
        this.toggleIndicator(GGRC.query_parser.parse(el.val()));
      },
      '.option-type-selector change': function (el, ev) {
        this.scope.attr('isFilterActive', false);
      },
      "#export-csv-button click": function (el, ev) {
        ev.preventDefault();
        this.scope.attr("export.loading", true);
        var panels = this.scope.attr("export.panels.items"),
            only_relevant = this.scope.attr("export.only_relevant"),
            query = _.map(panels, function (panel, index) {
              var relevant_filter = "",
                  predicates;
              predicates = _.map(panel.attr("relevant"), function (el) {
                var id = el.model_name === "__previous__" ? index - 1 : el.filter.id;
                return "#" + el.model_name + "," + id + "#";
              });
              relevant_filter = _.reduce(predicates, function (p1, p2) {
                return p1 + " AND " + p2;
              });
              return {
                object_name: panel.type,
                fields: _.compact(_.map(panel.columns(),
                  function (item, index) {
                    if (panel.selected[index]) {
                      return item.key;
                    }
                  })),
                filters: GGRC.query_parser.join_queries(
                  GGRC.query_parser.parse(relevant_filter || ""),
                  GGRC.query_parser.parse(panel.filter || "")
                )
              };
            });

        GGRC.Utils.export_request({
          data: query
        }).then(function (data) {
          GGRC.Utils.download(this.scope.attr("export.get_filename"), data);
        }.bind(this))
        .fail(function (data) {
          $("body").trigger("ajax:flash", {
            "error": $(data.responseText.split("\n")[3]).text()
          });
        }.bind(this))
        .always(function () {
          this.scope.attr("export.loading", false);
        }.bind(this));
      }
    }
  });


  can.Component.extend({
    tag: "export-group",
    template: "<content></content>",
    scope: {
      _index: 0
    },
    events: {
      "inserted": function () {
        this.addPanel({
          type: url.model_type || "Program"
        });
      },
      addPanel: function (data) {
        data = data || {};
        var index = this.scope.attr("_index") + 1;
        if (!data.type) {
          data.type = "Program";
        }

        this.scope.attr("_index", index);
        data.index = index;
        return this.scope.attr("panels.items").push(new panelModel(data));
      },
      getIndex: function (el) {
        return +el.closest("export-panel").control().scope.attr("item.index");
      },
      ".remove_filter_group click": function (el, ev) {
        ev.preventDefault();
        var elIndex = this.getIndex(el),
            index = _.pluck(this.scope.attr("panels.items"), "index").indexOf(elIndex);
        this.scope.attr("panels.items").splice(index, 1);
      },
      "#addAnotherObjectType click": function (el, ev) {
        ev.preventDefault();
        this.addPanel();
      }
    }
  });

  can.Component.extend({
    tag: "export-panel",
    template: "<content></content>",
    scope: {
      exportable: GGRC.Bootstrap.exportable,
      panel_number: "@",
      has_parent: false,
      fetch_relevant_data: function (id, type) {
        var dfd = CMS.Models[type].findOne({id: id});
        dfd.then(function (result) {
          this.attr("item.relevant").push(new filterModel({
            model_name: url.relevant_type,
            value: url.relevant_id,
            filter: result
          }));
        }.bind(this));
      }
    },
    events: {
      inserted: function () {
        var panel_number = +this.scope.attr("panel_number");

        if (!panel_number && url.relevant_id && url.relevant_type) {
          this.scope.fetch_relevant_data(url.relevant_id, url.relevant_type);
        }
        this.setSelected();
      },
      '[data-action=attribute_select_toggle] click': function (el, ev) {
        var items = GGRC.model_attr_defs[this.scope.attr('item.type')];
        var isMapping = el.data('type') === 'mappings';
        var value = el.data('value');

        _.each(items, function (item, index) {
          if (isMapping && item.type === 'mapping') {
            this.scope.attr('item.selected.' + index, value);
          }
          if (!isMapping && item.type !== 'mapping') {
            this.scope.attr('item.selected.' + index, value);
          }
        }.bind(this));
      },
      setSelected: function () {
        var selected = _.reduce(this.scope.attr('item').columns(),
          function (memo, data, index) {
            memo[index] = true;
            return memo;
          }, {});
        this.scope.attr('item.selected', selected);
      },
      "{scope.item} type": function () {
        this.scope.attr("item.selected", {});
        this.scope.attr("item.relevant", []);
        this.scope.attr("item.filter", "");
        this.scope.attr("item.has_parent", false);

        this.setSelected();
      }
    },
    helpers: {
      first_panel: function (options) {
        if (+this.attr("panel_number") > 0) {
          return options.fn();
        }
        return options.inverse();
      }
    }
  });
  var csvExport = $("#csv_export");
  if (csvExport.length) {
    csvExport.html(can.view(GGRC.mustache_path + "/import_export/export.mustache", {}));
  }

})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $) {

  GGRC.Components('csvImportWidget', {
    tag: "csv-import",
    template: "<content></content>",
    requestData: null,
    scope: {
      importUrl: "/_service/import_csv",
      import: null,
      filename: "",
      isLoading: false,
      state: "select",
      states: function () {
        var state = this.attr("state") || "select",
            states = {
              select: {
                class: "btn-success",
                text: "Choose CSV file to import"
              },
              analyzing: {
                class: "btn-draft",
                showSpinner: true,
                isDisabled: true,
                text: "Analyzing"
              },
              import: {
                class: "btn-primary",
                text: "Import data",
                isDisabled: function () {
                  var toImport = this.import;  // info on blocks to import
                  var nonEmptyBlockExists;

                  if (!toImport || toImport.length < 1) {
                    return true;
                  }

                  // A non-empty block is a block containing at least one
                  // line that is not ignored (due to errors, etc.).
                  nonEmptyBlockExists = _.any(toImport, function (block) {
                    return block.rows > block.ignored;
                  });

                  return !nonEmptyBlockExists;
                }.bind(this)  // bind the scope object as context
              },
              importing: {
                class: "btn-draft",
                showSpinner: true,
                isDisabled: true,
                text: "Importing"
              },
              success: {
                class: "btn-success",
                isDisabled: true,
                text: "<i class=\"fa fa-check-square-o white\">"+
                  "</i> Import successful"
              }
            };

        return _.extend(states[state], {state: state});
      }
    },
    events: {
      ".state-reset click": function (el, ev) {
        ev.preventDefault();
        this.scope.attr({
          state: "select",
          filename: "",
          import: null
        });
        this.element.find(".csv-upload").val("");
      },
      ".state-select click": function (el, ev) {
        ev.preventDefault();
        this.element.find(".csv-upload").trigger("click");
      },
      ".state-import click": function (el, ev) {
        ev.preventDefault();
        this.scope.attr("state", "importing");
        this.requestData.headers["X-test-only"] = "false";

        $.ajax(this.requestData)
        .done(function (data) {
          var result_count = data.reduce(function (prev, curr) {
                _.each(Object.keys(prev), function(key) {
                  prev[key] += curr[key] || 0;
                });
                return prev;
              }, {created: 0, updated: 0, deleted: 0, ignored: 0});

          this.scope.attr("state", "success");
          this.scope.attr("data", [result_count]);
        }.bind(this))
        .fail(function (data) {
          this.scope.attr("state", "select");
          $("body").trigger("ajax:flash", {
            "error": $(data.responseText.split("\n")[3]).text()
          });
        }.bind(this))
        .always(function () {
          this.scope.attr("isLoading", false);
        }.bind(this));
      },
      ".csv-upload change": function (el, ev) {
        var file = el[0].files[0],
            formData = new FormData();

        this.scope.attr("state", "analyzing");
        this.scope.attr("isLoading", true);
        this.scope.attr("filename", file.name);
        formData.append("file", file);

        this.requestData = {
          type: "POST",
          url: this.scope.attr("importUrl"),
          data: formData,
          cache: false,
          contentType: false,
          processData: false,
          headers: {
            "X-test-only": "true",
            "X-requested-by": "gGRC"
          }
        };

        $.ajax(this.requestData)
        .done(function (data) {
          this.scope.attr("import", _.map(data, function (element) {
            element.data = [];
            if (element.block_warnings.concat(element.row_warnings).length) {
              element.data.push({
                status: "warnings",
                messages: element.block_warnings.concat(element.row_warnings)
              });
            }
            if (element.block_errors.concat(element.row_errors).length) {
              element.data.push({
                status: "errors",
                messages: element.block_errors.concat(element.row_errors)
              });
            }
            return element;
          }));
          this.scope.attr("state", "import");
        }.bind(this))
        .fail(function (data) {
          this.scope.attr("state", "select");
          $("body").trigger("ajax:flash", {
            "error": $(data.responseText.split("\n")[3]).text()
          });
        }.bind(this))
        .always(function () {
          this.scope.attr("isLoading", false);
        }.bind(this));
      }
    }
  });
  var csvImport = $("#csv_import");
  if (csvImport.length) {
    csvImport.html(can.view(GGRC.mustache_path + "/import_export/import.mustache", {}));
  }

})(window.can, window.can.$);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  GGRC.Components('peopleList', {
    tag: 'people-list',
    template: can.view(GGRC.mustache_path +
      '/base_templates/people_list.mustache'),
    scope: {
      editable: '@',
      deferred: '@',
      validate: '@',
      disableTitle: '@',
      /*
       * Checks whether there are any conflicts between assignable roles.
       *
       * If `conflicts` is specified on an object with assignable mixin,
       * bind to the role's mapping and on any change to it check if any
       * user is holding roles that are in violation of the rules.
       *
       * @prop {Array of Arrays} conflicts - Array of an array containing
       *  conflicting roles that no single user should hold at the same time.
       * @prop {Array of objects} assignable_list - A list of available roles
       *  with mappins to those roles.
       */
      _checkConflict: function () {
        var conflicts = this.instance.class.conflicts;
        var assignableList = this.instance.class.assignable_list;
        var bindings = {};

        if (_.isUndefined(conflicts)) {
          return;
        }

        function checkConflicts() {
          // Verify that there is not intersections between role bindings and
          // show warning if it exists.
          _.each(conflicts, function (conflictRoles) {
            var rolePeople = _.map(conflictRoles, function (role) {
              return _.map(bindings[role].list, function (person) {
                return person.instance.id;
              });
            });
            var hasConflicts = !_.isEmpty(
                _.intersection.apply(null, rolePeople));
            this.instance.attr('roleConflicts', hasConflicts);
          }.bind(this));
        }

        // Set up listening to change event on role bindings.
        _.each(conflicts, function (conflictRoles) {
          _.each(conflictRoles, function (role) {
            var roleMapping = _.find(
              assignableList, _.matchesProperty('type', role)).mapping;
            var roleBinding = this.instance.get_binding(roleMapping);
            bindings[role] = roleBinding;
            roleBinding.list.bind('change', checkConflicts.bind(this));
          }.bind(this));
        }.bind(this));
      }
    },
    events: {
      inserted: function () {
        this.scope._checkConflict();
      }
    }
  });

  GGRC.Components('peopleGroup', {
    tag: 'people-group',
    template: can.view(GGRC.mustache_path +
      '/base_templates/people_group.mustache'),
    scope: {
      limit: '@',
      mapping: null,
      required: '@',
      type: null,
      heading: null,
      toggle_add: false,
      mapped_people: [],
      results: [],
      list_pending: [],
      list_mapped: [],
      computed_mapping: false,
      forbiddenForUnmap: [],
      /**
        * Get pending joins for current instance
        *
        * @return {Array} - the list of current pending joins
        */
      get_pending: function () {
        if (!this.attr('deferred')) {
          return [];
        }
        return this.attr('instance._pending_joins');
      },
      /**
        * Get people mapped to this instance
        *
        * @return {Promise} - a promise that returns the list of current mapped people
        */
      get_mapped_deferred: function () {
        // We call get_mapping only once because canjs events can get caught in a loop
        // computed_mapping needs to be in scope so its separated from other people lists
        if (!this.computed_mapping) {
          return this.attr('instance')
            .get_mapping_deferred(this.attr('mapping'))
            .then(function (data) {
              this.attr('list_mapped', data);
              this.computed_mapping = true;
              return data;
            }.bind(this));
        }
        return $.when(this.attr('list_mapped'));
      },
      /**
        * Get the first (or only) pending join for a person
        *
        * @param {CMS.Models.Person} person - the person whose join to get
        *
        * @return {Object} - the pending join for the person if available
        *                    or undefined
        */
      get_pending_operation: function (person) {
        return _.find(this.get_pending(), function (join) {
          return join.what === person;
        });
      },
      /**
        * Change pending joins list to add a role to a person
        *
        * If there is a pending 'add' or 'update', extends roles list in it.
        * If there is a pending 'remove', cancels it and creates a new 'update'
        * with the role.
        * If there is no pending join and the person already has roles assigned,
        * creates a new 'update' with extended roles list.
        * If there is no pending join and the person has no roles assigned yet,
        * creates a new 'add' with the role.
        *
        * @param {CMS.Models.Person} person - the person who gets the new role
        * @param {String} role - the role that is added
        */
      deferred_add_role: function (person, role) {
        var pendingOperation = this.get_pending_operation(person);
        if (!pendingOperation) {
          // no pending join for this person
          this.get_roles(person, this.instance).then(function (result) {
            var roles = result.roles;

            if (roles.length) {
              // the person already has roles assigned, create 'update'
              this.add_or_replace_operation(
                person,
                {
                  how: 'update',
                  roles: _.union(roles, [role])
                }
              );
            } else {
              // the person was not yet assigned, create 'add'
              this.add_or_replace_operation(
                person,
                {
                  how: 'add',
                  roles: [role]
                }
              );
            }
          }.bind(this));
        } else if (pendingOperation.how === 'remove') {
          // 'remove' pending for this person, cancel it and create 'update'
          // with single role
          this.add_or_replace_operation(
            person,
            {
              how: 'update',
              roles: [role]
            }
          );
        } else if (pendingOperation.how === 'add' ||
                   pendingOperation.how === 'update') {
          // 'add' or 'update' pending, extend the roles list with the role
          this.add_or_replace_operation(
            person,
            {
              how: pendingOperation.how,
              roles: _.union(this.parse_roles_list(pendingOperation), [role])
            }
          );
        }
      },
      /**
        * Change pending joins list to remove a role from a person
        *
        * If there is a pending 'add' or 'update', cancels this role addition.
        * If there is a pending 'remove', does nothing.
        * If there is no pending join and the person has several roles assigned,
        * creates a new 'update' with all stored roles except the role.
        * If there is no pending join and the person has a single role assigned,
        * creates a new 'remove'.
        *
        * @param {CMS.Model.Person} person - the person who loses the role
        * @param {String} role - the role that is removed
        */
      deferred_remove_role: function (person, role) {
        var pendingOperation = this.get_pending_operation(person);
        var roles;

        if (!pendingOperation) {
          // no pending join for this person
          this.get_roles(person, this.instance).then(function (result) {
            var roles = result.roles;

            roles = _.without(roles, role);
            if (roles.length) {
              // there are still roles remaining, create 'update'
              this.add_or_replace_operation(
                person,
                {
                  how: 'update',
                  roles: roles
                }
              );
            } else {
              // there are no roles remaining, create 'remove'
              this.add_or_replace_operation(
                person,
                {
                  how: 'remove'
                }
              );
            }
          }.bind(this));
        } else if (pendingOperation.how === 'remove') {
          // no action required
          return;
        } else if (pendingOperation.how === 'add' ||
                   pendingOperation.how === 'update') {
          // 'add' or 'update' pending, cancel the role addition
          roles = this.parse_roles_list(pendingOperation);
          roles = _.without(roles, role);
          if (roles.length) {
            // update the roles list in the pending join
            this.add_or_replace_operation(
              person,
              {
                how: pendingOperation.how,
                roles: roles
              }
            );
          } else if (pendingOperation.how === 'add') {
            // cancel the pending 'add'
            this.add_or_replace_operation(
              person,
              null
            );
          } else if (pendingOperation.how === 'update') {
            // replace the 'update' with 'remove'
            this.add_or_replace_operation(
              person,
              {
                how: 'remove'
              }
            );
          }
        }
      },
      /**
        * Add a new pending join, remove all pending joins for same person
        *
        * @param {CMS.Model.Person} person - the person to be joined
        * @param {Object} operation - a description of the new pending join;
        * if operation is false-value, all pending joins would be removed,
        * but none will be added.
        * @param {String} operation.how - the type of the operation
        * ('add', 'remove' or 'update')
        * @param {String} operation.roles - the list of added/updated roles
        */
      add_or_replace_operation: function (person, operation) {
        var roles;
        if (!operation) {
          // just remove all pending joins for person
          this.instance.remove_duplicate_pending_joins(person);
        } else {
          // convert roles list to a string
          if (_.isArray(operation.roles)) {
            roles = operation.roles.join(',');
          }
          if (operation.how === 'add') {
            this.instance.mark_for_addition(
              'related_objects_as_destination',
              person,
              {
                attrs: {
                  AssigneeType: roles
                },
                context: this.instance.context
              }
            );
          } else if (operation.how === 'update') {
            this.instance.mark_for_update(
              'related_objects_as_destination',
              person,
              {
                attrs: {
                  AssigneeType: roles
                }
              }
            );
          } else if (operation.how === 'remove') {
            this.instance.mark_for_deletion(
              'related_objects_as_destination',
              person
            );
          }
        }
      },
      /**
        * Get roles list from a pending join and split it into a list.
        *
        * Returns [] if no roles list exists.
        *
        * @param {Object} operation - a pending join object
        *
        * @return {Array} - an array of roles
        */
      parse_roles_list: function (operation) {
        var roles = _.exists(operation, 'extra.attrs.AssigneeType');
        return roles ? roles.split(',') : [];
      },
      /**
        * Remove a role assignment from a person
        *
        * Called with a role removal button
        *
        * @param {Object} parentScope - current page context
        * @param {jQuery.Object} el - clicked element
        * @param {Object} ev - click event handler
        */
      remove_role: function (parentScope, el, ev) {
        var person = CMS.Models.Person.findInCacheById(el.data('person'));
        var instance = this.instance;
        var roleToRemove = can.capitalize(this.attr('type'));
        var deferred = this.attr('deferred');

        // Turn off popover for the removed person
        $(el).closest('li').find('.person-tooltip-trigger')
          .removeClass('person-tooltip-trigger');

        if (deferred) {
          this.deferred_remove_role(person, roleToRemove);
        } else {
          this.get_roles(person, instance).then(function (result) {
            var roles = result.roles;
            var relationship = result.relationship;

            roles = _.without(roles, roleToRemove);

            if (roles.length) {
              relationship.attrs.attr('AssigneeType', roles.join(','));
              relationship.save();
            } else {
              relationship.destroy();
            }
          });
        }
      },
      /**
        * Get saved roles list for a person
        *
        * @param {CMS.Models.Person} person - the person whose roles to get
        * @param {Object} instance - the object to which the person is assigned
        *
        * @return {jQuery.Deferred} - a promise with the role list
        */
      get_roles: function (person, instance) {
        var rolesDfd = $.Deferred();

        CMS.Models.Relationship
          .getRelationshipBetweenInstances(person, instance, instance.isNew())
          .done(function (relationships) {
            var found = false;
            _.map(relationships, function (relationship) {
              if (!found && _.exists(relationship, 'attrs.AssigneeType')) {
                found = true;
                relationship.refresh().then(function (relationship) {
                  var roles = relationship.attrs.AssigneeType.split(',');
                  var result = {roles: roles,
                    relationship: relationship};
                  rolesDfd.resolve(result);
                });
              }
            });
            if (!found) {
              rolesDfd.resolve({roles: []});
            }
          })
          .fail(function (e) {
            rolesDfd.resolve({roles: []});
          });

        return rolesDfd;
      }
    },
    events: {
      inserted: function () {
        this.scope.get_mapped_deferred().then(function (data) {
          this.scope.attr('list_pending', this.scope.get_pending());
          this.scope.attr('list_mapped', data);
          this.updateMappedResult(data);
          if (!this.scope.attr('required')) {
            return;
          }
          this.scope.attr('mapped_people', data);
          if (this.scope.instance.isNew() && this.scope.validate) {
            this.validate();
          }
        }.bind(this));
      },
      validate: function () {
        if (!(this.scope.required && this.scope.validate)) {
          return;
        }
        this.scope.attr('instance').attr('validate_' +
          this.scope.attr('type'), !!this.scope.results.length);
      },
      updateResult: function () {
        this.scope.get_mapped_deferred().then(function (data) {
          this.updateMappedResult(data);
        }.bind(this));
      },
      updateMappedResult: function (data) {
        var type = can.capitalize(this.scope.type);
        var mapped = _.map(data, function (item) {
          return item.instance;
        });
        var pending = _.filter(this.scope.get_pending(), function (item) {
          return item.what.type === 'Person';
        });
        var added = _.filter(pending, function (item) {
          // any person who has `type` in their `add` or `update` roles list
          var roles = this.scope.parse_roles_list(item);
          return (item.how === 'add' || item.how === 'update') &&
            _.includes(roles, type);
        }.bind(this));
        var removed = _.filter(pending, function (item) {
          // any person who was mapped and has `remove` join or has no `type`
          // in their `update` roles list
          var roles = this.scope.parse_roles_list(item);
          var personMapped = _.find(mapped, function (map) {
            return map.id === item.what.id;
          });
          return personMapped &&
            (item.how === 'remove' ||
             item.how === 'update' && !_.includes(roles, type));
        }.bind(this));

        function getInstances(arr) {
          return _.map(arr, function (item) {
            return item.what;
          });
        }
        this.scope.instance.attr('_disabled', 'disabled');
        added = getInstances(added);
        removed = getInstances(removed);
        this.scope.attr('results').replace(
          _.union(_.filter(mapped, function (item) {
            return !_.findWhere(removed, {id: item.id});
          }
        ), added));
        this.scope.instance.attr('_disabled', '');
      },
      '{scope.list_mapped} change': 'updateResult',
      '{scope.list_pending} change': 'updateResult',
      '{scope.results} change': 'validate',
      '{scope.instance} modal:dismiss': function () {
        this.scope.attr('instance').removeAttr(
          'validate_' + this.scope.attr('type'));
      },
      '.person-selector input autocomplete:select': function (el, ev, ui) {
        var person = ui.item;
        var role = can.capitalize(this.scope.type);
        var instance = this.scope.attr('instance');
        var deferred = this.scope.attr('deferred');
        var relationship;

        if (deferred) {
          this.scope.deferred_add_role(person, role);
        } else {
          // create or modify a relationship without caching
          relationship = CMS.Models.Relationship.get_relationship(person,
                                                                  instance);
          if (!relationship) {
            relationship = CMS.Models.Relationship.createAssignee({
              role: role,
              source: person,
              destination: instance,
              context: instance.context
            });
            relationship = $.Deferred().resolve(relationship);
            this.scope.attr('forbiddenForUnmap').push(person);
            this.scope.attr('isNew', true);
          } else {
            relationship = relationship.refresh();
          }

          relationship.then(function (relationship) {
            var type = relationship.attr('attrs.AssigneeType');
            relationship.attr('attrs.AssigneeType',
              role + (type ? ',' + type : ''));
            return relationship.save();
          })
            .then(function (rel) {
              var props = ['related_sources', 'related_destinations'];
              var dfds = [];

              if (this.scope.attr('isNew')) {
                [instance, person].forEach(function (model) {
                  var dfd = $.Deferred();
                  props.forEach(function (prop) {
                    function checkRelationship(related, id) {
                      return _.findWhere(related, {id: id});
                    }
                    model[prop].on('change', function cb() {
                      if (checkRelationship(this, rel.id)) {
                        person[prop].unbind('change', cb);
                        dfd.resolve();
                      }
                    });
                  });
                  dfds.push(dfd);
                });
              }
              return $.when.apply($, dfds);
            }.bind(this))
            .then(function () {
              if (this.scope.attr('isNew')) {
                _.remove(this.scope.attr('forbiddenForUnmap'), function (item) {
                  return item.id === person.id;
                });
                this.scope.attr('isNew', false);
              }
              instance.refresh();
            }.bind(this));
        }
      },
      'modal:success': function () {
        // prevent navigating to a new object page when a new user is created
        return false;
      }
    },
    helpers: {
      has_permissions: function (options) {
        var isAllowed;
        if (this.attr('deferred')) {
          return options.fn(options.context);
        }
        isAllowed = Permission.is_allowed_for('update', this.attr('instance'));
        return options[isAllowed ? 'fn' : 'inverse'](options.context);
      },
      can_unmap: function (options) {
        var results = this.attr('results');
        var required = this.attr('required');
        var hiddens = this.attr('forbiddenForUnmap');
        var isNew = this.attr('isNew');

        if (isNew && _.findWhere(hiddens, {id: options.context.id})) {
          return options.inverse(options.context);
        }

        if (required) {
          if (results.length > 1) {
            return options.fn(options.context);
          }
          return options.inverse(options.context);
        }
        return options.fn(options.context);
      },
      show_add: function (options) {
        if (this.attr('editable') === 'true') {
          return options.fn(options.context);
        }
        return options.inverse(options.context);
      },
      if_has_role: function (roles, role, options) {
        roles = Mustache.resolve(roles) || '';
        role = Mustache.resolve(role) || '';
        roles = _.filter(roles.toLowerCase().split(','));
        role = role.toLowerCase();
        return options[
          _.includes(roles, role) ? 'fn' : 'inverse'](options.contexts);
      }
    }
  });
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  can.Component.extend({
    tag: 'mapping-tree-view',
    template: can.view(GGRC.mustache_path +
      '/base_templates/mapping_tree_view.mustache'),
    scope: {
      reusable: '@',
      reuseMethod: '@',
      treeViewClass: '@',
      expandable: '@',
      sortField: '@',
      parentInstance: null,
      mappedObjects: [],
      isExpandable: function () {
        var expandable = this.attr('expandable');
        if (expandable === null || expandable === undefined) {
          return true;
        } else if (typeof expandable === 'string') {
          return expandable === 'true';
        }
        return expandable;
      }
    },
    init: function (element) {
      var el = $(element);
      var binding;

      _.each(['mapping', 'itemTemplate'], function (prop) {
        if (!this.scope.attr(prop)) {
          this.scope.attr(prop,
            el.attr(can.camelCaseToDashCase(prop)));
        }
      }, this);

      binding = this.scope.parentInstance.get_binding(this.scope.mapping);

      binding.refresh_instances().then(function (mappedObjects) {
        this.scope.attr('mappedObjects').replace(
          this._sortObjects(mappedObjects)
        );
      }.bind(this));

      // We are tracking binding changes, so mapped items update accordingly
      binding.list.on('change', function () {
        this.scope.attr('mappedObjects').replace(
          this._sortObjects(binding.list)
        );
      }.bind(this));
    },
    /**
      * Sort objects list by this.scope.sortField, if defined
      *
      * @param {Array} mappedObjects - the list of objects to be sorted
      *
      * @return {Array} - if this.scope.sortField is defined, mappedObjects
      *                   sorted by field this field;
      *                   if this.scope.sortField is undefined, unsorted
      *                   mappedObjects.
      */
    _sortObjects: function (mappedObjects) {
      if (this.scope.attr('sortField')) {
        return _.sortBy(mappedObjects, this.scope.attr('sortField'));
      }
      return mappedObjects;
    },
    events: {
      '[data-toggle=unmap] click': function (el, ev) {
        var instance = el.find('.result').data('result');
        var mappings = this.scope.parentInstance.get_mapping(
          this.scope.mapping);
        var binding;

        ev.stopPropagation();

        binding = _.find(mappings, function (mapping) {
          return mapping.instance.id === instance.id &&
            mapping.instance.type === instance.type;
        });
        _.each(binding.get_mappings(), function (mapping) {
          mapping.refresh()
            .then(function () {
              return mapping.destroy();
            })
            .then(function () {
              if (mapping.documentable) {
                return mapping.documentable.reify();
              }
            })
            .fail(GGRC.Errors.notifierXHR('error'));
        });
      }
    }
  });
})(window.can, window.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $) {
  can.Component.extend({
    tag: 'reuse-objects',
    scope: {
      parentInstance: null,
      /*
       * Is passed to child component (reusable-object) and it tracks
       * the values(objects) that should be reused
       *
       * {
       *    {method}-{instance.type}-{instance.id}: `true/false`,
       *    ...
       * }
       *
       * {method} - createRelationship, createEvidenceRelationship
       * {instance.type} - child object type
       * {instance.id} - child object id
       */
      reusedObjects: new can.Map(),
      isLoading: false,
      /*
       * Reuse objects
       *
       * Checks reusedObjects truthy values, creates appropriate relationship
       * and notifies user on their creation
       *
       * @param {Object} scope - component scope
       * @param {jQuery.Object} el - clicked element
       * @param {Object} ev - click event handler
       */
      reuseIt: function (scope, el, ev) {
        var reused = this.attr('reusedObjects');
        var relatedDfds = [];
        var when;

        if (el.hasClass('disabled') || this.attr('isLoading')) {
          return;
        }
        this.attr('isLoading', true);
        relatedDfds = can.map(can.Map.keys(reused), function (prop) {
          var executer;
          var id;
          var type;

          if (!reused.attr(prop)) {
            return;
          }
          prop = prop.split('-');
          executer = this[prop[0]];
          id = Number(prop[2]);
          type = can.spaceCamelCase(prop[1]).replace(/ /g, '');

          relatedDfds.push(executer.call(this, {
            id: id,
            type: type
          }));
        }.bind(this));

        when = $.when.apply($, relatedDfds);
        when.then(function () {
          can.map(can.Map.keys(reused), function (prop) {
            reused.attr(prop, false);
          });
          $(document.body).trigger('ajax:flash', {
            success: 'Selected evidences are reused'
          });
          this.attr('isLoading', false);
        }.bind(this));
        GGRC.delay_leaving_page_until(when);
      },
      /*
       * Creates an Relationship between parent instance and destination object
       *
       * @param {Object} destination - Should have `id` and `type`
       * @return {Object} - Returns newly created Relationship as jQuery deferred
       */
      createRelationship: function (destination) {
        var source;
        var dest;

        if (!destination) {
          return $.Deferred().resolve();
        }

        source = this.attr('parentInstance');
        dest = CMS.Models.get_instance({
          id: destination.id,
          type: destination.type
        });

        return new CMS.Models.Relationship({
          source: source.stub(),
          destination: dest,
          context: source.context
        }).save();
      },
      /*
       * Creates an Object Document Relationship  between parent instancere and destination object
       *
       * @param {Object} destination - Should have `id` and `type`
       * @return {Object} - Returns newly created Relationship as jQuery deferred
       */
      createEvidenceRelationship: function (destination) {
        var source;
        var dest;

        if (!destination) {
          return $.Deferred().resolve();
        }

        source = this.attr('parentInstance');
        dest = CMS.Models.get_instance({
          id: destination.id,
          type: destination.type
        });

        return new CMS.Models.ObjectDocument({
          context: source.context,
          documentable: source,
          document: dest
        }).save();
      }
    },
    helpers: {
      /*
       * Check if `Reuse` button should be enabled
       *
       * @param {Object} options - Mustache options object
       */
      disableReuse: function (options) {
        var list = [];
        var reused = this.attr('reusedObjects');
        can.each(can.Map.keys(reused), function (prop) {
          if (reused.attr(prop)) {
            list.push(prop);
          }
        });

        if (!list.length) {
          return options.fn();
        }
        return options.inverse();
      }
    }
  });

  /*
   * Child component that tracks checkbox changes
   *
   * Values that we pass in:
   * - reusable - If reusable checkbox should be visible
   * - method - Which method from parent (reuse-objects) component should be used
   *            for makining relationship
   * - list - List on which set if item should be reused
   */
  can.Component.extend({
    tag: 'reusable-object',
    template: '<content></content>',
    scope: {
      list: null
    },
    helpers: {
      isDisabled: function (instance, options) {
        var isMapped = GGRC.Utils.is_mapped(
          this.attr('baseInstance'), instance, this.attr('mapping'));

        if (isMapped) {
          return options.fn(options.contexts);
        }
        return options.inverse(options.context);
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (_, can, $, GGRC, CMS) {
  'use strict';

  GGRC.Components('assessmentGeneratorButton', {
    tag: 'assessment-generator-button',
    template: '{{{> /static/mustache/base_objects/' +
    'generate_assessments_button.mustache}}}',
    scope: {
      audit: null,
      button: '@'
    },
    events: {
      'a click': function (el, ev) {
        var instance = this.scope.attr('audit') || GGRC.page_instance();
        this._results = null;
        GGRC.Controllers.MapperModal.launch(el, {
          object: 'Audit',
          type: 'Control',
          'join-object-id': instance.id,
          'join-mapping': 'program_controls',
          getList: true,
          useTemplates: true,
          assessmentGenerator: true,
          relevantTo: [{
            type: instance.type,
            id: instance.id
          }],
          template: {
            title: '/static/mustache/assessments/generator_title.mustache',
            submitButton: 'Generate Assessments',
            count: 'assessment(s) will be generated for each selection'
          },
          callback: this.generateAssessments.bind(this)
        });
      },
      showFlash: function (statuses) {
        var flash = {};
        var type;
        var redirectLink;
        var messages = {
          error: 'Assessment generation has failed.',
          progress: 'Assessment generation is in process. This may take ' +
                    'multiple hours depending on the volume.',
          success: 'Assessment generation successful. {reload_link}'
        };
        if (statuses.Failure > 0) {
          type = 'error';
        } else if (statuses.Pending > 0 || statuses.Running > 0) {
          type = 'progress';
        } else {
          type = 'success';
          redirectLink = window.location.pathname + '#assessment_widget';
        }

        flash[type] = messages[type];
        $('body').trigger('ajax:flash', [flash, redirectLink]);
      },
      updateStatus: function (ids, count) {
        var wait = [2, 4, 8, 16, 32, 64];
        if (count >= wait.length) {
          count = wait.length - 1;
        }
        CMS.Models.BackgroundTask.findAll({
          id__in: ids.join(',')
        }).then(function (tasks) {
          var statuses = _.countBy(tasks, function (task) {
            return task.status;
          });
          this.showFlash(statuses);
          if (statuses.Pending || statuses.Running) {
            setTimeout(function () {
              this.updateStatus(ids, ++count);
            }.bind(this), wait[count] * 1000);
          }
        }.bind(this));
      },
      generateAssessments: function (list, options) {
        var que = new RefreshQueue();

        this._results = null;
        que.enqueue(list).trigger().then(function (items) {
          var results = _.map(items, function (item) {
            var id = options.assessmentTemplate.split('-')[0];
            return this.generateModel(item, id);
          }.bind(this));
          this._results = results;
          $.when.apply($, results)
            .then(function () {
              var tasks = arguments;
              var ids;
              this.showFlash({Pending: 1});
              options.context.closeModal();
              if (!tasks.length || tasks[0] instanceof CMS.Models.Assessment) {
                // We did not create a task
                window.location.reload();
                return;
              }
              ids = _.uniq(_.map(arguments, function (task) {
                return task.id;
              }));
              this.updateStatus(ids, 0);
            }.bind(this));
        }.bind(this));
      },
      generateModel: function (object, template) {
        var assessmentTemplate = CMS.Models.AssessmentTemplate.findInCacheById(
          template);
        var title = object.title + ' assessment for ' + this.scope.audit.title;
        var data = {
          _generated: true,
          audit: this.scope.audit,
          object: object.stub(),
          context: this.scope.audit.context,
          template: assessmentTemplate && assessmentTemplate.stub(),
          title: title
        };

        if (assessmentTemplate) {
          if (_.exists(assessmentTemplate, 'procedure_description.length')) {
            data.test_plan = assessmentTemplate.procedure_description;
          }
          if (_.exists(assessmentTemplate, 'test_plan_procedure') &&
              _.exists(object, 'test_plan.length')) {
            data.test_plan = object.test_plan;
          }
        }
        data.run_in_background = true;
        return new CMS.Models.Assessment(data).save();
      },
      notify: function () {
        var success;
        var errors;
        var msg;

        if (!this._results) {
          return;
        }
        success = _.filter(this._results, function (assessment) {
          return !_.isNull(assessment) &&
            !(assessment.state && assessment.state() === 'rejected');
        }).length;
        errors = _.filter(this._results, function (assessment) {
          return assessment.state && assessment.state() === 'rejected';
        }).length;

        if (errors < 1) {
          if (success === 0) {
            msg = {
              success: 'Every Control already has an Assessment!'
            };
          } else {
            msg = {
              success: success + ' Assessments successfully created.'
            };
          }
        } else {
          msg = {
            error: 'An error occurred when creating Assessments.'
          };
        }

        $(document.body).trigger('ajax:flash', msg);
      }
    }
  });
})(window._, window.can, window.can.$, window.GGRC, window.CMS);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  can.Component.extend({
    tag: 'paginate',
    template: can.view(GGRC.mustache_path + '/base_objects/paginate.mustache'),
    scope: {
      list: null,
      current: 0,
      /**
        * Current page
        *
        * Returns current page, array is zero indexed so we are adding one,
        * to be more human readable
        *
        * @return {Number} - Number of current page
        */
      currentPage: function () {
        return this.attr('current') + 1;
      },
      /**
        * Sets previous page
        *
        * @param {Object} scope - current page context
        * @param {jQuery.Object} el - clicked element
        * @param {Object} ev - click event handler
        */
      setPrevious: function (scope, el, ev) {
        var current = this.attr('current') - 1;

        ev.preventDefault();
        if (current >= 0) {
          this.attr('current', current);
        }
      },
      /**
        * Sets next page
        *
        * @param {Object} scope - current page context
        * @param {jQuery.Object} el - clicked element
        * @param {Object} ev - click event handler
        */
      setNext: function (scope, el, ev) {
        var current = this.attr('current') + 1;
        var total = this.attr('totalPages');

        ev.preventDefault();
        if (current < total) {
          this.attr('current', current);
        }
      },
      perPage: '@',
      /**
        * List of currently displayed enteries
        *
        * We are slicing input list into parts and passing them to enteries
        *
        * @return {Array} - List of enteries for current page
        */
      entries: function () {
        var list = this.attr('list');
        var perPage = Number(this.attr('perPage'));
        var current = this.attr('current');

        return list.slice(current * perPage, current * perPage + perPage);
      },
      /**
        * Get list of pages
        *
        * @return {Array} - List of pagination objects
        *                   {
        *                     number: `Display page - we are adding 1 to avoid having page 0`
        *                     pageNum: `True page number that gets passed to setPage function`
        *                   }
        */
      totalPages: can.compute(function () {
        var list = this.attr('list');
        var perPage = Number(this.attr('perPage'));

        return Math.ceil(list.length / perPage);
      })
    }
  });
})(window.can, window.can.$);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can, $) {
  'use strict';

  GGRC.Components('tabsContainer', {
    tag: 'tabs',
    template: can.view(GGRC.mustache_path + '/base_objects/tabs.mustache'),
    scope: {
      panels: [],
      index: 0,
      /**
       * Activate currently clicked panel
       *
       * @param {Object} scope - current item value from `scope.panels`
       * @param {jQuery.Object} el - clicked element
       * @param {Object} ev - click event handler
       */
      setActive: function (scope, el, ev) {
        ev.preventDefault();
        scope.panel.attr('active', true);
        this.attr('index', Number(el.data('index')));
      }
    },
    events: {
      /**
       * Set default active tab if none defined
       *
       * @param {can.List} list - list of items in `panels` object
       * @param {Object} ev - event triggered on change length
       * @param {String} item - item that got changed
       * @param {String} action - in our case it can be `add` or `remove`
       */
      '{scope.panels} change': _.throttle(function (list, ev, item, action) {
        var active;
        var index;
        var panels;

        // Sometimes the handler is invoked when DOM element does not (yet?)
        // exist, and we need to safeguard against this.
        if (!this.element) {
          return;
        }

        index = this.scope.attr('index');
        panels = this.element.find('tab-panel');

        if (list.length !== panels.length) {
          return;
        }

        active = _.filter(list, function (item) {
          if (item.panel) {
            return item.panel.attr('active');
          }
        });

        if (!active.length) {
          list[index].panel.attr('active', true);
        }
      }, 10)
    }
  });

  GGRC.Components('tabPanel', {
    tag: 'tab-panel',
    template: can.view(
      GGRC.mustache_path + '/base_objects/tab_panel.mustache'
    ),
    scope: {
      active: false,
      titleText: '@',
      panels: null
    },
    events: {
      /**
       * Add this `panel` to `panels` list in fomat
       * {
       *   title: `Title`
       *   panel: `Current panel scope`
       * }
       */
      inserted: function () {
        var panels = this.scope.attr('panels');
        panels.push({
          title: this.scope.attr('titleText'),
          panel: this.scope
        });
      },

      /**
       * Check if other tabs are active and deactivate them
       *
       * @param {can.List} list - list of items in `panels` object
       * @param {Object} ev - event triggered on change
       * @param {String} item - item that got changed
       * @param {String} action - what got changed on the object
       * @param {String} status - status of changed item, we are looking for
       *   `active` property change to either `true` or `false`
       */
      '{scope.panels} change': function (list, ev, item, action, status) {
        var index;
        var panel;

        item = item.split('.');
        if (item.length !== 3 || item[1] !== 'panel' || item[2] !== 'active') {
          // if this is a change to a scope in a different panel we should
          // not switch tabs
          return;
        }
        index = Number(item[0]);
        panel = list[index].panel;
        if (status && this.scope !== panel) {
          this.scope.attr('active', false);
        }
      }
    }
  });
})(window.GGRC, window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  /*
   * Assessment template main component
   *
   * It collects fields data and it transforms them into appropriate
   * format for saving
   */
  GGRC.Components('templateAttributes', {
    tag: 'assessment-template-attributes',
    template: '<content></content>',
    scope: {
      fields: new can.List(),
      types: new can.List([{
        type: 'Text',
        name: 'Text',
        text: 'Enter description'
      }, {
        type: 'Rich Text',
        name: 'Rich Text',
        text: 'Enter description'
      }, {
        type: 'Date',
        name: 'Date',
        text: 'MM/DD/YYYY'
      }, {
        type: 'Checkbox',
        name: 'Checkbox',
        text: ''
      }, {
        type: 'Dropdown',
        name: 'Dropdown',
        text: 'Enter values separated by comma'
      }, {
        type: 'Map:Person',
        name: 'Person',
        text: ''
      }]),

      /**
       * A handler for when a user removes a Custom Attribute Definition.
       *
       * It removes the corresponding CA definition object from the list to
       * keep it in sync with the definitions listed in DOM.
       *
       * @param {CMS.Models.CustomAttributeDefinition} instance -
       *   the definition that was removed
       * @param {jQuery.Element} $el - the source of the event `ev`
       * @param {jQuery.Event} ev - the onRemove event object
       */
      fieldRemoved: function (instance, $el, ev) {
        var idx = _.findIndex(this.fields, {title: instance.title});
        if (idx >= 0) {
          this.fields.splice(idx, 1);
        } else {
          console.warn('The list of CAD doesn\'t contain item with "' +
            instance.title + '" title');
        }
      }
    },
    events: {
      inserted: function () {
        var el = $(this.element);
        var list = el.find('.sortable-list');
        list.sortable({
          items: 'li.sortable-item',
          placeholder: 'sortable-placeholder'
        });
        list.find('.sortable-item').disableSelection();
      },
      '.sortable-list sortstop': function () {
        var el = $(this.element);
        var sortables = el.find('li.sortable-item');
        // It's not nice way to rely on DOM for sorting,
        // but it was easiest for implementation
        this.scope.fields.replace(_.map(sortables,
           function (item) {
             return $(item).data('field');
           }
        ));
      }
    }
  });
  /*
   * Template field
   *
   * Represents each `field` passed from assessment-template-attributes `fields`
   */
  GGRC.Components('templateAttributesField', {
    tag: 'template-field',
    template: can.view(GGRC.mustache_path +
      '/assessment_templates/attribute_field.mustache'),
    scope: function (attrs, parentScope, element) {
      return {
        types: parentScope.attr('types'),
        pads: {
          COMMENT: 0,
          ATTACHMENT: 1
        },

        _EV_FIELD_REMOVED: 'on-remove',

        /*
         * Removes `field` from `fields`
         */
        removeField: function (scope, el, ev) {
          ev.preventDefault();

          // CAUTION: In order for the event to not get lost, triggering it
          // must happen before changing any of the scope attributes that
          // cause changes in the template.
          this.$rootEl.triggerHandler({
            type: this._EV_FIELD_REMOVED
          });

          scope.attr('_pending_delete', true);
        },
        /*
         * Denormalize field.multi_choice_mandatory into opts
         * "0, 1, 2" is normalized into
         * [
         * {value: 0, attachment: false, comment: false},
         * {value: 1, attachment: false, comment: true},
         * {value: 2, attachment: true, comment: false},
         * ]
         */
        denormalize_mandatory: function (field, pads) {
          var options = _.splitTrim(field.attr('multi_choice_options'));
          var vals = _.splitTrim(field.attr('multi_choice_mandatory'));
          var isEqualLength = options.length === vals.length;
          var range;

          if (!isEqualLength && options.length < vals.length) {
            vals.length = options.length;
          } else if (!isEqualLength && options.length > vals.length) {
            range = _.range(options.length - vals.length);
            range = range.map(function () {
              return '0';
            });
            vals = vals.concat(range);
          }

          return _.zip(options, vals).map(function (zip) {
            var attr = new can.Map();
            var val = zip[1];
            var attachment = !!(val & 1 << pads.ATTACHMENT);
            var comment = !!(val & 1 << pads.COMMENT);
            attr.attr('value', zip[0]);
            attr.attr('attachment', attachment);
            attr.attr('comment', comment);
            return attr;
          });
        },
        /*
         * Normalize opts into field.multi_choice_mandatory
         * [
         * {value: 0, attachment: true, comment: false},
         * {value: 1, attachment: true, comment: true},
         * ]
         * is normalized into "2, 3" (10b, 11b).
         */
        normalize_mandatory: function (attrs, pads) {
          return can.map(attrs, function (attr) {
            var attach = attr.attr('attachment') << pads.ATTACHMENT;
            var comment = attr.attr('comment') << pads.COMMENT;
            return attach | comment;
          }).join(',');
        }
      };
    },
    events: {
      /**
       * The component's entry point.
       *
       * @param {Object} element - the (unwrapped) DOM element that triggered
       *   creating the component instance
       * @param {Object} options - the component instantiation options
       */
      init: function (element, options) {
        var field = this.scope.attr('field');
        var pads = this.scope.attr('pads');
        var denormalized = this.scope.denormalize_mandatory(field, pads);
        var types = this.scope.attr('types');
        var item = _.find(types, function (obj) {
          return obj.type === field.attr('attribute_type');
        });
        this.scope.field.attr('attribute_name', item.name);
        this.scope.attr('attrs', denormalized);

        this.scope.attr('$rootEl', $(element));
      },
      '{attrs} change': function () {
        var attrs = this.scope.attr('attrs');
        var pads = this.scope.attr('pads');
        var normalized = this.scope.normalize_mandatory(attrs, pads);
        this.scope.field.attr('multi_choice_mandatory', normalized);
      }
    }
  });

  GGRC.Components('addTemplateField', {
    tag: 'add-template-field',
    template: can.view(GGRC.mustache_path +
      '/assessment_templates/attribute_add_field.mustache'),
    scope: function (attrs, parentScope) {
      return new can.Map({
        selected: new can.Map(),
        fields: parentScope.attr('fields'),
        types: parentScope.attr('types'),
        // the field types that require a list of possible values to be defined
        valueAttrs: ['Dropdown'],
        /*
         * Create a new field.
         *
         * Field must contain value title, type, values.
         * Opts are populated, once we start changing checkbox values
         *
         * @param {can.Map} scope - the current (add-template-field) scope
         * @param {jQuery.Object} el - the clicked DOM element
         * @param {Object} ev - the event object
         */
        addField: function (scope, el, ev) {
          var fields = scope.attr('fields');
          var selected = scope.attr('selected');
          var title = _.trim(selected.title);
          var type = _.trim(selected.type);
          var invalidInput = false;
          var values = _.splitTrim(selected.values, {
            unique: true
          }).join(',');
          ev.preventDefault();
          scope.attr('selected.invalidTitle', false);
          scope.attr('selected.emptyTitle', false);
          scope.attr('selected.dublicateTitle', false);
          scope.attr('selected.invalidValues', false);

          if (this.isEmptyTitle(title)) {
            this.attr('selected.invalidTitle', true);
            this.attr('selected.emptyTitle', true);
            invalidInput = true;
          } else if (this.isDublicateTitle(fields, title)) {
            this.attr('selected.invalidTitle', true);
            this.attr('selected.dublicateTitle', true);
            invalidInput = true;
          }
          if (this.isInvalidValues(scope.valueAttrs, type, values)) {
            scope.attr('selected.invalidValues', true);
            invalidInput = true;
          }
          if (invalidInput) {
            return;
          }
          // We need to defer adding in modal since validation is preventing
          // on adding the first item
          _.defer(function () {
            fields.push({
              id: scope.attr('id'),
              title: title,
              attribute_type: type,
              multi_choice_options: values
            });
            _.each(['title', 'values', 'multi_choice_options'],
              function (type) {
                selected.attr(type, '');
              });
          });
        },
        isInvalidValues: function (valueAttrs, type, values) {
          return _.contains(valueAttrs, type) && !values;
        },
        isDublicateTitle: function (fields, selectedTitle) {
          var duplicateField = _.some(fields, function (item) {
            return item.title === selectedTitle && !item._pending_delete;
          });
          return fields.length && duplicateField;
        },
        isEmptyTitle: function (selectedTitle) {
          return !selectedTitle;
        }
      });
    },
    events: {
      /*
       * Set default dropdown type on init
       */
      inserted: function () {
        var types = this.scope.attr('types');
        if (!this.scope.attr('selected.type')) {
          this.scope.attr('selected.type', _.first(types).attr('type'));
        }
      }
    },
    helpers: {
      /*
       * Get input placeholder value depended on type
       *
       * @param {Object} options - Mustache options
       */
      placeholder: function (options) {
        var types = this.attr('types');
        var item = _.findWhere(types, {
          type: this.attr('selected.type')
        });
        if (item) {
          return item.text;
        }
      }
    }
  });
})(window.can, window.can.$);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('lazyOpenClose', {
    tag: 'lazy-openclose',
    scope: {
      show: false
    },
    content: '<content/>',
    init: function () {
      this._control.element.closest('.tree-item').find('.openclose')
      .bind('click', function () {
        this.scope.attr('show', true);
      }.bind(this));
    }
  });
})(window.can, window.can.$);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  'use strict';

  /**
   * A component that calculates and renders the given Model object's revision
   * history.
   */
  GGRC.Components('objectHistory', {
    tag: 'revision-log',

    template: can.view(
      GGRC.mustache_path +
      '/components/object_history/object_history.mustache'
    ),

    scope: {
      instance: null,
      changeHistory: [],
      isLoading: true
    },

    _DATE_FIELDS: Object.freeze({
      created_at: 1,
      updated_at: 1,
      start_date: 1,
      end_date: 1,
      requested_on: 1,
      due_on: 1,
      finished_date: 1,
      verified_date: 1
    }),

    _LIST_FIELDS: Object.freeze({
      recipients: 1
    }),

    _EMBED_MAPPINGS: Object.freeze({
      Request: ['Comment', 'Document'],
      Assessment: ['Comment', 'Document']
    }),

    /**
     * The component's entry point. Invoked when a new component instance has
     * been created.
     *
     * @param {Object} element - the (unwrapped) DOM element that triggered
     *   creating the component instance
     * @param {Object} options - the component instantiation options
     */
    init: function (element, options) {
      var setUp = function () {
        this._fetchRevisionsData(
          this.scope.instance
        ).then(
          function success(revisions) {
            var changeHistory;

            // calculate history of role changes
            this.roleHistory = this._computeRoleChanges(revisions);

            // combine all the changes and sort them by date descending
            changeHistory = _([]).concat(
                _.toArray(this._computeObjectChanges(revisions.object)),
                _.toArray(this._computeMappingChanges(revisions.mappings))
            ).sortBy('updatedAt').reverse().value();
            this.scope.attr('changeHistory', changeHistory);
          }.bind(this),

          function error() {
            $(element).trigger(
              'ajax:flash',
              {error: 'Failed to fetch revision history data.'});
          }
        ).always(function () {
          this.scope.attr('isLoading', false);
        }.bind(this));
      }.bind(this);

      if (this.scope.instance === null) {
        throw new Error('Instance not passed through the HTML element.');
      }
      this.scope.instance.on('updated', function () {
        setUp();
      });
      setUp();
    },

    /**
     * Fetch the instance's Revisions data from the server, including the
     * Revisions of the instance's mappings.
     *
     * The `instance` here refers to the instance of an object currently being
     * handled by the component.
     *
     * @return {can.Deferred} - an object representing the async operation of
     *   fetching the data from the server. On success it is resolved with an
     *   object containing the following Revision data, order by date from
     *   oldest to newest:
     *   - {Array} object - the list of Revisions of the instance itself,
     *   - {Array} mappings - the list of Revisions of all the instance's
     *      mappings
     */
    _fetchRevisionsData: function () {
      var findAll = function (attr) {
        var query = {__sort: 'updated_at'};
        query[attr + '_type'] = this.scope.instance.type;
        query[attr + '_id'] = this.scope.instance.id;
        return CMS.Models.Revision.findAll(query);
      }.bind(this);

      return can.when(
        findAll('resource'), findAll('source'), findAll('destination')
      ).then(function (objRevisions, mappingsSrc, mappingsDest) {
        // manually include people for modified_by since using __include would
        // result in a lot of duplication
        var rq = new RefreshQueue();
        _.each(objRevisions.concat(mappingsSrc, mappingsDest),
            function (revision) {
              if (revision.modified_by) {
                rq.enqueue(revision.modified_by);
              }
            });
        _.each(mappingsSrc, function (revision) {
          if (revision.destination_type && revision.destination_id) {
            revision.destination = can.Stub.get_or_create({
              id: revision.destination_id,
              type: revision.destination_type
            });
            rq.enqueue(revision.destination);
          }
        });
        _.each(mappingsDest, function (revision) {
          if (revision.source_type && revision.source_id) {
            revision.source = can.Stub.get_or_create({
              id: revision.source_id,
              type: revision.source_type
            });
            rq.enqueue(revision.source);
          }
        });
        return this._fetchEmbeddedRevisionData(rq.objects, rq)
          .then(function (embedded) {
            return rq.trigger().then(function () {
              var reify = function (revision) {
                _.each(['modified_by', 'source', 'destination'],
                    function (field) {
                      if (revision[field] && revision[field].reify) {
                        revision.attr(field, revision[field].reify());
                      }
                    });
                return revision;
              };
              var mappings = mappingsSrc.concat(mappingsDest, embedded);
              return {
                object: _.map(objRevisions, reify),
                mappings: _.map(mappings, reify)
              };
            });
          });
      }.bind(this));
    },

    /**
     * Fetch revisions of indirect mappings ('Cross').
     *
     * @param {Array} mappedObjects - the list of object instances to fetch
     *   mappings to (objects mapped to the current instance).
     *
     * @param {RefreshQueue} rq - current refresh queue to use for fetching
     *   full objects.
     *
     * @return {Deferred} - A deferred that will resolve into a array of
     *   revisons of the indirect mappings.
     */
    _fetchEmbeddedRevisionData: function (mappedObjects, rq) {
      var filterElegible = function (obj) {
        return _.contains(this._EMBED_MAPPINGS[this.scope.instance.type],
                          obj.type);
      }.bind(this);
      var fetchRevisions = function (obj) {
        return [
          CMS.Models.Revision.findAll({
            source_type: obj.type,
            source_id: obj.id,
            __sort: 'updated_at'
          }).then(function (revisions) {
            return _.map(revisions, function (revision) {
              revision = new can.Map(revision.serialize());
              revision.attr({
                updated_at: new Date(revision.updated_at),
                source_type: this.scope.instance.type,
                source_id: this.scope.instance.id,
                source: this.scope.instance,
                destination: can.Stub.get_or_create({
                  type: revision.destination_type,
                  id: revision.destination_id
                })
              });
              rq.enqueue(revision.destination);
              return revision;
            }.bind(this));
          }.bind(this)),
          CMS.Models.Revision.findAll({
            destination_type: obj.type,
            destination_id: obj.id,
            __sort: 'updated_at'
          }).then(function (revisions) {
            return _.map(revisions, function (revision) {
              revision = new can.Map(revision.serialize());
              revision.attr({
                updated_at: new Date(revision.updated_at),
                destination_type: this.scope.instance.type,
                destination_id: this.scope.instance.id,
                destination: this.scope.instance,
                source: can.Stub.get_or_create({
                  type: revision.source_type,
                  id: revision.source_id
                })
              });
              rq.enqueue(revision.source);
              return revision;
            }.bind(this));
          }.bind(this))
        ];
      }.bind(this);
      var dfds = _.chain(mappedObjects).filter(filterElegible)
                                       .map(fetchRevisions)
                                       .flatten()
                                       .value();
      return $.when.apply($, dfds).then(function () {
        return _.filter(_.flatten(arguments), function (revision) {
          // revisions where source == destination will be introduced when
          // spoofing the obj <-> instance mapping
          return revision.source.href !== revision.destination.href;
        });
      });
    },

    /**
     * Compute the the history of object changes from a list of Revisions.
     *
     * The computed list of changes is sorted from oldest to newest (the method
     * assumes that the `revisions` list is also sorted chronologically with
     * the oldest Revision placed first).
     *
     *
     * @param {Array} revisions - the list of revisions of the instance
     *   being handled by the component, sorted from oldest to newest.
     *
     * @return {Array} - the history of changes to the instance. Each
     *   element follows the format returned by the `_objectChangeDiff` method.
     */
    _computeObjectChanges: function (revisions) {
      var diffList = _.map(revisions, function (revision, i) {
        // default to empty revision
        var prev = revisions[i - 1] || {content: {}};
        return this._objectChangeDiff(prev, revision);
      }.bind(this));
      return _.filter(diffList, 'changes.length');
    },

    /**
     * A helper function for computing the difference between the two Revisions
     * of an object.
     *
     * The function assumes that the given revisions are two distinct Revisions
     * of the same object (application entity).
     *
     * NOTE: The object fields that do not have a user-friendly alias defined are
     * considered 'internal', and are thus not included in the resulting diff
     * objects, because they are not meant to be shown to the end user.
     *
     * @param {CMS.Models.Revision} rev1 - the older of the two revisions
     * @param {CMS.Models.Revision} rev2 - the newer of the two revisions
     *
     * @return {Object} - A 'diff' object describing the changes between the
     *   revisions. The object has the following attributes:
     *   - madeBy: the user who made the changes
     *   - updatedAt: the time when the changes have been made
     *   - role: highest role at the time of change
     *   - changes:
     *       A list of objects describing the modified attributes of the
     *       instance`, with each object having the following attributes:
     *         - fieldName: the name of the changed`instance` attribute
     *         - origVal: the attribute's original value
     *         - newVal: the attribute's new (modified) value
     */
    _objectChangeDiff: function (rev1, rev2) {
      var diff = {
        madeBy: null,
        updatedAt: null,
        changes: []
      };
      var attrDefs = GGRC.model_attr_defs[rev2.resource_type];

      diff.madeBy = rev2.modified_by;
      diff.updatedAt = rev2.updated_at;
      diff.role = this._getRoleAtTime(rev2.modified_by.id, rev2.updated_at);

      can.each(rev2.content, function (value, fieldName) {
        var origVal = rev1.content[fieldName];
        var displayName;
        if (attrDefs) {
          displayName = (_.find(attrDefs, function (attr) {
            return attr.attr_name === fieldName;
          }) || {}).display_name;
        } else {
          displayName = fieldName;
        }

        if (displayName && value !== origVal) {
          // format date fields
          if (this._DATE_FIELDS[fieldName]) {
            if (value) {
              value = GGRC.Utils.formatDate(value, true);
            }
            if (origVal) {
              origVal = GGRC.Utils.formatDate(origVal, true);
            }
          }
          if (this._LIST_FIELDS[fieldName]) {
            if (value) {
              value = _(value).splitTrim(',').compact().join(', ');
            }
            if (origVal) {
              origVal = _(origVal).splitTrim(',').compact().join(', ');
            }
          }
          if (origVal || value) {
            diff.changes.push({
              fieldName: displayName,
              origVal: origVal || '—',
              newVal: value || '—'
            });
          }
        }
      }.bind(this));
      diff.changes = diff.changes.concat(
          this._objectCADiff(
            rev1.content.custom_attributes,
            rev1.content.custom_attribute_definitions,
            rev2.content.custom_attributes,
            rev2.content.custom_attribute_definitions));
      return diff;
    },

    _objectCADiff: function (origValues, origDefs, newValues, newDefs) {
      var ids;
      var defs;
      var showValue = function (value, def) {
        var obj;
        switch (def.attribute_type) {
          case 'Checkbox':
            return value.attribute_value ? '✓' : undefined;
          case 'Map:Person':
            obj = CMS.Models.Person.findInCacheById(value.attribute_object_id);
            if (obj === undefined) {
              return value.attribute_value;
            }
            return obj.name || obj.email || value.attribute_value;
          default:
            return value.attribute_value;
        }
      };

      origValues = _.indexBy(origValues, 'custom_attribute_id');
      origDefs = _.indexBy(origDefs, 'id');
      newValues = _.indexBy(newValues, 'custom_attribute_id');
      newDefs = _.indexBy(newDefs, 'id');

      ids = _.unique(_.keys(origValues).concat(_.keys(newValues)));
      defs = _.merge(origDefs, newDefs);

      return _.chain(ids).map(function (id) {
        var def = defs[id];
        var diff = {
          fieldName: def.title,
          origVal: showValue(origValues[id] || {}, def) || '—',
          newVal: showValue(newValues[id] || {}, def) || '—'
        };
        if (diff.origVal === diff.newVal) {
          return undefined;
        }
        return diff;
      }).filter().value();
    },

    /**
     * Compute the instance's object mapping-related changes from the list of
     * mapping revisions.
     *
     * @param {Array} revisions - the list of instance mappings' revision
     *   history, sorted from oldest to newest.
     *
     * @return {Array} - the history of instance mappings' changes. Each
     *   element follows the format returned by the `_mappingChange` helper
     *   method.
     */
    _computeMappingChanges: function (revisions) {
      var chains = _.chain(revisions)
                    .groupBy('resource_id')
                    .mapValues(function (chain) {
                      return _.sortBy(chain, 'updated_at');
                    }).value();
      return _.map(revisions, function (revision) {
        return this._mappingChange(revision, chains[revision.resource_id]);
      }.bind(this));
    },

    /**
     * A helper function for extracting the mapping change information from a
     * Revision object.
     *
     * @param {CMS.Models.Revision} revision - a Revision object describing a
     *   mapping between the object instance the component is handling, and an
     *   external object
     *
     * @param {Array} chain - revisions of the same resource ordered
     *   chronologically
     *
     * @return {Object} - A 'change' object describing a single modification
     *   of a mapping. The object has the following attributes:
     *   - madeBy: the user who made the changes
     *   - updatedAt: the time when the changes have been made
     *   - role: highest role at the time of change
     *   - changes:
     *       A list of objects describing the modified attributes of the
     *       instance`, with each object having the following attributes:
     *         - fieldName: the name of the changed`instance` attribute
     *         - origVal: the attribute's original value
     *         - newVal: the attribute's new (modified) value
     */
    _mappingChange: function (revision, chain) {
      var object;
      var displayName;
      var displayType;
      var fieldName;
      var origVal;
      var newVal;
      var previous;

      if (revision.destination_type === this.scope.instance.type &&
        revision.destination_id === this.scope.instance.id) {
        object = revision.source;
      } else {
        object = revision.destination;
      }

      if (object instanceof can.Stub) {
        object = object.reify();
      }

      displayName = object.display_name() || object.description;
      displayType = object.display_type() || object.type;

      fieldName = 'Mapping to ' + displayType + ': ' + displayName;
      origVal = '—';
      newVal = _.capitalize(revision.action);
      previous = chain[_.findIndex(chain, revision) - 1];
      if (revision.action !== 'deleted' &&
          _.exists(revision.content, 'attrs.AssigneeType')) {
        newVal = revision.content.attrs.AssigneeType;
      }
      if (_.exists(previous, 'content.attrs.AssigneeType')) {
        origVal = previous.content.attrs.AssigneeType;
      } else if (revision.action === 'deleted') {
        origVal = 'Created';
      }
      return {
        madeBy: revision.modified_by,
        updatedAt: revision.updated_at,
        role: this._getRoleAtTime(
          revision.modified_by.id, revision.updated_at),
        changes: {
          origVal: origVal,
          newVal: newVal,
          fieldName: fieldName
        }
      };
    },
    /**
     * Calculate each person's role history.
     *
     * It groups together all people mapping changes and for each change
     * gets the highest role at the time of change.
     *
     * If however the revision history isn't complete (they don't start with
     * "created" action, e.g. old assessments) it then adds "no role" to the
     * start of person's history.
     *
     * If we don't have any revisions to person mappings but they are
     * currently an assignee, we select the highest current role.
     *
     * If user has no role and was not or is not an assignee, we just add a
     * single role change ("no role").
     *
     * @param {CMS.Models.Revision} revision - a Revision object describing a
     *   mapping between the object instance the component is handling, and an
     *   external object
     *
     * @return {Object} - An object containing user IDs as keys and person's
     *   role history through time ordered in increasing order.
     */

    _computeRoleChanges: function (revisions) {
      var mappings = _.sortBy(revisions.mappings, 'updated_at');
      var instance = this.scope.instance;
      var assigneeList = instance.class.assignable_list;
      var perPersonMappings;
      var perPersonRoleHistory;
      var modifiers;
      var currentAssignees;
      var assigneeRoles;
      var unmodifiedAssignees;
      var unassignedPeople;

      perPersonMappings = _(mappings)
        .filter(function (rev) {
          if (rev.source_type === 'Person' ||
            rev.destination_type === 'Person') {
            return rev;
          }
        })
        .groupBy(function (rev) {
          if (rev.source_type === 'Person') {
            return rev.source_id;
          }
          return rev.destination_id;
        }).value();

      perPersonRoleHistory = _.zipObject(
        _.map(perPersonMappings, function (revisions, pid) {
          var history = _.map(revisions, function (rev) {
            // Add extra check to fix possible issue with inconsistent data
            if (rev.action === 'deleted' || !rev.content.attrs.AssigneeType) {
              return {
                updated_at: rev.updated_at,
                role: 'none'
              };
            }
            return {
              updated_at: rev.updated_at,
              role: GGRC.Utils.get_highest_assignee_role(
                instance,
                rev.content.attrs.AssigneeType.split(','))
            };
          });

          if (revisions[0].action !== 'created') {
            history.unshift({
              role: 'none',
              updated_at: instance.created_at
            });
          }
          return [pid, history];
        }));

      modifiers = _.unique(
        _.map(
          _.union(
            revisions.object,
            revisions.mappings),
          'modified_by.id')).map(String);

      currentAssignees = _.groupBy(
        _.flattenDeep(_.map(assigneeList, function (assignableType) {
          return _.map(instance.get_binding(assignableType.mapping).list,
            function (person) {
              return {
                id: person.instance.id,
                type: assignableType.type
              };
            });
        })), 'id');

      assigneeRoles = _.zipObject(
        _.map(currentAssignees, function (rolePeople, pid) {
          return [pid, _.map(rolePeople, 'type')];
        }));

      unmodifiedAssignees = _.difference(
        _.keys(assigneeRoles), _.keys(perPersonRoleHistory));

      _.forEach(unmodifiedAssignees, function (pid) {
        var existingRoles = assigneeRoles[pid];
        var role = GGRC.Utils.get_highest_assignee_role(
          instance, existingRoles);
        perPersonRoleHistory[pid] = [{
          updated_at: instance.created_at,
          role: role
        }];
      });

      unassignedPeople = _.difference(
        modifiers, _.keys(perPersonRoleHistory));

      _.forEach(unassignedPeople, function (pid) {
        perPersonRoleHistory[pid] = [{
          updated_at: instance.created_at,
          role: 'none'
        }];
      });

      return perPersonRoleHistory;
    },
    /**
     * A function to return person's highest role at a certain time
     *
     * @param {String|Number} personId - Person ID
     * @param {Date} timePoint - Time of change
     * @return {String} - Lowercase role string
     */
    _getRoleAtTime: function (personId, timePoint) {
      var personHistory = this.roleHistory[personId] || [];
      var role = _.last(_.takeWhile(personHistory, function (roleChange) {
        return roleChange.updated_at <= timePoint;
      }));
      if (role) {
        return role.role;
      }
      return 'none';
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $) {
  'use strict';
  var warningMessage = 'Selected objects will be mapped ' +
    'to the corresponding Program, ' +
    'and system will create snapshots of selected objects for this Audit';

  var MapperModel = GGRC.Models.MapperModel = can.Map.extend({
    defaults: {
      defaultGroups: {
        all_objects: {
          name: 'All Objects',
          value: 'AllObject',
          plural: 'allobjects',
          table_plural: 'allobjects',
          singular: 'AllObject',
          models: []
        },
        entities: {
          name: 'People/Groups',
          items: []
        },
        business: {
          name: 'Assets/Business',
          items: []
        },
        governance: {
          name: 'Governance',
          items: []
        }
      }
    }
  }, {
    init: function () {
      this.attr('types', this.initTypes());
      this.attr('parentInstance', this.initInstance());
    },
    type: 'AllObject', // We set default as All Object
    warningMessage: warningMessage,
    contact: null,
    contactEmail: null,
    deferred: '@',
    deferred_to: '@',
    term: '',
    object: '',
    model: {},
    bindings: {},
    is_loading: false,
    page_loading: false,
    is_saving: false,
    all_selected: false,
    assessmentTemplate: '',
    search_only: false,
    join_object_id: '',
    selected: new can.List(),
    entries: new can.List(),
    options: new can.List(),
    relevant: new can.List(),
    is_snapshotable: false,
    snapshot_scope_id: '',
    snapshot_scope_type: '',
    parentInstance: null,
    allowedToCreate: function () {
      var isAllTypeSelected = this.attr('type') === 'AllObject';
      var isSearch = this.attr('search_only');
      return !isAllTypeSelected && !isSearch;
    },
    showWarning: function () {
      return !(GGRC.Mappings
        .canBeMappedDirectly(this.attr('type'), this.attr('object')));
    },
    initInstance: function () {
      return CMS.Models.get_instance(
        this.attr('object'),
        this.attr('join_object_id')
      );
    },
    prepareCorrectTypeFormat: function (cmsModel) {
      return {
        category: cmsModel.category,
        name: cmsModel.title_plural,
        value: cmsModel.shortName,
        singular: cmsModel.shortName,
        plural: cmsModel.title_plural.toLowerCase().replace(/\s+/, '_'),
        table_plural: cmsModel.table_plural,
        title_singular: cmsModel.title_singular,
        isSelected: cmsModel.shortName === this.attr('type')
      };
    },
    addFormattedType: function (modelName, groups) {
      var group;
      var type;
      var cmsModel;
      cmsModel = GGRC.Utils.getModelByType(modelName);
      if (!cmsModel || cmsModel.title_singular === 'Reference') {
        return;
      }
      type = this.prepareCorrectTypeFormat(cmsModel);
      group = !groups[type.category] ?
        groups.governance :
        groups[type.category];

      group.items.push(type);
      groups.all_objects.models.push(type.singular);
    },
    getModelNamesList: function (object) {
      var exclude = [];
      var include = [];
      // These inclusions\exclusions might be changed and better be defined outside
      if (this.attr('getList')) {
        exclude = ['AssessmentTemplate', 'Assessment', 'Audit',
          'CycleTaskGroupObjectTask', 'Request', 'TaskGroup',
          'TaskGroupTask', 'Workflow'];
      }
      if (this.attr('search_only')) {
        include = ['TaskGroupTask', 'TaskGroup',
          'CycleTaskGroupObjectTask'];
      }
      return GGRC.Mappings
        .getMappingList(object, include, exclude)
        .map(function (item) {
          return item.modelName;
        });
    },
    initTypes: function () {
      var object = this.attr('getList') ?
        'MultitypeSearch' :
        this.attr('object');
      // Can.JS wrap all objects with can.Map by default
      var groups = this.attr('defaultGroups').serialize();
      var list = this.getModelNamesList(object);

      list.forEach(function (modelName) {
        return this.addFormattedType(modelName, groups);
      }.bind(this));

      if (groups.all_objects.models.length < 2) {
        delete groups.all_objects;
      }
      return groups;
    },
    setContact: function (scope, el, ev) {
      this.attr('contact', ev.selectedItem);

      _.defer(function () {
        this.attr('contactEmail', ev.selectedItem.email);
      }.bind(this));
    },
    getBindingName: function (instance, plural) {
      return (instance.has_binding(plural) ? '' : 'related_') + plural;
    },
    modelFromType: function (type) {
      var types = _.reduce(_.values(
        this.attr('types').serialize()), function (memo, val) {
        if (val.items) {
          return memo.concat(val.items);
        }
        return memo;
      }, []);
      return _.findWhere(types, {value: type});
    }
  });

  /**
   * A component implementing a modal for mapping objects to other objects,
   * taking the object type mapping constraints into account.
   */
  GGRC.Components('modalMapper', {
    tag: 'modal-mapper',
    template: can.view(GGRC.mustache_path + '/modals/mapper/base.mustache'),
    scope: function (attrs, parentScope, el) {
      var $el = $(el);
      var data = {};
      var id = Number($el.attr('join-object-id'));
      var object = $el.attr('object');
      var type = $el.attr('type');
      var treeView = GGRC.tree_view.sub_tree_for[object];

      if ($el.attr('search-only')) {
        data.search_only = /true/i.test($el.attr('search-only'));
      }

      if (object) {
        data.object = object;
      }

      type = CMS.Models[type] && type;
      if (!data.search_only) {
        if (type) {
          data.type = type;
        } else if (id === GGRC.page_instance().id || !treeView) {
          data.type = 'AllObject';
        } else {
          data.type = treeView.display_list[0];
        }
      } else {
        data.type = 'Program';
      }

      if (id || GGRC.page_instance()) {
        data.join_object_id = id || GGRC.page_instance().id;
      }

      return {
        isLoadingOrSaving: function () {
          return (this.attr('mapper.page_loading') ||
          this.attr('mapper.is_saving') ||
          this.attr('mapper.block_type_change'));
        },
        mapper: new MapperModel(can.extend(data, {
          relevantTo: parentScope.attr('relevantTo'),
          callback: parentScope.attr('callback'),
          getList: parentScope.attr('getList'),
          useTemplates: parentScope.attr('useTemplates'),
          assessmentGenerator: parentScope.attr('assessmentGenerator'),
          is_snapshotable: parentScope.attr('is_snapshotable'),
          snapshot_scope_id: parentScope.attr('snapshot_scope_id'),
          snapshot_scope_type: parentScope.attr('snapshot_scope_type')
        })),
        template: parentScope.attr('template'),
        draw_children: true
      };
    },

    events: {
      inserted: function () {
        this.scope.attr('mapper.selected').replace([]);
        this.scope.attr('mapper.entries').replace([]);

        this.setModel();
        this.setBinding();
      },
      closeModal: function () {
        this.scope.attr('mapper.is_saving', false);

        // TODO: Find proper way to dismiss the modal
        this.element.find('.modal-dismiss').trigger('click');
      },
      deferredSave: function () {
        var source = this.scope.attr('deferred_to').instance ||
          this.scope.attr('mapper.object');

        var data = {
          multi_map: true,
          arr: _.compact(_.map(
            this.scope.attr('mapper.selected'),
            function (desination) {
              var isAllowed = GGRC.Utils.allowed_to_map(source, desination);
              var inst = _.find(
                this.scope.attr('mapper.entries'),
                function (entry) {
                  return (entry.instance.id === desination.id &&
                  entry.instance.type === desination.type);
                }
              );

              if (inst && isAllowed) {
                return inst.instance;
              }
            }.bind(this)
          ))
        };

        this.scope.attr('deferred_to').controller.element.trigger(
          'defer:add', [data, {map_and_save: true}]);
        this.closeModal();
      },
      '.add-button modal:added': 'addNew',
      '.add-button modal:success': 'addNew',
      addNew: function (el, ev, model) {
        var entries = this.scope.attr('mapper.entries');
        var getBindingName = this.scope.attr('mapper').getBindingName;
        var binding;
        var item;
        var mapping;
        var selected;

        selected = this.scope.attr('mapper.parentInstance');
        binding = selected.get_binding(
          getBindingName(selected, model.constructor.table_plural));
        mapping = GGRC.Mappings.get_canonical_mapping_name(
          selected.type, model.type);
        mapping = model.get_mapping(mapping);

        item = new GGRC.ListLoaders.MappingResult(model, mapping, binding);
        item.append = true;
        entries.unshift(item);
      },
      '.modal-footer .btn-map click': function (el, ev) {
        var callback = this.scope.attr('mapper.callback');
        var type = this.scope.attr('mapper.type');
        var object = this.scope.attr('mapper.object');
        var assessmentTemplate = this.scope.attr('mapper.assessmentTemplate');
        var isAllObject = type === 'AllObject';
        var instance = CMS.Models[object].findInCacheById(
          this.scope.attr('mapper.join_object_id'));
        var mapping;
        var Model;
        var data = {};
        var defer = [];
        var que = new RefreshQueue();

        ev.preventDefault();
        if (el.hasClass('disabled')) {
          return;
        }
        if (this.scope.attr('mapper.getList')) {
          this.scope.attr('mapper.is_saving', true);
          return callback(this.scope.attr('mapper.selected'), {
            type: type,
            target: object,
            instance: instance,
            assessmentTemplate: assessmentTemplate,
            context: this
          });
        }

        // TODO: Figure out nicer / proper way to handle deferred save
        if (this.scope.attr('deferred')) {
          return this.deferredSave();
        }
        this.scope.attr('mapper.is_saving', true);

        que.enqueue(instance).trigger().done(function (inst) {
          data.context = instance.context || null;
          _.each(this.scope.attr('mapper.selected'), function (destination) {
            var modelInstance;
            var isMapped = GGRC.Utils.is_mapped(instance, destination);
            var isAllowed = GGRC.Utils.allowed_to_map(instance, destination);

            if (isMapped || !isAllowed) {
              return;
            }
            mapping = GGRC.Mappings.get_canonical_mapping(
              object, isAllObject ? destination.type : type);
            Model = CMS.Models[mapping.model_name];
            data[mapping.object_attr] = {
              href: instance.href,
              type: instance.type,
              id: instance.id
            };
            data[mapping.option_attr] = destination;
            modelInstance = new Model(data);
            defer.push(modelInstance.save());
          }, this);

          $.when.apply($, defer)
            .fail(function (response, message) {
              $('body').trigger('ajax:flash', {error: message});
            })
            .always(function () {
              this.scope.attr('mapper.is_saving', false);
              this.closeModal();
            }.bind(this));
        }.bind(this));
      },

      setBinding: function () {
        var binding;
        var getBindingName;
        var selected;
        var tablePlural;

        if (this.scope.attr('mapper.search_only')) {
          return;
        }

        getBindingName = this.scope.attr('mapper').getBindingName;
        selected = this.scope.attr('mapper.parentInstance');
        tablePlural = getBindingName(
          selected, this.scope.attr('mapper.model.table_plural'));

        if (!selected.has_binding(tablePlural)) {
          return;
        }

        binding = selected.get_binding(tablePlural);
        binding.refresh_list().then(function (mappings) {
          can.each(mappings, function (mapping) {
            this.scope.attr('mapper.bindings')[mapping.instance.id] = mapping;
          }, this);
        }.bind(this));
      },
      setModel: function () {
        var type = this.scope.attr('mapper.type');
        var types = this.scope.attr('mapper.types');

        if (~['All Object', 'AllObject'].indexOf(type)) {
          return this.scope.attr('mapper.model', types.all_objects);
        }
        this.scope.attr(
          'mapper.model', this.scope.mapper.modelFromType(type));
      },
      '{mapper} type': function () {
        this.scope.attr('mapper.term', '');
        this.scope.attr('mapper.contact', null);
        this.scope.attr('mapper.contactEmail', null);
        if (!this.scope.attr('mapper.getList')) {
          this.scope.attr('mapper.relevant').replace([]);
        }
        this.setModel();
        this.setBinding();
      },
      '{mapper} assessmentTemplate': function (scope, ev, val, oldVal) {
        var type;
        if (_.isEmpty(val)) {
          return this.scope.attr('mapper.block_type_change', false);
        }

        val = val.split('-');
        type = val[1];
        this.scope.attr('mapper.block_type_change', true);
        this.scope.attr('mapper.type', type);
      },
      '#search-by-owner autocomplete:select': function (el, ev, data) {
        this.scope.attr('mapper.contact', data.item);
      },

      '#search-by-owner keyup': function (el, ev) {
        if (!el.val()) {
          this.scope.attr('mapper.contact', {});
        }
      },

      '#search keyup': function (el, ev) {
        if (ev.keyCode === 13) {
          this.scope.attr('mapper.term', el.val());
          this.element.find('mapper-results').control().getResults();
        }
      },

      allSelected: function () {
        var selected = this.scope.attr('mapper.selected');
        var entries = this.scope.attr('mapper.entries');

        if (!entries.length && !selected.length) {
          return;
        }
        this.scope.attr(
          'mapper.all_selected', selected.length === entries.length);
      },
      '{mapper.entries} length': 'allSelected',
      '{mapper.selected} length': 'allSelected'
    },

    helpers: {
      get_title: function (options) {
        var instance = this.attr('mapper.parentInstance');
        return (
          (instance && instance.title) ?
            instance.title :
            this.attr('mapper.object')
        );
      },
      get_object: function (options) {
        var type = CMS.Models[this.attr('mapper.type')];
        if (type && type.title_plural) {
          return type.title_plural;
        }
        return 'Objects';
      },
      loading_or_saving: function (options) {
        if (this.attr('mapper.page_loading') ||
          this.attr('mapper.is_saving') ||
          this.attr('mapper.block_type_change')) {
          return options.fn();
        }
        return options.inverse();
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('mapperResults', {
    tag: 'mapper-results',
    template: can.view(
      GGRC.mustache_path +
      '/components/unified_mapper/mapper_results.mustache'
    ),
    scope: {
      'items-per-page': '@',
      page: 0,
      page_loading: false,
      select_state: false,
      loading_or_saving: can.compute(function () {
        return this.attr('page_loading') || this.attr('mapper.is_saving');
      }),
      isRelevantToCurrent: function () {
        var relevant = this.attr('mapper.relevant');
        var instance = GGRC.page_instance();
        if (relevant.length !== 1) {
          return false;
        }
        relevant = relevant[0].filter;
        return relevant.id === instance.id &&
               relevant.type === instance.type;
      },
      unselectAll: function (scope, el, ev) {
        ev.preventDefault();

        this.attr('mapper.all_selected', false);
        this.attr('select_state', false);
        scope.attr('selected').replace([]);
        this.attr('selected', []);
      },
      selectAll: function (scope, el, ev) {
        var entries;
        var que;

        ev.preventDefault();

        if (el.hasClass('disabled')) {
          return;
        }

        que = new RefreshQueue();
        entries = this.attr('entries');

        this.attr('select_state', true);
        this.attr('mapper.all_selected', true);
        this.attr('is_loading', true);

        que.enqueue(_.pluck(entries, 'instance'))
          .trigger()
          .then(function (models) {
            this.attr('is_loading', false);
            this.attr('selected', _.map(models, function (model) {
              return {
                id: model.id,
                type: model.type,
                href: model.href
              };
            }));
          }.bind(this));
      }
    },
    events: {
      inserted: function () {
        this.scope.attr('entries', []);
        this.scope.attr('options', []);
        this.element.find('.results-wrap').cms_controllers_infinite_scroll();
      },
      '.modalSearchButton click': 'getResults',
      '{scope.entries} add': function (list, ev, added) {
        var instance;
        var option;

        // TODO: I'm assuming we are adding only one item manually
        if (!added[0].append) {
          return;
        }

        instance = added[0].instance;
        option = this.getItem(instance);

        option.appended = true;
        this.scope.attr('options').unshift(option);
        this.scope.attr('selected').push({
          id: instance.id,
          type: instance.type,
          href: instance.href
        });
        if (this.scope.attr('page') === 0) {
          // if the added item is the first one rendered, update the page
          // counter manually not to confuse drawPage method
          this.scope.attr('page', 1);
        }
      },
      '.results-wrap scrollNext': 'drawPage',
      getItem: function (model) {
        var selected;
        var mapper;
        var binding;
        var bindings;
        if (!model.type) {
          return undefined;
        }

        if (this.scope.attr('mapper.search_only')) {
          return {
            instance: model,
            selected_object: false,
            binding: {},
            mappings: []
          };
        }

        selected = this.scope.attr('mapper.parentInstance');
        mapper = this.scope.mapper.modelFromType(model.type);
        bindings = this.scope.attr('mapper.bindings');

        if (bindings[model.id]) {
          return _.extend(bindings[model.id], {
            selected_object: selected
          });
        }
        if (selected.has_binding(mapper.plural.toLowerCase())) {
          binding = selected.get_binding(mapper.plural.toLowerCase());
        }
        return {
          instance: model,
          selected_object: selected,
          binding: binding,
          mappings: []
        };
      },
      drawPage: function () {
        var page = this.scope.attr('page');
        var nextPage = page + 1;
        var perPage = Number(this.scope.attr('items-per-page'));
        var pageItems = this.scope.attr('entries').slice(
          page * perPage,
          nextPage * perPage
        );
        var options = this.scope.attr('options');
        var que = new RefreshQueue();

        if (this.scope.attr('mapper.page_loading') || !pageItems.length) {
          return undefined;
        }

        this.scope.attr('mapper.page_loading', true);

        return que.enqueue(
            _.pluck(pageItems, 'instance')
          ).trigger().then(
            function (models) {
              this.scope.attr('mapper.page_loading', false);
              this.scope.attr('page', nextPage);
              options.push.apply(
                options,
                can.map(models, this.getItem.bind(this))
              );
            }.bind(this)
          );
      },
      searchFor: function (data) {
        var joinModel;

        data.options = data.options || {};

        joinModel = GGRC.Mappings.join_model_name_for(
          this.scope.attr('mapper.object'), data.model_name);
        if (joinModel !== 'TaskGroupObject' && data.model_name === 'Program') {
          data.options.permission_parms = {
            __permission_model: joinModel
          };
        }

        if (!_.includes(['ObjectPerson', 'WorkflowPerson'], joinModel) &&
            !this.options.scope.attr('mapper.search_only')) {
          data.options.__permission_type =
            data.options.__permission_type || 'update';
        }
        data.model_name = _.isString(data.model_name) ?
          [data.model_name] :
          data.model_name;

        return GGRC.Models.Search.search_for_types(
          data.term || '', data.model_name, data.options);
      },

      getResults: function () {
        var contact = this.scope.attr('contact');
        var contactEmail = this.scope.attr('mapper.contactEmail');
        var filters;
        var list;
        var modelName = this.scope.attr('type');
        var params = {};
        var relevantList = this.scope.attr('mapper.relevant');
        var binding;
        var instance;
        var term = this.scope.attr('term');

        if (this.scope.attr('mapper.page_loading') ||
            this.scope.attr('mapper.is_saving')) {
          return;
        }
        this.scope.attr('page', 0);
        this.scope.attr('entries', []);
        this.scope.attr('selected', []);
        this.scope.attr('options', []);
        this.scope.attr('select_state', false);
        this.scope.attr('mapper.all_selected', false);

        if (this.scope.attr('mapper.assessmentGenerator') &&
            this.scope.isRelevantToCurrent() &&
            (!term || !contact)) {
          instance = GGRC.page_instance();
          binding = this.scope.mapper.getBindingName(
            instance,
            this.scope.attr('mapper.model.table_plural')
          );
          if (instance.has_binding(binding)) {
            this.scope.attr('mapper.page_loading', false);
            this.scope.attr('entries', instance.get_mapping(binding));
            this.drawPage();
            return undefined;
          }
        }

        filters = _.compact(_.map(relevantList, function (relevant) {
          if (!relevant.value || !relevant.filter) {
            return undefined;
          }
          return relevant.filter.type + ':' + relevant.filter.id;
        }));

        if (modelName === 'AllObject') {
          modelName = this.scope.attr('types.all_objects.models');
        }
        if (contact && contactEmail) {
          params.contact_id = contact.id;
        }

        // Filter by scope
        if (this.scope.attr('mapper.is_snapshotable')) {
          // We can also display it in UI as disabled filter
          filters.push({
            type: this.scope.attr('mapper.snapshot_scope_type'),
            id: this.scope.attr('mapper.snapshot_scope_id')
          });
        }

        if (!_.isEmpty(filters)) {
          params.relevant_objects = filters.join(',');
        }

        this.scope.attr('mapper.page_loading', true);

        list = new GGRC.ListLoaders.SearchListLoader(function (binding) {
          return this.searchFor({
            term: term,
            model_name: modelName,
            options: params
          }).then(function (mappings) {
            return mappings.entries;
          });
        }.bind(this)).attach({});

        list.refresh_stubs().then(function (options) {
          this.scope.attr('mapper.page_loading', false);
          this.scope.attr('entries', options);
          this.drawPage();
        }.bind(this));
      }
    },
    helpers: {
      inProgress: function (options) {
        if (this.attr('mapper.page_loading') || this.attr('mapper.is_saving')) {
          return options.fn();
        }
        return options.inverse();
      },
      allSelected: function (options) {
        if (this.attr('mapper.page_loading') ||
            this.attr('mapper.is_saving') ||
            this.attr('mapper.all_selected')) {
          return options.fn();
        }
        return options.inverse();
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('mapperCheckbox', {
    tag: 'mapper-checkbox',
    template: '<content />',
    scope: {
      instance: null,
      checkbox: can.compute(function (status) {
        if (this.attr('mapper.getList') && !this.attr('appended')) {
          return false;
        }
        return (
          this.attr('isMapped') ||
          this.attr('select_state') ||
          this.attr('appended')
        );
      }),
      define: {
        isMapped: {
          type: 'boolean',
          'default': false
        },
        allowedToMap: {
          type: 'boolean',
          'default': false
        }
      }
    },
    init: function () {
      var scope = this.scope;
      var parentInstance = scope.attr('mapper.parentInstance');
      var instance = scope.attr('instance');
      var isMapped = GGRC.Utils.is_mapped(parentInstance, instance);
      var hasPending = GGRC.Utils.hasPending(parentInstance, instance, 'add');

      if (isMapped || hasPending) {
        scope.attr('isMapped', true);
        scope.attr('checkbox', true);
      }
    },
    events: {
      '{scope} selected': function () {
        var checked = _.findWhere(this.scope.attr('selected'), {
          id: Number(this.scope.attr('instance').id)
        });
        // Avoid null and undefined
        if (!checked) {
          checked = false;
        }
        this.element
          .find('.object-check-single')
          .prop('checked', checked);
      },
      '.object-check-single change': function (el, ev) {
        var scope = this.scope;
        var instance = scope.attr('instance');
        var item = _.find(scope.attr('options'), function (option) {
          return option.instance.id === instance.id &&
                 option.instance.type === instance.type;
        });
        var status = el.prop('checked');
        var selected = this.scope.attr('selected');
        var needle = {id: item.instance.id, type: item.instance.type};
        var index;

        if (el.prop('disabled') || el.hasClass('disabled')) {
          return false;
        }

        if (!status) {
          index = _.findIndex(selected, needle);
          selected.splice(index, 1);
        } else if (!_.findWhere(selected, needle)) {
          selected.push({
            id: item.instance.id,
            type: item.instance.type,
            href: item.instance.href
          });
        }
      }
    },
    helpers: {
      not_allowed_to_map: function (options) {
        if (this.attr('mapper.getList')) {
          return options.inverse();
        }
        if (!this.attr('allowedToMap')) {
          return options.fn();
        }
        return options.inverse();
      },
      is_disabled: function (options) {
        if (this.attr('is_saving') ||
            this.attr('is_loading')) {
          return options.fn();
        }
        if (this.attr('mapper.getList')) {
          return options.inverse();
        }
        if (this.attr('isMapped') ||
            !this.attr('allowedToMap')) {
          return options.fn();
        }
        return options.inverse();
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  /*
    Below this line we're defining a few can.Components, which are in this file
    because they work similarly to the quick form controller (in fact, you should
    expect the quick form controller to be refactored into a component in the
    future) but they share no code with the quick form controller.

    the first component is quick add.  It is meant to have one or more form elements
    and a data-toggle="submit" link which will create a new join object between
    the parent instance and some selected option instance (likely picked through an
    autocomplete dropdown).

    Technically you can choose your instance however you want, as long as you find
    some way of getting its value into the component scope.  Extending this component
    with other methods to do that is fine.  You can also just pass it in when
    instantiating the component.
  */
  GGRC.Components('quickAdd', {
    tag: "ggrc-quick-add",
    // <content> in a component template will be replaced with whatever is contained
    //  within the component tag.  Since the views for the original uses of these components
    //  were already created with content, we just used <content> instead of making
    //  new view template files.
    template: "<content/>",
    scope: {
      parent_instance: null,
      source_mapping: null,
      join_model: "@",
      model: null,
      delay: "@",
      quick_create: "@",
      verify_event: "@",
      modal_description: "@",
      modal_title: "@",
      modal_button: "@",
      attributes: {},
      define: {
        deferred: {
          type: 'boolean',
          'default': false
        }
      },
      create_url: function () {
        var value = $.trim(this.element.find("input[type='text']").val());
        var dfd;

        // We are not validating the URL because application can locally we can
        // have URL's that are valid, but they wouldn't pass validation i.e.
        // - hi/there
        // - hi.something
        // - http://something.com etc
        // and thus we decided to validate just string existence
        if (!value || _.isEmpty(value)) {
          dfd = $.Deferred();
          dfd.reject({
            message: 'Please enter a URL'
          });
          return dfd.promise();
        }
        dfd = new CMS.Models.Document({
          link: value,
          title: value,
          context: this.scope.parent_instance.context || new CMS.Models.Context({
            id: null
          }),
          owners: [{type: "Person", id: GGRC.current_user.id}],
        });
        return dfd.save();
      }
    },
    events: {
      init: function () {
        this.scope.attr("controller", this);
      },
      // The inserted event fires when the component content is added to the DOM.
      //  At this time, live bound rendering should be resolved, which is not the
      //  case during init.
      inserted: function (el) {
        this.element.find("input:not([data-mapping], [data-lookup])").each(function(i, el) {
          this.scope.attributes.attr($(el).attr("name"), $(el).val());
        }.bind(this));
      },
      "a[data-toggle=submit]:not(.disabled) click": function (el, ev) {
        var scope = this.scope;
        var join_model_class;
        var join_object;
        var quick_create;
        var created_dfd;
        var verify_dfd = $.Deferred();

        if (scope.attr("verify_event")) {
          GGRC.Controllers.Modals.confirm({
            modal_description: scope.attr("modal_description"),
            modal_confirm: scope.attr("modal_button"),
            modal_title: scope.attr("modal_title"),
            button_view: GGRC.mustache_path + "/quick_form/confirm_buttons.mustache"
          }, verify_dfd.resolve);
        } else {
          verify_dfd.resolve();
        }

        verify_dfd.done(function () {
          if (this.scope.quick_create && this.scope.quick_create !== "@") {
            quick_create = this.scope[this.scope.quick_create].bind(this);
            if (quick_create) {
              created_dfd = quick_create();
              if (!this.scope.deferred) {
                created_dfd
                  .fail(function (error) {
                    $(document.body).trigger('ajax:flash', {
                      error: error.message
                    });
                  })
                  .done(function (data) {
                    this.scope.attr('instance', data);
                  }.bind(this));
              }
            }
          }
          if (!created_dfd) {
            created_dfd = $.Deferred().resolve();
          }

          if (created_dfd.state() === 'rejected') {
            created_dfd.fail(function (error) {
              $(document.body).trigger('ajax:flash', {
                error: error.message
              });
            });
            return;
          }

          if (this.scope.deferred) {
            created_dfd.done(function (instance) {
              this.scope.parent_instance
                .mark_for_addition('related_objects_as_source', instance);
              el.trigger('modal:success', instance);
            }.bind(this));
            return;
          }

          created_dfd.then(function() {
            if (this.scope.join_model && this.scope.join_model !== "@") {
              join_model_class = CMS.Models[this.scope.join_model] || CMS.ModelHelpers[this.scope.join_model];
              join_object = {};
              if (this.scope.join_model === "Relationship") {
                join_object["source"] = this.scope.parent_instance;
                join_object["destination"] = this.scope.instance;
              } else {
                join_object[this.scope.instance.constructor.table_singular] = this.scope.instance;
              }
              join_object = new join_model_class($.extend(
                join_object,
                {
                  context: this.scope.parent_instance.context
                              || new CMS.Models.Context({id : null}),
                },
                this.scope.attributes.serialize()
              ));
            } else {
              join_object = GGRC.Mappings.make_join_object(
                this.scope.parent_instance,
                this.scope.instance || this.scope.attributes.instance,
                $.extend({
                  context : this.scope.parent_instance.context
                            || new CMS.Models.Context({id : null})
                          },
                          this.scope.attributes.serialize())
              );
            }
            this.bindXHRToButton(
              join_object.save().done(function() {
                el.trigger("modal:success", join_object);
              }),
              el
              );
          }.bind(this));
        }.bind(this));
      },
      // this works like autocomplete_select on all modal forms and
      //  descendant class objects.
      autocomplete_select: function(el, event, ui) {
        var that = this;
        setTimeout(function() {
          that.scope.attr(el.attr("name"), ui.item);
        });
      },
      "input[null-if-empty] change" : function(el) {
        if (!el.val()) {
          this.scope.attributes.attr(el.attr("name"), null);
        }
      },
      "input:not([data-mapping], [data-lookup]) change" : function(el) {
        this.scope.attributes.attr(el.attr("name"), el.val());
      },
      ".ui-autocomplete-input modal:success" : function(el, ev, data, options) {
        var that = this,
          multi_map = data.multi_map,
          join_model_class,
          join_object;

        if(multi_map){
          var length = data.arr.length,
              my_data;

          if (length == 1){
            my_data = data.arr[0];

            GGRC.Mappings.make_join_object(
              this.scope.parent_instance,
              my_data,
              $.extend({
                context : this.scope.parent_instance.context
                        || new CMS.Models.Context({id : null})
                        },
                        this.scope.attributes.serialize())
            ).save().done(function() {
              that.element.find("a[data-toggle=submit]").trigger("modal:success");
            });
          }

          else{
            for(var i = 0; i < length-1; i++){
              my_data = data.arr[i];

              GGRC.Mappings.make_join_object(
                this.scope.parent_instance,
                my_data,
                $.extend({
                  context : this.scope.parent_instance.context
                          || new CMS.Models.Context({id : null})
                          },
                          this.scope.attributes.serialize())
              ).save().done(function(){});
            }
            my_data = data.arr[length-1];
            GGRC.Mappings.make_join_object(
              this.scope.parent_instance,
              my_data,
              $.extend({
                context : this.scope.parent_instance.context
                        || new CMS.Models.Context({id : null})
                        },
                        this.scope.attributes.serialize())
            ).save().done(function() {
              that.element.find("a[data-toggle=submit]").trigger("modal:success");
            });
          }
          //end multi-map
        } else {

          if (this.scope.join_model && this.scope.join_model !== "@") {
            join_model_class = CMS.Models[this.scope.join_model] || CMS.ModelHelpers[this.scope.join_model];
            join_object = new join_model_class(this.scope.attributes.serialize());
          } else {
            join_object = GGRC.Mappings.make_join_object(
              this.scope.parent_instance,
              data,
              $.extend({
                context : this.scope.parent_instance.context
                          || new CMS.Models.Context({id : null})
                        },
                        this.scope.attributes.serialize())
            );
          }
          join_object.save().done(function() {
             that.element.find("a[data-toggle=submit]").trigger("modal:success");
          });
        }
      }
    },
    helpers: {
      // Mapping-based autocomplete selectors use this helper to
      //  attach the mapping autocomplete ui widget.  These elements should
      //  be decorated with data-mapping attributes.
      mapping_autocomplete : function(options) {
        return function(el) {
          var $el = $(el);
          $el.ggrc_mapping_autocomplete({
            controller : options.contexts.attr("controller"),
            model : $el.data("model"),
            mapping : false
          });
        };
      }
    },
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  /*
    This component is for quickly updating the properties of an object through form fields.
    It works similar to GGRC.Controllers.QuickForm but has an extra feature: if the instance
    we're working with is a join object, and the option type is changed, it will work around
    the lack of support in proxy mappers for join objects being changed like that, and
    destroy the join object while creating a new one.

    Field updates trigger updates to the model automatically, even on the server.  This differs
    from the quick-add component above, in that it is not waiting for a submit trigger.
  */
  can.Component.extend({
    tag: "ggrc-quick-update",
    template: "<content/>",
    scope: {
      instance: null,
      source_mapping: null,
      model: null,
      attributes: {}
    },
    events: {
      init: function() {
        this.scope.attr("controller", this);
        this.scope.attr("model", this.scope.model || this.scope.instance.constructor);
        if(!this.scope.instance._transient) {
          //only refresh if there's not currently an edit modal spawned.
          this.scope.instance.refresh();
        }
      },
      //currently we don't support proxy object updates in mappings, so for now a change
      //  to a connected object (assuming we are operating on a proxy object) will trigger
      //  a deletion of the proxy object and creation of a new one.
      autocomplete_select : function(el, event, ui) {
        var that = this;
        setTimeout(function() {
          var serial = that.scope.instance.serialize();
          delete serial[el.attr("name")];
          delete serial[el.attr("name") + "_id"];
          delete serial[el.attr("name") + "_type"];
          delete serial.id;
          delete serial.href;
          delete serial.selfLink;
          delete serial.created_at;
          delete serial.updated_at;
          delete serial.provisional_id;
          serial[el.attr("name")] = ui.item.stub();
          that.scope.instance.destroy().then(function() {
            new that.scope.model(serial).save();
          });
        });
      },
      // null-if-empty attributes are a pattern carried over from GGRC.Controllers.Modals
      //  Useful for connected objects.
      "input[null-if-empty] change" : function(el) {
        if (!el.val()) {
          this.scope.instance.attr(el.attr("name"), null);
        }
      },
      // data-mapping is the element decoration that triggers an autocomplete based on a
      //  mapping to a parent instance.  The mapping_autocomplete helper defined below is
      //  generally for these.
      "input:not([data-mapping]), select change" : function(el) {
        var isCheckbox = el.is("[type=checkbox][multiple]");
        if (isCheckbox) {
          if(!this.scope.instance[el.attr("name")]) {
            this.scope.instance.attr(el.attr("name"), new can.List());
          }
          this.scope.instance
          .attr(el.attr("name"))
          .replace(
            can.map(
              this.element.find("input[name='" + el.attr("name") + "']:checked"),
              function(el) {
                return $(el).val();
              }
            )
          );
          this.element.find("input:checkbox").prop("disabled", true);
        } else {
          this.scope.instance.attr(el.attr("name"), el.val());
        }
        this.scope.instance.save().then(function () {
          if (isCheckbox) {
            this.element.find("input:checkbox").prop("disabled", false);
          }
        }.bind(this));
      },
    },
    helpers: {
      mapping_autocomplete : function(options) {
        return function(el) {
          $(el).ggrc_mapping_autocomplete({ controller : options.contexts.attr("controller") });
        };
      }
    },
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('assessmentTemplates', {
    tag: 'assessment-templates',
    template: can.view(
      GGRC.mustache_path +
      '/components/assessment_templates/assessment_templates.mustache'
    ),
    scope: {
      binding: '@',
      responses: [],
      instance: null,
      mapper: null,  // a shared object representing the mapper modal's state

      templates: function () {
        var result = {};
        var responses = this.attr('responses');
        var noValue = {
          title: 'No template',
          value: ''
        };
        _.each(responses, function (response) {
          var type;
          var instance;

          if (!response.instance) {
            return;
          }
          instance = response.instance;
          type = instance.template_object_type;
          if (!result[type]) {
            result[type] = {
              group: type,
              subitems: []
            };
          }
          result[type].subitems.push({
            title: instance.title,
            value: instance.id + '-' + type
          });
        });
        return [noValue].concat(_.toArray(result));
      },

      /**
       * Set the initial Assessment Template to be selected in the relevant
       * dropdown menu.
       *
       * By default, the first option from the first option group is selected,
       * unless such option does not exist, or if the mapper instance is not
       * given. In that case this method has no effect.
       *
       * @param {Array} templates - a list of possible options for the dropdown
       * @param {GGRC.Models.MapperModel} mapper - the shared object holding
       *   the state of the mapper modal
       */
      _selectInitialTemplate: function (templates, mapper) {
        var WARN_EMPTY_GROUP = [
          'GGRC.Components.assessmentTemplates: ',
          'An empty template group encountered, possible API error'
        ].join('');

        var initialTemplate;
        var nonDummyItem;

        if (!mapper) {
          return;
        }

        // The first element is a dummy option, thus if there are no other
        // elements, simply don't pick anything.
        if (templates.length < 2) {
          return;
        }

        nonDummyItem = templates[1];  // a single item or an object group

        if (!nonDummyItem.group) {  // a single item
          initialTemplate = nonDummyItem.value;
        } else {
          if (!nonDummyItem.subitems || nonDummyItem.subitems.length === 0) {
            console.warn(WARN_EMPTY_GROUP);
            return;  // an empty group, no option to pick from it
          }
          initialTemplate = nonDummyItem.subitems[0].value;
        }

        mapper.attr('assessmentTemplate', initialTemplate);
      }
    },
    init: function () {
      var scope = this.scope;
      var instance = scope.attr('instance');
      var binding = instance.get_binding(scope.attr('binding'));

      binding.refresh_instances().done(function (response) {
        scope.attr('responses', response);
        scope._selectInitialTemplate(scope.templates(), scope.mapper);
      });
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('wrapper-assessment-template', {
    tag: 'wrapper-assessment-template',
    template: '<content></content>',
    scope: {
      instance: null
    },
    events: {
      '{scope.instance} template_object_type': function () {
        this.scope.attr('instance.test_plan_procedure', false);
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('checkboxToList', {
    tag: 'checkbox-to-list',
    template: '<content></content>',
    scope: {
      property: '@',
      instance: null,
      values: {}
    },
    init: function () {
      var scope = this.scope;
      var values = scope.attr('instance.' + scope.attr('property'));

      if (values && _.isString(values)) {
        _.each(_.splitTrim(values, ','), function (val) {
          if (val) {
            scope.attr('values.' + val, true);
          }
        });
      }
    },
    events: {
      '{scope.values} change': function () {
        var scope = this.scope;
        var values = _.getExistingKeys(scope.attr('values').serialize());
        scope.instance.attr(scope.attr('property'), values.join(','));
      }
    }
  });
})(window.can, window.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, $) {
  'use strict';

  GGRC.Components('reminder', {
    tag: 'reminder',
    template: '<content/>',
    scope: {
      instance: null,
      type: '@',
      modal_title: '@',
      modal_description: '@',

      /**
       * Create reminder notifications for all assessors of an Assessment.
       *
       * @param {can.Map} scope - the component's scope
       * @param {jQuery.Object} $el - the DOM element that triggered the action
       * @param {jQuery.Event} ev - the event object
       */
      reminder: function (scope, $el, ev) {
        var instance = scope.instance;

        instance
          .refresh()
          .then(function () {
            instance.attr('reminderType', scope.type);
            return $.when(instance.save());
          })
          .then(function () {
            GGRC.Controllers.Modals.confirm({
              modal_title: scope.attr('modal_title'),
              modal_description: scope.attr('modal_description'),
              button_view:
                GGRC.mustache_path + '/modals/close_buttons.mustache'
            });
          });
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $, Quill) {
  'use strict';

  var formats = [
    'bold',
    'italic',
    'link',
    'underline',
    'list',
    'bullet',
    'strike'
  ];
  // We should Add Placeholder functionality
  GGRC.Components('richText', {
    tag: 'rich-text',
    template: can.view(
      GGRC.mustache_path +
      '/components/rich_text/rich_text.mustache'
    ),
    scope: {
      text: null,
      editor: null,
      placeholder: null,
      disabled: null,
      formats: formats,
      initEditor: function (wysiwyg, toolbar, text) {
        var editor = new Quill(wysiwyg, {
          theme: 'snow',
          formats: this.attr('formats'),
          modules: {
            'link-tooltip': true,
            toolbar: {
              container: toolbar
            }
          }
        });
        if (text) {
          editor.setHTML(text);
        }
        editor.on('text-change', this.onChange.bind(this));
        this.setEditor(editor);
      },
      onChange: function () {
        if (!this.getTextLength()) {
          // Should null text value if this is no content
          return this.attr('text', null);
        }
        return this.attr('text', this.getContent());
      },
      toggle: function (isDisabled) {
        var editor = this.getEditor().editor;
        var action = isDisabled ? 'disable' : 'enable';
        editor[action]();
      },
      setEditor: function (editor) {
        this.attr('editor', editor);
      },
      getEditor: function () {
        return this.attr('editor');
      },
      getTextLength: function () {
        return this.getText().trim().length;
      },
      /**
       * Returns only text content of the Rich Text
       * @return {String} - plain text value
       */
      getText: function () {
        return this.getEditor().getText();
      },
      /**
       * Returns the whole content of the Rich Text field with HTML content
       * @return {String} - current HTML String
       */
      getContent: function () {
        return this.getEditor().getHTML();
      }
    },
    events: {
      removed: function () {
        if (this.scope.getEditor()) {
          this.scope.getEditor().destroy();
        }
      },
      inserted: function () {
        var wysiwyg = this.element.find('.rich-text__content');
        var toolbar = this.element.find('.rich-text__toolbar');
        this.scope.initEditor(wysiwyg[0], toolbar[0], this.scope.attr('text'));
      },
      toogle: function (scope, ev, isDisabled) {
        if (!scope.getEditor()) {
          return this.destroy();
        }
        scope.toggle(isDisabled);
      },
      '{scope} disabled': 'toggle',
      // if text had been changed to nothing then clear
      '{scope} text': function (scope, ev, text) {
        if (!scope.getEditor()) {
          return this.destroy();
        }
        if (!text) {
          scope.getEditor().setHTML('');
        }
      }
    }
  });
})(window.can, window.can.$, window.Quill);

/*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  'use strict';

/**
   * A component that takes care of adding comments with attachments
   *
   */
  GGRC.Components('addComment', {
    tag: 'add-comment',
    template: can.view('/static/mustache/base_templates/add_comment.mustache'),
    scope: {
      attachments: new can.List(),
      parent_instance: null,
      instance: null,
      instance_attr: '@',
      source_mapping: null,
      source_mapping_source: '@',
      mapping: '@',
      deferred: '@',
      isSaving: false,  // is there a save operation currently in progress
      attributes: {},
      list: [],
      // the following are just for the case when we have no object to start with,
      changes: [],
      description: null,
      sendNotification: false,
      removePending: function (scope, el, ev) {
        var joins = this.instance._pending_joins;
        var model = scope.what;
        var index = _.findIndex(joins.serialize(), function (join) {
          return join.what.id === model.id &&
            join.what.type === model.type;
        });

        model.refresh().then(function () {
          model.destroy();
          joins.splice(index, 1);
        });
      },
      get_assignee_type: can.compute(function () {
        var types = new Map([
          ['related_verifiers', 'verifier'],
          ['related_assessors', 'assessor'],
          ['related_assignees', 'assignee'],
          ['related_requesters', 'requester'],
          ['related_creators', 'creator']
        ]);

        var instance = this.attr('parent_instance');
        var user = GGRC.current_user;
        var user_type;

        if (!instance || !user) {
          return;
        }
        types.forEach(function (type, mapping) {
          var mappings = instance.get_mapping(mapping);
          if (!mappings.length) {
            return;
          }
          if (_.filter(mappings, function (mapping) {
            return mapping.instance.id === user.id;
          }).length) {
            type = can.capitalize(type);
            user_type = user_type ? (user_type + ',' + type) : type;
          }
        });
        return user_type;
      })
    },
    events: {
      inserted: function () {
        if (!this.scope.attr('source_mapping')) {
          this.scope.attr('source_mapping', GGRC.page_instance());
        }
        this.scope.attr('sendNotification',
          this.scope.attr('parent_instance.send_by_default'));
        this.newInstance();
      },
      newInstance: function () {
        var instance = CMS.Models.Comment();
        instance.attr({
          _source_mapping: this.scope.attr('source_mapping'),
          context: this.scope.attr('parent_instance.context')
        });
        this.scope.attr('instance', instance);
      },
      cleanPanel: function () {
        this.scope.attachments.replace([]);
        this.scope.attr('description', null);
      },
      /**
       * The component's click event (happens when the user clicks add comment),
       * takes care of saving the comment with appended evidence.
       */
      '.btn-success click': function (el, ev) {
        var description = $.trim(this.scope.description);
        var attachments = this.scope.attachments;
        var source = this.scope.source_mapping;
        var instance = this.scope.instance;
        var data;

        if (!description.length && !attachments.length) {
          return;
        }
        data = {
          description: description,
          send_notification: this.scope.attr('sendNotification'),
          context: source.context,
          assignee_type: this.scope.attr('get_assignee_type')
        };

        this.scope.attr('isSaving', true);

        instance.attr(data).save()
          .then(function () {
            return instance.constructor.resolve_deferred_bindings(instance);
          })
          .then(function () {
            this.newInstance();
            this.cleanPanel();
          }.bind(this))
          .always(function () {
            this.scope.attr('isSaving', false);
          }.bind(this));
      }
    }
  });
})(window.GGRC, window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, $) {
  'use strict';

  GGRC.Components('objectCloner', {
    tag: 'object-cloner',
    template: '<content/>',
    scope: {
      instance: null,
      modalTitle: '@',
      modalDescription: '@',
      includeObjects: {},
      getIncluded: function () {
        var included = this.attr('includeObjects');
        return _.filter(can.Map.keys(included), function (val) {
          return included[val];
        });
      },
      cloneObject: function (scope, el, ev) {
        var instance = this.instance;
        this.attr('includeObjects', {});

        GGRC.Controllers.Modals.confirm({
          instance: scope,
          modal_title: scope.attr('modalTitle'),
          modal_description: scope.attr('modalDescription'),
          content_view: GGRC.mustache_path + '/' +
            instance.class.root_collection + '/object_cloner.mustache',
          modal_confirm: 'Clone',
          skip_refresh: true,
          button_view: GGRC.mustache_path + '/modals/prompt_buttons.mustache'
        }, function () {
          var clonedInstance = instance.clone({
            cloneOptions: {
              sourceObjectId: instance.id,
              mappedObjects: this.getIncluded()
            }
          });
          clonedInstance.save().done(function (object) {
            GGRC.navigate(object.viewLink);
          });
        }.bind(this));
      }
    }
  });
})(window.can, window.can.$);

/*!
   Copyright (C) 2016 Google Inc.
   Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $) {
  'use strict';

  /**
   *  Component for object counting. This component relies on backend to
   *  provide specified counter in GGRC.counts namespace for initial load
   *  and performs stub-only findAll query calls only on create/update/delete
   *  events for specific models.
   *
   *  Search values are strings so there's a translation table _getValue that
   *  translates string to value (e.g., 'current_user' gets resolved to
   *  GGRC.current_user.id) before making a GET request.
   *
   *  Search keys and search values lists should be of equal length and
   *  shouldn't be empty (unless that is expected as a query).
   *
   *  `updateCount` function is throttled because of a bug where if user
   *  starts multiple cycles manually `N` times, each subsequent start of a
   *  cycle triggers N events and could spam our server with 10 update requests
   *  if user started 10 cycles without refreshing the page in between.
   *
   *  @param {string} counter - Counter returned by backend in
   *    GGRC.counters.
   *  @param {string} ModelName - Name of a model to perform search on
   *  @param {string} searchKeys - a list semi-colon separated keys to use for
   *    searching
   *  @param {string} searchValues - a list of semi-colon separated values for
   *  corresponding keys that will be used for searching.
   *
   */
  GGRC.Components('ObjectCounter', {
    tag: 'object-counter',
    template: can.view(GGRC.mustache_path +
      '/components/object_counter/object_counter.mustache'),
    scope: {
      counter: '@',
      modelName: '@',
      searchKeys: '@',
      searchValues: '@',
      _getValue: {
        current_user: GGRC.current_user ? GGRC.current_user.id : -1,
        'true': true,
        'false': false
      },
      count: null,
      initialCount: function () {
        var counter = this.attr('counter');
        if (_.isUndefined(GGRC.counters[counter])) {
          throw new Error('Specified counter doesn\'t exist.');
        }
        this.attr('count', parseInt(GGRC.counters[counter], 10));
      },
      updateCount: _.throttle(function () {
        var searchData = {};
        var i;
        var key;
        var value;
        var data;

        var modelName = this.scope.attr('modelName');
        var keys = this.scope.attr('searchKeys').split(';');
        var values = this.scope.attr('searchValues').split(';');

        if (!GGRC.current_user || !GGRC.current_user.id) {
          return;
        }

        for (i = 0; i < keys.length; i++) {
          key = keys[i].trim();
          value = this.scope._getValue[values[i].trim()] || values[i];
          searchData[key] = value;
        }
        searchData.__stubs_only = true;

        data = CMS.Models[modelName].findAll(searchData);
        data.done(function (objectList) {
          this.scope.attr('count', objectList.length);
        }.bind(this));
      }, 10000) // See component documentation for explanation
    },
    init: function () {
      var updateEvents = ['created', 'updated', 'destroyed'];
      var model;
      var modelName = this.scope.attr('modelName');
      var keys = this.scope.attr('searchKeys').split(';');
      var values = this.scope.attr('searchValues').split(';');

      if (_.isUndefined(CMS.Models[modelName])) {
        throw new Error('Non-existing model');
      }

      if (keys.length !== values.length) {
        throw new Error('Search keys and values must be of equal length.');
      }

      model = CMS.Models[modelName];

      _.forEach(updateEvents, function (eventName) {
        model.bind(eventName, this.scope.updateCount.bind(this));
      }.bind(this));
    },
    events: {
      inserted: function () {
        this.scope.initialCount();
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  'use strict';

  GGRC.Components('tasksSortList', {
    tag: 'tasks-sort-list',
    scope: {
      sorted: null,
      mapping: null,
      next_sort_index: null
    },

    init: function () {
      var mapping = this.scope.attr('mapping');
      var getTaskDate = function (instance, type) {
        var date = new Date();
        var month = instance['relative_' + type + '_month'];
        var day = instance['relative_' + type + '_day'];

        if (instance[type + '_date']) {
          return instance[type + '_date'];
        }
        date.setHours(0, 0, 0, 0);
        date.setDate(day);
        if (month) {
          date.setMonth(month - 1);
        }
        return date;
      };
      var sort = function () {
        var arr = _.toArray(mapping);
        var last;
        var lastIndex;
        arr.sort(function (a, b) {
          var ad = getTaskDate(a.instance, 'start');
          var bd = getTaskDate(b.instance, 'start');
          var result = ad.getTime() - bd.getTime();

          if (!result) {
            ad = getTaskDate(a.instance, 'end');
            bd = getTaskDate(b.instance, 'end');
            result = ad - bd;
          }
          return result;
        });
        this.scope.attr('sorted', arr);
        last = arr[arr.length - 1];
        lastIndex = (last !== -Infinity && last) ?
            last.instance.sort_index :
            '0';
        this.scope.attr('next_sort_index',
            GGRC.Math.string_half(
                GGRC.Math.string_add(
                    Number.MAX_SAFE_INTEGER.toString(), lastIndex
                )
            )
        );
      }.bind(this);
      sort();
      mapping.bind('change', sort);
    },

    events: {
      ' sortupdate': function (el, ev, ui) {
        var mapping = this.scope.attr('mapping');
        var instanceIndex = _.indexBy(_.pluck(mapping, 'instance'), 'id');

        var instances = _.map(ui.item.parent().children('li'), function (el) {
          return instanceIndex[$(el).data('object-id')];
        });

        var targetIndex = _.findIndex(instances, {
          id: ui.item.data('object-id')
        });

        var nexts = []; // index for constant time next element lookup
        var dirty = []; // instances to be saved
        instances[targetIndex].attr('sort_index', null);
        nexts[instances.length] = Number.MAX_SAFE_INTEGER.toString();
        _.eachRight(instances, function (instance, index) {
          nexts[index] = instance.sort_index || nexts[index + 1];
        });

        // in most cases this will only update sort_index for targetIndex
        // but will also correctly resolve missing or duplicate sort_index-es
        _.each(instances, function (instance, index) {
          var prev;
          var next;
          if (instance.sort_index &&
              instance.sort_index !== nexts[index + 1]) {
            return;
          }
          prev = (instances[index - 1] || {sort_index: '0'}).sort_index;
          next = nexts[index + 1];
          instance.attr('sort_index', GGRC.Math.string_half(
                GGRC.Math.string_add(prev, next)
          ));
          dirty.push(instance);
        });

        _.each(dirty, function (instance) {
          var index = instance.sort_index;
          return instance.refresh().then(function (instance) {
            instance.attr('sort_index', index);
            instance.save();
          });
        });
      }
    }
  });
})(window.can, window.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

/**
 * A component that renders a tree pagination widget
 * Usage: <tree-pagination paging="paging"></tree-pagination>
 */
(function (GGRC, can) {
  GGRC.Components('treePagination', {
    tag: 'tree-pagination',
    template: can.view(
      GGRC.mustache_path +
      '/components/tree_pagination/tree_pagination.mustache'
    ),
    init: function () {
      /**
       * Entrance object validation
       *
       * paging = {
       *  current: {Number}, - current page number
       *  pageSize: {Number}, - amount elements on the page
       *  total: {Number}, - total amount of elements
       *  count: {Number}, - total amount of pages
       *  pageSizeSelect: {Array} - array of numbers that used for pageSize popover
       *  disabled: {Boolean} - true if frontend doesn't finish request to the server otherwise false
       * }
       */
      if (!this.scope.attr('paging')) {
        throw new Error('Paging object didn\'t init');
      }
    },
    scope: {
      /**
       * Gets value from input and after validation set it to paging.current
       * @param {Object} object - paging object
       * @param {Object} input - DOM element
       * @param {Object} event - DOM event
       */
      setCurrentPage: function (object, input, event) {
        var _value;
        var _page;
        event.stopPropagation();
        if (!this.paging.attr('disabled')) {
          _value = parseInt(input.val(), 10);
          _page = Math.min(Math.max(_value, 1) || 1, this.paging.count);

          this.paging.attr('current', _page);
        }
        input.val('');
        input.blur();
      },
      changePageSize: function (size) {
        if (!this.paging.attr('disabled')) {
          this.paging.attr('pageSize', size);
          this.paging.attr('current', 1);
        }
      },
      setLastPage: function () {
        if (this.paging.current < this.paging.count &&
          !this.paging.attr('disabled')) {
          this.paging.attr('current', this.paging.count);
        }
      },
      setFirstPage: function () {
        if (this.paging.current > 1 && !this.paging.attr('disabled')) {
          this.paging.attr('current', 1);
        }
      },
      setPrevPage: function () {
        if (this.paging.current > 1 && !this.paging.attr('disabled')) {
          this.paging.attr('current', this.paging.current - 1);
        }
      },
      setNextPage: function () {
        if (this.paging.current < this.paging.count &&
          !this.paging.attr('disabled')) {
          this.paging.attr('current', this.paging.current + 1);
        }
      }
    },
    helpers: {
      /**
       * @param {Number|String} current - current page number
       * @param {Number|String} count - total amount of pages
       * @return {string} pagination placeholder
       */
      paginationPlaceholder: function (current, count) {
        var _radix = 10;
        var _current = parseInt(Mustache.resolve(current), _radix);
        var _count = parseInt(Mustache.resolve(count), _radix);

        if (_count && _count >= _current) {
          return 'Page ' + _current + ' of ' + _count;
        } else if (!_count) {
          return '';
        }

        return 'Wrong value';
      },
      /**
       * @param {Number|String} current - current page number
       * @param {Number|String} size - amount elements on the page
       * @param {Number|String} total - total amount of elements
       * @return {string} - pagination info
       */
      paginationInfo: function (current, size, total) {
        var _radix = 10;
        var _first;
        var _last;
        var _current = parseInt(Mustache.resolve(current), _radix);
        var _size = parseInt(Mustache.resolve(size), _radix);
        var _total = parseInt(Mustache.resolve(total), _radix);

        _first = (_current - 1) * _size + 1;
        _last = _current * _size < _total ? _current * _size : _total;

        return _last ? _first + '-' + _last + ' of ' + _total + ' items' :
          'No records';
      }
    }
  });
})(window.GGRC, window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  'use strict';

  GGRC.Components('viewObjectButtons', {
    tag: 'view-object-buttons',
    template: can.view(
      GGRC.mustache_path +
      '/components/view-object-buttons/view-object-buttons.mustache'
    ),
    scope: {
      instance: null,
      openIsHidden: false,
      maximizeObject: function (scope, el, ev) {
        var tree = el.closest('.cms_controllers_tree_view_node');
        var node = tree.control();
        ev.preventDefault();
        ev.stopPropagation();
        if (node) {
          node.select(true);
        }
      }
    }
  });
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  'use strict';

  GGRC.Components('addObjectButton', {
    tag: 'add-object-button',
    template: can.view(
      GGRC.mustache_path +
      '/components/add-object-button/add-object-button.mustache'
    ),
    scope: {
      instance: null,
      linkclass: '@',
      content: '@',
      title: '@',
      singular: '@',
      plural: '@'
    }
  });
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, GGRC) {
  'use strict';

  GGRC.Components('effective-dates', {
    tag: 'effective-dates',
    template: can.view(
      GGRC.mustache_path +
      '/components/effective-dates/effective-dates.mustache'
    ),
    scope: {
      instance: null,
      configStartDate: {
        label: 'Effective Date',
        helpText: 'Enter the date this object becomes effective.',
        required: false
      },
      configEndDate: {
        label: 'Stop Date',
        helpText: 'Enter the date this object stops being effective.',
        required: false
      }
    }
  });
})(window.can, window.GGRC);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, $) {
  'use strict';

  GGRC.Components('SnapshotIndividualUpdater', {
    tag: 'snapshot-individual-update',
    template: '<content/>',
    scope: {
      instance: null,
      updateIt: function (scope, el, ev) {
        GGRC.Controllers.Modals.confirm({
          instance: scope,
          modal_title: 'Update to latest version',
          modal_description:
            'Do you want to update this ' +
            this.instance.class.title_singular +
            ' version of the Audit to the latest version?',
          modal_confirm: 'Update',
          skip_refresh: true,
          button_view: GGRC.mustache_path + '/modals/prompt_buttons.mustache'
        }, function () {
          var instance = this.instance.snapshot;
          instance.refresh().then(function () {
            instance.attr('update_revision', 'latest');
            return instance.save();
          }).then(function () {
            window.location.reload();
          });
        }.bind(this));
      }
    }
  });
})(window.can, window.can.$);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, $) {
  'use strict';

  GGRC.Components('SnapshotScopeUpdater', {
    tag: 'snapshot-scope-update',
    template: '<content/>',
    scope: {
      instance: null,
      upsertIt: function (scope, el, ev) {
        GGRC.Controllers.Modals.confirm({
          instance: scope.instance,
          modal_title: 'Update to latest version',
          modal_description:
            'Do you want to update all objects of this Audit' +
            ' to the latest version?',
          modal_confirm: 'Update',
          button_view: GGRC.Controllers.Modals.BUTTON_VIEW_OK_CLOSE,
          skip_refresh: true
        }, function () {
          var instance = this.instance;
          instance.refresh().then(function () {
            var data = {
              operation: 'upsert'
            };
            instance.attr('snapshots', data);
            return instance.save();
          }).then(function () {
            window.location.reload();
          });
        }.bind(this));
      }
    }
  });
})(window.can, window.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  'use strict';

  GGRC.Components('infoPinButtons', {
    tag: 'info-pin-buttons',
    template: can.view(
      GGRC.mustache_path +
      '/components/info-pin-buttons/info-pin-buttons.mustache'
    ),
    scope: {
      onChangeMaximizedState: null,
      onClose: null,
      define: {
        maximized: {
          type: 'boolean',
          'default': false
        }
      },
      toggleSize: function (scope, el, ev) {
        var maximized = !this.attr('maximized');
        ev.preventDefault();
        this.attr('maximized', maximized);
        this.onChangeMaximizedState(maximized);
      },
      close: function (scope, el, ev) {
        el.find('[rel=tooltip]').data('tooltip').hide();
        ev.preventDefault();
        this.onClose();
      }
    }
  });
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $) {
  /* Auditor Assignment Modal
  */
  GGRC.Controllers.Modals('GGRC.Controllers.AuditRoleSelector', {
    _templates: [
      'base_modal_view'
    ],

    defaults: {
      base_modal_view:
        GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/audit_modal.mustache',
      option_model: null,
      option_query: {},
      join_model: null,
      modal_title: null
    },

    launch: function ($trigger, options) {
      // Extract parameters from data attributes
      var href = $trigger.attr('data-href') || $trigger.attr('href');
      var modalClass = 'modal hide';
      var modalId =
        'ajax-modal-' + href.replace(/[\/\?=\&#%]/g, '-').replace(/^-/, '');
      var $target =
        $('<div id="' + modalId + '" class="' + modalClass + '"></div>');
      var scope = $trigger.attr('data-modal-scope') || null;

      options.scope = scope;
      options.$target = $target;
      $target.modal_form({}, $trigger);
      this.newInstance($target[0], $.extend({$trigger: $trigger}, options));

      return $target;
    }
  }, {
    init: function () {
      this.init_context();
      this.init_view();
    },

    init_context: function () {
      if (!this.context) {
        this.context = new can.Observe($.extend({
          page_model: GGRC.page_model

        }, this.options));
      }
      return this.context;
    },

    init_view: function () {
      var self = this;
      var deferred = $.Deferred();

      can.view(
        this.options.base_modal_view,
        this.context,
        function (frag) {
          $(self.element).html(frag);
          deferred.resolve();
          self.element.trigger('loaded');
        });

      // Start listening for events
      this.on();
      return deferred;
    },
    set_value: function () {},
    'input[data-lookup] change': function (el, ev) {
      // Clear the user
      if (el.val() == '') {
        this.options.instance.auditor = null;
      }
    },
    "a.btn[data-toggle='modal-submit'] click": function (el, ev) {
      var self = this;

      function finish() {
        CMS.Models[self.options.scope].cache[self.options.scope_id].refresh();
        self.element.trigger('modal:success').modal_form('hide');
      }
      this.saveAuditor(finish);
    }
  });

  /* Role Assignment Modal Selector
   *
   * parameters:
   *   Templates:
   *     base_modal_view:
   *     option_column_view:
   *     active_column_view:
   *     option_object_view:
   *     active_object_view:
   *     option_detail_view:
   *
   *   Models and Queries:
   *     option_model: The model being "selected" (the "many")
   *     option_query:
   *       Any additional parameters needed to restrict valid options
   *     active_query:
   *       Any additional parameters needed to restrict active options
   *     join_model: The model representing the join table
   *     extra_join_query:
   *       Any additional parameters needed to restrict the join results
   *     extra_join_params:
   *       And additional parameters to be POSTed in the join object
   *
   *   Customizable text components:
   *     modal_title:
   *     option_list_title:
   *     active_list_title:
   *     new_object_title:
   */
  can.Control('GGRC.Controllers.UserRolesModalSelector', {
    _templates: [
      'base_modal_view',
      'option_column_view',
      'active_column_view',
      'option_object_view',
      'active_object_view',
      'option_detail_view'
    ],

    defaults: {
      base_modal_view:
        GGRC.mustache_path + '/selectors/base_modal.mustache',
      option_column_view:
        GGRC.mustache_path + '/selectors/option_column.mustache',
      active_column_view:
        GGRC.mustache_path + '/selectors/active_column.mustache',
      option_object_view: null,
      active_object_view: null,
      option_detail_view:
        GGRC.mustache_path + '/selectors/option_detail.mustache',

      option_model: null,
      option_query: {},
      active_query: {},
      join_model: null,
      join_query: {},
      join_object: null,

      selected_id: null,

      modal_title: null,
      option_list_title: null,
      active_list_title: null,
      new_object_title: null
    },

    launch: function ($trigger, options) {
      // Extract parameters from data attributes
      var href = $trigger.attr('data-href') || $trigger.attr('href');
      var modalId =
        'ajax-modal-' + href.replace(/[\/\?=\&#%]/g, '-').replace(/^-/, '');
      var $target = $(
        '<div id="' + modalId + '" class="modal modal-selector hide"></div>'
      );
      var scope = $trigger.attr('data-modal-scope') || null;

      options.scope = scope;
      $target.modal_form({}, $trigger);
      this.newInstance($target[0], $.extend({$trigger: $trigger}, options));
      return $target;
    }
  }, {
    init: function () {
      this.object_list = new can.Observe.List();
      this.option_list = new can.Observe.List();
      this.join_list = new can.Observe.List();
      this.active_list = new can.Observe.List();

      this.init_context();
      this.init_bindings();
      this.init_view();
      this.init_data();
    },

    '.object_column li click': 'select_object',
    '.option_column li click': 'select_option',
    '.confirm-buttons a.btn:not(.disabled) click': 'change_option',

    init_bindings: function () {
      this.join_list.bind('change', this.proxy('update_active_list'));
      this.context.bind('selected_object', this.proxy('refresh_join_list'));
      this.option_list.bind('change', this.proxy('update_option_radios'));
    },

    init_view: function () {
      var self = this;
      var deferred = $.Deferred();

      can.view(
        this.options.base_modal_view,
        this.context,
        function (frag) {
          $(self.element).html(frag);
          deferred.resolve();
          self.element.trigger('loaded');
        });

      this.on();  // Start listening for events

      return deferred;
    },

    init_data: function () {
      return $.when(
        this.refresh_object_list(),
        this.refresh_option_list(),
        this.refresh_join_list()
      );
    },

    init_context: function () {
      if (!this.context) {
        this.context = new can.Observe($.extend({
          objects: this.object_list,
          options: this.option_list,
          joins: this.join_list,
          actives: this.active_list,
          selected_object: null,
          selected_option: null,
          page_model: GGRC.page_model
        }, this.options));
      }
      return this.context;
    },

    update_active_list: function () {
      var self = this;

      self.active_list.replace(
        can.map(self.join_list, function (join) {
          return new can.Observe({
            option: CMS.Models.get_instance(
              CMS.Models.get_link_type(join, self.options.option_attr),
              join[self.options.option_attr].id
            ),
            join: join
          });
        }));
    },

    refresh_object_list: function () {
      var self = this;

      return this.options.object_model.findAll(
        $.extend({}, this.options.object_query),
        function (objects) {
          self.object_list.replace(objects);
          if (self.object_list.length === 1) {
            self.context.attr('selected_object', self.object_list[0]);
          }
        });
    },

    refresh_option_list: function () {
      var self = this;
      var instance = GGRC.page_instance();
      var params = {};

      // If this is a private model, set the scope
      if (self.options.scope) {
        params.scope = self.options.scope;
      } else if (
        instance &&
        instance.constructor.shortName === 'Workflow' &&
        instance.context
      ) {
        params.scope = 'Workflow';
      } else if (
        instance &&
        instance.constructor.shortName === 'Program' &&
        instance.context
      ) {
        params.scope = 'Private Program';
      } else if (/admin/.test(window.location)) {
        params.scope__in = 'System,Admin';
      } else if (instance) {
        params.scope = instance.constructor.shortName;
      }

      return this.options.option_model.findAll(
        $.extend(params, this.option_query),
        function (options) {
          var description;

          options = can.makeArray(_.sortBy(options, 'role_order'));

          if (params.scope === 'Private Program') {
            description =
              'A person with no role will not be able to see the program, ' +
              'unless they have a system wide role (Reader, Editor, Admin) ' +
              'that allows it.';
          } else if (params.scope === 'Workflow') {
            description =
              'A person with the No Role role will not be able to update ' +
              'or contribute to this Workflow.';
          } else {
            description =
              'This role allows a user access to the MyWork dashboard and ' +
              'applications Help files.';
          }
          options.unshift({
            name: 'No role',
            id: 0,
            description: description,
            scope: params.scope || 'System'
          });
          self.option_list.replace(options);
        });
    },

    refresh_join_list: function () {
      var self = this;
      var joinObject = this.get_join_object();
      var joinQuery;

      if (joinObject) {
        joinQuery = can.extend({}, this.options.extra_join_query);
        joinQuery[this.options.join_id_field] = this.get_join_object_id();
        if (this.options.join_type_field) {
          joinQuery[this.options.join_type_field] =
            this.get_join_object_type();
        }

        return this.options.join_model.findAll(
          $.extend({}, joinQuery),
          function (joins) {
            self.join_list.replace(joins);
            self.update_option_radios();
          });
      }

      return $.Deferred().resolve();
    },

    update_option_radios: function () {
      var allowedIds = can.map(this.context.options, function (join) {
        return join.id;
      });
      if (!allowedIds.length) {
        return;
      }
      if (!this.join_list.length) {
        this.context.attr('selected_id', 0);
      }
      this.join_list.forEach(function (join) {
        var id = join[this.options.option_attr].id;
        if (allowedIds.indexOf(id) >= 0) {
          this.context.attr('selected_id', id);
        }
      }.bind(this));
    },

    select_object: function (el) {
      el.closest('.object_column').find('li').removeClass('selected');
      el.addClass('selected');
      this.context.attr('selected_object', el.data('object'));
    },

    select_option: function (el) {
      el.closest('.option_column').find('li').removeClass('selected');
      el.addClass('selected');
      this.context.attr('selected_option', el.data('option'));
    },

    change_option: function (el_, ev) {
      var self = this;
      var el = $('.people-selector').find('input[type=radio]:checked');
      var li = el.closest('li');
      var clickedOption = li.data('option') || {};
      var join;
      var deleteDfds;
      var alreadyExists = false;

      // Look for and remove the existing join.
      deleteDfds = $.map(li.parent().children(), function (el) {
        var $el = $(el);
        var option = $el.closest('li').data('option');
        var join = self.find_join(option.id);

        if (join && join.role.id === clickedOption.id) {
          // Don't delete the role we marked to add.
          alreadyExists = true;
          return;
        }
        if (join) {
          return join.refresh().then(function () {
            return join.destroy();
          }).then(function () {
            self.refresh_object_list();
            self.element.trigger('relationshipdestroyed', join);
          });
        }
      });

      // Create the new join (skipping "No Role" role, with id == 0)
      if (clickedOption.id > 0 && !alreadyExists) {
        $.when.apply($, deleteDfds).then(function () {
          join = self.get_new_join(
            clickedOption.id,
            clickedOption.scope,
            clickedOption.constructor.shortName
          );
          join.save().then(function () {
            self.join_list.push(join);
            self.refresh_option_list();
            self.refresh_object_list();
            self.element.trigger('relationshipcreated', join);
          });
        });
      } else {
        $.when.apply($, deleteDfds).then(function () {
          $('body').trigger('treeupdate');
        });
      }
    },

    // HELPERS

    find_join: function (optionId) {
      var self = this
        ;

      return can.reduce(
        this.join_list,
        function (result, join) {
          if (result) {
            return result;
          }
          if (self.match_join(optionId, join)) {
            return join;
          }
        },
        null
      );
    },

    match_join: function (optionId, join) {
      return (
        join[this.options.option_attr] &&
        join[this.options.option_attr].id == optionId
      );
    },

    get_new_join: function (optionId, optionScope, optionType) {
      var joinParams = {};
      joinParams[this.options.option_attr] = {};
      joinParams[this.options.option_attr].id = optionId;
      joinParams[this.options.option_attr].type = optionType;
      joinParams[this.options.join_attr] = {};
      joinParams[this.options.join_attr].id = this.get_join_object_id();
      joinParams[this.options.join_attr].type = this.get_join_object_type();

      $.extend(joinParams, this.options.extra_join_fields);
      if (optionScope === 'Admin') {
        joinParams.context = {id: 0, type: 'Context'};
      }
      return new (this.options.join_model)(joinParams);
    },

    get_join_object: function () {
      return this.context.attr('selected_object');
    },

    get_join_object_id: function () {
      return this.get_join_object().id;
    },

    get_join_object_type: function () {
      var joinObject = this.get_join_object();
      return (joinObject ? joinObject.constructor.shortName : null);
    }
  });

  function getOptionSet(name, data) {
    // Construct options for Authorizations selector
    var context;
    var objectQuery = {};
    var baseModalView;
    var extraJoinQuery;

    // Set object-specific context if requested (for Audits)
    if (data.params && data.params.context) {
      context = data.params.context;
      extraJoinQuery = {context_id: context.id};
    } else if (GGRC.page_object && !GGRC.page_object.person) {
      // Otherwise use the page context
      context = GGRC.make_model_instance(GGRC.page_object).context;
      if (!context) {
        throw new Error('`context` is required for Assignments model');
      }
      context = context.stub();
      extraJoinQuery = {context_id: context.id};
    } else {
      context = {id: null};
      extraJoinQuery = {context_id__in: [context.id, 0]};
    }

    if (data.person_id) {
      objectQuery = {id: data.person_id};
    }

    if (data.base_modal === 'auditor') {
      baseModalView =
          '/ggrc_basic_permissions/people_roles/audit_modal.mustache';
    } else {
      baseModalView =
          '/ggrc_basic_permissions/people_roles/base_modal.mustache';
    }

    return {
      base_modal_view: GGRC.mustache_path + baseModalView,
      option_column_view:
        GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/option_column.mustache',
      option_detail_view:
        GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/option_detail.mustache',
      active_column_view:
        GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/active_column.mustache',

      object_column_view:
        GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/object_column.mustache',
      object_detail_view:
        GGRC.mustache_path +
        '/ggrc_basic_permissions/people_roles/object_detail.mustache',

      new_object_title: 'Person',
      modal_title: data.modal_title || 'User Role Assignments',

      related_model_singular: 'Person',
      related_table_plural: 'people',
      related_title_singular: 'Person',
      related_title_plural: 'People',

      object_model: CMS.Models.Person,
      option_model: CMS.Models.Role,
      join_model: CMS.Models.UserRole,

      object_query: objectQuery,

      // join_object_attr
      option_attr: 'role',
      // join_option_attr
      join_attr: 'person',
      // join_option_id_field
      option_id_field: 'role_id',
      option_type_field: null,
      // join_object_id_field
      join_id_field: 'person_id',
      join_type_field: null,

      extra_join_fields: {
        context: context
      },
      extra_join_query: extraJoinQuery
    };
  }

  $(function () {
    $('body').on(
      'click',
      '[data-toggle="user-roles-modal-selector"]',
      function (ev) {
        var $this = $(this);
        var options = $this.data('modal-selector-options');
        var dataSet = can.extend({}, $this.data());
        var objectParams = $this.attr('data-object-params');

        dataSet.params = objectParams && JSON.parse(
          objectParams.replace(/\\n/g, '\\n')
        );

        can.each($this.data(), function (v, k) {
          //  This is just a mapping of keys to underscored keys
          var newKey = k.replace(
              /[A-Z]/g,
              function (str) {
                return '_' + str.toLowerCase();
              }
          );

          dataSet[newKey] = v;
          //  If we changed the key at all, delete the original
          if (newKey !== k) {
            delete dataSet[k];
          }
        });

        if (typeof options === 'string') {
          options = getOptionSet(options, dataSet);
        }

        ev.preventDefault();
        ev.stopPropagation();

        // Trigger the controller
        GGRC.Controllers.UserRolesModalSelector.launch($this, options)
          .on('relationshipcreated relationshipdestroyed', function (ev, data) {
            // $this.trigger("modal:" + ev.type, data);
          });
      });

    $('body').on(
      'click',
      '[data-toggle="audit-role-modal-selector"]',
      function (ev) {
        var $this = $(this);
        var options = $this.data('modal-selector-options');
        var instanceId = $this.data('object-id');
        var dataSet = can.extend({}, $this.data());
        var objectParams = $this.attr('data-object-params');
        var scope = $this.data('modal-scope');

        dataSet.params = objectParams && JSON.parse(
          objectParams.replace(/\\n/g, '\\n')
        );

        can.each($this.data(), function (v, k) {
          //  This is just a mapping of keys to underscored keys
          var newKey = k.replace(
              /[A-Z]/g,
              function (str) {
                return '_' + str.toLowerCase();
              }
          );

          dataSet[newKey] = v;
          //  If we changed the key at all, delete the original
          if (newKey !== k) {
            delete dataSet[k];
          }
        });

        if (typeof options === 'string') {
          options = getOptionSet(options, dataSet);
        }

        ev.preventDefault();
        ev.stopPropagation();

        options.instance = CMS.Models[scope].cache[instanceId];
        options.userRole_id = dataSet.params.userRole_id;
        options.scope_id = dataSet.params.scope_id;
        GGRC.Controllers.AuditRoleSelector.launch($this, options)
          .on('modal:success', function (ev, data) {
            $this.trigger('modal:' + ev.type, data);
          });
      });
  });
})(window.can, window.can.$);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

/*
 */

(function (can) {
  var path = GGRC.mustache_path + "/risk_assessments";

  can.Model.Cacheable("CMS.Models.RiskAssessment", {
    root_object: "risk_assessment",
    root_collection: "risk_assessments",
    category: "risk_assessment",
    mixins: ['ca_update', 'timeboxed'],
    findAll: "GET /api/risk_assessments",
    findOne: "GET /api/risk_assessments/{id}",
    create: "POST /api/risk_assessments",
    update: "PUT /api/risk_assessments/{id}",
    destroy: "DELETE /api/risk_assessments/{id}",
    is_custom_attributable: true,
    attributes: {
      ra_manager: "CMS.Models.Person.stub",
      ra_counsel: "CMS.Models.Person.stub",
      context: "CMS.Models.Context.stub",
      documents: "CMS.Models.Document.stubs",
      program: "CMS.Models.Program.stub",
      modified_by: "CMS.Models.Person.stub",
      object_documents: "CMS.Models.ObjectDocument.stubs",
      custom_attribute_values : "CMS.Models.CustomAttributeValue.stubs"
    },
    tree_view_options: {
      attr_list: [
        {attr_title: 'Title', attr_name: 'title'},
        {attr_title: 'Code', attr_name: 'slug'},
        {attr_title: 'Effective Date', attr_name: 'start_date'},
        {attr_title: 'Stop Date', attr_name: 'end_date'},
        {
          attr_title: 'Risk Manager',
          attr_name: 'ra_manager',
          attr_sort_field: 'ra_manager.name|email'
        },
        {
          attr_title: 'Risk Counsel',
          attr_name: 'ra_counsel',
          attr_sort_field: 'ra_counsel.name|email'
        }
      ],
      add_item_view: path + '/tree_add_item.mustache',
      child_options: [{
        model: can.Model.Cacheable,
        mapping: 'related_objects',
        show_view: path + '/tree.mustache',
        draw_children: true
      }]
    },
    init: function () {
      this._super && this._super.apply(this, arguments);
      this.validateNonBlank("title");
      this.validateNonBlank("start_date");
      this.validateNonBlank("end_date");
    }
  }, {
    save: function () {
      // Make sure the context is always set to the parent program
      if (!this.context || !this.context.id) {
        this.attr('context', this.program.reify().context);
      }
      return this._super.apply(this, arguments);
    }
  });

})(window.can);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function ($, CMS, GGRC) {
  var RiskAssessmentsExtension = {};
  var _risk_assessments_object_types = ['Program'];
  GGRC.extensions.push(RiskAssessmentsExtension);

  RiskAssessmentsExtension.name = 'risk_assessments';

  // Register RA models for use with `infer_object_type`
  RiskAssessmentsExtension.object_type_decision_tree = function () {
    return {
      risk_assessment: CMS.Models.RiskAssessment
    };
  };

  CMS.Models.Program.attributes.risk_assessments = 'CMS.Models.RiskAssessment.stubs';

  // Configure mapping extensions for ggrc_risk_assessments
  RiskAssessmentsExtension.init_mappings = function () {
    var Proxy = GGRC.MapperHelpers.Proxy;
    var Direct = GGRC.MapperHelpers.Direct;
    var Multi = GGRC.MapperHelpers.Multi;
    var TypeFilter = GGRC.MapperHelpers.TypeFilter;

    var mappings = {
      Program: {
        _canonical: {
          risk_assessments: 'RiskAssessment'
        },
        risk_assessments: Direct('RiskAssessment',
          'program', 'risk_assessments')
      },
      RiskAssessment: {
        related_objects_as_source: Proxy(
          null,
          'destination', 'Relationship',
          'source', 'related_destinations'
        ),
        related_objects_as_destination: Proxy(
          null,
          'source', 'Relationship',
          'destination', 'related_sources'
        ),
        related_objects: Multi(
          ['related_objects_as_source', 'related_objects_as_destination']
        ),
        destinations: Direct('Relationship', 'source', 'related_destinations'),
        sources: Direct('Relationship', 'destination', 'related_sources'),
        documents: Proxy('Document', 'document',
          'ObjectDocument', 'documentable', 'object_documents'),
        cycle_task_group_object_tasks: TypeFilter('related_objects',
          'CycleTaskGroupObjectTask')
      }
    };
    new GGRC.Mappings('ggrc_risk_assessments', mappings);
  };

  // Override GGRC.extra_widget_descriptors and GGRC.extra_default_widgets
  // Initialize widgets for risk assessment page
  RiskAssessmentsExtension.init_widgets = function init_widgets() {
    var descriptor = {};
    var page_instance = GGRC.page_instance();
    var tree_widgets = GGRC.tree_view.base_widgets_by_type;
    var treeViewDepth = 2;
    var relatedObjectsOptions = [GGRC.Utils.getRelatedObjects(treeViewDepth)];

    _.each(_risk_assessments_object_types, function (type) {
      if (!type || !tree_widgets[type]) {
        return;
      }
      tree_widgets[type] = tree_widgets[type].concat(["RiskAssessment"]);
    });
    if (page_instance && ~can.inArray(page_instance.constructor.shortName, _risk_assessments_object_types)) {
      descriptor[page_instance.constructor.shortName] = {
        risk_assessments: {
          widget_id: 'risk_assessments',
          widget_name: 'Risk Assessments',
          content_controller: GGRC.Controllers.TreeView,
          content_controller_options: {
            add_item_view: GGRC.mustache_path +
              '/risk_assessments/tree_add_item.mustache',
            mapping: 'risk_assessments',
            parent_instance: page_instance,
            model: CMS.Models.RiskAssessment,
            show_view: GGRC.mustache_path + '/risk_assessments/tree.mustache',
            draw_children: true,
            allow_mapping: false,
            child_options: relatedObjectsOptions
          }
        }
      };
    }
    new GGRC.WidgetList('ggrc_risk_assessments', descriptor);
  };

  RiskAssessmentsExtension.init_mappings();
})(this.can.$, this.CMS, this.GGRC);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */


/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */


(function ($, CMS, GGRC) {
  var RisksExtension = {};

  // Insert risk mappings to all gov/business object types
  var _risk_object_types = [
      "Program", "Regulation", "Standard", "Policy", "Contract",
      "Objective", "Control", "Section", "Clause", "System", "Process",
      "DataAsset", "Facility", "Market", "Product", "Project",
      "MultitypeSearch", "Issue", "Assessment", "AccessGroup", "Request",
      "Person", "OrgGroup", "Vendor"
    ],
    related_object_descriptors = {},
    threat_descriptor, risk_descriptor;

  // Register `risks` extension with GGRC
  GGRC.extensions.push(RisksExtension);

  RisksExtension.name = "risks";

  // Register Risk Assessment models for use with `infer_object_type`
  RisksExtension.object_type_decision_tree = function () {
    return {
      "risk": CMS.Models.Risk,
      "threat": CMS.Models.Threat
    };
  };

  // Configure mapping extensions for ggrc_risks
  RisksExtension.init_mappings = function init_mappings() {
    var Proxy = GGRC.MapperHelpers.Proxy,
      Direct = GGRC.MapperHelpers.Direct,
      Cross = GGRC.MapperHelpers.Cross,
      CustomFilter = GGRC.MapperHelpers.CustomFilter,
      Reify = GGRC.MapperHelpers.Reify,
      Search = GGRC.MapperHelpers.Search,
      TypeFilter = GGRC.MapperHelpers.TypeFilter,
      Multi = GGRC.MapperHelpers.Multi,
      Indirect = GGRC.MapperHelpers.Indirect;

    // Add mappings for risk objects
    var mappings = {

      related: {
        related_objects_as_source: Proxy(
          null, "destination", "Relationship", "source", "related_destinations"),
        related_objects_as_destination: Proxy(
          null, "source", "Relationship", "destination", "related_sources"),
        related_objects: Multi(["related_objects_as_source", "related_objects_as_destination"]),
      },
      related_objects: {
        _canonical: {
          "related_objects_as_source": _risk_object_types,
        },
        related_programs: TypeFilter("related_objects", "Program"),
        related_data_assets: TypeFilter("related_objects", "DataAsset"),
        related_access_groups: TypeFilter("related_objects", "AccessGroup"),
        related_facilities: TypeFilter("related_objects", "Facility"),
        related_markets: TypeFilter("related_objects", "Market"),
        related_processes: TypeFilter("related_objects", "Process"),
        related_products: TypeFilter("related_objects", "Product"),
        related_projects: TypeFilter("related_objects", "Project"),
        related_systems: TypeFilter("related_objects", "System"),
        related_controls: TypeFilter("related_objects", "Control"),
        related_clauses: TypeFilter("related_objects", "Clause"),
        related_sections: TypeFilter("related_objects", "Section"),
        related_regulations: TypeFilter("related_objects", "Regulation"),
        related_contracts: TypeFilter("related_objects", "Contract"),
        related_policies: TypeFilter("related_objects", "Policy"),
        related_standards: TypeFilter("related_objects", "Standard"),
        related_objectives: TypeFilter("related_objects", "Objective"),
        related_issues: TypeFilter("related_objects", "Issue"),
        related_assessments: TypeFilter("related_objects", "Assessment"),
        related_requests: TypeFilter("related_objects", "Request"),
        related_people: TypeFilter("related_objects", "Person"),
        related_org_groups: TypeFilter("related_objects", "OrgGroup"),
        related_vendors: TypeFilter("related_objects", "Vendor")

      },
      related_risk: {
        _canonical: {
          "related_objects_as_source": ['Risk'].concat(_risk_object_types)
        },
        related_risks: TypeFilter("related_objects", "Risk")
      },
      related_threat: {
        _canonical: {
          "related_objects_as_source": ['Threat'].concat(_risk_object_types)
        },
        related_threats: TypeFilter("related_objects", "Threat")
      },
      ownable: {
        owners: Proxy(
          "Person", "person", "ObjectOwner", "ownable", "object_owners")
      },
      Risk: {
        _mixins: ['related', 'related_objects', 'related_threat', 'ownable'],
        orphaned_objects: Multi([])
      },
      Threat: {
        _mixins: ['related', 'related_objects', 'related_risk', 'ownable'],
        orphaned_objects: Multi([])
      },
      Person: {
        owned_risks: TypeFilter('related_objects_via_search', 'Risk'),
        owned_threats: TypeFilter('related_objects_via_search', 'Threat'),
        all_risks: Search(function (binding) {
          return CMS.Models.Risk.findAll({});
        }),
        all_threats: Search(function (binding) {
          return CMS.Models.Threat.findAll({});
        })
      }
    };

    // patch Person to extend query for dashboard
    GGRC.Mappings.modules.ggrc_core
      .Person.related_objects_via_search
      .observe_types.push("Risk", "Threat");

    can.each(_risk_object_types, function (type) {
        mappings[type] = _.extend(mappings[type] || {}, {
          _canonical: {
            "related_objects_as_source": ["Risk", "Threat"]
          },
          _mixins: ["related", "related_risk", "related_threat"],
        });
    });
    new GGRC.Mappings("ggrc_risks", mappings);
  };

  // Override GGRC.extra_widget_descriptors and GGRC.extra_default_widgets
  // Initialize widgets for risk page
  RisksExtension.init_widgets = function init_widgets() {
    var treeViewDepth = 2;
    var relatedObjectsChildOptions = [GGRC.Utils.getRelatedObjects(treeViewDepth)];
    var page_instance = GGRC.page_instance();
    var is_my_work = function () {
      return page_instance && page_instance.type === 'Person';
    };

    var related_or_owned = is_my_work() ? 'owned_' : 'related_';
    var sorted_widget_types = _.sortBy(_risk_object_types, function (type) {
      var model = CMS.Models[type] || {};
      return model.title_plural || type;
    });
    var baseWidgetsByType = GGRC.tree_view.base_widgets_by_type;
    var moduleObjectNames = ['Risk', 'Threat'];
    var extendedModuleTypes = _risk_object_types.concat(moduleObjectNames);
    var subTrees = GGRC.tree_view.sub_tree_for;

    if (/^\/objectBrowser\/?$/.test(window.location.pathname)) {
      related_or_owned = 'all_';
    }
    // Init widget descriptors:
    can.each(sorted_widget_types, function (model_name) {
      var model;

      if (model_name === "MultitypeSearch" || !baseWidgetsByType[model_name]) {
        return;
      }
      model = CMS.Models[model_name];

      // First we add Risk and Threat to other object's maps
      baseWidgetsByType[model_name] = baseWidgetsByType[model_name].concat(
        moduleObjectNames);

      related_object_descriptors[model_name] = {
        content_controller: CMS.Controllers.TreeView,
        content_controller_selector: "ul",
        widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
        widget_id: model.table_singular,
        widget_name: model.model_plural,
        widget_icon: model.table_singular,
        content_controller_options: {
          add_item_view: GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
          child_options: relatedObjectsChildOptions,
          draw_children: true,
          parent_instance: page_instance,
          model: model,
          mapping: "related_" + model.table_plural
        }
      };
    });

    // Add risk and Threat to base widget types and set up
    // tree_view.basic_model_list and tree_view.sub_tree_for for risk module
    // objects
    can.each(moduleObjectNames, function (name) {
      baseWidgetsByType[name] = extendedModuleTypes;

      var widgetList = baseWidgetsByType[name];
      var child_model_list = [];

      GGRC.tree_view.basic_model_list.push({
        model_name: name,
        display_name: CMS.Models[name].title_singular
      });

      can.each(widgetList, function (item) {
        if (extendedModuleTypes.indexOf(item) !== -1) {
          child_model_list.push({
            model_name: item,
            display_name: CMS.Models[item].title_singular
          });
        }
      });

      if (!_.isEmpty(subTrees.serialize())) {
        subTrees.attr(name, {
          model_list: child_model_list,
          display_list: CMS.Models[name].tree_view_options.child_tree_display_list || widgetList
        });
      }
    });

    threat_descriptor = {
      content_controller: CMS.Controllers.TreeView,
      content_controller_selector: "ul",
      widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
      widget_id: CMS.Models.Threat.table_singular,
      widget_name: CMS.Models.Threat.title_plural,
      widget_icon: CMS.Models.Threat.table_singular,
      order: 275,
      content_controller_options: {
        child_options: relatedObjectsChildOptions,
        draw_children: true,
        parent_instance: page_instance,
        model: CMS.Models.Threat,
        mapping: related_or_owned + CMS.Models.Threat.table_plural,
        footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache'
      }
    };
    risk_descriptor = {
      content_controller: CMS.Controllers.TreeView,
      content_controller_selector: "ul",
      widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
      widget_id: CMS.Models.Risk.table_singular,
      widget_name: CMS.Models.Risk.title_plural,
      widget_icon: CMS.Models.Risk.table_singular,
      order: 265,
      content_controller_options: {
        child_options: relatedObjectsChildOptions,
        draw_children: true,
        parent_instance: page_instance,
        model: CMS.Models.Risk,
        mapping: related_or_owned + CMS.Models.Risk.table_plural,
        footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache'
      }
    };

    if (page_instance instanceof CMS.Models.Risk) {
      RisksExtension.init_widgets_for_risk_page();
    } else if (page_instance instanceof CMS.Models.Threat) {
      RisksExtension.init_widgets_for_threat_page();
    } else if (page_instance instanceof CMS.Models.Person) {
      RisksExtension.init_widgets_for_person_page();
    } else {
      RisksExtension.init_widgets_for_other_pages();
    }
  };

  RisksExtension.init_widgets_for_risk_page =
    function init_widgets_for_risk_page() {
      var risk_descriptors = $.extend({},
        related_object_descriptors, {
          Threat: threat_descriptor
        }
      );
      new GGRC.WidgetList("ggrc_risks", {
        Risk: risk_descriptors
      });
  };

  RisksExtension.init_widgets_for_threat_page =
    function init_widgets_for_threat_page() {
      var threat_descriptors = $.extend({},
        related_object_descriptors, {
          Risk: risk_descriptor
        }
      );
      new GGRC.WidgetList("ggrc_risks", {
        Threat: threat_descriptors
      });
  };

  RisksExtension.init_widgets_for_person_page =
    function init_widgets_for_person_page() {
      var people_widgets = $.extend({}, {
          Threat: threat_descriptor
        }, {
          Risk: risk_descriptor
        }
      );

      new GGRC.WidgetList("ggrc_risks", {
        Person: people_widgets
      });
  };

  RisksExtension.init_widgets_for_other_pages =
    function init_widgets_for_other_pages() {
      var descriptor = {},
          page_instance = GGRC.page_instance();
      if (page_instance && ~can.inArray(page_instance.constructor.shortName, _risk_object_types)) {
        descriptor[page_instance.constructor.shortName] = {
          risk: risk_descriptor,
          threat: threat_descriptor
        };
      }
      new GGRC.WidgetList("ggrc_risks", descriptor);
  };



  GGRC.register_hook("LHN.Sections_risk", GGRC.mustache_path + "/dashboard/lhn_risks");

  RisksExtension.init_mappings();

})(this.can.$, this.CMS, this.GGRC);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */


(function(can) {

  can.Model.Cacheable("CMS.Models.Risk", {
    root_object: "risk",
    root_collection: "risks",
    category: "risk",
    findAll: "GET /api/risks",
    findOne: "GET /api/risks/{id}",
    create: "POST /api/risks",
    update: "PUT /api/risks/{id}",
    destroy: "DELETE /api/risks/{id}",
    mixins: ['ownable', 'contactable', 'unique_title', 'ca_update'],
    is_custom_attributable: true,
    attributes : {
      context : "CMS.Models.Context.stub",
      contact : "CMS.Models.Person.stub",
      owners : "CMS.Models.Person.stubs",
      modified_by : "CMS.Models.Person.stub",
      objects : "CMS.Models.get_stubs",
      risk_objects: "CMS.Models.RiskObject.stubs"
    },
    tree_view_options: {
      add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache"
    },
    defaults: {
      status: 'Draft'
    },
    statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
    init: function () {
      this._super && this._super.apply(this, arguments);
      var req_fields = ["title", "description", "contact"];
      for (var i = 0; i < req_fields.length; i++) {
        this.validatePresenceOf(req_fields[i]);
      }
    }
  }, {});

})(window.can);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */


(function(can) {

  can.Model.Join("CMS.Models.RiskObject", {
    root_object: "risk_object",
    root_collection: "risk_objects",
    join_keys: {
      "risk": CMS.Models.Risk,
      "object": can.Model.Cacheable,
    },
    attributes: {
      context: "CMS.Models.Context.stub",
      modified_by: "CMS.Models.Person.stub",
      risk: "CMS.Models.Risk.stub",
      object: "CMS.Models.get_stub",
    },
    findAll: "GET /api/risk_objects",
    create: "POST /api/risk_objects",
    destroy: "DELETE /api/risk_objects/{id}"
  }, {
  });

})(window.can);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */


(function (can) {
  can.Model.Cacheable("CMS.Models.Threat", {
    root_object: "threat",
    root_collection: "threats",
    category: "risk",
    findAll: "GET /api/threats",
    findOne: "GET /api/threats/{id}",
    create: "POST /api/threats",
    update: "PUT /api/threats/{id}",
    destroy: "DELETE /api/threats/{id}",
    mixins: ['ownable', 'contactable', 'unique_title', 'ca_update'],
    is_custom_attributable: true,
    attributes: {
      context: "CMS.Models.Context.stub",
      contact: "CMS.Models.Person.stub",
      owners: "CMS.Models.Person.stubs",
      modified_by: "CMS.Models.Person.stub",
      object_people: "CMS.Models.ObjectPerson.stubs",
      people: "CMS.Models.Person.stubs",
      related_sources: "CMS.Models.Relationship.stubs",
      related_destinations: "CMS.Models.Relationship.stubs",
      object_objectives: "CMS.Models.ObjectObjective.stubs",
      objectives: "CMS.Models.Objective.stubs",
      object_controls: "CMS.Models.ObjectControl.stubs",
      controls: "CMS.Models.Control.stubs",
      object_sections: "CMS.Models.ObjectSection.stubs",
      sections: "CMS.Models.get_stubs"
    },
    tree_view_options: {
      add_item_view : GGRC.mustache_path + "/base_objects/tree_add_item.mustache",
      attr_list : can.Model.Cacheable.attr_list.concat([
        {attr_title: 'URL', attr_name: 'url'},
        {attr_title: 'Reference URL', attr_name: 'reference_url'}
      ])
    },
    defaults: {
      status: 'Draft'
    },
    statuses: ['Draft', 'Final', 'Effective', 'Ineffective', 'Launched',
      'Not Launched', 'In Scope', 'Not in Scope', 'Deprecated'],
    init: function () {
      this._super && this._super.apply(this, arguments);
      this.validatePresenceOf("title");
    }
  }, {});
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

;(function(CMS, GGRC, can, $) {



  can.Control("GGRC.Controllers.WorkflowPage", {
    defaults: {
    }
  }, {
    //  FIXME: This should trigger expansion of the TreeNode, without using
    //    global event listeners or routes or timeouts, but currently object
    //    creation and tree insertion is disconnected.
    "{CMS.Models.TaskGroup} created": function(model, ev, instance) {
      if (instance instanceof CMS.Models.TaskGroup) {
        setTimeout(function() {
          // If the TaskGroup was created as part of a Workflow, we don't want to
          //  do a redirect here
          if (instance._no_redirect) {
            return;
          }
          window.location.hash =
            'task_group_widget/task_group/' + instance.id;
        }, 250);
      }
    }
  });

  can.Model.Cacheable("CMS.ModelHelpers.CloneWorkflow", {
    defaults : {
      clone_people: true,
      clone_tasks: true,
      clone_objects: true
    }
  }, {
    refresh: function() {
      return $.when(this);
    },
    save: function() {
      var workflow = new CMS.Models.Workflow({
        clone: this.source_workflow.id,
        context: null,
        clone_people: this.clone_people,
        clone_tasks: this.clone_tasks,
        clone_objects: this.clone_objects
      });

      return workflow.save().then(function(workflow) {
        GGRC.navigate(workflow.viewLink);
        return this;
      });

    }
  });

  can.Model.Cacheable("CMS.ModelHelpers.CloneTaskGroup", {
    defaults : {
      clone_objects: true,
      clone_tasks: true,
      clone_people: true
    }
  }, {
    refresh: function() {
      return $.when(this);
    },
    save: function() {
      var task_group = new CMS.Models.TaskGroup({
        clone: this.source_task_group.id,
        context: null,
        clone_objects: this.clone_objects,
        clone_tasks: this.clone_tasks,
        clone_people: this.clone_people
      });

      return task_group.save();
    }
  });

})(this.CMS, this.GGRC, this.can, this.can.$);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function ($, CMS, GGRC) {
  var WorkflowExtension = {};
  var _workflowObjectTypes = Array.prototype.concat.call(
    [],
    'Program Regulation Policy Standard Contract Clause Section'.split(' '),
    'Request Control Objective OrgGroup Vendor AccessGroup'.split(' '),
    'System Process DataAsset Product Project Facility Market'.split(' '),
    'Issue Assessment Risk Threat'.split(' ')
  );
  var _taskSortFunction = function (a, b) {
    var dateA = Number(new Date(a.end_date));
    var dateB = Number(new Date(b.end_date));

    if (dateA === dateB) {
      if (a.id < b.id) {
        return -1;
      } else if (a.id > b.id) {
        return 1;
      }
      return 0;
    }
    if (dateA < dateB) {
      return -1;
    }
    return 1;
  };

  var draftOnUpdateMixin;

  var historyWidgetCountsName = 'cycles:history';
  var currentWidgetCountsName = 'cycles:active';

  var historyWidgetFilter = {
    expression: {
      op: {name: '='},
      left: 'is_current',
      right: 0
    }
  };

  var currentWidgetFilter = {
    expression: {
      op: {name: '='},
      left: 'is_current',
      right: 1
    }
  };

  // Register `workflows` extension with GGRC
  GGRC.extensions.push(WorkflowExtension);

  WorkflowExtension.name = 'workflows';

  WorkflowExtension.countsMap = {
    history: {
      name: 'Cycle',
      countsName: historyWidgetCountsName,
      additionalFilter: historyWidgetFilter
    },
    activeCycles: {
      name: 'Cycle',
      countsName: currentWidgetCountsName,
      additionalFilter: currentWidgetFilter
    },
    person: 'Person',
    taskGroup: 'TaskGroup'
  };

  // Register Workflow models for use with `infer_object_type`
  WorkflowExtension.object_type_decision_tree = function () {
    return {
      cycle: CMS.Models.Cycle,
      cycle_task_entry: CMS.Models.CycleTaskEntry,
      cycle_task_group: CMS.Models.CycleTaskGroup,
      cycle_task_group_object_task: CMS.Models.CycleTaskGroupObjectTask,
      task_group: CMS.Models.TaskGroup,
      workflow: CMS.Models.Workflow
    };
  };

  // Configure mapping extensions for ggrc_workflows
  WorkflowExtension.init_mappings = function () {
    var Proxy = GGRC.MapperHelpers.Proxy;
    var Direct = GGRC.MapperHelpers.Direct;
    var Cross = GGRC.MapperHelpers.Cross;
    var Multi = GGRC.MapperHelpers.Multi;
    var CustomFilter = GGRC.MapperHelpers.CustomFilter;
    var Reify = GGRC.MapperHelpers.Reify;
    var Search = GGRC.MapperHelpers.Search;
    var TypeFilter = GGRC.MapperHelpers.TypeFilter;

    // Add mappings for basic workflow objects
    var mappings = {
      TaskGroup: {
        _canonical: {
          objects: _workflowObjectTypes.concat(['Cacheable'])
        },
        task_group_tasks: Direct(
          'TaskGroupTask', 'task_group', 'task_group_tasks'),
        objects: Proxy(
          null, 'object', 'TaskGroupObject', 'task_group',
          'task_group_objects'),
        workflow: Direct(
          'Workflow', 'task_groups', 'workflow')
      },

      Workflow: {
        _canonical: {
          task_groups: 'TaskGroup',
          people: 'Person',
          context: 'Context'
        },
        task_groups: Direct(
          'TaskGroup', 'workflow', 'task_groups'),
        tasks: Cross(
          'task_groups', 'task_group_tasks'),
        cycles: Direct(
          'Cycle', 'workflow', 'cycles'),
        previous_cycles: CustomFilter('cycles', function (result) {
          return !result.instance.attr('is_current');
        }),
        current_cycle: CustomFilter('cycles', function (result) {
          return result.instance.attr('is_current');
        }),
        current_task_groups: Cross('current_cycle', 'cycle_task_groups'),
        current_tasks: Cross(
          'current_task_groups', 'cycle_task_group_object_tasks'
        ),
        current_all_tasks: Cross(
          'current_task_groups', 'cycle_task_group_tasks'
        ),

        people: Proxy(
          'Person',
          'person', 'WorkflowPerson',
          'workflow', 'workflow_people'
        ),
        context: Direct(
          'Context', 'related_object', 'context'),
        authorization_contexts: Multi(['context']),
        authorizations: Cross(
          'authorization_contexts', 'user_roles'),
        authorized_people: Cross(
          'authorization_contexts', 'authorized_people'),
        mapped_and_or_authorized_people: Multi([
          'people', 'authorized_people']),
        roles: Cross('authorizations', 'role'),

        // This is a dummy mapping that ensures the WorkflowOwner role is loaded
        //  before we do the custom filter for owner_authorizations.
        authorizations_and_roles: Multi(['authorizations', 'roles']),
        owner_authorizations: CustomFilter(
          'authorizations_and_roles',
          function (binding) {
            return binding.instance instanceof CMS.Models.UserRole &&
                binding.instance.attr('role') &&
                binding.instance.role.reify().attr('name') === 'WorkflowOwner';
          }
        ),
        owners: Cross('owner_authorizations', 'person'),
        orphaned_objects: Multi([
          'cycles',
          'task_groups',
          'tasks',
          'current_task_groups',
          'current_tasks'
        ])
      },

      Cycle: {
        cycle_task_groups: Direct(
          'CycleTaskGroup', 'cycle', 'cycle_task_groups'),
        reify_cycle_task_groups: Reify('cycle_task_groups'),
        workflow: Direct('Workflow', 'cycles', 'workflow')
      },

      CycleTaskGroup: {
        cycle: Direct(
          'Cycle', 'cycle_task_groups', 'cycle'),
        cycle_task_group_tasks: Direct(
          'CycleTaskGroupObjectTask',
          'cycle_task_group',
          'cycle_task_group_tasks'),

        // effectively an alias for 'cycle_task_group_tasks', specifying just
        // the latter's name as a string does not work for some reason
        cycle_task_group_object_tasks: Direct(
          'CycleTaskGroupObjectTask',
          'cycle_task_group',
          'cycle_task_group_tasks')
      },

      CycleTaskGroupObjectTask: {
        _canonical: {
          related_objects_as_source: [
            'DataAsset', 'Facility', 'Market', 'OrgGroup', 'Vendor', 'Process',
            'Product', 'Project', 'System', 'Regulation', 'Policy', 'Contract',
            'Standard', 'Program', 'Issue', 'Control', 'Section', 'Clause',
            'Objective', 'Audit', 'Assessment', 'AccessGroup', 'Request',
            'Document', 'Risk', 'Threat'
          ]
        },
        related_objects_as_source: Proxy(
          null,
          'destination', 'Relationship',
          'source', 'related_destinations'
        ),
        related_objects_as_destination: Proxy(
          null,
          'source', 'Relationship',
          'destination', 'related_sources'
        ),
        related_objects: Multi(
          ['related_objects_as_source', 'related_objects_as_destination']
        ),
        destinations: Direct('Relationship', 'source', 'related_destinations'),
        sources: Direct('Relationship', 'destination', 'related_sources'),
        relationships: Multi(['sources', 'destinations']),
        related_access_groups: TypeFilter('related_objects', 'AccessGroup'),
        related_data_assets: TypeFilter('related_objects', 'DataAsset'),
        related_facilities: TypeFilter('related_objects', 'Facility'),
        related_markets: TypeFilter('related_objects', 'Market'),
        related_org_groups: TypeFilter('related_objects', 'OrgGroup'),
        related_vendors: TypeFilter('related_objects', 'Vendor'),
        related_processes: TypeFilter('related_objects', 'Process'),
        related_products: TypeFilter('related_objects', 'Product'),
        related_projects: TypeFilter('related_objects', 'Project'),
        related_systems: TypeFilter('related_objects', 'System'),
        related_issues: TypeFilter('related_objects', 'Issue'),
        related_audits: TypeFilter('related_objects', 'Audit'),
        related_controls: TypeFilter('related_objects', 'Control'),
        related_documents: TypeFilter('related_objects', 'Document'),
        related_assessments: TypeFilter('related_objects', 'Assessment'),
        related_requests: TypeFilter('related_objects', 'Request'),
        regulations: TypeFilter('related_objects', 'Regulation'),
        contracts: TypeFilter('related_objects', 'Contract'),
        policies: TypeFilter('related_objects', 'Policy'),
        standards: TypeFilter('related_objects', 'Standard'),
        programs: TypeFilter('related_objects', 'Program'),
        controls: TypeFilter('related_objects', 'Control'),
        sections: TypeFilter('related_objects', 'Section'),
        clauses: TypeFilter('related_objects', 'Clause'),
        objectives: TypeFilter('related_objects', 'Objective'),
        cycle: Direct(
          'Cycle', 'cycle_task_group_object_tasks', 'cycle'),
        cycle_task_group: Direct(
          'CycleTaskGroup',
          'cycle_task_group_object_tasks',
          'cycle_task_group'),
        cycle_task_entries: Direct(
          'CycleTaskEntry',
          'cycle_task_group_object_task',
          'cycle_task_entries'),

        info_related_objects: CustomFilter(
          'related_objects',
          function (relatedObjects) {
            return !_.includes(
              ['Comment', 'Document', 'Person'],
              relatedObjects.instance.type
            );
          }
        ),

        // This code needs to be reworked to figure out how to return the single
        // most recent task entry with is_declining_review = true.
        declining_cycle_task_entries: Search(function (binding) {
          return CMS.Models.CycleTaskEntry.findAll({
            cycle_task_group_object_task_id: binding.instance.id,
            is_declining_review: 1
          });
        }, 'Cycle')
      },

      CycleTaskEntry: {
        documents: Proxy(
          'Document',
          'document', 'ObjectDocument',
          'documentable', 'object_documents'
        ),
        cycle: Direct(
          'Cycle', 'cycle_task_entries', 'cycle'),
        cycle_task_group_object_task: Direct(
          'CycleTaskGroupObjectTask',
          'cycle_task_entries',
          'cycle_task_group_object_task'),
        workflow: Cross('cycle', 'workflow')
      },

      People: {
        _canonical: {
          workflows: 'Workflow'
        },
        workflows: Proxy(
          'Workflow', 'workflow', 'WorkflowPerson', 'person', 'workflow_people'
        )

      },
      Person: {
        assigned_tasks: Search(function (binding) {
          return CMS.Models.CycleTaskGroupObjectTask.findAll({
            contact_id: binding.instance.id,
            'cycle.is_current': true,
            status__in: 'Assigned,InProgress,Finished,Declined'
          });
        }, 'Cycle'),
        assigned_tasks_with_history: Search(function (binding) {
          return CMS.Models.CycleTaskGroupObjectTask.findAll({
            contact_id: binding.instance.id
          });
        }, 'Cycle')
      }
    };

    // Insert `workflows` mappings to all business object types
    can.each(_workflowObjectTypes, function (type) {
      var model = CMS.Models[type];
      if (model === undefined || model === null) {
        return;
      }
      mappings[type] = {
        task_groups:
          new GGRC.ListLoaders.ProxyListLoader(
            'TaskGroupObject',
            'object',
            'task_group',
            'task_group_objects',
            null
          ),
        object_tasks: TypeFilter('related_objects', 'CycleTaskGroupObjectTask'),
        approval_tasks: CustomFilter('object_tasks', function (object) {
          return object.instance.attr('object_approval');
        }),
        workflows: Cross('task_groups', 'workflow'),
        approval_workflows: CustomFilter('workflows', function (binding) {
          return binding.instance.attr('object_approval');
        }),
        current_approval_cycles: Cross('approval_workflows', 'current_cycle'),
        _canonical: {
          workflows: 'Workflow',
          task_groups: 'TaskGroup'
        }
      };
      mappings[type].orphaned_objects = Multi([
        GGRC.Mappings.get_mappings_for(type).orphaned_objects,
        mappings[type].workflows
      ]);

      CMS.Models[type].attributes.task_group_objects =
        'CMS.Models.TaskGroupObject.stubs';

      // Also register a render hook for object approval
      GGRC.register_hook(
        type + '.info_widget_actions',
        GGRC.mustache_path + '/base_objects/approval_link.mustache'
        );
    });
    new GGRC.Mappings('ggrc_workflows', mappings);
  };

  // Override GGRC.extra_widget_descriptors and GGRC.extra_default_widgets
  // Initialize widgets for workflow page
  WorkflowExtension.init_widgets = function () {
    var pageInstance = GGRC.page_instance();
    var treeWidgets = GGRC.tree_view.base_widgets_by_type;
    var subTrees = GGRC.tree_view.sub_tree_for;
    var subTreeItems = ['Cycle', 'Request'];
    var models = ['TaskGroup', 'Workflow', 'CycleTaskEntry',
      'CycleTaskGroupObjectTask', 'CycleTaskGroupObject', 'CycleTaskGroup'];
    _.each(_workflowObjectTypes, function (type) {
      var widget;
      if (!type || !treeWidgets[type]) {
        return;
      }

      widget = subTrees[type];

      treeWidgets[type] = treeWidgets[type].concat(models);
      if (!_.isEmpty(subTrees.serialize)) {
        widget.attr({
          display_list: widget.display_list
            .concat(['CycleTaskGroupObjectTask']),
          model_list: widget.model_list
            .concat({
              display_name: CMS.Models.CycleTaskGroupObjectTask.title_singular,
              display_status: true,
              model_name: 'CycleTaskGroupObjectTask'
            })
        });
      }
    });
    subTreeItems.concat(models).forEach(function (item) {
      var defaults = {
        model_list: GGRC.tree_view.basic_model_list,
        display_list: can.Map.keys(GGRC.tree_view.base_widgets_by_type)
      };
      defaults.display_list.concat(models);

      treeWidgets.attr(item,
        can.Map.keys(GGRC.tree_view.base_widgets_by_type).concat(models));
      subTrees.attr(item, {
        display_list: defaults.display_list
          .concat(models),
        model_list: defaults.model_list
      });
    });

    if (pageInstance instanceof CMS.Models.Workflow) {
      WorkflowExtension.init_widgets_for_workflow_page();
    } else if (pageInstance instanceof CMS.Models.Person) {
      WorkflowExtension.init_widgets_for_person_page();
    } else {
      WorkflowExtension.init_widgets_for_other_pages();
    }
  };

  WorkflowExtension.init_widgets_for_other_pages = function () {
    var descriptor = {};
    var pageInstance = GGRC.page_instance();

    if (
      pageInstance &&
      ~can.inArray(pageInstance.constructor.shortName, _workflowObjectTypes)
    ) {
      descriptor[pageInstance.constructor.shortName] = {
        workflow: {
          widget_id: 'workflow',
          widget_name: 'Workflows',
          order: 400,
          content_controller: GGRC.Controllers.TreeView,
          content_controller_options: {
            mapping: 'workflows',
            parent_instance: pageInstance,
            model: CMS.Models.Workflow,
            show_view: GGRC.mustache_path + '/workflows/tree.mustache',
            footer_view: GGRC.mustache_path + '/workflows/tree_footer.mustache'
          }
        },
        task: {
          widget_id: 'task',
          widget_name: 'Workflow Tasks',
          order: 410,
          content_controller: GGRC.Controllers.TreeView,
          content_controller_options: {
            mapping: 'object_tasks',
            parent_instance: pageInstance,
            model: CMS.Models.CycleTaskGroupObjectTask,
            show_view:
              GGRC.mustache_path +
              '/cycle_task_group_object_tasks/tree.mustache',
            header_view:
              GGRC.mustache_path +
              '/cycle_task_group_object_tasks/tree_header.mustache',
            footer_view:
              GGRC.mustache_path +
              '/cycle_task_group_object_tasks/tree_footer.mustache',
            add_item_view:
              GGRC.mustache_path +
              '/cycle_task_group_object_tasks/tree_add_item.mustache',
            sort_property: null,
            sort_function: _taskSortFunction,
            draw_children: true,
            events: {
              'show-history': function (el, ev) {
                this.options.attr('mapping', el.attr('mapping'));
                this.reload_list();
              }
            },
            child_options: [
              {
                model: CMS.Models.CycleTaskEntry,
                mapping: 'cycle_task_entries',
                show_view:
                  GGRC.mustache_path + '/cycle_task_entries/tree.mustache',
                footer_view:
                  GGRC.mustache_path +
                  '/cycle_task_entries/tree_footer.mustache',
                draw_children: true,
                allow_creating: true
              }
            ]
          }
        }
      };
    }

    new GGRC.WidgetList('ggrc_workflows', descriptor, [
      'info_widget',
      'task_widget'
    ]);
  };

  WorkflowExtension.init_widgets_for_workflow_page = function () {
    var newWidgetDescriptors = {};
    var newDefaultWidgets = [
      'info', 'person', 'task_group', 'current', 'history'
    ];
    var historyWidgetDescriptor;
    var currentWidgetDescriptor;
    var object = GGRC.page_instance();

    can.each(
      GGRC.WidgetList.get_current_page_widgets(),
      function (descriptor, name) {
        if (~newDefaultWidgets.indexOf(name)) {
          newWidgetDescriptors[name] = descriptor;
        }
      }
    );

    // Initialize controller -- probably this should go in a separate
    // initialization area
    $(document.body).ggrc_controllers_workflow_page();

    GGRC.register_hook(
        'ObjectNav.Actions',
        GGRC.mustache_path + '/dashboard/object_nav_actions');

    $.extend(
      true,
      newWidgetDescriptors,
      {
        info: {
          content_controller: GGRC.Controllers.InfoWidget,
          content_controller_options: {
            widget_view: GGRC.mustache_path + '/workflows/info.mustache'
          }
        },
        person: {
          widget_id: 'person',
          widget_name: 'People',
          widget_icon: 'person',
          content_controller: GGRC.Controllers.TreeView,
          content_controller_options: {
            parent_instance: object,
            model: CMS.Models.Person,
            mapping: 'mapped_and_or_authorized_people',
            show_view:
              GGRC.mustache_path +
              '/ggrc_basic_permissions/people_roles/' +
              'authorizations_by_person_tree.mustache',
            footer_view:
              GGRC.mustache_path + '/base_objects/tree_footer.mustache',
            add_item_view:
              GGRC.mustache_path + '/wf_people/tree_add_item.mustache'
          }
        },
        task_group: {
          widget_id: 'task_group',
          widget_name: 'Setup',
          widget_icon: 'task_group',
          content_controller: CMS.Controllers.TreeView,
          content_controller_selector: 'ul',
          widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
          content_controller_options: {
            parent_instance: object,
            model: CMS.Models.TaskGroup,
            show_view: GGRC.mustache_path + '/task_groups/tree.mustache',
            sortable: true,
            sort_property: 'sort_index',
            mapping: 'task_groups',
            draw_children: true,

            // Note that we are using special naming for the tree views here.
            // Also, tasks for a task group aren't directly mapping to the
            // tasks themselves but to the join object.  This is important
            // since the join objects themselves have important attributes.
            child_options: [
              {
                model: can.Model.Cacheable,
                mapping: 'objects',
                show_view:
                  GGRC.mustache_path +
                  '/base_objects/task_group_subtree.mustache',
                footer_view:
                  GGRC.mustache_path +
                  '/base_objects/task_group_subtree_footer.mustache',
                add_item_view:
                  GGRC.mustache_path +
                  '/base_objects/task_group_subtree_add_item.mustache'
              }, {
                model: CMS.Models.TaskGroupTask,
                mapping: 'task_group_tasks',
                show_view:
                  GGRC.mustache_path +
                  '/task_group_tasks/task_group_subtree.mustache',
                footer_view:
                  GGRC.mustache_path +
                  '/task_group_tasks/task_group_subtree_footer.mustache',
                add_item_view:
                  GGRC.mustache_path +
                  '/task_group_tasks/task_group_subtree_add_item.mustache',
                sort_property: 'sort_index',
                allow_creating: true
              }
            ]
          }
        }
      }
    );

    historyWidgetDescriptor = {
      content_controller: CMS.Controllers.TreeView,
      content_controller_selector: 'ul',
      widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
      widget_id: 'history',
      widget_name: 'History',
      widget_icon: 'history',
      content_controller_options: {
        draw_children: true,
        parent_instance: object,
        model: 'Cycle',
        counts_name: historyWidgetCountsName,
        mapping: 'previous_cycles',
        additional_filter: historyWidgetFilter
      }
    };

    currentWidgetDescriptor = {
      content_controller: CMS.Controllers.TreeView,
      content_controller_selector: 'ul',
      widget_initial_content: '<ul class="tree-structure new-tree"></ul>',
      widget_id: 'current',
      widget_name: 'Active Cycles',
      widget_icon: 'cycle',
      content_controller_options: {
        draw_children: true,
        parent_instance: object,
        model: 'Cycle',
        counts_name: currentWidgetCountsName,
        mapping: 'current_cycle',
        additional_filter: currentWidgetFilter,
        header_view: GGRC.mustache_path + '/cycles/tree_header.mustache',
        add_item_view:
          GGRC.mustache_path +
          '/cycle_task_group_object_tasks/tree_add_item.mustache'
      }
    };

    newWidgetDescriptors.history = historyWidgetDescriptor;
    newWidgetDescriptors.current = currentWidgetDescriptor;

    GGRC.Utils.QueryAPI
      .initCounts([
        WorkflowExtension.countsMap.history,
        WorkflowExtension.countsMap.activeCycles,
        WorkflowExtension.countsMap.person,
        WorkflowExtension.countsMap.taskGroup
      ], {
        type: object.type,
        id: object.id
      });

    new GGRC.WidgetList(
      'ggrc_workflows',
      {Workflow: newWidgetDescriptors}
    );

    // Setup extra refresh required due to automatic creation of permissions
    // on creation of WorkflowPerson
    CMS.Models.WorkflowPerson.bind('created', function (ev, instance) {
      if (instance instanceof CMS.Models.WorkflowPerson) {
        if (instance.context) {
          instance.context.reify().refresh();
        }
      }
    });
  };

  WorkflowExtension.init_widgets_for_person_page = function () {
    var descriptor = {};
    var pageInstance = GGRC.page_instance();

    descriptor[pageInstance.constructor.shortName] = {
      task: {
        widget_id: 'task',
        widget_name: 'My Tasks',
        content_controller: GGRC.Controllers.TreeView,

        content_controller_options: {
          parent_instance: GGRC.page_instance(),
          model: CMS.Models.CycleTaskGroupObjectTask,
          show_view:
            GGRC.mustache_path +
            '/cycle_task_group_object_tasks/tree.mustache',
          header_view:
            GGRC.mustache_path +
            '/cycle_task_group_object_tasks/tree_header.mustache',
          footer_view:
            GGRC.mustache_path +
            '/cycle_task_group_object_tasks/tree_footer.mustache',
          add_item_view:
            GGRC.mustache_path +
            '/cycle_task_group_object_tasks/tree_add_item.mustache',
          mapping: 'assigned_tasks',
          sort_property: null,
          sort_function: _taskSortFunction,
          draw_children: true,
          events: {
            'show-history': function (el, ev) {
              this.options.attr('mapping', el.attr('mapping'));
              this.reload_list();
            }
          }
        }
      }
    };
    new GGRC.WidgetList('ggrc_workflows', descriptor, [
      'info_widget',
      'task_widget'
    ]);
  };

  GGRC.register_hook(
      'Dashboard.Widgets', GGRC.mustache_path + '/dashboard/widgets');

  GGRC.register_hook(
      'Dashboard.Errors', GGRC.mustache_path + '/dashboard/info/errors');

  WorkflowExtension.init_mappings();

  draftOnUpdateMixin = can.Model.Mixin({
  }, {
    before_update: function () {
      if (this.status && this.os_state === 'Approved') {
        this.attr('status', 'Draft');
      }
    }
  });
  can.each(_workflowObjectTypes, function (modelName) {
    var model = CMS.Models[modelName];
    if (model === undefined || model === null) {
      return;
    }
    draftOnUpdateMixin.add_to(model);
  });
})(this.can.$, this.CMS, this.GGRC);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

;(function(CMS, GGRC, can, $) {

  function is_overdue_task(task) {
    var end_date = new Date(task.instance.end_date || null),
        today = new Date();

    //Any task that is not finished or verified are subject to overdue
    if (task.instance.status === "Finished" || task.instance.status === "Verified")
      return false;
    // TODO: [Overdue] Move this logic to helper.
    else if (end_date.getTime() < today.getTime())
      return true;
  }

  can.Component.extend({
    tag: "dashboard-widgets",
    template: "<content/>",
    scope: {
      initial_wf_size: 5,
      workflow_view: GGRC.mustache_path + "/dashboard/info/workflow_progress.mustache",
      workflow_data: {},
      workflow_count: 0,
      workflow_show_all: false
    },
    events: {
      // Click action to show all workflows
      "a.workflow-trigger.show-all click" : function(el, ev) {
        this.scope.workflow_data.attr('list', this.scope.workflow_data.cur_wfs);

        el.text('Show top 5 workflows');
        el.removeClass('show-all');
        el.addClass('show-5');

        ev.stopPropagation();
      },
      //Show onlt top 5 workflows
      "a.workflow-trigger.show-5 click" : function(el, ev) {
        this.scope.workflow_data.attr('list', this.scope.workflow_data.cur_wfs5);

        el.text('Show all my workflows');
        el.removeClass('show-5');
        el.addClass('show-all');

        ev.stopPropagation();
      },

      // Show Workflows
      "li.workflow-tab click" : function(el, ev) {
        el.addClass('active');
        this.element.find('.workflow-wrap-main').show();
        ev.stopPropagation();
      }
    },
    init: function() {
      this.init_my_workflows();
    },
    init_my_workflows: function() {
      var self = this,
          my_view = this.scope.workflow_view,
          workflow_data = {},
          wfs,              // list of all workflows
          cur_wfs,          // list of workflows with current cycles
          cur_wfs5;         // list of top 5 workflows with current cycle

      if (!GGRC.current_user) {
        return;
      }

      GGRC.Models.Search.search_for_types('', ['Workflow'], {contact_id: GGRC.current_user.id})
      .then(function(result_set){
          var wf_data = result_set.getResultsForType('Workflow');
          var refresh_queue = new RefreshQueue();
          refresh_queue.enqueue(wf_data);
          return refresh_queue.trigger();
      }).then(function(options){
          wfs = options;

          return $.when.apply($, can.map(options, function(wf){
            return self.update_tasks_for_workflow(wf);
          }));
      }).then(function(){
        if(wfs.length > 0){
          //Filter workflows with a current cycle
          cur_wfs = self.filter_current_workflows(wfs);
          self.scope.attr('workflow_count', cur_wfs.length);
          //Sort the workflows in ascending order by first_end_date
          cur_wfs.sort(self.sort_by_end_date);
          workflow_data.cur_wfs = cur_wfs;

          if (cur_wfs.length > self.scope.initial_wf_size) {
            cur_wfs5 = cur_wfs.slice(0, self.scope.initial_wf_size);
            self.scope.attr('workflow_show_all', true);
          } else {
            cur_wfs5 = cur_wfs;
            self.scope.attr('workflow_show_all', false);
          }

          workflow_data.cur_wfs5 = cur_wfs5;
          workflow_data.list = cur_wfs5;
          self.scope.attr('workflow_data', workflow_data);
        }
      });

      return 0;
    },
    update_tasks_for_workflow: function(workflow){
      var self = this,
          dfd = $.Deferred(),
          task_count = 0,
          finished = 0,
          in_progress = 0,
          declined = 0,
          verified = 0,
          assigned = 0,
          over_due = 0,
          today = new Date(),
          first_end_date,
          task_data = {};

        workflow.get_binding('current_all_tasks').refresh_instances().then(function(d){
          var mydata = d;
          task_count = mydata.length;
          for(var i = 0; i < task_count; i++){
            var data = mydata[i].instance,
                end_date = new Date(data.end_date || null);

            //Calculate first_end_date for the workflow / earliest end for all the tasks in a workflow
            if (i === 0)
              first_end_date = end_date;
            else if (end_date.getTime() < first_end_date.getTime())
              first_end_date = end_date;

            //Any task not verified is subject to overdue
            if (data.status === 'Verified')
              verified++;
            else {
              // TODO: [Overdue] Move this logic to helper.
              if (end_date.getTime() < today.getTime()) {
                over_due++;
                $('dashboard-errors').control().scope.attr('error_msg', 'Some tasks are overdue!');
              }
              else if (data.status === 'Finished')
                finished++;
              else if (data.status === 'InProgress')
                in_progress++;
              else if (data.status === 'Declined')
                declined++;
              else
                assigned++;
            }
          }
          //Update Task_data object for workflow and Calculate %
          if (task_count > 0) {
            task_data.task_count = task_count;
            task_data.finished = finished;
            task_data.finished_percentage = ((finished * 100) / task_count).toFixed(2); //precision up to 2 decimal points
            task_data.in_progress = in_progress;
            task_data.in_progress_percentage = ((in_progress * 100) / task_count).toFixed(2);
            task_data.verified = verified;
            task_data.verified_percentage = ((verified * 100) / task_count).toFixed(2);
            task_data.declined = declined;
            task_data.declined_percentage = ((declined * 100) / task_count).toFixed(2);
            task_data.over_due = over_due;
            task_data.over_due_percentage = ((over_due * 100) / task_count).toFixed(2);
            task_data.assigned = assigned;
            task_data.assigned_percentage = ((assigned * 100) / task_count).toFixed(2);
            task_data.first_end_dateD = first_end_date;
            task_data.first_end_date = first_end_date.toLocaleDateString();
            //calculate days left for first_end_date
            if(today.getTime() >= first_end_date.getTime())
              task_data.days_left_for_first_task = 0;
            else {
              var time_interval = first_end_date.getTime() - today.getTime();
              var day_in_milli_secs = 24 * 60 * 60 * 1000;
              task_data.days_left_for_first_task = Math.floor(time_interval/day_in_milli_secs);
            }

            //set overdue flag
            task_data.over_due_flag = over_due ? true : false;
          }

          workflow.attr('task_data', new can.Map(task_data));
          dfd.resolve();
        });

        return dfd;
    },
    /*
      filter_current_workflows filters the workflows with current tasks in a
      new array and returns the new array.
      filter_current_workflows should be called after update_tasks_for_workflow.
      It looks at the task_data.task_count for each workflow
      For workflow with current tasks, task_data.task_count must be > 0;
    */
    filter_current_workflows: function(workflows){
      var filtered_wfs = [];

      can.each(workflows, function(item){
        if (item.task_data) {
          if (item.task_data.task_count > 0)
            filtered_wfs.push(item);
        }
      });
      return filtered_wfs;
    },
    /*
      sort_by_end_date sorts workflows in assending order with respect to task_data.first_end_date
      This should be called with workflows with current tasks.
    */
    sort_by_end_date: function(a, b) {
        return (a.task_data.first_end_dateD.getTime() - b.task_data.first_end_dateD.getTime());
    }

  });

  can.Component.extend({
    tag: "dashboard-errors",
    template: "<content/>",
    scope: {
      error_msg: '',
    }
  });

})(this.CMS, this.GGRC, this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

;(function(CMS, GGRC, can, $) {



  can.Control("GGRC.Controllers.WorkflowPage", {
    defaults: {
    }
  }, {
    //  FIXME: This should trigger expansion of the TreeNode, without using
    //    global event listeners or routes or timeouts, but currently object
    //    creation and tree insertion is disconnected.
    "{CMS.Models.TaskGroup} created": function(model, ev, instance) {
      if (instance instanceof CMS.Models.TaskGroup) {
        setTimeout(function() {
          // If the TaskGroup was created as part of a Workflow, we don't want to
          //  do a redirect here
          if (instance._no_redirect) {
            return;
          }
          window.location.hash =
            'task_group_widget/task_group/' + instance.id;
        }, 250);
      }
    }
  });

  can.Model.Cacheable("CMS.ModelHelpers.CloneWorkflow", {
    defaults : {
      clone_people: true,
      clone_tasks: true,
      clone_objects: true
    }
  }, {
    refresh: function() {
      return $.when(this);
    },
    save: function() {
      var workflow = new CMS.Models.Workflow({
        clone: this.source_workflow.id,
        context: null,
        clone_people: this.clone_people,
        clone_tasks: this.clone_tasks,
        clone_objects: this.clone_objects
      });

      return workflow.save().then(function(workflow) {
        GGRC.navigate(workflow.viewLink);
        return this;
      });

    }
  });

  can.Model.Cacheable("CMS.ModelHelpers.CloneTaskGroup", {
    defaults : {
      clone_objects: true,
      clone_tasks: true,
      clone_people: true
    }
  }, {
    refresh: function() {
      return $.when(this);
    },
    save: function() {
      var task_group = new CMS.Models.TaskGroup({
        clone: this.source_task_group.id,
        context: null,
        clone_objects: this.clone_objects,
        clone_tasks: this.clone_tasks,
        clone_people: this.clone_people
      });

      return task_group.save();
    }
  });

})(this.CMS, this.GGRC, this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can) {
  var _mustachePath;
  var overdueCompute;

  overdueCompute = can.compute(function (val) {
    var date;
    var today = moment().startOf('day');
    var startOfDate;
    if (this.attr('status') === 'Verified') {
      return '';
    }
    date = moment(this.attr('next_due_date') || this.attr('end_date'));
    startOfDate = moment(date).startOf('day');
    // TODO: [Overdue] Move this logic to helper.
    if (date && today.diff(startOfDate, 'days') <= 0) {
      return '';
    }
    return 'overdue';
  });

  function refreshAttr(instance, attr) {
    if (instance.attr(attr).reify().selfLink) {
      instance.attr(attr).reify().refresh();
    }
  }

  function refreshAttrWrap(attr) {
    return function (ev, instance) {
      if (instance instanceof this) {
        refreshAttr(instance, attr);
      }
    };
  }

  function populateFromWorkflow(form, workflow) {
    if (!workflow || typeof workflow === 'string') {
      // We need to invalidate the form, so we remove workflow if it's not set
      form.removeAttr('workflow');
      return;
    }
    if (workflow.reify) {
      workflow = workflow.reify();
    } else {
      console.log("Can't reify workflow");
      return;
    }
    if (typeof workflow.cycles === undefined || !workflow.cycles) {
      $(document.body).trigger(
        'ajax:flash',
        {warning: 'No cycles in the workflow!'}
      );
      return;
    }

    workflow.refresh_all('cycles').then(function (cycleList) {
      var activeCycleList = _.filter(cycleList, {is_current: true});
      var activeCycle;

      if (!activeCycleList.length) {
        $(document.body).trigger(
          'ajax:flash',
          {warning: 'No active cycles in the workflow!'}
        );
        return;
      }
      activeCycleList = _.sortByOrder(
        activeCycleList, ['start_date'], ['desc']);
      activeCycle = activeCycleList[0];
      form.attr('workflow', {id: workflow.id, type: 'Workflow'});
      form.attr('context', {id: workflow.context.id, type: 'Context'});
      form.attr('cycle', {id: activeCycle.id, type: 'Cycle'});
      form.cycle_task_group = activeCycle.cycle_task_groups[0].id;
    });
  }

  _mustachePath = GGRC.mustache_path + '/cycles';
  can.Model.Cacheable('CMS.Models.Cycle', {
    root_object: 'cycle',
    root_collection: 'cycles',
    category: 'workflow',
    findAll: 'GET /api/cycles',
    findOne: 'GET /api/cycles/{id}',
    create: 'POST /api/cycles',
    update: 'PUT /api/cycles/{id}',
    destroy: 'DELETE /api/cycles/{id}',

    attributes: {
      workflow: 'CMS.Models.Workflow.stub',
      cycle_task_groups: 'CMS.Models.CycleTaskGroup.stubs',
      modified_by: 'CMS.Models.Person.stub',
      context: 'CMS.Models.Context.stub'
    },

    tree_view_options: {
      show_view: _mustachePath + '/tree.mustache',
      header_view: _mustachePath + '/tree_header.mustache',
      draw_children: true,
      child_options: [
        {
          model: 'CycleTaskGroup',
          mapping: 'cycle_task_groups',
          allow_creating: false
        }
      ]
    },
    init: function () {
      var that = this;
      this._super.apply(this, arguments);
      this.bind('created', refreshAttrWrap('workflow').bind(this));
      this.bind('destroyed', function (ev, inst) {
        if (inst instanceof that) {
          can.each(inst.cycle_task_groups, function (cycleTaskGroup) {
            if (!cycleTaskGroup) {
              return;
            }
            cycleTaskGroup = cycleTaskGroup.reify();
            can.trigger(cycleTaskGroup, 'destroyed');
            can.trigger(
              cycleTaskGroup.constructor, 'destroyed', cycleTaskGroup);
          });
        }
      });
    }
  }, {
    init: function () {
      var that = this;
      this._super.apply(this, arguments);
      this.bind('status', function (ev, newVal) {
        if (newVal === 'Verified') {
          new RefreshQueue().enqueue(this.workflow.reify())
            .trigger()
            .then(function (wfs) {
              return wfs[0].get_binding('owners').refresh_instances();
            })
            .then(function (wfOwnerBindings) {
              var currentUser = CMS.Models.get_instance(
                'Person', GGRC.current_user.id);
              if (
                ~can.inArray(
                  currentUser,
                  can.map(wfOwnerBindings, function (wfOwnerBinding) {
                    return wfOwnerBinding.instance;
                  })
                )
              ) {
                that.refresh().then(function () {
                  if (that.attr('is_current')) {
                    that.attr('is_current', false);
                    that.save();
                  }
                });
              }
            });
        }
      });
    },
    overdue: overdueCompute
  });

  _mustachePath = GGRC.mustache_path + '/cycle_task_entries';
  can.Model.Cacheable('CMS.Models.CycleTaskEntry', {
    root_object: 'cycle_task_entry',
    root_collection: 'cycle_task_entries',
    category: 'workflow',
    findAll: 'GET /api/cycle_task_entries',
    findOne: 'GET /api/cycle_task_entries/{id}',
    create: 'POST /api/cycle_task_entries',
    update: 'PUT /api/cycle_task_entries/{id}',
    destroy: 'DELETE /api/cycle_task_entries/{id}',
    info_pane_options: {
      attachments: {
        mapping: 'documents',
        show_view: GGRC.mustache_path + '/base_templates/attachment.mustache'
      }
    },
    attributes: {
      cycle_task_group_object_task: 'CMS.Models.CycleTaskGroupObjectTask.stub',
      modified_by: 'CMS.Models.Person.stub',
      context: 'CMS.Models.Context.stub',
      object_documents: 'CMS.Models.ObjectDocument.stubs',
      documents: 'CMS.Models.Document.stubs',
      cycle: 'CMS.Models.Cycle.stub'
    },

    tree_view_options: {
      show_view: _mustachePath + '/tree.mustache',
      footer_view: _mustachePath + '/tree_footer.mustache',
      child_options: [{
        // 0: Documents
        model: 'Document',
        mapping: 'documents',
        show_view: _mustachePath + '/documents.mustache',
        footer_view: _mustachePath + '/documents_footer.mustache'
      }]
    },
    init: function () {
      this._super.apply(this, arguments);
      this.bind('created',
        refreshAttrWrap('cycle_task_group_object_task').bind(this));
      this.validateNonBlank('description');
    }
  }, {
    workflowFolder: function () {
      return this.refresh_all('cycle', 'workflow').then(function (workflow) {
        if (workflow.has_binding('folders')) {
          return workflow.refresh_all('folders').then(function (folders) {
            if (folders.length === 0) {
              return null;  // workflow folder has not been assigned
            }
            return folders[0].instance;
          }, function (result) {
            return result;
          });
        }
      });
    }
  });

  _mustachePath = GGRC.mustache_path + '/cycle_task_groups';
  can.Model.Cacheable('CMS.Models.CycleTaskGroup', {
    root_object: 'cycle_task_group',
    root_collection: 'cycle_task_groups',
    category: 'workflow',
    findAll: 'GET /api/cycle_task_groups',
    findOne: 'GET /api/cycle_task_groups/{id}',
    create: 'POST /api/cycle_task_groups',
    update: 'PUT /api/cycle_task_groups/{id}',
    destroy: 'DELETE /api/cycle_task_groups/{id}',

    attributes: {
      cycle: 'CMS.Models.Cycle.stub',
      task_group: 'CMS.Models.TaskGroup.stub',
      cycle_task_group_tasks: 'CMS.Models.CycleTaskGroupObjectTask.stubs',
      modified_by: 'CMS.Models.Person.stub',
      context: 'CMS.Models.Context.stub'
    },

    tree_view_options: {
      sort_property: 'sort_index',
      show_view: _mustachePath + '/tree.mustache',
      draw_children: true,
      child_options: [
        {
          title: 'Tasks',
          model: 'CycleTaskGroupObjectTask',
          mapping: 'cycle_task_group_tasks',
          allow_creating: false
        }
      ]
    },

    init: function () {
      var that = this;
      this._super.apply(this, arguments);

      this.validateNonBlank('contact');
      this.validateContact(['_transient.contact', 'contact']);
      this.bind('updated', function (ev, instance) {
        var dfd;
        if (instance instanceof that) {
          dfd = instance.refresh_all_force('cycle', 'workflow');
          dfd.then(function () {
            return $.when(
              instance.refresh_all_force('related_objects'),
              instance.refresh_all_force('cycle_task_group_tasks')
            );
          });
        }
      });
      this.bind('destroyed', function (ev, inst) {
        if (inst instanceof that) {
          can.each(inst.cycle_task_group_tasks, function (ctgt) {
            if (!ctgt) {
              return;
            }
            ctgt = ctgt.reify();
            can.trigger(ctgt, 'destroyed');
            can.trigger(ctgt.constructor, 'destroyed', ctgt);
          });
        }
      });
    }
  }, {
    overdue: overdueCompute
  });

  _mustachePath = GGRC.mustache_path + '/cycle_task_group_object_tasks';
  can.Model.Cacheable('CMS.Models.CycleTaskGroupObjectTask', {
    root_object: 'cycle_task_group_object_task',
    root_collection: 'cycle_task_group_object_tasks',
    mixins: ['timeboxed'],
    category: 'workflow',
    findAll: 'GET /api/cycle_task_group_object_tasks',
    findOne: 'GET /api/cycle_task_group_object_tasks/{id}',
    create: 'POST /api/cycle_task_group_object_tasks',
    update: 'PUT /api/cycle_task_group_object_tasks/{id}',
    destroy: 'DELETE /api/cycle_task_group_object_tasks/{id}',
    title_singular: 'Cycle Task',
    attributes: {
      cycle_task_group: 'CMS.Models.CycleTaskGroup.stub',
      task_group_task: 'CMS.Models.TaskGroupTask.stub',
      cycle_task_entries: 'CMS.Models.CycleTaskEntry.stubs',
      modified_by: 'CMS.Models.Person.stub',
      contact: 'CMS.Models.Person.stub',
      context: 'CMS.Models.Context.stub',
      cycle: 'CMS.Models.Cycle.stub'
    },
    permalink_options: {
      url: '<%= base.viewLink %>#current_widget/cycle/<%= instance.cycle.id %>/cycle_task_group/<%= instance.cycle_task_group.id %>/cycle_task_group_object_task/<%= instance.id %>',
      base: 'cycle:workflow'
    },
    info_pane_options: {
      mapped_objects: {
        model: can.Model.Cacheable,
        mapping: 'info_related_objects',
        show_view: GGRC.mustache_path + '/base_templates/subtree.mustache'
      },
      comments: {
        model: can.Model.Cacheable,
        mapping: 'cycle_task_entries',
        show_view: GGRC.mustache_path + '/cycle_task_entries/tree.mustache'
      }
    },
    tree_view_options: {
      sort_property: 'sort_index',
      show_view: _mustachePath + '/tree.mustache',
      attr_list: [
        {
          attr_title: 'Title',
          attr_name: 'title'
        },
        {
          attr_title: 'Workflow',
          attr_name: 'workflow',
          attr_sort_field: 'cycle.workflow.title'
        },
        {
          attr_title: 'State',
          attr_name: 'status'
        },
        {
          attr_title: 'Assignee',
          attr_name: 'assignee',
          attr_sort_field: 'contact.name|email'
        },
        {
          attr_title: 'Start Date',
          attr_name: 'start_date'
        },
        {
          attr_title: 'End Date',
          attr_name: 'end_date'
        },
        {
          attr_title: 'Last Updated',
          attr_name: 'updated_at'
        }
      ],
      display_attr_names: ['title', 'assignee', 'start_date'],
      mandatory_attr_name: ['title'],
      draw_children: true,
      child_options: [
        {
          model: 'CycleTaskEntry',
          mapping: 'cycle_task_entries',
          allow_creating: true
        },
        {
          model: can.Model.Cacheable,
          mapping: 'info_related_objects',
          allow_creating: true
        }
      ]
    },
    init: function () {
      var that = this;
      this._super.apply(this, arguments);
      this.validateNonBlank('title');
      this.validateNonBlank('workflow');
      this.validateNonBlank('cycle');
      this.validateContact(['_transient.contact', 'contact']);
      this.validateNonBlank('start_date');
      this.validateNonBlank('end_date');

      this.bind('updated', function (ev, instance) {
        if (instance instanceof that) {
          instance.refresh_all_force('related_objects').then(function (object) {
            return instance.refresh_all_force(
              'cycle_task_group', 'cycle', 'workflow');
          });
        }
      });
    }
  }, {
    overdue: overdueCompute,
    _workflow: function () {
      return this.refresh_all('cycle', 'workflow').then(function (workflow) {
        return workflow;
      });
    },
    set_properties_from_workflow: function (workflow) {
      // The form sometimes returns plaintext instead of object, return in that case
      if (typeof workflow === 'string') {
        return;
      }
      populateFromWorkflow(this, workflow);
    },
    form_preload: function (newObjectForm) {
      var form = this;
      var workflows;
      var _workflow;
      var cycle;
      var person = {
        id: GGRC.current_user.id,
        type: 'Person'
      };

      if (newObjectForm) {
        // prepopulate dates with default ones
        this.attr('start_date', new Date());
        this.attr('end_date', moment().add({month: 3}).toDate());

        if (!form.contact) {
          form.attr('contact', person);
          form.attr('_transient.contact', person);
        }

        // using setTimeout to execute this after the modal is loaded
        // so we can see when the workflow is already set and use that one
        setTimeout(function () {
          // if we are creating a task from the workflow page, the preset
          // workflow should be that one
          if (form.workflow !== undefined) {
            populateFromWorkflow(form, form.workflow);
            return;
          }

          workflows = CMS.Models.Workflow.findAll({
            kind: 'Backlog', status: 'Active', __sort: '-created_at'});
          workflows.then(function (workflowList) {
            if (!workflowList.length) {
              $(document.body).trigger(
                'ajax:flash',
                {warning: 'No Backlog workflows found! Contact your administrator to enable this functionality.'}
              );
              return;
            }
            _workflow = workflowList[0];
            populateFromWorkflow(form, _workflow);
          });
        }, 0);
      } else {
        cycle = form.cycle.reify();
        if (!_.isUndefined(cycle.workflow)) {
          form.attr('workflow', cycle.workflow.reify());
        }
        if (this.contact) {
          this.attr('_transient.contact', this.contact);
        }
      }
    },
    object: function () {
      return this.refresh_all(
        'task_group_object', 'object'
      ).then(function (object) {
        return object;
      });
    },
    response_options_csv: can.compute(function (val) {
      if (val != null) {
        this.attr(
          'response_options',
          $.map(val.split(','), $.proxy(''.trim.call, ''.trim))
        );
      } else {
        return (this.attr('response_options') || []).join(', ');
      }
    }),

    selected_response_options_csv: can.compute(function (val) {
      if (val != null) {
        this.attr(
          'selected_response_options',
          $.map(val.split(','), $.proxy(''.trim.call, ''.trim))
        );
      } else {
        return (this.attr('selected_response_options') || []).join(', ');
      }
    })
  });
})(window.can);

/*!
 Copyright (C) 2016 Google Inc.
 Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can) {
  'use strict';

  can.Model.Cacheable('CMS.Models.TaskGroup', {
    root_object: 'task_group',
    root_collection: 'task_groups',
    category: 'workflow',
    findAll: 'GET /api/task_groups',
    findOne: 'GET /api/task_groups/{id}',
    create: 'POST /api/task_groups',
    update: 'PUT /api/task_groups/{id}',
    destroy: 'DELETE /api/task_groups/{id}',

    mixins: ['contactable'],
    permalink_options: {
      url: '<%= base.viewLink %>#task_group_widget/' +
      'task_group/<%= instance.id %>',
      base: 'workflow'
    },
    attributes: {
      workflow: 'CMS.Models.Workflow.stub',
      task_group_tasks: 'CMS.Models.TaskGroupTask.stubs',
      tasks: 'CMS.Models.Task.stubs',
      task_group_objects: 'CMS.Models.TaskGroupObject.stubs',
      objects: 'CMS.Models.get_stubs',
      modified_by: 'CMS.Models.Person.stub',
      context: 'CMS.Models.Context.stub',
      end_date: 'date'
    },

    tree_view_options: {
      sort_property: 'sort_index',
      header_view: GGRC.mustache_path + '/task_groups/tree_header.mustache',
      footer_view: GGRC.mustache_path + '/base_objects/tree_footer.mustache',
      add_item_view: GGRC.mustache_path + '/task_groups/tree_add_item.mustache'
    },

    init: function () {
      var that = this;
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validateNonBlank('title');
      this.validateNonBlank('contact');
      this.validateContact(['_transient.contact', 'contact']);

      // Refresh workflow people:
      this.bind('created', function (ev, instance) {
        if (instance instanceof that) {
          instance.refresh_all_force('workflow', 'context');
        }
      });
      this.bind('updated', function (ev, instance) {
        if (instance instanceof that) {
          instance.refresh_all_force('workflow', 'context');
        }
      });
      this.bind('destroyed', function (ev, inst) {
        if (inst instanceof that) {
          can.each(inst.task_group_tasks, function (tgt) {
            if (!tgt) {
              return;
            }
            tgt = tgt.reify();
            can.trigger(tgt, 'destroyed');
            can.trigger(tgt.constructor, 'destroyed', tgt);
          });
          inst.refresh_all_force('workflow', 'context');
        }
      });
    }
  }, {});

  can.Model.Cacheable('CMS.Models.TaskGroupTask', {
    root_object: 'task_group_task',
    root_collection: 'task_group_tasks',
    findAll: 'GET /api/task_group_tasks',
    create: 'POST /api/task_group_tasks',
    update: 'PUT /api/task_group_tasks/{id}',
    destroy: 'DELETE /api/task_group_tasks/{id}',

    mixins: ['contactable', 'timeboxed'],
    permalink_options: {
      url: '<%= base.viewLink %>#task_group_widget/' +
      'task_group/<%= instance.task_group.id %>',
      base: 'task_group:workflow'
    },
    attributes: {
      context: 'CMS.Models.Context.stub',
      modified_by: 'CMS.Models.Person.stub',
      task_group: 'CMS.Models.TaskGroup.stub'
    },

    init: function () {
      var that = this;
      if (this._super) {
        this._super.apply(this, arguments);
      }
      this.validateNonBlank('title');
      this.validateNonBlank('contact');
      this.validateContact(['_transient.contact', 'contact']);

      this.validate(['start_date', 'end_date'], function () {
        var that = this;
        var workflow = GGRC.page_instance();
        var datesAreValid = true;

        if (!(workflow instanceof CMS.Models.Workflow)) {
          return;
        }

        // Handle cases of a workflow with start and end dates
        if (workflow.frequency === 'one_time') {
          datesAreValid = that.start_date && that.end_date &&
            that.start_date <= that.end_date;
        }

        if (!datesAreValid) {
          return 'Start and/or end date is invalid';
        }
      });

      this.bind('created', function (ev, instance) {
        if (instance instanceof that) {
          if (instance.task_group.reify().selfLink) {
            instance.task_group.reify().refresh();
            instance._refresh_workflow_people();
          }
        }
      });

      this.bind('updated', function (ev, instance) {
        if (instance instanceof that) {
          instance._refresh_workflow_people();
        }
      });

      this.bind('destroyed', function (ev, instance) {
        if (instance instanceof that) {
          if (instance.task_group && instance.task_group.reify().selfLink) {
            instance.task_group.reify().refresh();
            instance._refresh_workflow_people();
          }
        }
      });
    }
  }, {
    init: function () {
      // default start and end date
      var startDate = this.attr('start_date') || new Date();
      var endDate = this.attr('end_date') ||
        new Date(moment().add(7, 'days').format());
      if (this._super) {
        this._super.apply(this, arguments);
      }
      // Add base values to this property
      this.attr('response_options', []);
      this.attr('start_date', startDate);
      this.attr('end_date', endDate);
      this.attr('minStartDate', new Date());

      this.bind('task_group', function (ev, newTask) {
        var task;
        var taskGroup;
        var props = [
          'relative_start_day',
          'relative_start_month',
          'relative_end_day',
          'relative_end_month',
          'start_date',
          'end_date'
        ];
        if (!newTask) {
          return;
        }
        newTask = newTask.reify();
        taskGroup = newTask.get_mapping('task_group_tasks').slice(0);

        do {
          task = taskGroup.splice(-1)[0];
          task = task && task.instance;
        } while (task === this);

        if (!task) {
          return;
        }
        can.each(props, function (prop) {
          if (task[prop] && !this[prop]) {
            this.attr(prop, task.attr(prop) instanceof Date ?
              new Date(task[prop]) :
              task[prop]);
          }
        }, this);
      });
    },

    _refresh_workflow_people: function () {
      //  TaskGroupTask assignment may add mappings and role assignments in
      //  the backend, so ensure these changes are reflected.
      var workflow;
      var taskGroup = this.task_group.reify();
      if (taskGroup.selfLink) {
        workflow = taskGroup.workflow.reify();
        return workflow.refresh().then(function (workflow) {
          return workflow.context.reify().refresh();
        });
      }
    },

    response_options_csv: can.compute(function (val) {
      var isSet = val && val.length;
      var responseOptions = this.attr('response_options');
      var options = isSet ?
        val.split(',') :
        responseOptions;

      if (isSet) {
        this.attr('response_options', options.map(function (item) {
          return item.trim();
        }));
      } else {
        return options.join(', ');
      }
    })
  });
})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/


(function(can) {

  can.Model.Cacheable("CMS.Models.Workflow", {
    root_object: "workflow",
    root_collection: "workflows",
    category: "workflow",
    mixins: ['ca_update', 'timeboxed'],
    findAll: "GET /api/workflows",
    findOne: "GET /api/workflows/{id}",
    create: "POST /api/workflows",
    update: "PUT /api/workflows/{id}",
    destroy: "DELETE /api/workflows/{id}",
    is_custom_attributable: true,

    defaults: {
      frequency_options: [
        {title: 'One time', value: 'one_time'},
        {title: 'Weekly', value: 'weekly'},
        {title: 'Monthly', value: 'monthly'},
        {title: 'Quarterly', value: 'quarterly'},
        {title: 'Annually', value: 'annually'}
      ],
      frequency: 'one_time' // default value
    },

    attributes: {
      people: "CMS.Models.Person.stubs",
      workflow_people: "CMS.Models.WorkflowPerson.stubs",
      task_groups: "CMS.Models.TaskGroup.stubs",
      cycles: "CMS.Models.Cycle.stubs",
      //workflow_task_groups: "CMS.Models.WorkflowTaskGroup.stubs"
      modified_by: "CMS.Models.Person.stub",
      context: "CMS.Models.Context.stub",
      custom_attribute_values: "CMS.Models.CustomAttributeValue.stubs",
      default_lhn_filters: {
        Workflow: {status: 'Active'},
        Workflow_All: {},
        Workflow_Active: {status: 'Active'},
        Workflow_Inactive: {status: 'Inactive'},
        Workflow_Draft: {status: 'Draft'}
      }
    },
    obj_nav_options: {
      show_all_tabs: true,
    },
    tree_view_options: {
      show_view: GGRC.mustache_path + "/workflows/tree.mustache",
      attr_list : [
        {attr_title: 'Title', attr_name: 'title'},
        {attr_title: 'Manager', attr_name: 'owner', attr_sort_field: ''},
        {attr_title: 'Code', attr_name: 'slug'},
        {attr_title: 'State', attr_name: 'status'},
        {attr_title: 'Frequency', attr_name: 'frequency'},
        {attr_title: 'Last Updated', attr_name: 'updated_at'}
      ]
    },

    init: function() {
      this._super && this._super.apply(this, arguments);
      this.validateNonBlank("title");
      this.bind("destroyed", function(ev, inst) {
        if(inst instanceof CMS.Models.Workflow) {
          can.each(inst.cycles, function(cycle) {
            if (!cycle) {
              return;
            }
            cycle = cycle.reify()
            can.trigger(cycle, "destroyed");
            can.trigger(cycle.constructor, "destroyed", cycle);
          });
          can.each(inst.task_groups, function(tg) {
            if (!tg) {
              return;
            }
            tg = tg.reify();
            can.trigger(tg, "destroyed");
            can.trigger(tg.constructor, "destroyed", tg);
          });
        }
      });
    }
  }, {
    save: function () {
      var taskGroupTitle = this.task_group_title;
      var redirectLink;
      var taskGroup;
      var dfd;

      dfd = this._super.apply(this, arguments);
      dfd.then(function (instance) {
        redirectLink = instance.viewLink + '#task_group_widget';
        instance.attr('_redirect', redirectLink);
        if (!taskGroupTitle) {
          return instance;
        }
        taskGroup = new CMS.Models.TaskGroup({
          title: taskGroupTitle,
          workflow: instance,
          contact: instance.people && instance.people[0] || instance.modified_by,
          context: instance.context
        });
        return taskGroup.save()
          .then(function (tg) {
            // Prevent the redirect form workflow_page.js
            taskGroup.attr('_no_redirect', true);
            instance.attr('_redirect', redirectLink + '/task_group/' + tg.id);
            return this;
          }.bind(this));
      }.bind(this));
      return dfd;
    },
    // Check if task groups are slated to start
    //   in the current week/month/quarter/year
    is_mid_frequency: function() {
      var dfd = new $.Deferred(),
          self = this;

      function _afterOrSame(d1, d2) {
        return d1.isAfter(d2, 'day') || d1.isSame(d2, 'day');
      }
      function _beforeOrSame(d1, d2) {
        return d1.isBefore(d2, 'day') || d1.isSame(d2, 'day');
      }
      function _currentQuarter() {
        return moment().dayOfYear(1).quarter(moment().quarter());
      }
      function _check_all_tasks(tasks) {
        tasks.each(function(task) {
          var start, end, current = moment();
          task = task.reify();
          switch(self.frequency) {
            case "weekly":
              start = moment().isoWeekday(task.relative_start_day);
              end = moment().isoWeekday(task.relative_end_day);
              if (_afterOrSame(start, end)) {
                end.add('w', 1);
              }
              break;
            case "monthly":
              start = moment().date(task.relative_start_day);
              end = moment().date(task.relative_end_day);
              if (_afterOrSame(start, end)) {
                end.add('M', 1);
              }
              break;
            case "quarterly":
              start = _currentQuarter().date(task.relative_start_day).add('M', task.relative_start_month-1);
              end = _currentQuarter().date(task.relative_end_day).add('M', task.relative_end_month-1);
              if (_afterOrSame(start, end)) {
                end.add('q', 1);
              }
              break;
            case "annually":
              start = moment().date(task.relative_start_day).month(task.relative_start_month-1);
              end = moment().date(task.relative_end_day).month(task.relative_end_month-1);
              if (_afterOrSame(start, end)) {
                end.add('y', 1);
              }
              break;
          }
          if (_afterOrSame(current, start) && _beforeOrSame(current, end)) {
            dfd.resolve(true);
          }
        });
        dfd.resolve(false);
      }

      if (!this.frequency_duration || this.frequency === 'one_time') {
        return dfd.resolve(false);
      }

      // Check each task in the workflow:
      this.refresh_all('task_groups', 'task_group_tasks').then(function(s) {
        var tasks = new can.List();
        self.task_groups.each(function(task_group) {
          task_group.reify().task_group_tasks.each(function(task) {
            tasks.push(task.reify());
          });
        });
        _check_all_tasks(tasks);
      });
      return dfd;
    },

    // Get duration from frequency or false for one_time or continuous wfs.
    frequency_duration: function() {
      switch (this.frequency) {
        case "weekly": return "week";
        case "monthly": return "month";
        case "quarterly": return "quarter";
        case "annually": return "year";
        default: return false;
      }
    },
    // start day of month, affects start_date.
    //  Use when month number doesn't matter or is
    //  selectable.
    start_day_of_month: can.compute(function(val) {
      var newdate;
      if(val) {
        while(val.isComputed) {
          val = val();
        }
        if(val > 31) {
          val = 31;
        }
        newdate = new Date(this.start_date || null);
        while(moment(newdate).daysInMonth() < val) {
          newdate.setMonth((newdate.getMonth() + 1) % 12);
        }
        newdate.setDate(val);
        this.attr("start_date", newdate);
      } else {
        newdate = this.attr("start_date");
        if(newdate) {
          return newdate.getDate();
        } else {
          return null;
        }
      }
    }),

    // end day of month, affects end_date.
    //  Use when month number doesn't matter or is
    //  selectable.
    end_day_of_month: can.compute(function(val) {
      var newdate;
      if(val) {
        while(val.isComputed) {
          val = val();
        }
        if(val > 31) {
          val = 31;
        }
        newdate = new Date(this.end_date || null);
        while(moment(newdate).daysInMonth() < val) {
          newdate.setMonth((newdate.getMonth() + 1) % 12);
        }
        newdate.setDate(val);
        this.attr("end_date", newdate);
      } else {
        newdate = this.attr("end_date");
        if(newdate) {
          return newdate.getDate();
        } else {
          return null;
        }
      }
    }),

    // start month of quarter, affects start_date.
    //  Sets month to be a 31-day month in the chosen quarterly cycle:
    //  1 for Jan-Apr-Jul-Oct, 2 for Feb-May-Aug-Nov, 3 for Mar-Jun-Sep-Dec
    start_month_of_quarter: can.compute(function(val) {
      var newdate;
      var month_lookup = [0, 4, 2]; //31-day months in quarter cycles: January, May, March

      if(val) {
        newdate = new Date(this.start_date || null);
        newdate.setMonth(month_lookup[(val - 1) % 3]);
        this.attr("start_date", newdate);
      } else {
        newdate = this.attr("start_date");
        if(newdate) {
          return newdate.getMonth() % 3 + 1;
        } else {
          return null;
        }
      }
    }),

    // end month of quarter, affects end_date.
    //  Sets month to be a 31-day month in the chosen quarterly cycle:
    //  1 for Jan-Apr-Jul-Oct, 2 for Feb-May-Aug-Nov, 3 for Mar-Jun-Sep-Dec
    end_month_of_quarter: can.compute(function(val) {
      var newdate;
      var month_lookup = [0, 7, 2]; //31-day months in quarter cycles: January, May, March

      if(val) {
        newdate = new Date(this.end_date || null);
        newdate.setMonth(month_lookup[(val - 1) % 3]);
        this.attr("end_date", newdate);
      } else {
        newdate = this.attr("end_date");
        if(newdate) {
          return newdate.getMonth() % 3 + 1;
        } else {
          return null;
        }
      }
    }),

    // start month of yesr, affects start_date.
    //  Sets month to the chosen month, and adjusts
    //  day of month to be within chosen month
    start_month_of_year: can.compute(function(val) {
      var newdate;
      if(val) {
        if(val > 12) {
          val = 12;
        }
        newdate = new Date(this.start_date || null);
        if(moment(newdate).date(1).month(val - 1).daysInMonth() < newdate.getDate()) {
          newdate.setDate(moment(newdate).date(1).month(val - 1).daysInMonth());
        }
        newdate.setMonth(val - 1);
        this.attr("start_date", newdate);
      } else {
        newdate = this.attr("start_date");
        if(newdate) {
          return newdate.getMonth() + 1;
        } else {
          return null;
        }
      }
    }),

    // end month of yesr, affects end_date.
    //  Sets month to the chosen month, and adjusts
    //  day of month to be within chosen month
    end_month_of_year: can.compute(function(val) {
      var newdate;
      if(val) {
        if(val > 12) {
          val = 12;
        }
        newdate = new Date(this.end_date || null);
        if(moment(newdate).date(1).month(val - 1).daysInMonth() < newdate.getDate()) {
          newdate.setDate(moment(newdate).date(1).month(val - 1).daysInMonth());
        }
        newdate.setMonth(val - 1);
        this.attr("end_date", newdate);
      } else {
        newdate = this.attr("end_date");
        if(newdate) {
          return newdate.getMonth() + 1;
        } else {
          return null;
        }
      }
    }),

    // start day of week, affects start_date.
    //  Sets day of month to the first day of the
    //  month that is the selected day of the week
    //  Sunday is 0, Saturday is 6
    start_day_of_week: can.compute(function(val) {
      var newdate;
      if(val) {
        val = +val;
        newdate = new Date(this.start_date || null);
        newdate.setDate((newdate.getDate() + 7 - newdate.getDay() + val - 1) % 7 + 1);
        this.attr("start_date", newdate);
      } else {
        newdate = this.attr("start_date");
        if(newdate) {
          return newdate.getDay();
        } else {
          return null;
        }
      }
    }),

    // end day of week, affects end_date.
    //  Sets day of month to the first day of the
    //  month that is the selected day of the week
    //  Sunday is 0, Saturday is 6
    end_day_of_week: can.compute(function(val) {
      var newdate;
      if(val) {
        val = +val;
        newdate = new Date(this.end_date || null);
        newdate.setDate((newdate.getDate() + 7 - newdate.getDay() + val - 1) % 7 + 1);
        this.attr("end_date", newdate);
      } else {
        newdate = this.attr("end_date");
        if(newdate) {
          return newdate.getDay();
        } else {
          return null;
        }
      }
    })
  });

})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/


(function(can) {

  can.Model.Join("CMS.Models.TaskGroupObject", {
    root_object: "task_group_object",
    root_collection: "task_group_objects",
    join_keys: {
      "task_group": CMS.Models.TaskGroup,
      "object": can.Model.Cacheable,
    },
    attributes: {
      context: "CMS.Models.Context.stub",
      modified_by: "CMS.Models.Person.stub",
      task_group: "CMS.Models.TaskGroup.stub",
      object: "CMS.Models.get_stub",
    },
    findAll: "GET /api/task_group_objects",
    create: "POST /api/task_group_objects",
    update: "PUT /api/task_group_objects/{id}",
    destroy: "DELETE /api/task_group_objects/{id}"
  }, {
  });

  can.Model.Join("CMS.Models.WorkflowPerson", {
    root_object: "workflow_person",
    root_collection: "workflow_people",
    join_keys: {
      workflow: CMS.Models.Workflow,
      person: CMS.Models.Person,
    },
    attributes: {
      context: "CMS.Models.Context.stub",
      modified_by: "CMS.Models.Person.stub",
      workflow: "CMS.Models.Workflow.stub",
      person: "CMS.Models.Person.stub",
    },
    findAll: "GET /api/workflow_people",
    create: "POST /api/workflow_people",
    destroy: "DELETE /api/workflow_people/{id}",
  }, {
  });

})(window.can);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $, CMS) {
  var ApprovalWorkflowErrors = can.compute(function () {
    var errors = null;
    if (!this.attr('contact')) {
      errors = {
        contact: 'Must be defined'
      };
    }
    if (!this.attr('end_date')) {
      errors = $.extend(errors, {
        end_date: 'Must be defined'
      });
    }
    return errors;
  });

  can.Observe('CMS.ModelHelpers.CycleTask', {
    findInCacheById: function () {
      return null;
    }
  }, {
    init: function () {
      this.attr('owners', new CMS.Models.Person.List(this.owners));
    },
    save: function () {
      var Task;

      // FIXME: temporary fix for 'Could not get any raw data while
      // converting using .models'
      this._data.owners = $.map(this._data.owners, function (owner) {
        return {
          id: owner.id,
          type: owner.type
        };
      });

      Task = new CMS.Models.TaskGroupTask({
        task_group: this.task_group,
        title: this.title,
        description: this.description,
        sort_index: Number.MAX_SAFE_INTEGER / 2,
        contact: this.contact,
        context: this.context
      });

      return Task.save()
        .then(function (taskGroupTask) {
          var CycleTask = new CMS.Models.CycleTaskGroupObjectTask({
            cycle: this.cycle,
            start_date: this.cycle.reify().start_date,
            end_date: this.cycle.reify().end_date,
            task_group_task: taskGroupTask,
            sort_index: this.sort_index,
            title: this.title,
            description: this.description,
            status: 'Assigned',
            contact: this.contact,
            context: this.context
          });
          return CycleTask.save();
        }.bind(this));
    },
    computed_errors: can.compute(function () {
      var errors = null;
      if (!this.attr('title')) {
        errors = {
          title: 'Must be defined'
        };
      }
      return errors;
    })
  });

  can.Observe('CMS.ModelHelpers.ApprovalWorkflow', {
    defaults: {
      original_object: null
    }
  }, {
    save: function () {
      var that = this;
      var aws_dfd = this.original_object.get_binding('approval_workflows').refresh_list();
      var reviewTemplate = _.template('Object review for ${type} "${title}"');
      var notifyTemplate = _.template('<br/><br/> ${name} (${email}) asked ' +
        'you to review newly created ${type} "${title}" before ${before}. ' +
        'Click <a href="${href}#workflows_widget">here</a> to perform a review.'
      );

      return aws_dfd.then(function (aws) {
        var ret;
        if (aws.length < 1) {
          ret = $.when(
            new CMS.Models.Workflow({
              frequency: 'one_time',
              status: 'Active',
              title: reviewTemplate({
                type: that.original_object.constructor.title_singular,
                title: that.original_object.title
              }),
              object_approval: true,
              notify_on_change: true,
              notify_custom_message: notifyTemplate({
                name: GGRC.current_user.name,
                email: GGRC.current_user.email,
                type: that.original_object.constructor.model_singular,
                title: that.original_object.title,
                before: moment(that.end_date).format('MM/DD/YYYY'),
                href: window.location.href.replace(/#.*$/, '')
              }),
              context: that.original_object.context
            }).save()
          ).then(function(wf) {
              return $.when(
                wf,
                new CMS.Models.TaskGroup({
                  workflow : wf,
                  title: reviewTemplate({
                    type: that.original_object.constructor.title_singular,
                    title: that.original_object.title
                  }),
                  contact: that.contact,
                  context: wf.context
                }).save()
              );
          }).then(function(wf, tg) {
              return $.when(
                wf,
                new CMS.Models.TaskGroupTask({
                  task_group: tg,
                  start_date: moment().format('MM/DD/YYYY'),
                  end_date: that.end_date,
                  object_approval: true,
                  sort_index: (Number.MAX_SAFE_INTEGER / 2).toString(10),
                  contact: that.contact,
                  context: wf.context,
                  task_type: "text",
                  title: reviewTemplate({
                    type: that.original_object.constructor.title_singular,
                    title: that.original_object.title
                  })
                }).save(),
                new CMS.Models.TaskGroupObject({
                  task_group: tg,
                  object: that.original_object,
                  context: wf.context
                }).save()
              );
          });
        } else {
          ret = $.when(
            aws[0].instance.refresh(),
            $.when.apply(
              $,
              can.map(aws[0].instance.task_groups.reify(), function(tg) {
                return tg.refresh();
              })
            ).then(function() {
              return $.when.apply($, can.map(can.makeArray(arguments), function(tg) {
                return tg.attr("contact", that.contact).save().then(function(tg) {
                  return $.when.apply($, can.map(tg.task_group_tasks.reify(), function(tgt) {
                    return tgt.refresh().then(function(tgt) {
                      return tgt.attr({
                        'contact': that.contact,
                        'end_date': that.end_date,
                        'start_date': moment().format('MM/DD/YYYY'),
                        'task_type': tgt.task_type || 'text'
                        }).save();
                    });
                  }));
                });
              }));
            })
          );
        }

        return ret.then(function (wf) {
          var cycleDfd = new CMS.Models.Cycle({
            workflow: wf,
            autogenerate: true,
            context: wf.context
          }).save();
          cycleDfd.then(function () {
            return that.original_object.refresh();
          });
          return cycleDfd;
        });
      });
    },
    computed_errors: ApprovalWorkflowErrors,
    computed_unsuppressed_errors: ApprovalWorkflowErrors
  });
})(this.can, this.can.$, this.CMS);

/*
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (can, $, Mustache) {
  /*
   sort_index_at_end mustache helper

   Given a list of items with a sort_index property, or a list of
   bindings with instances having a sort_index property, return
   a sort_index value suitable for placing a new item in the list
   at the end when sorted.

   @helper_type string -- use within attribute or outside of element

   @param list a list of objects or bindings
   */
  Mustache.registerHelper('sort_index_at_end', function (list, options) {
    var max_int = Number.MAX_SAFE_INTEGER.toString(10);
    var list_max = '0';

    list = Mustache.resolve(list);
    can.each(list, function (item) {
      var idx;
      if (item.reify) {
        item = item.reify();
      }
      idx = item.attr
        ? (item.attr('sort_index') || item.attr('instance.sort_index'))
        : item.sort_index || item.instance && (item.instance.attr
        ? item.instance.attr('sort_index')
        : item.instance.sort_index);
      if (typeof idx !== 'undefined') {
        list_max = GGRC.Math.string_max(idx, list_max);
      }
    });

    return GGRC.Math.string_half(GGRC.Math.string_add(list_max, max_int));
  });

  /*
   sortable_if mustache helper

   Apply jQuery-UI sortable to the parent element if the supplied value
   is true, or false if the hash has an 'inverse' key set to a truthy value

   in the other case (false for not inverse, true for inverse) the sortable
   widget attached to the element will be destroyed if it exists.

   @helper_type attributes -- use within an element tag

   @param val some computed value with a truthy or falsy value
   @param sortable_opts a JSON stringified object of options to pass to
   @hashbparam inverse whether to invert the boolean check of val.
   */
  Mustache.registerHelper('sortable_if', function () {
    var args = can.makeArray(arguments).slice(0, arguments.length - 1);
    var options = arguments[arguments.length - 1];
    var inverse = options.hash && options.hash.inverse;

    return function (el) {
      can.view.live.attributes(el, can.compute(function () {
        var val = Mustache.resolve(args[0]);
        var sortable_opts = args[1];

        if (val ^ inverse) {  // value XOR inverse, one must be true, one false
          $(el).sortable(JSON.parse(sortable_opts || '{}'));
        } else if ($(el).is('.ui-sortable')) {
          $(el).sortable('destroy');
        }
      }));
    };
  });

  Mustache.registerHelper('workflow_owner',
    function (instance, modal_title, options) {
      var loader;
      if (Mustache.resolve(modal_title).indexOf('New ') === 0) {
        return GGRC.current_user.email;
      }
      loader = Mustache.resolve(instance).get_binding('authorizations');
      return $.map(loader.list, function (binding) {
        if (binding.instance.role &&
            binding.instance.role.reify().attr('name') === 'WorkflowOwner') {
          return binding.instance.person.reify().attr('email');
        }
      }).join(', ');
    });

  Mustache.registerHelper('if_cycle_assignee_privileges',
    function (instance, options) {
      var workflow_dfd;
      var current_user = GGRC.current_user;
      var admin = Permission.is_allowed('__GGRC_ADMIN__');

      if (!options) {
        options = instance;
        instance = options.context;
      }
      instance = Mustache.resolve(instance);

      // short-circuit if admin.
      if (admin) {
        return options.fn(options.contexts);
      }

      workflow_dfd = instance.get_binding('cycle').refresh_instances()
        .then(function (cycle_bindings) {
          return new RefreshQueue()
            .enqueue(cycle_bindings[0].instance.workflow.reify())
            .trigger();
        }).then(function (workflows) {
          return $.when(
            workflows[0].get_binding('authorizations').refresh_instances(),
            workflows[0].get_binding('owner_authorizations').refresh_instances()
          );
        });

      return Mustache.defer_render('span',
        function (authorizations, owner_auths) {
          var owner_auth_ids = can.map(owner_auths, function (auth) {
            return auth.instance.person && auth.instance.person.id;
          });
          var all_auth_ids = can.map(authorizations, function (auth) {
            return auth.instance.person && auth.instance.person.id;
          });

          if (~can.inArray(current_user.id, owner_auth_ids) ||
              ~can.inArray(current_user.id, all_auth_ids) &&
              current_user.id === instance.contact.id) {
            return options.fn(options.contexts);
          }
          return options.inverse(options.contexts);
        }, workflow_dfd);
    });

  Mustache.registerHelper('if_task_group_assignee_privileges',
    function (instance, options) {
      var workflow_dfd;
      var current_user = GGRC.current_user;
      var admin = Permission.is_allowed('__GGRC_ADMIN__');

      if (!options) {
        options = instance;
        instance = options.context;
      }
      instance = Mustache.resolve(instance);

      // short-circuit if admin.
      if (admin) {
        return options.fn(options.contexts);
      }
      if (instance.workflow.id in CMS.Models.Workflow.cache) {
        workflow_dfd = new $.Deferred().resolve(instance.workflow.reify());
      } else {
        workflow_dfd = instance.workflow.reify().refresh();
      }
      workflow_dfd = workflow_dfd.then(function (workflow) {
        return $.when(
          workflow.get_binding('authorizations').refresh_instances(),
          workflow.get_binding('owner_authorizations').refresh_instances()
        );
      });

      return Mustache.defer_render('span',
        function (authorizations, owner_auths) {
          var owner_auth_ids = can.map(owner_auths, function (auth) {
            return auth.instance.person && auth.instance.person.id;
          });
          var all_auth_ids = can.map(authorizations, function (auth) {
            return auth.instance.person && auth.instance.person.id;
          });
          var task_group_contact_id = instance.contact && instance.contact.id;

          if (~can.inArray(current_user.id, owner_auth_ids) ||
              ~can.inArray(current_user.id, all_auth_ids) &&
             (current_user.id === task_group_contact_id)) {
            return options.fn(options.contexts);
          }
          return options.inverse(options.contexts);
        }, workflow_dfd);
    });

  /*
   if_recurring_workflow mustache helper

   Given an object, it  determines if it's a workflow, and if it's a recurring
   workflow or not.

   @param object - the object we want to check
   */
  Mustache.registerHelper('if_recurring_workflow', function (object, options) {
    object = Mustache.resolve(object);
    if (object.type === 'Workflow' &&
        _.includes(['weekly', 'monthly', 'quarterly', 'annually'],
                   object.frequency)) {
      return options.fn(this);
    }
    return options.inverse(this);
  });

  Mustache.registerHelper('can_edit_response', function (instance, status) {
    var cycle = Mustache.resolve(instance).cycle.reify();
    status = Mustache.resolve(status);
    return cycle.is_current && ['Finished', 'Verified'].indexOf(status) === -1;
  });
})(this.can, this.can.$, this.Mustache);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

;(function(can, $, GGRC, CMS) {

GGRC.Controllers.Modals("GGRC.Controllers.ApprovalWorkflow", {
  defaults : {
    original_object : null,
    new_object_form: true,
    model: CMS.ModelHelpers.ApprovalWorkflow,
    modal_title: "Submit for review",
    custom_save_button_text: "Submit",
    content_view: GGRC.mustache_path + "/wf_objects/approval_modal_content.mustache",
    button_view : GGRC.Controllers.Modals.BUTTON_VIEW_SAVE_CANCEL
  }
}, {
  init : function() {
    this.options.button_view = GGRC.Controllers.Modals.BUTTON_VIEW_SAVE_CANCEL;
    this._super.apply(this, arguments);
    this.options.attr("instance", new CMS.ModelHelpers.ApprovalWorkflow({
      original_object : this.options.instance
    }));
  },
  "input[null-if-empty] change" : function(el, ev) {
    if(el.val() === "") {
      this.options.instance.attr(el.attr("name").split(".").slice(0, -1).join("."), null);
    }
  }
});

GGRC.register_modal_hook("approvalform", function($target, $trigger, option) {
  var instance,
      object_params = JSON.parse($trigger.attr('data-object-params') || "{}");

  if($trigger.attr('data-object-id') === "page") {
    instance = GGRC.page_instance();
  } else {
    instance = CMS.Models.get_instance(
      $trigger.data('object-singular'),
      $trigger.attr('data-object-id')
    );
  }

  $target
  .modal_form(option, $trigger)
  .ggrc_controllers_approval_workflow({
    object_params : object_params,
    current_user : GGRC.current_user,
    instance : instance
  });
});

})(this.can, this.can.$, this.GGRC, this.CMS);


//Calendar authentication

jQuery(function($){
  $('body').on('click', '.calendar-auth', function(e) {
    var calenderAuthWin = null,
      href = window.location.origin + "/calendar_oauth_request", //"https://ggrc-dev.googleplex.com/calendar_oauth_request"
      name = "Calendar Authentication";

    if(calenderAuthWin === null || calenderAuthWin.closed){
      calenderAuthWin = window.open(href, name);
      calenderAuthWin.focus();
    }
    else{
      calenderAuthWin.focus();
    }
  });
});

  /*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  'use strict';

  can.Component.extend({
    tag: "workflow-clone",
    template: "<content/>",
    events: {
      click: function(el) {
        var workflow, $target;

        $target = $('<div class="modal hide"></div>').uniqueId();
        $target.modal_form({}, el);
        $target.ggrc_controllers_modals({
          modal_title: "Clone Workflow",
          model: CMS.ModelHelpers.CloneWorkflow,
          instance: new CMS.ModelHelpers.CloneWorkflow({ source_workflow: this.scope.workflow }),
          content_view: GGRC.mustache_path + "/workflows/clone_modal_content.mustache",
          custom_save_button_text: "Proceed",
          button_view: GGRC.Controllers.Modals.BUTTON_VIEW_SAVE_CANCEL
        });
      }
    }
  });
})(window.GGRC, window.can);

  /*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  'use strict';

  can.Component.extend({
    tag: "task-group-clone",
    template: "<content/>",
    events: {
      click: function(el) {
        var $target;

        $target = $('<div class="modal hide"></div>').uniqueId();
        $target.modal_form({}, el);
        $target.ggrc_controllers_modals({
          modal_title: "Clone Task Group",
          model: CMS.ModelHelpers.CloneTaskGroup,
          instance: new CMS.ModelHelpers.CloneTaskGroup({ source_task_group: this.scope.taskGroup }),
          content_view: GGRC.mustache_path + "/task_groups/clone_modal_content.mustache",
          custom_save_button_text: "Proceed",
          button_view: GGRC.Controllers.Modals.BUTTON_VIEW_SAVE_CANCEL
        });
      }
    }
  });
})(window.GGRC, window.can);

  /*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

/**
 * A component that wraps a button for ending a Workflow cycle, and
 * automatically handles a click on it.
 *
 * As a result, the Cycle instance passed to the component is ended, and
 * a couple of affected objects are refreshed in the process.
 *
 * Usage example (state and permission checks not included):
 *
 *   <cycle-end-cycle cycle="instance">
 *       <button>Click to end a Cycle</button>
 *   </cycle-end-cycle>
 *
 */
(function (GGRC, can) {
  'use strict';

  GGRC.Components('endCycleButtonWrap', {
    tag: 'cycle-end-cycle',
    template: '<content/>',
    events: {
      click: function () {
        this.scope.cycle
          .refresh()
          .then(function (cycle) {
            return cycle.attr('is_current', false).save();
          })
          .then(function () {
            return GGRC.page_instance().refresh();
          })
          .then(function () {
            // We need to update person's assigned_tasks mapping manually
            var person = CMS.Models.Person.cache[GGRC.current_user.id];
            var binding = person.get_binding('assigned_tasks');

            // FIXME: Find a better way of removing stagnant
            // items from the list.
            binding.list.splice(0, binding.list.length);
            return binding.loader.refresh_list(binding);
          })
          .then(function () {
            var pageInstance = GGRC.page_instance();
            var WorkflowExtension =
              GGRC.extensions.find(function (extension) {
                return extension.name === 'workflows';
              });

            $('body').trigger('treeupdate');
            return GGRC.Utils.QueryAPI
              .initCounts([
                WorkflowExtension.countsMap.history
              ], {
                type: pageInstance.type,
                id: pageInstance.id
              });
          });
      }
    }
  });
})(window.GGRC, window.can);

  /*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  'use strict';

  function _generate_cycle() {
    var workflow = GGRC.page_instance();
    var dfd = new $.Deferred();
    var cycle;

    GGRC.Controllers.Modals.confirm({
      modal_title: 'Confirm',
      modal_confirm: 'Proceed',
      skip_refresh: true,
      button_view: GGRC.mustache_path + '/workflows/confirm_start_buttons.mustache',
      content_view: GGRC.mustache_path + '/workflows/confirm_start.mustache',
      instance: workflow
    }, function (params, option) {
      var data = {};

      can.each(params, function (item) {
        data[item.name] = item.value;
      });

      cycle = new CMS.Models.Cycle({
        context: workflow.context.stub(),
        workflow: {id: workflow.id, type: 'Workflow'},
        autogenerate: true
      });

      cycle.save().then(function (cycle) {
        // Cycle created. Workflow started.
        setTimeout(function () {
          dfd.resolve();
          window.location.hash = 'current_widget/cycle/' + cycle.id;
        }, 250);
      });
    }, function () {
      dfd.reject();
    });
    return dfd;
  }

  can.Component.extend({
    tag: 'workflow-start-cycle',
    content: '<content/>',
    events: {
      click: _generate_cycle
    }
  });

  can.Component.extend({
    tag: 'workflow-activate',
    template: '<content/>',
    init: function () {
      this.scope._can_activate_def();
    },
    scope: {
      waiting: true,
      can_activate: false,
      _can_activate_def: function () {
        var self = this;
        var workflow = GGRC.page_instance();

        self.attr('waiting', true);
        $.when(
          workflow.refresh_all('task_groups', 'task_group_objects'),
          workflow.refresh_all('task_groups', 'task_group_tasks')
        )
        .always(function () {
          self.attr('waiting', false);
        })
        .done(function () {
          var task_groups = workflow.task_groups.reify();
          var can_activate = task_groups.length;

          task_groups.each(function (task_group) {
            if (!task_group.task_group_tasks.length) {
              can_activate = false;
            }
          });
          self.attr('can_activate', can_activate);
        })
        .fail(function (error) {
          console.warn('Workflow activate error', error.message);
        });
      },
      _handle_refresh: function (model) {
        var models = ['TaskGroup', 'TaskGroupTask', 'TaskGroupObject'];
        if (models.indexOf(model.shortName) > -1) {
          this._can_activate_def();
        }
      },
      _restore_button: function () {
        this.attr('waiting', false);
      },
      _activate: function () {
        var workflow = GGRC.page_instance();
        var scope = this;
        var restore_button = scope._restore_button.bind(scope);

        scope.attr('waiting', true);
        if (workflow.frequency !== 'one_time') {
          workflow.refresh().then(function () {
            workflow.attr('recurrences', true);
            workflow.attr('status', 'Active');
            return workflow.save();
          }, restore_button).then(function (workflow) {
            if (moment(workflow.next_cycle_start_date).isSame(moment(), 'day')) {
              return new CMS.Models.Cycle({
                context: workflow.context.stub(),
                workflow: {id: workflow.id, type: 'Workflow'},
                autogenerate: true
              }).save();
            }
          }, restore_button).then(restore_button);
        } else {
          _generate_cycle().then(function () {
            return workflow.refresh();
          }, restore_button).then(function (workflow) {
            return workflow.attr('status', 'Active').save();
          }, restore_button).then(restore_button);
        }
      }
    },
    events: {
      '{can.Model.Cacheable} created': function (model) {
        this.scope._handle_refresh(model);
      },
      '{can.Model.Cacheable} destroyed': function (model) {
        this.scope._handle_refresh(model);
      },
      'button click': function () {
        this.scope._activate();
      }
    }
  });
})(window.GGRC, window.can);


  /*!
  Copyright (C) 2016 Google Inc.
  Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function (GGRC, can) {
  'use strict';

  can.Component.extend({
    tag: "workflow-deactivate",
    template: "<content/>",
    events: {
      click: function() {
        var workflow = GGRC.page_instance();
        workflow.refresh().then(function(workflow) {
          workflow.attr('recurrences', false).save();
        });
      }
    }
  });
})(window.GGRC, window.can);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can) {
  'use strict';

  var gdrive_findAll;
  var gapi_request_with_auth;
  var scopes = ['https://www.googleapis.com/auth/drive',
    'https://www.googleapis.com/auth/apps.groups.settings'];

  /*
    create a search query that matches the expected format for GDrive API.
    It's a series of boolean constructors with operators for testing equality
    and list membership (the 'in' operator).  Add more fields as necessary, as
    this is the minimal needed set.

    Reference for search query format:
    https://developers.google.com/drive/search-parameters
  */
  window.process_gapi_query = function (params) {
    var qstr = [];
    var i;

    for (i in params) {
      if (params.hasOwnProperty(i)) {
        switch (i) {
          case 'parents' :
            qstr.push("'" + (params[i].id ? params[i].id : params[i]) + "' in " + i);
            break;
          case 'mimeType' :
            qstr.push(i + " = '" + params[i] + "'");
            break;
          case 'mimeTypeNot' :
            qstr.push("mimeType != '" + params[i] + "'");
            break;
          default:
            break;
        }
      }
    }
    return qstr.join(' and ');
  };

  // Template for all findAll operations on GDrive objects.
  // https://developers.google.com/drive/v2/reference/files/list
  gdrive_findAll = function (extra_params, extra_path) {
    return function (params) {
      var that = this;
      var path = '/drive/v2/files';
      var q;

      params = params || {};

    // Short-circuit for refresh queue, because GAPI doesn't play that.
      if (params.id__in) {
        return $.when.apply($, can.map(params.id__in.split(','), function (id) {
          return that.findOne({id: id});
        })).then(function () {
          return can.makeArray(arguments);
        });
      }

      if (params.parentfolderid) {
        params.parents = params.parentfolderid;
        delete params.parentfolderid;
      }
      if (!params.parents && !params.id) {
        params.parents = 'root';
      }
      $.extend(params, extra_params);
      q = process_gapi_query(params);

      if (params.id) {
        path += '/' + params.id;
      }
      if (extra_path) {
        path += extra_path;
      }
      if (q) {
        path += '?q=' + encodeURIComponent(q);
      }

      return gapi_request_with_auth({
        path: path,
        method: 'get', // "post"
        callback: function (dfd, result) {
          var objs;
          if (!result || result.error) {
            dfd.reject(result ? result.error : JSON.parse(arguments[1]));
          } else if (result.items) {
            objs = result.items;
            can.each(objs, function (obj) {
              obj.selfLink = obj.selfLink || '#';
            });
            dfd.resolve(objs);
          } else { // single object case
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    };
  };

  /**
    GDrive files not including folders.  Folders are also files in GDrive,
    with a particular MIME type, but we distinguish between them here as
    different object types for conceptual ease.

    https://developers.google.com/drive/v2/reference/files
  */
  can.Model.Cacheable('CMS.Models.GDriveFile', {
    findAll: gdrive_findAll({
      mimeTypeNot: 'application/vnd.google-apps.folder'
    }),
    findOne: gdrive_findAll({}),
    addToParent: function (object, parent) {
      if (typeof parent === 'string') {
        parent = {id: parent};
      }

      return gapi_request_with_auth({
        path: '/drive/v2/files/' + object.id + '/parents',
        method: 'post',
        body: parent.stub ? parent.stub() : parent,
        callback: function (dfd, result) {
          if (result && result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            dfd.resolve();
          }
        },
        scopes: scopes
      }).done(function () {
        object.refresh();
      });
    },

    copyToParent: function (object, parent) {
      if (typeof parent === 'string') {
        parent = {id: parent};
      }

      return gapi_request_with_auth({
        path: '/drive/v2/files/' + object.id + '/copy',
        method: 'post',
        body: {parents: [{id: parent.id}], title: object.title},
        callback: function (dfd, result) {
          if (result && result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    },

    removeFromParent: function (object, parent_id) {
      if (typeof object !== 'object') {
        object = this.store[object];
      }
      return gapi_request_with_auth({
        path: '/drive/v2/files/' + parent_id + '/children/' + object.id,
        method: 'delete',
        callback: function (dfd, result) {
          if (result && result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            dfd.resolve();
          }
        },
        scopes: scopes
      }).done(function () {
        object.refresh();
      });
    },
    destroy: function (id) {
      return gapi_request_with_auth({
        path: '/drive/v2/files/' + id + '/trash',
        method: 'post',
        callback: function (dfd, result) {
          if (result && result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    },
    from_id: function (id) {
      return new this({id: id});
    },
    attributes: {
      permissions: 'CMS.Models.GDriveFilePermission.models',
      revisions: 'CMS.Models.GDriveFileRevision.models'
    }
  }, {
    findPermissions: function () {
      return CMS.Models.GDriveFilePermission.findAll(this.serialize());
    },
    findRevisions: function () {
      return CMS.Models.GDriveFileRevision.findAll(this.serialize());
    },
    refresh: function (params) {
      return this.constructor.findOne({id: this.id})
      .then($.proxy(this.constructor, 'model'))
      .done(function (d) {
        d.updated();
        //  Trigger complete refresh of object -- slow, but fixes live-binding
        //  redraws in some cases
        can.trigger(d, 'change', '*');
      });
    },
    addToParent: function (parent) {
      return this.constructor.addToParent(this, parent);
    },
    copyToParent: function (parent) {
      return this.constructor.copyToParent(this, parent);
    },
    removeFromParent: function (parent) {
      return this.constructor.removeFromParent(this, parent.id || parent);
    }
  });

  /**
    The separate type for folders.

    The docs have a special page about working with folders, which is
    worth reading:
    https://developers.google.com/drive/web/folder
  */
  CMS.Models.GDriveFile('CMS.Models.GDriveFolder', {

    findAll: gdrive_findAll({
      mimeType: 'application/vnd.google-apps.folder'
    }),
    create: function (params) {
      if (!params.parents) {
        params.parents = [{id: 'root'}];
      }
      return gapi_request_with_auth({
        path: '/drive/v2/files',
        method: 'post',
        body: {
          mimeType: 'application/vnd.google-apps.folder',
          title: params.title,
          parents: params.parents.push ? params.parents : [params.parents]
        },
        callback: function (dfd, result) {
          if (result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    },
    findChildFolders: function (params) {
      if (typeof params !== 'string') {
        params = params.id;
      }
      return this.findAll({parents: params});
    },
    addChildFolder: function (parent, params) {
      return this.create($.extend({parent: parent}, params));
    },
    from_id: function (id) {
      return new this({id: id});
    },
    // Note that when you get the file and folder objects back from the server
    // the current user's permission on the file comes back in the 'userPermission'
    // property, but we can't modelize these permissions because they always have ID "me"
    attributes: {
      permissions: 'CMS.Models.GDriveFolderPermission.models',
      revisions: 'CMS.Models.GDriveFileRevision.models'
    }
  }, {
    findChildFolders: function () {
      return this.constructor.findChildFolders(this);
    },
    findPermissions: function () {
      return CMS.Models.GDriveFolderPermission.findAll(this.serialize());
    },
    uploadFiles: function () {
      var that = this;
      var dfd = new $.Deferred();
      gapi.load('picker', {
        callback: createPicker
      });

        // Create and render a Picker object for searching images.
      function createPicker() {
        window.oauth_dfd.done(function (token, oauth_user) {
          var dialog;
          var picker = new google.picker.PickerBuilder()
                  .addView(new google.picker.DocsUploadView().setParent(that.id))
                  .addView(google.picker.ViewId.DOCS)
                  .setOAuthToken(gapi.auth.getToken().access_token)
                  .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
                  .setDeveloperKey(GGRC.config.GAPI_KEY)
                  .setCallback(pickerCallback)
                  .build();

          picker.setVisible(true);
          dialog = GGRC.Utils.getPickerElement(picker);
          if (dialog) {
            dialog.style.zIndex = 4001; // our modals start with 2050
          }
        });
      }

        // A simple callback implementation.
      function pickerCallback(data) {
        var action = data[google.picker.Response.ACTION];
        if (action === google.picker.Action.PICKED) {
          dfd.resolve(CMS.Models.GDriveFile.models(data[google.picker.Response.DOCUMENTS]));
        } else if (action === google.picker.Action.CANCEL) {
          dfd.reject('action canceled');
        }
      }
      return dfd.promise();
    }
  });

  /*
    permissions come from a sub-endpoint of the files endpoint, so we
    can get away with just using findAll from the File/Folder model with a little tweak
  */
  can.Model.Cacheable('CMS.Models.GDriveFilePermission', {
    // call findAll with id param.
    findAll: gdrive_findAll({}, '/permissions'),
    id: 'etag', // id is a user's Permission ID, so using etags instead for cache keys.
    create: function (params) {
      var file = typeof params.file === 'object' ? params.file.id : params.file;

      return gapi_request_with_auth({
        path: '/drive/v2/files/' + file + '/permissions?sendNotificationEmails=false',
        method: 'post',
        body: {
          role: params.role || 'writer',
          type: params.permission_type || 'user',
          value: params.email || CMS.Models.get_instance('Person', params.person.id).email
        },
        callback: function (dfd, result) {
          if (result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            result.file = typeof params.file === 'object' ? params.file : CMS.Models.GDriveFile.cache[params.file];
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    },
    destroy: function (etag) {
      return this.cache[etag].destroy();
    },
    findUserPermissionId: function (person) {
      var person_email = typeof person === 'string' ? person : person.email;

      return gapi_request_with_auth({
        path: '/drive/v2/permissionIds/' + person_email,
        method: 'get',
        callback: function (dfd, result) {
          if (result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            dfd.resolve(result.id);
          }
        },
        scopes: scopes
      });
    }
  }, {
    destroy: function () {
      var that = this;

      return gapi_request_with_auth({
        path: this.selfLink.replace(/https?:\/\/[^\/]+/, ''), // have to relativize the url
        method: 'delete',
        callback: function (dfd, result) {
          if (result && result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            can.trigger(that, 'destroyed', that);
            can.trigger(that.constructor, 'destroyed', that);
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    }
  });

  CMS.Models.GDriveFilePermission('CMS.Models.GDriveFolderPermission', {
    create: function (params) {
      var folder = typeof params.folder === 'object' ? params.folder.id : params.folder;

      return gapi_request_with_auth({
        path: '/drive/v2/files/' + folder + '/permissions?sendNotificationEmails=false',
        method: 'post',
        body: {
          role: params.role || 'writer',
          type: params.permission_type || 'user',
          value: params.email || CMS.Models.get_instance('Person', params.person.id).email
        },
        callback: function (dfd, result) {
          if (result.error) {
            dfd.reject(dfd, result.error.status, result.error);
          } else {
            result.folder = typeof params.folder === 'object' ? params.folder : CMS.Models.GDriveFolder.cache[params.folder];
            dfd.resolve(result);
          }
        },
        scopes: scopes
      });
    }
  }, {});

  can.Model.Cacheable('CMS.Models.GDriveFileRevision', {
    findAll: gdrive_findAll({}, '/revisions'),
    id: 'etag', // id is a user's Permission ID, so using etags instead for cache keys.
    attributes: {
      modifiedDate: 'datetime'
    }
  }, {
  });

  can.Model.Join('CMS.Models.ObjectFolder', {
    root_object: 'object_folder',
    root_collection: 'object_folders',
    findAll: 'GET /api/object_folders?__include=folder',
    create: 'POST /api/object_folders',
    update: 'PUT /api/object_folders/{id}',
    destroy: 'DELETE /api/object_folders/{id}',
    join_keys: {
      folderable: can.Model.Cacheable,
      folder: CMS.Models.GDriveFolder
    },
    attributes: {
      modified_by: 'CMS.Models.Person.stub',
      folder: 'CMS.Models.GDriveFolder.stub',
      folderable: 'CMS.Models.get_stub'
    },
    model: function (params) {
      if (typeof params === 'object') {
        if (params.folder_id) {
          params.folder = new CMS.Models.GDriveFolder({
            id: params.folder_id,
            href: '/drive/v2/files/' + params.folder_id
          }).stub();
        }
      }
      return this._super(params);
    }
  }, {
    init: function () {
      this._super.apply(this, arguments);
      if (!this.folder && this.folder_id) {
        this.attr('folder', new CMS.Models.GDriveFolder({
          id: this.folder_id,
          parentfolderid: this.parent_folder_id,
          href: '/drive/v2/files/' + this.folder_id
        }));
      }
    },
    serialize: function (attr) {
      var serial;
      if (!attr) {
        serial = this._super.apply(this, arguments);
        serial.folder_id = serial.folder ? serial.folder.id : serial.folder_id;
        delete serial.folder;
        return serial;
      }
      if (attr === 'folder_id') {
        return this.folder_id || this.folder.id;
      }
      return this._super.apply(this, arguments);
    }
  });

  $(document).ready(function () {
    gapi_request_with_auth = GGRC.gapi_request_with_auth;
  });
})(window.can);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function(can, $) {
  var gcal_findAll, gcalevent_findAll
  , scopes = ['https://www.googleapis.com/auth/calendar'];

  can.Model.Cacheable("CMS.Models.GCal", {

    findAll : (gcal_findAll = function(params) {
      return GGRC.gapi_request_with_auth({
        path : "/calendar/v3/users/me/calendarList"
               + (params && params.id ? "/" + params.id : "")
               + "?"
               + $.param($.extend({ minAccessRole : "writer"}, params))
        , callback : function(dfd, result) {
          if(result.error) {
            dfd.reject(result.error);
          } else {
            var objs = result.items || [result];
            can.each(objs, function(obj) {
              obj.selfLink = obj.selfLink || "#";
            });
            dfd.resolve(objs);
          }
        }
      });
    })
    , findOne : gcal_findAll

    , getPrimary : function() {
      return GGRC.gapi_request_with_auth({
        path : "/calendar/v3/calendars/primary"
        , callback : function(dfd, d) { dfd.resolve(d); }
        , scopes : scopes
      });
    }

  }, {

    eventsModel : function() {
      var that = this;
      return CMS.Models.GCalEvent.extend({
        getPath : function() {
          return "/calendar/v3/calendars/" + that.id + "/events";
        }
      }, {});
    }
    , refresh : function(params) {
      return this.constructor.findOne({ id : this.id })
      .then($.proxy(this.constructor, "model"))
      .done(function(d) {
        d.updated();
        //  Trigger complete refresh of object -- slow, but fixes live-binding
        //  redraws in some cases
        can.trigger(d, "change", "*");
      });
    }

  });

  function check_path(obj, params) {
    if(!obj.getPath(params)) {
      GGRC.config = GGRC.config || {};
      return CMS.Models.GCal.getPrimary().then(function(d) {
        GGRC.config.USER_PRIMARY_CALENDAR = d;
        if(!GGRC.config.DEFAULT_CALENDAR) {
          GGRC.config.DEFAULT_CALENDAR = d;
        }
      });
    } else {
      return $.when();
    }
  }

  can.Model.Cacheable("CMS.Models.GCalEvent", {

    getPath : function(params) {
      if(!params.calendar && !GGRC.config.DEFAULT_CALENDAR) {
        return null;
      }

      return ["/calendar/v3/calendars/"
      , (params && params.calendar ? params.calendar.id : GGRC.config.DEFAULT_CALENDAR.id)
      , "/events"
      , (params && params.id ? "/" + params.id : "")
      , (params && params.q ? "?q=" + encodeURIComponent(params.q) : "")].join("");
    }

    , findAll : (gcalevent_findAll = function(params) {
      var dfd = check_path(this, params)
      , that = this;

      if(params && params.response) {
        params.q = "Response #" + params.response.id;
      }
      return dfd.then(function() {
        return GGRC.gapi_request_with_auth({
          path : that.proxy("getPath", params)
          , method : "get"
          , callback : function(dfd, result) {
            if(result.error) {
              dfd.reject(result.error);
            } else if(result.items) {
              var objs = result.items;
              can.each(objs, function(obj) {
                obj.selfLink = obj.selfLink || "#";
              });
              dfd.resolve(objs);
            } else {
              result.selfLink = "#";
              dfd.resolve(result);
            }
          }
          , scopes : scopes
        });
      });
    })
    , findOne : gcalevent_findAll
    , create : function(params) {
      var dfd = check_path(this, params)
      , that = this;
      return dfd.then(function() {
        return GGRC.gapi_request_with_auth({
          path : that.getPath(params)
          , body : params
          , method : "post"
          , callback : function(dfd, d) {
            dfd.resolve(d);
          }
          , scopes : scopes
        });
      });
    }
    , destroy : function(id) {
      var dfd = check_path(this, params)
      , that = this;
      return dfd.then(function() {
        return GGRC.gapi_request_with_auth({
          path : that.getPath() + "/" + id
          , method : "delete"
          , callback : function(dfd, d) {
            dfd.resolve(d);
          }
          , scopes : scopes
        });
      });
    }
    , attributes : {
      start : "packaged_datetime"
      , end : "packaged_datetime"
      , attendees: "email_only"
    }
    , serialize : {
      email_only : function(val) {
        if(val.reify) {
          return can.map(val.reify(), function(p) { return {email : p.email}; });
        }
      }
    }
    , convert : {
      email_only : function(val) {
        var finds = []
        , result = new CMS.Models.Person.List();
        can.each(val, function(g_person) {
          var p;
          if(p = CMS.Models.Person.findInCacheByEmail(g_person.email)) {
            result.push(p);
          } else {
            finds.push(g_person.email);
          }
        });
        if(finds.length > 0) {
          CMS.Models.Person.findAll({"email__in" : finds.join(",") }).done(function(np) {
            result.push.apply(result, np);
          });
        }
        return result;
      }
    }
  }, {

    refresh : function(params) {
      return this.constructor.findOne({ calendar : this.calendar, id : this.id })
      .then($.proxy(this.constructor, "model"))
      .done(function(d) {
        d.updated();
        //  Trigger complete refresh of object -- slow, but fixes live-binding
        //  redraws in some cases
        can.trigger(d, "change", "*");
      });
    }
  });

can.Model.Join("CMS.Models.ObjectEvent", {
  root_object : "object_event"
  , root_collection : "object_events"
  , findAll: "GET /api/object_events?__include=event"
  , create : "POST /api/object_events"
  , update : "PUT /api/object_events/{id}"
  , destroy : "DELETE /api/object_events/{id}"
  , join_keys : {
    eventable : can.Model.Cacheable
    , event : CMS.Models.GCalEvent
  }
  , attributes : {
      modified_by : "CMS.Models.Person.stub"
    , event : "CMS.Models.GCalEvent.stub"
    , eventable : "CMS.Models.get_stub"
    , calendar : "CMS.Models.GCal.stub"
  }

  , model : function(params) {
    if(typeof params === "object") {
      params.event = {
        id : params.event_id
        , type : "GCalEvent"
        , calendar_id : params.calendar_id
        , href : "/calendar/v3/calendars/" + params.calendar_id + "/events/" + params.event_id
      };
    }
    return this._super(params);
  }
}, {

  serialize : function(attr) {
    var serial;
    if(!attr) {
      serial = this._super.apply(this, arguments);
      serial.event_id = serial.event ? serial.event.id : serial.event_id;
      delete serial.event;
      serial.calendar_id = serial.calendar ? serial.calendar.id : serial.calendar_id;
      delete serial.calendar;
      return serial;
    }
    switch(attr) {
      case "event":
        return this.event_id || this.event.id;
      case "calendar":
        return this.calendar_id || this.calendar.id;
      default:
        return this._super.apply(this, arguments);
    }
  }
});
})(this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

;(function(CMS, GGRC, can, $) {

  GGRC.Controllers.Modals("GGRC.Controllers.GAPIModal", {
    defaults: {
      skip_refresh: true
      , content_view : GGRC.mustache_path + "/gdrive/auth_button.mustache"
    }
    , init : function() {
      this._super.apply(this, arguments);
      this.defaults.button_view = can.view.mustache("");
    }
  }, {
    init : function() {
      this._super();
      this.element.trigger("shown");
    }

    , "{scopes} change" : function() {
      this.element.trigger("shown");
    }

    , "{$content} a.btn[data-toggle=gapi]:not(.disabled) click" : function(el, ev) {
      el.addClass("disabled");
      GGRC.Controllers.GAPI.doGAuth_step2(null, true);
      window.oauth_dfd.always($.proxy(this.element, "modal_form", "hide"));
    }

    , " hide" : function() {
      if(window.oauth_dfd.state() === "pending") {
        window.oauth_dfd.reject("User canceled operation");
      }
      this.element && this.element.remove();
    }

  });

  window.oauth_dfd = new $.Deferred();

  can.Control("GGRC.Controllers.GAPI", {
    canonical_instance : null
    , o2dfd : null
    , drivedfd : null
    , gapidfd : new $.Deferred()

    , authorize : function(newscopes, force) {
      return this.canonical_instance.authorize(newscopes, force);
    }

    , doGAuth : function(scopes, use_popup) {
      var that = this
      , $modal;
      this.drive = this.drive || new $.Deferred();
      if(window.oauth_dfd.state() !== "pending") {
        window.oauth_dfd = new $.Deferred();
      }
      can.each({
        "drivedfd" : "drive"
        , "o2dfd" : "oauth2"
      }, function(p, d) {
        if(!that[d]) {
          that[d] = new $.Deferred();
          that.gapidfd.done(function() {
            window.gapi.client.load(p, 'v2', function(result) {
              if(!result){
                that[d].resolve();
              } else {
                that[d].reject(result);
              }
            });
          });
        }
      });

      if(use_popup) {
        $modal = $(".ggrc_controllers_gapi_modal");
        if(!$modal.length) {
          $("<div class='modal hide'>").modal_form().appendTo(document.body).ggrc_controllers_gapi_modal({
            scopes : scopes
            , modal_title : "Please log in to Google API"
            , new_object_form : true
          });
        } else {
          $modal.modal_form("show");
        }
      } else {
        this.doGAuth_step2(scopes, use_popup);
      }
    }
    , doGAuth_step2 : function(scopes, use_popup) {
      var authdfd = new $.Deferred()
      , that = this;

      scopes = scopes || this.canonical_instance.options.scopes;

      this.gapidfd.done(function() {
        window.gapi.auth.authorize({
          'client_id': GGRC.config.GAPI_CLIENT_ID
          , 'scope': scopes.serialize()
          , 'immediate': !use_popup
          , 'login_hint' : GGRC.current_user && GGRC.current_user.email
        }).then(function(authresult) {
          authdfd.resolve(authresult);
        }, function() {
          if(!use_popup) {
            that.doGAuth(scopes, true);
            authdfd.reject("login required. Switching to non-immediate");
          } else {
            window.oauth_dfd.reject();
            authdfd.reject("auth failed");
          }
        });
      });
      $.when(authdfd, this.o2dfd)
      .then(function(authresult) {
        var o2d = new $.Deferred();
        gapi.client.oauth2.userinfo.get().execute(function(user) {
          if(user.error) {
            $(document.body).trigger("ajax:flash", { error : user.error });
            o2d.reject(user.error);
          } else {
            o2d.resolve(user);
          }
        });
        return $.when(authresult, o2d);
      })
      .done(function(authresult, o2result){  //success
        if(!authresult)
          return; //assume we had to do a non-immediate auth

        if(o2result.email.toLowerCase().trim() !== GGRC.current_user.email.toLowerCase().trim()) {
          $(document.body).trigger(
            "ajax:flash"
            , { warning : [
              "You are signed into GGRC as"
              , GGRC.current_user.email
              , "and into Google Apps as"
              , o2result.email
              , ". You may experience problems uploading evidence."
              ].join(' ')
            });
        }
        window.oauth_dfd.resolve(authresult, o2result);
      });
    }
    , gapi_request_with_auth : function(params) {
      var that = this;
      return that.authorize(params.scopes).then(function() {
        var dfd = new $.Deferred();
        var cb = params.callback;
        var check_auth = function(result) {
          var args = can.makeArray(arguments);
          args.unshift(dfd);
          if(result && result.error && result.error.code === 401) {
            //that.doGAuth(scopes); //changes oauth_dfd to a new deferred
            params.callback = cb;
            that.authorize(params.scopes, true).then($.proxy(that.gapi_request_with_auth, that, params))
            .then(
              function() {
                dfd.resolve.apply(dfd, arguments);
              }, function() {
                dfd.reject.apply(dfd, arguments);
              });
          } else {
            cb.apply(window, args);
          }
        };
        params.callback = check_auth;
        if(typeof params.path === "function") {
          params.path = params.path();
        }
        window.gapi.client.request(params);
        return dfd.promise();
      });
    }

  }, {

    init : function() {
      var that = this;
      this._super.apply(this, arguments);
      if(!this.constructor.canonical_instance) {
        this.constructor.canonical_instance = this;
      }

      this.doGAuthWithScopes = _.debounce($.proxy(this.constructor, "doGAuth", this.options.scopes, false), 500);
    }

    , authorize : function(newscopes, force) {
      var dfd, f, old_dfd
      , that = this
      , found = false;

      can.each(newscopes, function(ns) {
        if(!~can.inArray(ns, that.options.scopes)) {
          that.options.scopes.push(ns);
          found = true;
        }
      });

      if(force ||
          (found
            ? window.oauth_dfd.state() !== "pending"
            : window.oauth_dfd.state() === "rejected"
          )
      ) {
        old_dfd = window.oauth_dfd;
        dfd = new $.Deferred();
        setTimeout(f = function() {
          if(window.oauth_dfd === old_dfd) {
            setTimeout(f, 500);
          } else {
            window.oauth_dfd.done(function() {
              dfd.resolve.apply(dfd, arguments);
            });
          }
        }, 500);
        this.doGAuthWithScopes();
        return dfd;
      } else {
        return window.oauth_dfd;
      }
    }

    , "{scopes} change" : function(scopes, ev) {
      this.doGAuthWithScopes(); //debounce in case we push several scopes in sequence
    }
  });

})(this.CMS, this.GGRC, this.can, this.can.$);

/*!
    Copyright (C) 2016 Google Inc.
    Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
*/

(function(can, $, CMS, GGRC) {

  var scopes = new can.Observe.List(['https://www.googleapis.com/auth/userinfo.email']);


  new GGRC.Mappings("ggrc_gdrive_integration", {
    folderable : {
      _canonical : {
        folders : "GDriveFolder"
      },
      object_folders: new GGRC.ListLoaders.DirectListLoader("ObjectFolder", "folderable", "object_folders"),
      folders: new GGRC.ListLoaders.ProxyListLoader("ObjectFolder", "folderable", "folder", "object_folders", "GDriveFolder")
    },

    revisionable : {
      _canonical : {
        revisions : "GDriveFileRevision"
      },
      revisions : new GGRC.ListLoaders.DirectListLoader("GDriveFileRevision", "id")
    },

    Program : {
      _mixins : ["folderable"]
    },
    Audit : {
      _mixins : ["folderable"],
      extended_folders: new GGRC.ListLoaders.MultiListLoader(["folders"]),
      folders: new GGRC.ListLoaders.ProxyListLoader("ObjectFolder", "folderable",
        "folder", "object_folders", "GDriveFolder")
    },
    Request : {
      folders : new GGRC.ListLoaders.CrossListLoader("_audit", "folders"),
      _audit : new GGRC.ListLoaders.DirectListLoader("Audit", "requests", "audit"),
      extended_folders: new GGRC.ListLoaders.CrossListLoader("audits", "folders")
    },
    Assessment: {
      audits: GGRC.MapperHelpers.TypeFilter("related_objects", "Audit"),
      folders : new GGRC.ListLoaders.CrossListLoader("audits", "folders"),
      extended_folders: new GGRC.ListLoaders.CrossListLoader("audits", "folders")
    },
    Meeting : {
      _canonical : {
        "events" : "GCalEvent"
      },
      events : new GGRC.ListLoaders.ProxyListLoader("ObjectEvent", "eventable", "event", "object_events", "GCalEvent")
    },
    Workflow: {
      _mixins :  ["folderable"],
      folders : new GGRC.ListLoaders.ProxyListLoader("ObjectFolder", "folderable", "folder", "object_folders", "GDriveFolder"),
      orphaned_objects : new GGRC.ListLoaders.MultiListLoader(["cycles", "task_groups", "tasks", "current_task_groups", "current_tasks", "folders"])
    },
    CycleTaskEntry : {
      folders : new GGRC.ListLoaders.CrossListLoader("workflow", "folders"),
      extended_folders : new GGRC.ListLoaders.MultiListLoader(["folders"])
    },
    GDriveFolder : {
      _mixins : ["revisionable"],
      _canonical : {
        permissions : "GDriveFolderPermission"
      },
      permissions : new GGRC.ListLoaders.DirectListLoader("GDriveFolderPermission", "id")
    },
    GDriveFile : {
      _mixins : ["revisionable"],
      _canonical : {
        permissions : "GDriveFilePermission"
      },
      permissions : new GGRC.ListLoaders.DirectListLoader("GDriveFilePermission", "id")
    }
  });

  GGRC.gapi_request_with_auth = $.proxy(GGRC.Controllers.GAPI, "gapi_request_with_auth");
  $(function() {
    $(document.body).ggrc_controllers_gapi({ scopes : scopes });
  });

  // set up a temporary global auth function so the GAPI onload can find it
  var r = Math.floor(Math.random() * 100000000);
  window["resolvegapi" + r] = function(gapi) {
    GGRC.Controllers.GAPI.gapidfd.resolve(gapi);
    delete window["resolvegapi" + r];
  };
  $('head').append("<script type='text/javascript' src='https://apis.google.com/js/client.js?onload=resolvegapi" + r + "'></script>");


  $.extend(true, CMS.Models.Audit.attributes, {
    "object_folders" : "CMS.Models.ObjectFolder.stubs"
    , "folders" : "CMS.Models.GDriveFolder.stubs"
  });

  can.view.mustache("picker-tag-default", "<ggrc-gdrive-folder-picker {{^is_allowed 'update' instance context='for'}}readonly=true{{/is_allowed}} instance='instance'/>");
  GGRC.register_hook("Audit.tree_view_info", "picker-tag-default");
  GGRC.register_hook("Audit.storage_folder_picker", GGRC.mustache_path + "/audits/gdrive_folder_picker.mustache");


  can.view.mustache("picker-tag-readonly", "<ggrc-gdrive-folder-picker instance='instance' readonly='true'/>");
    //We are no longer mapping GDrive files directly to responses.  It makes it difficult to figure out which GDrive file is which
  // document when we go to present. however, this functionality is still supported.


  // GGRC.JoinDescriptor.from_arguments_list([
  //   [["Program", "Audit", "Request"], "GDriveFolder", "ObjectFolder", "folder", "folderable"]
  //   , ["GDriveFile", "§", "file", "fileable"]
  // ]);

  $.extend(true, CMS.Models.Meeting.attributes, {
    "object_events" : "CMS.Models.ObjectEvent.stubs"
    , "events" : "CMS.Models.GCalEvent.stubs"
  });
  GGRC.register_hook("Meeting.tree_view_info", GGRC.mustache_path + "/meetings/gcal_info.mustache");

  GGRC.register_hook("Role.option_detail", GGRC.mustache_path + "/roles/gdrive_option_detail.mustache");

  // Enable these hooks when the deployment allows G+ APIs
  // GGRC.register_hook("Person.popover_actions", GGRC.mustache_path + "/people/gplus_actions.mustache");
  // GGRC.register_hook("Person.popover_info", GGRC.mustache_path + "/people/gplus_photo.mustache");

  GGRC.register_hook("Workflow.storage_folder_picker", GGRC.mustache_path + "/workflows/gdrive_folder_picker.mustache");

  GGRC.register_hook("Request.gdrive_evidence_storage", GGRC.mustache_path + "/requests/gdrive_evidence_storage.mustache");
  GGRC.register_hook("Request.gdrive_comment_attachment", GGRC.mustache_path + "/requests/gdrive_comment_attachment.mustache");

})(this.can, this.can.$, this.CMS, this.GGRC);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

(function (can, $) {
  'use strict';

  GGRC.Components('gDrivePickerLauncher', {
    tag: 'ggrc-gdrive-picker-launcher',
    template: can.view(GGRC.mustache_path + '/gdrive/gdrive_file.mustache'),
    scope: {
      instance: null,
      folder_instance: null,
      deferred: '@',
      icon: '@',
      link_text: '@',
      link_class: '@',
      click_event: '@',
      verify_event: '@',
      modal_description: '@',
      modal_title: '@',
      modal_button: '@',
      trigger_upload: function (scope, el, ev) {
        // upload files without a parent folder (risk assesment)
        var that = this;
        var dfd;
        var folderId = el.data('folder-id');

        // the result of the confirmation modal (if shown to the user)
        var dfdModalConfirm = $.Deferred();

        scope.attr('pickerActive', true);

        // Create and render a Picker object for searching images.
        function createPicker() {
          window.oauth_dfd.done(function (token, oauthUser) {
            var dialog;
            var view;
            var docsView;
            var docsUploadView;
            var picker = new google.picker.PickerBuilder()
                    .setOAuthToken(gapi.auth.getToken().access_token)
                    .setDeveloperKey(GGRC.config.GAPI_KEY)
                    .setCallback(pickerCallback);

            if (el.data('type') === 'folders') {
              view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
                  .setIncludeFolders(true)
                  .setSelectFolderEnabled(true);
              picker.addView(view);
            } else {
              docsUploadView = new google.picker.DocsUploadView()
                .setParent(folderId);
              docsView = new google.picker.DocsView()
                .setParent(folderId);

              picker.addView(docsUploadView)
                .addView(docsView)
                .enableFeature(google.picker.Feature.MULTISELECT_ENABLED);
            }
            picker = picker.build();
            picker.setVisible(true);

            dialog = GGRC.Utils.getPickerElement(picker);
            if (dialog) {
              dialog.style.zIndex = 4001; // our modals start with 2050
            }
          })
          .fail(function () {
            scope.attr('pickerActive', false);
          });
        }

        function pickerCallback(data) {
          var files;
          var PICKED = google.picker.Action.PICKED;
          var ACTION = google.picker.Response.ACTION;
          var DOCUMENTS = google.picker.Response.DOCUMENTS;
          var CANCEL = google.picker.Action.CANCEL;

          if (data[ACTION] === PICKED) {
            files = CMS.Models.GDriveFile.models(data[DOCUMENTS]);
            that.attr('pending', true);
            scope.attr('pickerActive', false);

            return new RefreshQueue().enqueue(files).trigger()
              .then(function (files) {
                var docDfds = that.handle_file_upload(files);
                $.when.apply($, docDfds).then(function () {
                  // Trigger modal:success event on scope
                  can.trigger(
                    that, 'modal:success', {arr: can.makeArray(arguments)});
                  el.trigger('modal:success', {arr: can.makeArray(arguments)});
                  that.attr('pending', false);
                });
              });
          } else if (data[ACTION] === CANCEL) {
            el.trigger('rejected');
            scope.attr('pickerActive', false);
          }
        }

        if (scope.attr('verify_event')) {
          GGRC.Controllers.Modals.confirm({
            modal_description: scope.attr('modal_description'),
            modal_confirm: scope.attr('modal_button'),
            modal_title: scope.attr('modal_title'),
            button_view: GGRC.mustache_path +
              '/gdrive/confirm_buttons.mustache'
          }, dfdModalConfirm.resolve, dfdModalConfirm.reject);
        } else {
          dfdModalConfirm.resolve();
        }

        dfdModalConfirm.done(function () {
          dfd = GGRC.Controllers.GAPI.authorize(
            ['https://www.googleapis.com/auth/drive']
          );
          dfd.done(function () {
            gapi.load('picker', {callback: createPicker});
          }).fail(function () {
            scope.attr('pickerActive', false);
          });
        })
        .fail(function () {
          scope.attr('pickerActive', false);
        });
      },

      trigger_upload_parent: function (scope, el, ev) {
        // upload files with a parent folder (audits and workflows)
        var that = this;
        var verifyDfd = $.Deferred();
        var parentFolderDfd;
        var folderInstance = this.folder_instance || this.instance;

        function isOwnFolder(mapping, instance) {
          if (mapping.binding.instance !== instance) {
            return false;
          }
          if (!mapping.mappings ||
              mapping.mappings.length < 1 ||
              mapping.instance === true) {
            return true;
          }
          return can.reduce(mapping.mappings, function (current, mp) {
            return current || isOwnFolder(mp, instance);
          }, false);
        }

        if (scope.attr('verify_event')) {
          GGRC.Controllers.Modals.confirm({
            modal_description: scope.attr('modal_description'),
            modal_confirm: scope.attr('modal_button'),
            modal_title: scope.attr('modal_title'),
            button_view: GGRC.mustache_path +
              '/gdrive/confirm_buttons.mustache'
          }, verifyDfd.resolve);
        } else {
          verifyDfd.resolve();
        }

        verifyDfd.done(function () {
          if (that.instance.attr('_transient.folder')) {
            parentFolderDfd = $.when(
              [{instance: folderInstance.attr('_transient.folder')}]
            );
          } else {
            parentFolderDfd = folderInstance
              .get_binding('extended_folders')
              .refresh_instances();
          }
          can.Control.prototype.bindXHRToButton(parentFolderDfd, el);

          parentFolderDfd.done(function (bindings) {
            var parentFolder;
            if (bindings.length < 1 || !bindings[0].instance.selfLink) {
              // no ObjectFolder or cannot access folder from GAPI
              el.trigger('ajax:flash', {
                warning: 'Can\'t upload: No GDrive folder found'
              });
              return;
            }

            parentFolder = can.map(bindings, function (binding) {
              return can.reduce(binding.mappings, function (current, mp) {
                return current || isOwnFolder(mp, that.instance);
              }, false) ? binding.instance : undefined;
            });
            parentFolder = parentFolder[0] || bindings[0].instance;

            // NB: resources returned from uploadFiles() do not match the
            // properties expected from getting files from GAPI --
            // "name" <=> "title", "url" <=> "alternateLink". Of greater
            // annoyance is the "url" field from the picker differs from the
            // "alternateLink" field value from GAPI: the URL has a query
            // parameter difference, "usp=drive_web" vs "usp=drivesdk". For
            // consistency, when getting file references back from Picker,
            // always put them in a RefreshQueue before using their properties.
            // --BM 11/19/2013
            parentFolder.uploadFiles().then(function (files) {
              that.attr('pending', true);
              return new RefreshQueue().enqueue(files).trigger()
                .then(function (fs) {
                  var mapped = can.map(fs, function (file) {
                    if (
                      !_.includes(_.map(file.parents, 'id'), parentFolder.id)
                    ) {
                      return file.copyToParent(parentFolder);
                    }
                    return file;
                  });
                  return $.when.apply($, mapped);
                });
            }).done(function () {
              var files = can.map(can.makeArray(arguments), function (file) {
                return CMS.Models.GDriveFile.model(file);
              });
              var dfdsDoc = that.handle_file_upload(files);

              $.when.apply($, dfdsDoc).then(function () {
                can.trigger(
                  that, 'modal:success', {arr: can.makeArray(arguments)});
                el.trigger('modal:success', {arr: can.makeArray(arguments)});
                that.attr('pending', false);
              });
            });
          });
        });
      },

      handle_file_upload: function (files) {
        var that = this;
        var dfdsDoc = [];
        var dfd;

        can.each(files, function (file) {
          // Since we can re-use existing file references from the picker,
          // check for that case.
          dfd = CMS.Models.Document.findAll({
            link: file.alternateLink})
          .then(function (docs) {
            var dfdDoc;
            var objectDoc;

            if (docs.length < 1) {
              docs.push(new CMS.Models.Document({
                context: that.instance.context || {id: null},
                title: file.title,
                link: file.alternateLink
              }));
            }
            if (that.deferred || !docs[0].isNew()) {
              dfdDoc = $.when(docs[0]);
            } else {
              dfdDoc = docs[0].save();
            }

            dfdDoc = dfdDoc.then(function (doc) {
              if (that.deferred) {
                that.instance.mark_for_addition('documents', doc, {
                  context: that.instance.context || {id: null}
                });
              } else {
                objectDoc = new CMS.Models.ObjectDocument({
                  context: that.instance.context || {id: null},
                  documentable: that.instance,
                  document: doc
                }).save();
              }

              return objectDoc;
            });
            return dfdDoc;
          });
          dfdsDoc.push(dfd);
        });
        return dfdsDoc;
      }
    },
    events: {
      init: function () {
        if (!this.scope.link_class) {
          this.scope.attr('link_class', 'btn');
        }
        this.scope.attr('pickerActive', false);
      },
      '{scope} modal:success': function (_scope, _event) {
        var instance = this.scope.instance.reify();
        instance.refresh();
      }
    }
  });
})(this.can, this.can.$);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */
(function (can, $) {
  'use strict';

  function attachFiles(files, type, object) {
    return new RefreshQueue().enqueue(files).trigger().then(function (files) {
      can.each(files, function (file) {
        // Since we attach_files can re-use existing file references
        // from the picker, check for that case.
        var link = {link: file.alternateLink};
        CMS.Models.Document.findAll(link).done(function (d) {
          if (d.length) {
            new CMS.Models.ObjectDocument({
              context: object.context || {id: null},
              documentable: object,
              document: d[0]
            }).save();
          } else {
            if (type === 'folders') {
              new CMS.Models.ObjectFolder({
                folderable: object,
                folder: file,
                context: object.context || {id: null}
              }).save();
              return;
            }
            // File not found, make Document object.
            new CMS.Models.Document({
              context: object.context || {id: null},
              title: file.title,
              link: file.alternateLink
            }).save().then(function (doc) {
              return $.when([
                new CMS.Models.ObjectDocument({
                  context: object.context || {id: null},
                  documentable: object,
                  document: doc
                }).save()
              ]);
            });
          }
        });
      });
    });
  }

  GGRC.Components('gDriveFolderPicker', {
    tag: 'ggrc-gdrive-folder-picker',
    template: can.view(GGRC.mustache_path + '/gdrive/gdrive_folder.mustache'),
    scope: {
      _folder_change_pending: false,
      no_detach: '@',
      deferred: '@',
      tabindex: '@',
      placeholder: '@',
      readonly: '@',
      folder_list: [],
      instance: null,
      /**
       * Helper method for unlinking all object folders currently linked to the
       * given instance.
       *
       * @param {Object} instance - an instance of a model object (e.g Audit) for
       *   which to unlink the object folders from
       * @return {Object} - a deferred object that is resolved when the instance's
       *   object folders have been successfully unlinked from it
       */
      _unlinkObjFolders: function (instance) {
        var deleteDeferred;

        // make sure the object_folders list is up to date, and then delete all
        // existing upload folders currently mapped to the instance
        deleteDeferred = instance.refresh().then(function () {
          var deferredDeletes;
          var objFolders = instance.object_folders;

          // delete folders and collect their deferred delete objects
          deferredDeletes = $.map(objFolders, function (folder) {
            var deferredDestroy = folder
              .reify()
              .refresh()
              .then(function (folderRefreshed) {
                return folderRefreshed.destroy();
              });

            return deferredDestroy;
          });

          return $.when.apply($, deferredDeletes);
        });

        return deleteDeferred;
      }
    },
    events: {
      setCurrent: function (unsetPending) {
        return function (folders) {
          var folder = folders[0] ? folders[0].instance : null;
          if (unsetPending) {
            this.scope.attr('_folder_change_pending', false);
          }
          this.scope.attr('current_folder', folder);
          this.scope.attr('folder_list').replace(folders);
        }.bind(this);
      },
      setCurrentFail: function (error) {
        this.scope.attr('_folder_change_pending', false);
        this.scope.attr('folder_error', error);
      },
      unsetCurrent: function () {
        this.scope.attr('_folder_change_pending', false);
        this.scope.attr('folder_error', null);
        this.scope.attr('current_folder', null);
      },
      setExtendedFolder: function () {
        // Try to load extended folders if main folder was not found
        if (!this.scope.instance.get_binding('extended_folders') ||
             this.scope.current_folder ||
             this.scope.folder_error) {
          return this.scope.attr('_folder_change_pending', false);
        }
        this.scope.instance.get_binding('extended_folders')
          .refresh_instances()
          .done(this.setCurrent(true))
          .fail(this.setCurrentFail.bind(this));
      },
      inserted: function () {
        var foldersBinding = this.scope.instance.get_binding('folders');

        this.element.removeAttr('tabindex');
        this.scope.attr('_folder_change_pending', true);

        foldersBinding.refresh_instances()
          .then(this.setCurrent(), this.setCurrentFail.bind(this))
          .then(this.setExtendedFolder.bind(this));
      },
      '{scope.instance} change': function (inst, ev, attr) {
        // Error recovery from previous refresh_instances error when we couldn't set up the binding.
        if (!this.scope.folder_error) {
          return;
        }
        this.scope.instance.get_binding('folders')
          .refresh_instances()
          .then(this.setCurrent(true), this.setCurrentFail.bind(this))
          .then(this.setExtendedFolder.bind(this));
      },
      '{scope.folder_list} change': function () {
        var pjlength;
        var item = this.scope.instance.get_binding('folders').list[0];
        if (!item && this.scope.instance.get_binding('extended_folders')) {
          item = this.scope.instance.get_binding('extended_folders').list[0];
        }

        this.scope.attr('current_folder', item ? item.instance : null);
        if (this.scope.deferred && this.scope.instance._pending_joins) {
          pjlength = this.scope.instance._pending_joins.length;
          can.each(this.scope.instance._pending_joins.slice(0).reverse(), function (pj, i) {
            if (pj.through === 'folders') {
              this.scope.instance._pending_joins.splice(pjlength - i - 1, 1);
            }
          }, this);
        }
      },

      /**
       * Handle a click on the button for detaching an upload folder from
       * a model instance (e.g. an Audit).
       *
       * @param {Object} el - The jQuery-wrapped DOM element on which the event
       *   has been triggered.
       * @param {Object} ev - The event object.
       */
      'a[data-toggle=gdrive-remover] click': function (el, ev) {
        var scope = this.scope,
          dfd;

        if (scope.deferred) {
          if (scope.current_folder) {
            scope.instance.mark_for_deletion('folders', scope.current_folder);
          } else if (scope.folder_error && !scope.instance.object_folders) {
            // If object_folders are not defined for this instance the error
            // is from extended_folders, we just need to clear folder_error
            // in this case.
            scope.attr('folder_error', null);
          } else {
            can.each(scope.instance.object_folders.reify(), function (object_folder) {
              object_folder.refresh().then(function (of) {
                scope.instance.mark_for_deletion('object_folders', of);
              });
            });
          }
          dfd = $.when();
        } else {
          dfd = scope._unlinkObjFolders(scope.instance);
        }

        dfd.then(function () {
          if (scope.instance.get_binding('extended_folders')) {
            $.when(
              scope.instance.get_binding('folders').refresh_instances(),
              scope.instance.get_binding('extended_folders').refresh_instances()
            ).then(function (local_bindings, extended_bindings) {
              var self_folders, remote_folders;
              self_folders = can.map(local_bindings, function (folder_binding) {
                return folder_binding.instance;
              });
              remote_folders = can.map(extended_bindings, function (folder_binding) {
                return ~can.inArray(folder_binding.instance, self_folders) ? undefined : folder_binding.instance;
              });

              scope.attr('current_folder', remote_folders[0] || null);
            });
          } else {
            scope.attr('current_folder', null);
          }

          scope.attr('folder_error', null);
        });
      },

      'a[data-toggle=gdrive-picker] click': function (el, ev) {
        var dfd = GGRC.Controllers.GAPI.authorize(['https://www.googleapis.com/auth/drive']);
        var folder_id = el.data('folder-id');

        // Create and render a Picker object for searching images.
        function createPicker() {
          window.oauth_dfd.done(function (token, oauth_user) {
            var dialog;
            var view;
            var docsUploadView;
            var docsView;
            var picker = new google.picker.PickerBuilder()
                  .setOAuthToken(gapi.auth.getToken().access_token)
                  .setDeveloperKey(GGRC.config.GAPI_KEY)
                  .setCallback(pickerCallback);

            if (el.data('type') === 'folders') {
              view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
                .setMimeTypes(['application/vnd.google-apps.folder'])
                .setSelectFolderEnabled(true);
              picker.setTitle('Select folder');
              picker.addView(view);
            } else {
              docsUploadView = new google.picker.DocsUploadView()
                .setParent(folder_id);
              docsView = new google.picker.DocsView()
                .setParent(folder_id);

              picker.addView(docsUploadView)
                .addView(docsView)
                .enableFeature(google.picker.Feature.MULTISELECT_ENABLED);
            }
            picker = picker.build();
            picker.setVisible(true);
            // use undocumented fu to make the Picker be "modal"
            // this is the "mask" displayed behind the dialog box div
            $('div.picker-dialog-bg').css('zIndex', 4000);  // there are multiple divs of that sort
            // and this is the dialog box modal div, which we must display on top of our modal, if any

            dialog = GGRC.Utils.getPickerElement(picker);
            if (dialog) {
              dialog.style.zIndex = 4001; // our modals start with 2050
            }
          });
        }

        function pickerCallback(data) {
          var files;
          var model;
          var PICKED = google.picker.Action.PICKED;
          var ACTION = google.picker.Response.ACTION;
          var DOCUMENTS = google.picker.Response.DOCUMENTS;
          var CANCEL = google.picker.Action.CANCEL;

          if (data[ACTION] === PICKED) {
            if (el.data('type') === 'folders') {
              model = CMS.Models.GDriveFolder;
            } else {
              model = CMS.Mdoels.GDriveFile;
            }
            files = model.models(data[DOCUMENTS]);
            el.trigger('picked', {
              files: files
            });
          } else if (data[ACTION] === CANCEL) {
            el.trigger('rejected');
          }
        }

        dfd.fail(this.unsetCurrent.bind(this))
          .done(function () {
            gapi.load('picker', {
              callback: createPicker
            });
          });
      },

      /*
       * Handle an event of the user picking a new GDrive upload folder.
       *
       * @param {Object} el - The jQuery-wrapped DOM element on which the event
       *   has been triggered.
       * @param {Object} ev - The event object.
       * @param {Object} data - Additional event data.
       *   @param {Array} data.files - The list of GDrive folders the user picked
       *     in the GDrive folder picker modal.
       */
      '.entry-attachment picked': function (el, ev, data) {
        var dfd;
        var files = data.files || [];
        var scope = this.scope;

        if (el.data('type') === 'folders' &&
            files.length &&
            files[0].mimeType !== 'application/vnd.google-apps.folder'
        ) {
          $(document.body).trigger('ajax:flash', {
            error: 'ERROR: Something other than a Drive folder was chosen for a folder slot.  Please choose a folder.'
          });
          return;
        }

        this.scope.attr('_folder_change_pending', true);
        if (!el.data('replace')) {
          dfd = $.when();
        } else if (scope.deferred) {
          if (scope.current_folder) {
            scope.instance.mark_for_deletion('folders', scope.current_folder);
          } else if (scope.folder_error && !scope.instance.object_folders) {
            // If object_folders are not defined for this instance the error
            // is from extended_folders, we just need to clear folder_error
            // in this case.
            scope.attr('folder_error', null);
          } else {
            can.each(scope.instance.object_folders.reify(), function (object_folder) {
              object_folder.refresh().then(function (of) {
                scope.instance.mark_for_deletion('object_folders', of);
              });
            });
          }
          dfd = $.when();
        } else {
          dfd = scope._unlinkObjFolders(scope.instance);
        }

        dfd
        .always(function () {
          this.scope.attr('_folder_change_pending', false);
        }.bind(this))
        .then(function () {
          if (scope.deferred) {
            return $.when.apply($,
              can.map(files, function (file) {
                scope.instance.mark_for_addition('folders', file);
                return file.refresh();
              })
            );
          }
          return attachFiles(files, el.data('type'), scope.instance);
        })
        .then(function () {
          scope.attr('folder_error', null);
          scope.attr('current_folder', files[0]);
          if (scope.deferred && scope.instance._transient) {
            scope.instance.attr('_transient.folder', files[0]);
          }
        })
        .fail(this.setCurrentFail.bind(this));
        return dfd;
      }
    }
  });
})(this.can, this.can.$);

/*
 * Copyright (C) 2016 Google Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0 <see LICENSE file>
 */

